// Does the advanced quickstart example work? No. But I'll leave it here becuase a lot of the stuff here could be useful.

open corebase
open corecuda
open coreext
open tensorm

inl main() =
    run fun () =>
        // https://github.com/NVIDIA/cutlass/blob/main/media/docs/quickstart.md#launching-a-gemm-kernel-using-cutlass-30-or-newer
        global "#include <cutlass/cutlass.h>"
        global "#include <cutlass/numeric_types.h>"
        // global "#include \"cutlass/epilogue/collective/default_epilogue.hpp\""
        // global "#include \"cutlass/epilogue/thread/linear_combination.h\""
        // global "#include \"cutlass/gemm/collective/collective_builder.hpp\""
        global "#include \"cutlass/gemm/device/gemm_universal_adapter.h\""
        global "#include \"cutlass/gemm/kernel/gemm_universal.hpp\""

        // global "#include \"cutlass/util/host_tensor.h\""
        // global "#include \"cutlass/util/packed_stride.hpp\""

        global "using namespace cute;"
        // // A matrix configuration
        // using         ElementA    = float;                                          // Element type for A matrix operand
        // using         LayoutA     = cutlass::layout::RowMajor;                      // Layout type for A matrix operand
        // constexpr int AlignmentA  = 128 / cutlass::sizeof_bits<ElementA>::value;    // Memory access granularity/alignment of A matrix in units of elements (up to 16 bytes)

        // // B matrix configuration
        // using         ElementB    = float;                                          // Element type for B matrix operand
        // using         LayoutB     = cutlass::layout::ColumnMajor;                   // Layout type for B matrix operand
        // constexpr int AlignmentB  = 128 / cutlass::sizeof_bits<ElementB>::value;    // Memory access granularity/alignment of B matrix in units of elements (up to 16 bytes)

        // // C/D matrix configuration
        // using         ElementC    = float;                                          // Element type for C and D matrix operands
        // using         LayoutC     = cutlass::layout::ColumnMajor;                   // Layout type for C and D matrix operands
        // constexpr int AlignmentC  = 128 / cutlass::sizeof_bits<ElementC>::value;    // Memory access granularity/alignment of C matrix in units of elements (up to 16 bytes)

        // A matrix configuration
        // $"using         ElementA    = float"                               // Element type for A matrix operand
        // $"using         LayoutA     = cutlass::layout::RowMajor"                      // Layout type for A matrix operand
        // $"constexpr int AlignmentA  = 128 / cutlass::sizeof_bits<ElementA>::value"    // Memory access granularity/alignment of A matrix in units of elements (up to 16 bytes)

        // // B matrix configuration
        // $"using         ElementB    = cutlass::half_t"                                // Element type for B matrix operand
        // $"using         LayoutB     = cutlass::layout::ColumnMajor"                   // Layout type for B matrix operand
        // $"constexpr int AlignmentB  = 128 / cutlass::sizeof_bits<ElementB>::value"    // Memory access granularity/alignment of B matrix in units of elements (up to 16 bytes)

        // // C/D matrix configuration
        // $"using         ElementC    = cutlass::half_t"                                // Element type for C and D matrix operands
        // $"using         LayoutC     = cutlass::layout::ColumnMajor"                   // Layout type for C and D matrix operands

        // // Core kernel configurations
        // $"using ElementAccumulator  = float"                                          // Element type for internal accumulation
        // $"using ArchTag             = cutlass::arch::Sm90"                            // Tag indicating the minimum SM that supports the intended feature
        // $"using OperatorClass       = cutlass::arch::OpClassTensorOp"                 // Operator class tag
        // $"using TilesShape          = Shape<_128,_128,_64>"                           // Threadblock-level tile size
        // $"using ClusterShape        = Shape<_1,_2,_1>"                                // Shape of the threadblocks in a cluster
        // $"using StageCountType = cutlass::gemm::collective::StageCountAuto"           // Stage count maximized based on the tile size
        // $"using KernelSchedule = cutlass::gemm::collective::KernelScheduleAuto"       // Kernel to launch based on the default setting in the Collective Builder
        // $"using CollectiveMainloop = typename cutlass::gemm::collective::CollectiveBuilder<ArchTag, OperatorClass, ElementA, LayoutA, AlignmentA, ElementB, LayoutB, AlignmentB, ElementAccumulator, TilesShape, ClusterShape, cutlass::gemm::collective::StageCountAuto, cutlass::gemm::collective::KernelScheduleAuto>::CollectiveOp"
        // $"using CollectiveEpilogue = cutlass::epilogue::collective::DefaultEpilogue<cutlass::gemm::TagToStrideC_t<LayoutC>, cutlass::gemm::TagToStrideC_t<LayoutC>, cutlass::epilogue::thread::LinearCombination<ElementC, 1, ElementAccumulator, ElementAccumulator>>"
        // $"using GemmKernel = cutlass::gemm::kernel::GemmUniversal<Shape<int,int,int>,CollectiveMainloop,CollectiveEpilogue>"
        if rangem.threads_in_grid().from = 0 then
            console.write_ln "hello"
        ()