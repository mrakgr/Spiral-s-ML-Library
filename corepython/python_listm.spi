open corebase

// Python's list module.
nominal python_list a = $"list"

// Creates a python list.
inl create' forall t. : python_list t = $"[]"

// Concatenates an array of strings.
inl join' (sep : string) (l : python_list string) : string = $"!sep.join(!l)"
// Removes the element at the given index and returns it.
inl pop forall el. (l : python_list el) (i : int) : el = $"!l.pop(!i)"
// Appends to an array.
inl push forall el. (l : python_list el) (x : el) : () = $"!l.append(!x)"
// Cleards the array.
inl clear forall el. (l : python_list el) : () = $"!l.clear()"

instance index python_list = fun ar i => $"!ar[!i]"
instance set python_list = fun ar i v => $"!ar[!i] = !v"
instance length python_list = fun ar => $"len(!ar)"
instance create python_list = fun i => $"[None] * !i"

// Does on in-place shuffle of the list.
inl shuffle forall t. (deck : python_list t) : () =
    global "import random"
    $"random.shuffle(!deck)"

open tensorm

// Converts the tensor into a Numpy one, which use the main system memory. By default, the tensor are using CuPy arrays whose memory resides on the GPU.
inl tensor_to_numpy forall dim el. (x : tensor dim el) : tensor dim el = 
    inl _ : tensor _ _ = flatten x // Asserts the tensor is contiguous.
    inl (tensor {bodies dim}) = x |> apply_ptr
    tensor { dim bodies = real
        struct.map (fun (tensor_body {array stride offset}) =>
            typecase `array with ~ar ~el => 
            tensor_body `dim `el {
                stride offset array = $"!array.get()" : ar el // `get` converts the array to a Numpy one, transferring it to host.
            }) bodies
    }

inl from_2d_tensor forall a b t. (x : tensor (a * b) t) : python_list (python_list t) =
    inl l, x = create', tensor_to_numpy x
    loop.linear (fst x.dim) fun a =>
        inl l' = create'
        loop.linear (snd x.dim) fun b =>
            push l' (tensor_index (a,b) x)
        push l l'
    l