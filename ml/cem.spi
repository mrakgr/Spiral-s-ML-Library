open corebase
open corecuda
open primitives

inl cross_entropy_noise() = 0.1

type ensemble_id = int
type ratio = float * float
type trace_rewards = tensor ensemble_id ratio // actual reward is fst ratio / snd ratio
type weights = list (exists dim float{number; float}. tensor (ensemble_id * dim) float * tensor (dim * ensemble_id) float)

inl calculate_updates (trace_rewards : trace_rewards) (ensemble_id : ensemble_id) (ratio : ratio) =
    tensor_cuda.tensor_atomic_add ensemble_id ratio trace_rewards

inl cem forall dim float{number; float}. rng (transposed_weights : tensor (dim * ensemble_id) float) (trace_rewards : trace_rewards) =
    grid_row_map' (fun config x i j_tns =>
            inl mask = 
                inl average = local_average config x
                local_map (fun x => x >= average) x
            inl winner_mean = local_masked_reduce config 0 (+) (tensorm.zip x mask)
            inl winner_std = 
                inl x = local_map (fun x => inl r = x - winner_mean in r * r) x
                local_masked_reduce config 0 (+) (tensorm.zip x mask)
                |> sqrt
            local_map (fun x,b => 
                inl r = conv (random.normal rng) * (winner_std + cross_entropy_noise()) + winner_mean
                if b then x else r
                ) (tensorm.zip x mask)
            )
        transposed_weights transposed_weights

inl apply_updates rng grid (weights : weights) (trace_rewards : trace_rewards) : () =
    weights |> listm.iter (fun (exists dim float. weights, transposed_weights) =>
        grid_transpose weights transposed_weights
        )
    cooperative_groups.sync grid
    weights |> listm.iter (fun (exists dim float. _, transposed_weights) =>
        cem rng transposed_weights trace_rewards
        )
    cooperative_groups.sync grid
    weights |> listm.iter (fun (exists dim float. weights, transposed_weights) =>
        grid_transpose transposed_weights weights
        )
    cooperative_groups.sync grid

inl test1 weights transposed_weights trace_rewards =
    run fun () =>
        inl grid = cooperative_groups.create_grid()
        inl rng : ref random.philox_state = random.init {seed = random.clock64(); subsequence=conv rangem.threads_in_grid().from; offset=0}

        // step 1
        calculate_updates trace_rewards 0 (13 * 0.5, 0.5)
        calculate_updates trace_rewards 1 (13 * 0.3, 0.3)

        // step 2
        calculate_updates trace_rewards 0 (5 * 0.58, 0.58)
        calculate_updates trace_rewards 1 (5 * 0.342, 0.342)

        // step 3
        calculate_updates trace_rewards 0 (-4 * 0.5, 0.5)
        calculate_updates trace_rewards 1 (-4 * 0.3, 0.3)

        apply_updates rng weights transposed_weights trace_rewards