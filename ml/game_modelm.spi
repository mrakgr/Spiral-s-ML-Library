open corebase
open layers
open tensorm

type size = // The block and thread dimensions should match blocks_per_grid and threads_per_block
    {
        ensemble : int
    }

open corecuda
open rangem
inl run' forall inp out. (exists t. model : exists t. model t) (input : pickler.pu inp) (output : int -> out) (data : inp) =
    // Get the ensemble,block and thread dimensions based on the output tensor.
    inl ensemble,block,thread,_ = (key_extract model .output_probs : tensor d4 float).dim
    inl () = // Assert that all the dimensions are right.
        assert (block = blocks_per_grid()) "The second dimension of the output tensor has to equal the number of blocks per grid."
        assert (thread = threads_per_block()) "The third dimension of the output tensor has to equal number threads per block."
        inl block',thread' = (key_extract model .output_indices : tensor d2 int).dim
        assert ((block,thread) = (block',thread')) "The dimensions of the output indices tensor have to match."
        inl block',thread',_ = (key_extract model .input : tensor d3 float).dim
        assert ((block,thread) = (block',thread')) "The first two dimensions of the input tensor have to match number of blocks per grid and number of threads per block respectively."

    // Creates the layer state.
    inl ls = create_layer_state()

    // Extract the input tensor.
    inl x = (key_extract model .input : tensor (int * int * int) float)
    assert (block = fst x.dim) "The first dimension of the input tensor has to equal the number of blocks per grid."
    inl x = x |> apply block_index()
    assert (thread = fst x.dim) "The second dimension of the input tensor has to equal number threads per block."

    // Creates the layer state.
    inl ls = create_layer_state()

    // Sets the input tensor to 0.
    loop.projective threads_in_block(x.dim) fun i =>
        tensor_set i 0 x

    __syncthreads()

    // Serializes the data into the input tensor.
    inl _ =
        open pickler
        inl tns_input = x |> apply thread_index()
        input.pickle data (0,tns_input |> ptr_at_current_offset)

    __syncthreads()

    // Runs the model on the inputs.
    loop.linear ensemble fun ensemble =>
        graph_run_device model ls {ensemble}

    __syncthreads()

    // Randomly pick an ensemble id for each thread.
    inl ensemble_id : int = random.int_range {from=0; nearTo=ensemble} ls.rng

    // Extract the output probabilities (already calculated).
    inl output_probs = (key_extract model .output_probs : tensor d4 float) 

    // Extract the output indices tensor.
    inl output_indices =
        (key_extract model .output_indices : tensor d2 int) 
        |> apply block_index()

    inl () = // Calculate the output indices.
        open primitives
        inl output_probs = output_probs |> apply ensemble_id |> apply block_index()
        row_reduce (local_discrete_sampling ls.rng) output_probs output_indices
    
    inl output_id = tensor_index thread_index() output_indices
    {
        action = output output_id
        sampling_prob_ensemble =
            output_probs
            |> reorder (fun ensemble,block,thread,inner => block,thread,inner,ensemble)
            |> apply block_index()
            |> apply thread_index()
            |> apply output_id
        sampling_prob_selected = 
            output_probs
            |> apply ensemble_id 
            |> apply block_index()
            |> apply thread_index()
            |> tensor_index output_id
        ensemble_id
        output_id
        // output_max_probs_for_id =
        //     open primitives
        //     inl x = output_probs |> apply ensemble_id |> apply block_index()
        //     inl y = (key_extract model .output_max_probs : tensor d2 float) |> apply block_index()
        //     row_reduce (fun config x i tns_j => local_reduce config 0 max x) x y
        //     y
    }

nominal game_model inp out = 
    {
        model : exists t. model t
        input : pickler.pu inp
        output : int -> out
    }

inl run forall inp out. (game_model {model input output} : game_model inp out) = run' model input output