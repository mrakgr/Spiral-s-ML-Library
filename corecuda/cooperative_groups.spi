open corebase
open struct
open refm

inl grid_group_num_blocks() : int = $"cooperative_groups::grid_group::num_blocks()"
inl grid_group_block_rank() : int = $"cooperative_groups::grid_group::block_rank()"
inl grid_group_num_threads() : int = $"cooperative_groups::grid_group::num_threads()"
inl grid_group_thread_rank() : int = $"cooperative_groups::grid_group::thread_rank()"
inl thread_block_num_threads() : int = $"cooperative_groups::thread_block::num_threads()"
inl thread_block_thread_rank() : int = $"cooperative_groups::thread_block::thread_rank()"

nominal grid_group = $"cooperative_groups::grid_group"
nominal thread_block = $"cooperative_groups::thread_block"
nominal thread_block_tile parent size = $"cooperative_groups::thread_block_tile<@size, `parent>"
nominal thread = $"cooperative_groups::thread_block_tile<1>"
nominal coalesced_group = $"cooperative_groups::coalesced_group"

prototype groupable t : t -> ()
instance groupable thread = fun _ => ()
instance groupable thread_block = fun _ => ()
instance groupable coalesced_group = fun _ => ()
instance groupable thread_block_tile parent size = fun _ => ()
instance groupable grid_group = fun _ => ()

inl wait forall group {groupable}. (group : ref group) : () = $"cooperative_groups::wait(!group)"
inl sync forall group {groupable}. (group : ref group) : () = $'!group.sync() '

prototype tileable t : t -> ()
instance tileable thread = fun _ => ()
instance tileable thread_block = fun _ => ()
instance tileable thread_block_tile parent size = fun _ => ()
instance tileable coalesced_group = fun _ => ()

inl meta_group_size forall group {tileable}. (cg : ref group) : int = $"!cg.meta_group_size()"
inl meta_group_rank forall group {tileable}. (cg : ref group) : int = $"!cg.meta_group_rank()"

inl create_grid() : ref grid_group = $"auto \v = cooperative_groups::this_grid()"
inl create_block() : ref thread_block = $"auto \v = cooperative_groups::this_thread_block()"
inl create_thread() : ref thread = $"auto \v = cooperative_groups::this_thread()"

// These can only be created from tiles of size 32 or less.
inl create_labeled_partition forall parent {tileable}. (x : ref parent) (i : int) : ref coalesced_group = $"auto \v = cooperative_groups::labeled_partition(!x,!i)"
inl create_binary_partition forall parent {tileable}. (x : ref parent) (i : bool) : ref coalesced_group = $"auto \v = cooperative_groups::binary_partition(!x,!i)"
inl create_coalesced_threads() : ref coalesced_group = $"auto \v = cooperative_groups::coalesced_threads()"

inl cg_reduce forall el. (tile : ref coalesced_group) (f : el -> el -> el) (x : el) : el = 
    global "#include <cooperative_groups/reduce.h>"
    // The CUDA reduce function is passing the arguments in wrong order so we correct them here.
    inl f (arg a), (arg b) : el = f b a
    $"cooperative_groups::reduce(!tile, !x, !f)"
inl cg_inclusive_scan forall el. (tile : ref coalesced_group) (f : el -> el -> el) (x : el) : el = 
    global "#include <cooperative_groups/scan.h>"
    // The CUDA inclusive scan function is passing the arguments in wrong order so we correct them here.
    inl f (arg a), (arg b) : el = f b a
    $"cooperative_groups::inclusive_scan(!tile, !x, !f)"
inl cg_shuffle forall el. (tile : ref coalesced_group) (x : el) (i : int) : el = $"!tile.shfl(!x,!i)"
// Also returns the sum at the end.
inl cg_exclusive_scan forall el. (tile : ref coalesced_group) neutral_element (f : el -> el -> el) (x : el) : el * el = 
    global "#include <cooperative_groups/scan.h>"
    inl inclusive : el = cg_inclusive_scan tile f x
    inl exclusive = $"!tile.shfl_up(!inclusive,1)"
    (if $"!tile.thread_rank() == 0" then neutral_element else exclusive), $"!tile.shfl(!inclusive,!tile.num_threads()-1)"
inl cg_exclusive_scan' forall el. (tile : ref coalesced_group) neutral_element (f : el -> el -> el) (x : el) : el = 
    global "#include <cooperative_groups/scan.h>"
    inl inclusive : el = cg_inclusive_scan tile f x
    inl exclusive = $"!tile.shfl_up(!inclusive,1)"
    if $"!tile.thread_rank() == 0" then neutral_element else exclusive