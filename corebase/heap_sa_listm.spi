// Resizable arrays based on the static ones. The dim in the type determines their max length.
// Is intended to be a value type on the Cuda backend, and how it works on the Python backend, is merely a serialization convenience.
nominal heap_sa_list dim el = 
    mut {
        array : array el
        length : int
    }

// Creates an empty array.
inl create' forall dim el. : heap_sa_list dim el = 
    inl dim : int = real real_core.type_lit_to_lit `dim
    assert (0 <= dim) "The dimension of the array has to be non-negative."
    mut {
        array = create dim
        length = 0
    } |> heap_sa_list
    
// Returns the length of an array.
instance length heap_sa_list dim = fun ar => ar.length

// Sets the array to the specified length. Returns the old one. Doesn't do any checking that the new length is in range.
inl unsafe_set_length forall dim el. (heap_sa_list ar : heap_sa_list dim el) (f : int) : () = ar.length <- f

instance create heap_sa_list dim = fun dim =>
    assert ((real real_core.type_lit_to_lit `dim) >= dim) "The type level dimension has to equal the value passed at runtime into create."
    inl ar = create'
    unsafe_set_length ar dim
    ar

// Returns the maximum length of the array.
inl max_length forall dim el. (ar : heap_sa_list dim el) : int = real real_core.type_lit_to_lit `dim
    
// Indexes into an array.
instance index heap_sa_list dim = fun ar i => 
    assert (0 <= i && i < length ar) "The read index needs to be in range for the static array list."
    index ar.array i

// Sets the value of an array at the specified index.
instance set heap_sa_list dim = fun ar i v =>
    assert (0 <= i && i < length ar) "The set index needs to be in range for the static array list."
    set ar.array i v

// Pushes a value into the array.
inl push forall dim el. (ar : heap_sa_list dim el) (x : el) =
    inl len = length ar
    assert (len < max_length ar) "The length has to be less than the maximum length of the array."
    unsafe_set_length ar (len + 1)
    set ar len x

// Pop a value from the top of the array.
inl pop forall dim el. (ar : heap_sa_list dim el) : el =
    inl len = length ar - 1
    assert (len >= 0) "The length before popping has to be greater than 0."
    inl x = index ar len
    unsafe_set_length ar len
    x

// Sets the length of the array to 0.
inl clear forall dim el. (ar : heap_sa_list dim el) : () = unsafe_set_length ar 0

open arraym

instance equable heap_sa_list dim el = generic_equable
instance comparable heap_sa_list dim el = generic_comparable

open console

instance printable heap_sa_list dim el = array_print 100