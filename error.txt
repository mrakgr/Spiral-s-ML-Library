Error trace on line: 4, column: 9 in module: c:\Spiral's ML Library\tests\test1.spi.
inl main() =
        ^
Error trace on line: 5, column: 5 in module: c:\Spiral's ML Library\tests\test1.spi.
    run fun () =>
    ^
Error trace on line: 65, column: 13 in module: c:\Spiral's ML Library\corecuda\base.spi.
inl run f = run' {shared_mem = 0} f
            ^
Error trace on line: 30, column: 5 in module: c:\Spiral's ML Library\corecuda\base.spi.
    inl blocks_per_grid, threads_per_block = blocks_per_grid(), threads_per_block()
    ^
Error trace on line: 30, column: 9 in module: c:\Spiral's ML Library\corecuda\base.spi.
    inl blocks_per_grid, threads_per_block = blocks_per_grid(), threads_per_block()
        ^
Error trace on line: 32, column: 5 in module: c:\Spiral's ML Library\corecuda\base.spi.
    global "options = []"
    ^
Error trace on line: 34, column: 5 in module: c:\Spiral's ML Library\corecuda\base.spi.
    global "options.append('--diag-suppress=550,20012')" // suppresses some warnings related to unused vars
    ^
Error trace on line: 35, column: 5 in module: c:\Spiral's ML Library\corecuda\base.spi.
    global "options.append('--dopt=on')" // turns on the device optimizations
    ^
Error trace on line: 36, column: 5 in module: c:\Spiral's ML Library\corecuda\base.spi.
    global "options.append('--restrict')" // assumes all the pointers are restriced
    ^
Error trace on line: 38, column: 5 in module: c:\Spiral's ML Library\corecuda\base.spi.
    match threads_per_block with
    ^
Error trace on line: 44, column: 5 in module: c:\Spiral's ML Library\corecuda\base.spi.
    inl compiler = NVRTC
    ^
Error trace on line: 45, column: 5 in module: c:\Spiral's ML Library\corecuda\base.spi.
    match compiler with
    ^
Error trace on line: 48, column: 5 in module: c:\Spiral's ML Library\corecuda\base.spi.
    inl kernel_i, vars = join_backend Cuda
    ^
Error trace on line: 49, column: 9 in module: c:\Spiral's ML Library\corecuda\base.spi.
        match compiler with
        ^
Error trace on line: 54, column: 9 in module: c:\Spiral's ML Library\corecuda\base.spi.
        f () : ()
        ^
Error trace on line: 5, column: 13 in module: c:\Spiral's ML Library\tests\test1.spi.
    run fun () =>
            ^
Error trace on line: 6, column: 9 in module: c:\Spiral's ML Library\tests\test1.spi.
        inl f (x : int) = x
        ^
Error trace on line: 7, column: 9 in module: c:\Spiral's ML Library\tests\test1.spi.
        inl ~_ = f
        ^
Error trace on line: 7, column: 13 in module: c:\Spiral's ML Library\tests\test1.spi.
        inl ~_ = f
            ^
Regular functions do not have a composable type in the Cuda backend. Consider explicitly converting them to either closures or pointers using `to_closure` or `to_fptr` if you want to pass them through boundaries.