kernel = r"""
#include <new>
#include <assert.h>
#include <stdio.h>
#include <curand_kernel.h>
#include <mma.h>
using namespace nvcuda;
#include <cuda/pipeline>
#include <cooperative_groups/memcpy_async.h>
#include <cooperative_groups.h>
#include <cooperative_groups/reduce.h>
#include <cooperative_groups/scan.h>
using default_int = int;
using default_uint = unsigned int;
template <typename el>
struct sptr // Shared pointer for the Spiral datatypes. They have to have the refc field inside them to work.
{
    el* base;

    __device__ sptr() : base(nullptr) {}
    __device__ sptr(el* ptr) : base(ptr) { this->base->refc++; }

    __device__ ~sptr()
    {
        if (this->base != nullptr && --this->base->refc == 0)
        {
            delete this->base;
            this->base = nullptr;
        }
    }

    __device__ sptr(sptr& x)
    {
        this->base = x.base;
        this->base->refc++;
    }

    __device__ sptr(sptr&& x)
    {
        this->base = x.base;
        x.base = nullptr;
    }

    __device__ sptr& operator=(sptr& x)
    {
        if (this->base != x.base)
        {
            delete this->base;
            this->base = x.base;
            this->base->refc++;
        }
        return *this;
    }

    __device__ sptr& operator=(sptr&& x)
    {
        if (this->base != x.base)
        {
            delete this->base;
            this->base = x.base;
            x.base = nullptr;
        }
        return *this;
    }
};

template <typename el>
struct csptr : public sptr<el>
{ // Shared pointer for closures specifically.
    using sptr<el>::sptr;
    template <typename... Args>
    __device__ auto operator()(Args... args) -> decltype(this->base->operator()(args...))
    {
        return this->base->operator()(args...);
    }
};

template <typename el, default_int max_length>
struct static_array
{
    el ptr[max_length];
    __device__ el& operator[](default_int i) {
        assert("The index has to be in range." && 0 <= i && i < max_length);
        return this->ptr[i];
    }
};

template <typename el, default_int max_length>
struct static_array_list
{
    default_int length{ 0 };
    el ptr[max_length];

    __device__ el& operator[](default_int i) {
        assert("The index has to be in range." && 0 <= i && i < this->length);
        return this->ptr[i];
    }
    __device__ void push(el& x) {
        ptr[this->length++] = x;
        assert("The array after pushing should not be greater than max length." && this->length <= max_length);
    }
    __device__ void push(el&& x) {
        ptr[this->length++] = std::move(x);
        assert("The array after pushing should not be greater than max length." && this->length <= max_length);
    }
    __device__ el pop() {
        assert("The array before popping should be greater than 0." && 0 < this->length);
        auto x = ptr[--this->length];
        ptr[this->length].~el();
        new (&ptr[this->length]) el();
        return x;
    }
    // Should be used only during initialization.
    __device__ void unsafe_set_length(default_int i) {
        assert("The new length should be in range." && 0 <= i && i <= max_length);
        this->length = i;
    }
};

template <typename el, default_int max_length>
struct dynamic_array_base
{
    int refc{ 0 };
    el* ptr;

    __device__ dynamic_array_base() : ptr(new el[max_length]) {}
    __device__ ~dynamic_array_base() { delete[] this->ptr; }

    __device__ el& operator[](default_int i) {
        assert("The index has to be in range." && 0 <= i && i < this->length);
        return this->ptr[i];
    }
};

template <typename el, default_int max_length>
struct dynamic_array
{
    sptr<dynamic_array_base<el, max_length>> ptr;

    __device__ dynamic_array() = default;
    __device__ dynamic_array(bool t) : ptr(new dynamic_array_base<el, max_length>()) {}
    __device__ el& operator[](default_int i) {
        return this->ptr.base->operator[](i);
    }
};

template <typename el, default_int max_length>
struct dynamic_array_list_base
{
    int refc{ 0 };
    default_int length{ 0 };
    el* ptr;

    __device__ dynamic_array_list_base() : ptr(new el[max_length]) {}
    __device__ dynamic_array_list_base(default_int l) : ptr(new el[max_length]) { this->unsafe_set_length(l); }
    __device__ ~dynamic_array_list_base() { delete[] this->ptr; }

    __device__ el& operator[](default_int i) {
        assert("The index has to be in range." && 0 <= i && i < this->length);
        return this->ptr[i];
    }
    __device__ void push(el& x) {
        ptr[this->length++] = x;
        assert("The array after pushing should not be greater than max length." && this->length <= max_length);
    }
    __device__ void push(el&& x) {
        ptr[this->length++] = std::move(x);
        assert("The array after pushing should not be greater than max length." && this->length <= max_length);
    }
    __device__ el pop() {
        assert("The array before popping should be greater than 0." && 0 < this->length);
        auto x = ptr[--this->length];
        ptr[this->length].~el();
        new (&ptr[this->length]) el();
        return x;
    }
    // Should be used only during initialization.
    __device__ void unsafe_set_length(default_int i) {
        assert("The new length should be in range." && 0 <= i && i <= max_length);
        this->length = i;
    }
};

template <typename el, default_int max_length>
struct dynamic_array_list
{
    sptr<dynamic_array_list_base<el, max_length>> ptr;

    __device__ dynamic_array_list() = default;
    __device__ dynamic_array_list(default_int l) : ptr(new dynamic_array_list_base<el, max_length>(l)) {}

    __device__ el& operator[](default_int i) {
        return this->ptr.base->operator[](i);
    }
    __device__ void push(el& x) {
        this->ptr.base->push(x);
    }
    __device__ void push(el&& x) {
        this->ptr.base->push(std::move(x));
    }
    __device__ el pop() {
        return this->ptr.base->pop();
    }
    // Should be used only during initialization.
    __device__ void unsafe_set_length(default_int i) {
        this->ptr.base->unsafe_set_length(i);
    }
    __device__ default_int length_() {
        return this->ptr.base->length;
    }
};

struct Union1;
struct Union2;
struct Union0;
__device__ int f_1(unsigned char * v0);
__device__ void f_3(unsigned char * v0);
__device__ Union1 f_2(unsigned char * v0);
__device__ Union2 f_5(unsigned char * v0);
__device__ static_array<Union2,2> f_4(unsigned char * v0);
__device__ Union0 f_0(unsigned char * v0);
struct Union6;
struct Union5;
struct Union4;
struct Union3;
struct Union7;
struct Union8;
struct Tuple0;
__device__ unsigned int f_7(unsigned char * v0);
__device__ int f_8(unsigned char * v0);
struct Tuple1;
__device__ Union6 f_11(unsigned char * v0);
__device__ Tuple1 f_10(unsigned char * v0);
struct Tuple2;
__device__ int f_13(unsigned char * v0);
__device__ Tuple2 f_12(unsigned char * v0);
__device__ Union4 f_9(unsigned char * v0);
__device__ int f_14(unsigned char * v0);
struct Tuple3;
__device__ Tuple3 f_16(unsigned char * v0);
struct Tuple4;
__device__ Tuple4 f_17(unsigned char * v0);
struct Tuple5;
__device__ Tuple5 f_18(unsigned char * v0);
__device__ Union7 f_15(unsigned char * v0);
__device__ int f_19(unsigned char * v0);
__device__ Tuple0 f_6(unsigned char * v0);
struct StackMut0;
struct Tuple6;
__device__ unsigned int loop_21(unsigned int v0, curandStatePhilox4_32_10_t & v1);
__device__ Tuple6 draw_card_20(curandStatePhilox4_32_10_t & v0, unsigned int v1);
struct Tuple7;
struct Union9;
struct Union10;
__device__ int int_range_22(int v0, int v1, curandStatePhilox4_32_10_t & v2);
struct Union11;
__device__ void method_23(unsigned int * v0, int v1, float * v2);
struct Tuple8;
struct Tuple9;
struct Tuple10;
struct Tuple11;
__device__ Tuple8 method_24(curandStatePhilox4_32_10_t & v0, int * v1, float * v2, float * v3, float * v4, float * v5, float * v6, float * v7, float * v8, int v9, int v10);
struct Union12;
struct Union13;
__device__ int tag_26(Union6 v0);
__device__ bool is_pair_27(int v0, int v1);
__device__ Tuple7 order_28(int v0, int v1);
__device__ Union13 compare_hands_25(Union5 v0, bool v1, static_array<Union6,2> v2, int v3, static_array<int,2> v4, int v5);
__device__ void f_30(unsigned char * v0, unsigned int v1);
__device__ void f_31(unsigned char * v0, int v1);
__device__ void f_32(unsigned char * v0);
__device__ void f_34(unsigned char * v0, int v1);
__device__ void f_36(unsigned char * v0, Union6 v1);
__device__ void f_35(unsigned char * v0, Union5 v1, bool v2, static_array<Union6,2> v3, int v4, static_array<int,2> v5, int v6);
__device__ void f_38(unsigned char * v0, int v1);
__device__ void f_37(unsigned char * v0, Union5 v1, bool v2, static_array<Union6,2> v3, int v4, static_array<int,2> v5, int v6, Union1 v7);
__device__ void f_33(unsigned char * v0, Union4 v1);
__device__ void f_39(unsigned char * v0, int v1);
__device__ void f_41(unsigned char * v0, int v1, Union1 v2);
__device__ void f_42(unsigned char * v0, int v1, Union6 v2);
__device__ void f_43(unsigned char * v0, static_array<Union6,2> v1, int v2, int v3);
__device__ void f_40(unsigned char * v0, Union7 v1);
__device__ void f_44(unsigned char * v0, Union2 v1);
__device__ void f_45(unsigned char * v0, int v1);
__device__ void f_29(unsigned char * v0, unsigned int v1, Union3 v2, static_array_list<Union7,32> v3, static_array<Union2,2> v4, Union8 v5);
struct StackMut1;
struct Union14;
__device__ float method_47(int * v0, float * v1, float * v2, float * v3, float * v4, float * v5, float * v6, float * v7, int v8, int v9, int v10);
__device__ void method_46(unsigned char * v0, unsigned char * v1, StackMut1 & v2, int v3, Union4 v4);
struct Tuple12;
__device__ void method_48(unsigned char * v0, unsigned char * v1, StackMut1 & v2, Union4 v3);
__device__ float method_50(int * v0, float * v1, float * v2, float * v3, float * v4, float * v5, float * v6, float * v7, int v8, int v9, int v10);
__device__ void method_49(unsigned char * v0, unsigned char * v1, StackMut1 & v2, Union4 v3);
struct Union1_0 { // Call
};
struct Union1_1 { // Fold
};
struct Union1_2 { // Raise
};
struct Union1 {
    union {
        Union1_0 case0; // Call
        Union1_1 case1; // Fold
        Union1_2 case2; // Raise
    };
    unsigned char tag{255};
    __device__ Union1() {}
    __device__ Union1(Union1_0 t) : tag(0), case0(t) {} // Call
    __device__ Union1(Union1_1 t) : tag(1), case1(t) {} // Fold
    __device__ Union1(Union1_2 t) : tag(2), case2(t) {} // Raise
    __device__ Union1(Union1 & x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union1_0(x.case0); break; // Call
            case 1: new (&this->case1) Union1_1(x.case1); break; // Fold
            case 2: new (&this->case2) Union1_2(x.case2); break; // Raise
        }
    }
    __device__ Union1(Union1 && x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union1_0(std::move(x.case0)); break; // Call
            case 1: new (&this->case1) Union1_1(std::move(x.case1)); break; // Fold
            case 2: new (&this->case2) Union1_2(std::move(x.case2)); break; // Raise
        }
    }
    __device__ Union1 & operator=(Union1 & x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = x.case0; break; // Call
                case 1: this->case1 = x.case1; break; // Fold
                case 2: this->case2 = x.case2; break; // Raise
            }
        } else {
            this->~Union1();
            new (this) Union1{x};
        }
        return *this;
    }
    __device__ Union1 & operator=(Union1 && x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = std::move(x.case0); break; // Call
                case 1: this->case1 = std::move(x.case1); break; // Fold
                case 2: this->case2 = std::move(x.case2); break; // Raise
            }
        } else {
            this->~Union1();
            new (this) Union1{std::move(x)};
        }
        return *this;
    }
    __device__ ~Union1() {
        switch(this->tag){
            case 0: this->case0.~Union1_0(); break; // Call
            case 1: this->case1.~Union1_1(); break; // Fold
            case 2: this->case2.~Union1_2(); break; // Raise
        }
        this->tag = 255;
    }
};
struct Union2_0 { // Computer
};
struct Union2_1 { // Human
};
struct Union2_2 { // Random
};
struct Union2 {
    union {
        Union2_0 case0; // Computer
        Union2_1 case1; // Human
        Union2_2 case2; // Random
    };
    unsigned char tag{255};
    __device__ Union2() {}
    __device__ Union2(Union2_0 t) : tag(0), case0(t) {} // Computer
    __device__ Union2(Union2_1 t) : tag(1), case1(t) {} // Human
    __device__ Union2(Union2_2 t) : tag(2), case2(t) {} // Random
    __device__ Union2(Union2 & x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union2_0(x.case0); break; // Computer
            case 1: new (&this->case1) Union2_1(x.case1); break; // Human
            case 2: new (&this->case2) Union2_2(x.case2); break; // Random
        }
    }
    __device__ Union2(Union2 && x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union2_0(std::move(x.case0)); break; // Computer
            case 1: new (&this->case1) Union2_1(std::move(x.case1)); break; // Human
            case 2: new (&this->case2) Union2_2(std::move(x.case2)); break; // Random
        }
    }
    __device__ Union2 & operator=(Union2 & x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = x.case0; break; // Computer
                case 1: this->case1 = x.case1; break; // Human
                case 2: this->case2 = x.case2; break; // Random
            }
        } else {
            this->~Union2();
            new (this) Union2{x};
        }
        return *this;
    }
    __device__ Union2 & operator=(Union2 && x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = std::move(x.case0); break; // Computer
                case 1: this->case1 = std::move(x.case1); break; // Human
                case 2: this->case2 = std::move(x.case2); break; // Random
            }
        } else {
            this->~Union2();
            new (this) Union2{std::move(x)};
        }
        return *this;
    }
    __device__ ~Union2() {
        switch(this->tag){
            case 0: this->case0.~Union2_0(); break; // Computer
            case 1: this->case1.~Union2_1(); break; // Human
            case 2: this->case2.~Union2_2(); break; // Random
        }
        this->tag = 255;
    }
};
struct Union0_0 { // ActionSelected
    Union1 v0;
    __device__ Union0_0(Union1 t0) : v0(t0) {}
    __device__ Union0_0() = delete;
};
struct Union0_1 { // PlayerChanged
    static_array<Union2,2> v0;
    __device__ Union0_1(static_array<Union2,2> t0) : v0(t0) {}
    __device__ Union0_1() = delete;
};
struct Union0_2 { // StartGame
};
struct Union0_3 { // StartTrainingVsRando
};
struct Union0_4 { // StartTrainingVsSelf
};
struct Union0 {
    union {
        Union0_0 case0; // ActionSelected
        Union0_1 case1; // PlayerChanged
        Union0_2 case2; // StartGame
        Union0_3 case3; // StartTrainingVsRando
        Union0_4 case4; // StartTrainingVsSelf
    };
    unsigned char tag{255};
    __device__ Union0() {}
    __device__ Union0(Union0_0 t) : tag(0), case0(t) {} // ActionSelected
    __device__ Union0(Union0_1 t) : tag(1), case1(t) {} // PlayerChanged
    __device__ Union0(Union0_2 t) : tag(2), case2(t) {} // StartGame
    __device__ Union0(Union0_3 t) : tag(3), case3(t) {} // StartTrainingVsRando
    __device__ Union0(Union0_4 t) : tag(4), case4(t) {} // StartTrainingVsSelf
    __device__ Union0(Union0 & x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union0_0(x.case0); break; // ActionSelected
            case 1: new (&this->case1) Union0_1(x.case1); break; // PlayerChanged
            case 2: new (&this->case2) Union0_2(x.case2); break; // StartGame
            case 3: new (&this->case3) Union0_3(x.case3); break; // StartTrainingVsRando
            case 4: new (&this->case4) Union0_4(x.case4); break; // StartTrainingVsSelf
        }
    }
    __device__ Union0(Union0 && x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union0_0(std::move(x.case0)); break; // ActionSelected
            case 1: new (&this->case1) Union0_1(std::move(x.case1)); break; // PlayerChanged
            case 2: new (&this->case2) Union0_2(std::move(x.case2)); break; // StartGame
            case 3: new (&this->case3) Union0_3(std::move(x.case3)); break; // StartTrainingVsRando
            case 4: new (&this->case4) Union0_4(std::move(x.case4)); break; // StartTrainingVsSelf
        }
    }
    __device__ Union0 & operator=(Union0 & x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = x.case0; break; // ActionSelected
                case 1: this->case1 = x.case1; break; // PlayerChanged
                case 2: this->case2 = x.case2; break; // StartGame
                case 3: this->case3 = x.case3; break; // StartTrainingVsRando
                case 4: this->case4 = x.case4; break; // StartTrainingVsSelf
            }
        } else {
            this->~Union0();
            new (this) Union0{x};
        }
        return *this;
    }
    __device__ Union0 & operator=(Union0 && x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = std::move(x.case0); break; // ActionSelected
                case 1: this->case1 = std::move(x.case1); break; // PlayerChanged
                case 2: this->case2 = std::move(x.case2); break; // StartGame
                case 3: this->case3 = std::move(x.case3); break; // StartTrainingVsRando
                case 4: this->case4 = std::move(x.case4); break; // StartTrainingVsSelf
            }
        } else {
            this->~Union0();
            new (this) Union0{std::move(x)};
        }
        return *this;
    }
    __device__ ~Union0() {
        switch(this->tag){
            case 0: this->case0.~Union0_0(); break; // ActionSelected
            case 1: this->case1.~Union0_1(); break; // PlayerChanged
            case 2: this->case2.~Union0_2(); break; // StartGame
            case 3: this->case3.~Union0_3(); break; // StartTrainingVsRando
            case 4: this->case4.~Union0_4(); break; // StartTrainingVsSelf
        }
        this->tag = 255;
    }
};
struct Union6_0 { // Jack
};
struct Union6_1 { // King
};
struct Union6_2 { // Queen
};
struct Union6 {
    union {
        Union6_0 case0; // Jack
        Union6_1 case1; // King
        Union6_2 case2; // Queen
    };
    unsigned char tag{255};
    __device__ Union6() {}
    __device__ Union6(Union6_0 t) : tag(0), case0(t) {} // Jack
    __device__ Union6(Union6_1 t) : tag(1), case1(t) {} // King
    __device__ Union6(Union6_2 t) : tag(2), case2(t) {} // Queen
    __device__ Union6(Union6 & x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union6_0(x.case0); break; // Jack
            case 1: new (&this->case1) Union6_1(x.case1); break; // King
            case 2: new (&this->case2) Union6_2(x.case2); break; // Queen
        }
    }
    __device__ Union6(Union6 && x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union6_0(std::move(x.case0)); break; // Jack
            case 1: new (&this->case1) Union6_1(std::move(x.case1)); break; // King
            case 2: new (&this->case2) Union6_2(std::move(x.case2)); break; // Queen
        }
    }
    __device__ Union6 & operator=(Union6 & x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = x.case0; break; // Jack
                case 1: this->case1 = x.case1; break; // King
                case 2: this->case2 = x.case2; break; // Queen
            }
        } else {
            this->~Union6();
            new (this) Union6{x};
        }
        return *this;
    }
    __device__ Union6 & operator=(Union6 && x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = std::move(x.case0); break; // Jack
                case 1: this->case1 = std::move(x.case1); break; // King
                case 2: this->case2 = std::move(x.case2); break; // Queen
            }
        } else {
            this->~Union6();
            new (this) Union6{std::move(x)};
        }
        return *this;
    }
    __device__ ~Union6() {
        switch(this->tag){
            case 0: this->case0.~Union6_0(); break; // Jack
            case 1: this->case1.~Union6_1(); break; // King
            case 2: this->case2.~Union6_2(); break; // Queen
        }
        this->tag = 255;
    }
};
struct Union5_0 { // None
};
struct Union5_1 { // Some
    Union6 v0;
    __device__ Union5_1(Union6 t0) : v0(t0) {}
    __device__ Union5_1() = delete;
};
struct Union5 {
    union {
        Union5_0 case0; // None
        Union5_1 case1; // Some
    };
    unsigned char tag{255};
    __device__ Union5() {}
    __device__ Union5(Union5_0 t) : tag(0), case0(t) {} // None
    __device__ Union5(Union5_1 t) : tag(1), case1(t) {} // Some
    __device__ Union5(Union5 & x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union5_0(x.case0); break; // None
            case 1: new (&this->case1) Union5_1(x.case1); break; // Some
        }
    }
    __device__ Union5(Union5 && x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union5_0(std::move(x.case0)); break; // None
            case 1: new (&this->case1) Union5_1(std::move(x.case1)); break; // Some
        }
    }
    __device__ Union5 & operator=(Union5 & x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = x.case0; break; // None
                case 1: this->case1 = x.case1; break; // Some
            }
        } else {
            this->~Union5();
            new (this) Union5{x};
        }
        return *this;
    }
    __device__ Union5 & operator=(Union5 && x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = std::move(x.case0); break; // None
                case 1: this->case1 = std::move(x.case1); break; // Some
            }
        } else {
            this->~Union5();
            new (this) Union5{std::move(x)};
        }
        return *this;
    }
    __device__ ~Union5() {
        switch(this->tag){
            case 0: this->case0.~Union5_0(); break; // None
            case 1: this->case1.~Union5_1(); break; // Some
        }
        this->tag = 255;
    }
};
struct Union4_0 { // ChanceCommunityCard
    Union5 v0;
    static_array<Union6,2> v2;
    static_array<int,2> v4;
    int v3;
    int v5;
    bool v1;
    __device__ Union4_0(Union5 t0, bool t1, static_array<Union6,2> t2, int t3, static_array<int,2> t4, int t5) : v0(t0), v1(t1), v2(t2), v3(t3), v4(t4), v5(t5) {}
    __device__ Union4_0() = delete;
};
struct Union4_1 { // ChanceInit
};
struct Union4_2 { // Round
    Union5 v0;
    static_array<Union6,2> v2;
    static_array<int,2> v4;
    int v3;
    int v5;
    bool v1;
    __device__ Union4_2(Union5 t0, bool t1, static_array<Union6,2> t2, int t3, static_array<int,2> t4, int t5) : v0(t0), v1(t1), v2(t2), v3(t3), v4(t4), v5(t5) {}
    __device__ Union4_2() = delete;
};
struct Union4_3 { // RoundWithAction
    Union5 v0;
    static_array<Union6,2> v2;
    static_array<int,2> v4;
    Union1 v6;
    int v3;
    int v5;
    bool v1;
    __device__ Union4_3(Union5 t0, bool t1, static_array<Union6,2> t2, int t3, static_array<int,2> t4, int t5, Union1 t6) : v0(t0), v1(t1), v2(t2), v3(t3), v4(t4), v5(t5), v6(t6) {}
    __device__ Union4_3() = delete;
};
struct Union4_4 { // TerminalCall
    Union5 v0;
    static_array<Union6,2> v2;
    static_array<int,2> v4;
    int v3;
    int v5;
    bool v1;
    __device__ Union4_4(Union5 t0, bool t1, static_array<Union6,2> t2, int t3, static_array<int,2> t4, int t5) : v0(t0), v1(t1), v2(t2), v3(t3), v4(t4), v5(t5) {}
    __device__ Union4_4() = delete;
};
struct Union4_5 { // TerminalFold
    Union5 v0;
    static_array<Union6,2> v2;
    static_array<int,2> v4;
    int v3;
    int v5;
    bool v1;
    __device__ Union4_5(Union5 t0, bool t1, static_array<Union6,2> t2, int t3, static_array<int,2> t4, int t5) : v0(t0), v1(t1), v2(t2), v3(t3), v4(t4), v5(t5) {}
    __device__ Union4_5() = delete;
};
struct Union4 {
    union {
        Union4_0 case0; // ChanceCommunityCard
        Union4_1 case1; // ChanceInit
        Union4_2 case2; // Round
        Union4_3 case3; // RoundWithAction
        Union4_4 case4; // TerminalCall
        Union4_5 case5; // TerminalFold
    };
    unsigned char tag{255};
    __device__ Union4() {}
    __device__ Union4(Union4_0 t) : tag(0), case0(t) {} // ChanceCommunityCard
    __device__ Union4(Union4_1 t) : tag(1), case1(t) {} // ChanceInit
    __device__ Union4(Union4_2 t) : tag(2), case2(t) {} // Round
    __device__ Union4(Union4_3 t) : tag(3), case3(t) {} // RoundWithAction
    __device__ Union4(Union4_4 t) : tag(4), case4(t) {} // TerminalCall
    __device__ Union4(Union4_5 t) : tag(5), case5(t) {} // TerminalFold
    __device__ Union4(Union4 & x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union4_0(x.case0); break; // ChanceCommunityCard
            case 1: new (&this->case1) Union4_1(x.case1); break; // ChanceInit
            case 2: new (&this->case2) Union4_2(x.case2); break; // Round
            case 3: new (&this->case3) Union4_3(x.case3); break; // RoundWithAction
            case 4: new (&this->case4) Union4_4(x.case4); break; // TerminalCall
            case 5: new (&this->case5) Union4_5(x.case5); break; // TerminalFold
        }
    }
    __device__ Union4(Union4 && x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union4_0(std::move(x.case0)); break; // ChanceCommunityCard
            case 1: new (&this->case1) Union4_1(std::move(x.case1)); break; // ChanceInit
            case 2: new (&this->case2) Union4_2(std::move(x.case2)); break; // Round
            case 3: new (&this->case3) Union4_3(std::move(x.case3)); break; // RoundWithAction
            case 4: new (&this->case4) Union4_4(std::move(x.case4)); break; // TerminalCall
            case 5: new (&this->case5) Union4_5(std::move(x.case5)); break; // TerminalFold
        }
    }
    __device__ Union4 & operator=(Union4 & x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = x.case0; break; // ChanceCommunityCard
                case 1: this->case1 = x.case1; break; // ChanceInit
                case 2: this->case2 = x.case2; break; // Round
                case 3: this->case3 = x.case3; break; // RoundWithAction
                case 4: this->case4 = x.case4; break; // TerminalCall
                case 5: this->case5 = x.case5; break; // TerminalFold
            }
        } else {
            this->~Union4();
            new (this) Union4{x};
        }
        return *this;
    }
    __device__ Union4 & operator=(Union4 && x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = std::move(x.case0); break; // ChanceCommunityCard
                case 1: this->case1 = std::move(x.case1); break; // ChanceInit
                case 2: this->case2 = std::move(x.case2); break; // Round
                case 3: this->case3 = std::move(x.case3); break; // RoundWithAction
                case 4: this->case4 = std::move(x.case4); break; // TerminalCall
                case 5: this->case5 = std::move(x.case5); break; // TerminalFold
            }
        } else {
            this->~Union4();
            new (this) Union4{std::move(x)};
        }
        return *this;
    }
    __device__ ~Union4() {
        switch(this->tag){
            case 0: this->case0.~Union4_0(); break; // ChanceCommunityCard
            case 1: this->case1.~Union4_1(); break; // ChanceInit
            case 2: this->case2.~Union4_2(); break; // Round
            case 3: this->case3.~Union4_3(); break; // RoundWithAction
            case 4: this->case4.~Union4_4(); break; // TerminalCall
            case 5: this->case5.~Union4_5(); break; // TerminalFold
        }
        this->tag = 255;
    }
};
struct Union3_0 { // None
};
struct Union3_1 { // Some
    Union4 v0;
    __device__ Union3_1(Union4 t0) : v0(t0) {}
    __device__ Union3_1() = delete;
};
struct Union3 {
    union {
        Union3_0 case0; // None
        Union3_1 case1; // Some
    };
    unsigned char tag{255};
    __device__ Union3() {}
    __device__ Union3(Union3_0 t) : tag(0), case0(t) {} // None
    __device__ Union3(Union3_1 t) : tag(1), case1(t) {} // Some
    __device__ Union3(Union3 & x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union3_0(x.case0); break; // None
            case 1: new (&this->case1) Union3_1(x.case1); break; // Some
        }
    }
    __device__ Union3(Union3 && x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union3_0(std::move(x.case0)); break; // None
            case 1: new (&this->case1) Union3_1(std::move(x.case1)); break; // Some
        }
    }
    __device__ Union3 & operator=(Union3 & x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = x.case0; break; // None
                case 1: this->case1 = x.case1; break; // Some
            }
        } else {
            this->~Union3();
            new (this) Union3{x};
        }
        return *this;
    }
    __device__ Union3 & operator=(Union3 && x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = std::move(x.case0); break; // None
                case 1: this->case1 = std::move(x.case1); break; // Some
            }
        } else {
            this->~Union3();
            new (this) Union3{std::move(x)};
        }
        return *this;
    }
    __device__ ~Union3() {
        switch(this->tag){
            case 0: this->case0.~Union3_0(); break; // None
            case 1: this->case1.~Union3_1(); break; // Some
        }
        this->tag = 255;
    }
};
struct Union7_0 { // CommunityCardIs
    Union6 v0;
    __device__ Union7_0(Union6 t0) : v0(t0) {}
    __device__ Union7_0() = delete;
};
struct Union7_1 { // PlayerAction
    Union1 v1;
    int v0;
    __device__ Union7_1(int t0, Union1 t1) : v0(t0), v1(t1) {}
    __device__ Union7_1() = delete;
};
struct Union7_2 { // PlayerGotCard
    Union6 v1;
    int v0;
    __device__ Union7_2(int t0, Union6 t1) : v0(t0), v1(t1) {}
    __device__ Union7_2() = delete;
};
struct Union7_3 { // Showdown
    static_array<Union6,2> v0;
    int v1;
    int v2;
    __device__ Union7_3(static_array<Union6,2> t0, int t1, int t2) : v0(t0), v1(t1), v2(t2) {}
    __device__ Union7_3() = delete;
};
struct Union7 {
    union {
        Union7_0 case0; // CommunityCardIs
        Union7_1 case1; // PlayerAction
        Union7_2 case2; // PlayerGotCard
        Union7_3 case3; // Showdown
    };
    unsigned char tag{255};
    __device__ Union7() {}
    __device__ Union7(Union7_0 t) : tag(0), case0(t) {} // CommunityCardIs
    __device__ Union7(Union7_1 t) : tag(1), case1(t) {} // PlayerAction
    __device__ Union7(Union7_2 t) : tag(2), case2(t) {} // PlayerGotCard
    __device__ Union7(Union7_3 t) : tag(3), case3(t) {} // Showdown
    __device__ Union7(Union7 & x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union7_0(x.case0); break; // CommunityCardIs
            case 1: new (&this->case1) Union7_1(x.case1); break; // PlayerAction
            case 2: new (&this->case2) Union7_2(x.case2); break; // PlayerGotCard
            case 3: new (&this->case3) Union7_3(x.case3); break; // Showdown
        }
    }
    __device__ Union7(Union7 && x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union7_0(std::move(x.case0)); break; // CommunityCardIs
            case 1: new (&this->case1) Union7_1(std::move(x.case1)); break; // PlayerAction
            case 2: new (&this->case2) Union7_2(std::move(x.case2)); break; // PlayerGotCard
            case 3: new (&this->case3) Union7_3(std::move(x.case3)); break; // Showdown
        }
    }
    __device__ Union7 & operator=(Union7 & x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = x.case0; break; // CommunityCardIs
                case 1: this->case1 = x.case1; break; // PlayerAction
                case 2: this->case2 = x.case2; break; // PlayerGotCard
                case 3: this->case3 = x.case3; break; // Showdown
            }
        } else {
            this->~Union7();
            new (this) Union7{x};
        }
        return *this;
    }
    __device__ Union7 & operator=(Union7 && x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = std::move(x.case0); break; // CommunityCardIs
                case 1: this->case1 = std::move(x.case1); break; // PlayerAction
                case 2: this->case2 = std::move(x.case2); break; // PlayerGotCard
                case 3: this->case3 = std::move(x.case3); break; // Showdown
            }
        } else {
            this->~Union7();
            new (this) Union7{std::move(x)};
        }
        return *this;
    }
    __device__ ~Union7() {
        switch(this->tag){
            case 0: this->case0.~Union7_0(); break; // CommunityCardIs
            case 1: this->case1.~Union7_1(); break; // PlayerAction
            case 2: this->case2.~Union7_2(); break; // PlayerGotCard
            case 3: this->case3.~Union7_3(); break; // Showdown
        }
        this->tag = 255;
    }
};
struct Union8_0 { // GameNotStarted
};
struct Union8_1 { // GameOver
    Union5 v0;
    static_array<Union6,2> v2;
    static_array<int,2> v4;
    int v3;
    int v5;
    bool v1;
    __device__ Union8_1(Union5 t0, bool t1, static_array<Union6,2> t2, int t3, static_array<int,2> t4, int t5) : v0(t0), v1(t1), v2(t2), v3(t3), v4(t4), v5(t5) {}
    __device__ Union8_1() = delete;
};
struct Union8_2 { // WaitingForActionFromPlayerId
    Union5 v0;
    static_array<Union6,2> v2;
    static_array<int,2> v4;
    int v3;
    int v5;
    bool v1;
    __device__ Union8_2(Union5 t0, bool t1, static_array<Union6,2> t2, int t3, static_array<int,2> t4, int t5) : v0(t0), v1(t1), v2(t2), v3(t3), v4(t4), v5(t5) {}
    __device__ Union8_2() = delete;
};
struct Union8 {
    union {
        Union8_0 case0; // GameNotStarted
        Union8_1 case1; // GameOver
        Union8_2 case2; // WaitingForActionFromPlayerId
    };
    unsigned char tag{255};
    __device__ Union8() {}
    __device__ Union8(Union8_0 t) : tag(0), case0(t) {} // GameNotStarted
    __device__ Union8(Union8_1 t) : tag(1), case1(t) {} // GameOver
    __device__ Union8(Union8_2 t) : tag(2), case2(t) {} // WaitingForActionFromPlayerId
    __device__ Union8(Union8 & x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union8_0(x.case0); break; // GameNotStarted
            case 1: new (&this->case1) Union8_1(x.case1); break; // GameOver
            case 2: new (&this->case2) Union8_2(x.case2); break; // WaitingForActionFromPlayerId
        }
    }
    __device__ Union8(Union8 && x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union8_0(std::move(x.case0)); break; // GameNotStarted
            case 1: new (&this->case1) Union8_1(std::move(x.case1)); break; // GameOver
            case 2: new (&this->case2) Union8_2(std::move(x.case2)); break; // WaitingForActionFromPlayerId
        }
    }
    __device__ Union8 & operator=(Union8 & x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = x.case0; break; // GameNotStarted
                case 1: this->case1 = x.case1; break; // GameOver
                case 2: this->case2 = x.case2; break; // WaitingForActionFromPlayerId
            }
        } else {
            this->~Union8();
            new (this) Union8{x};
        }
        return *this;
    }
    __device__ Union8 & operator=(Union8 && x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = std::move(x.case0); break; // GameNotStarted
                case 1: this->case1 = std::move(x.case1); break; // GameOver
                case 2: this->case2 = std::move(x.case2); break; // WaitingForActionFromPlayerId
            }
        } else {
            this->~Union8();
            new (this) Union8{std::move(x)};
        }
        return *this;
    }
    __device__ ~Union8() {
        switch(this->tag){
            case 0: this->case0.~Union8_0(); break; // GameNotStarted
            case 1: this->case1.~Union8_1(); break; // GameOver
            case 2: this->case2.~Union8_2(); break; // WaitingForActionFromPlayerId
        }
        this->tag = 255;
    }
};
struct Tuple0 {
    Union3 v1;
    static_array_list<Union7,32> v2;
    static_array<Union2,2> v3;
    Union8 v4;
    unsigned int v0;
    __device__ Tuple0() = default;
    __device__ Tuple0(unsigned int t0, Union3 t1, static_array_list<Union7,32> t2, static_array<Union2,2> t3, Union8 t4) : v0(t0), v1(t1), v2(t2), v3(t3), v4(t4) {}
};
struct Tuple1 {
    Union5 v0;
    static_array<Union6,2> v2;
    static_array<int,2> v4;
    int v3;
    int v5;
    bool v1;
    __device__ Tuple1() = default;
    __device__ Tuple1(Union5 t0, bool t1, static_array<Union6,2> t2, int t3, static_array<int,2> t4, int t5) : v0(t0), v1(t1), v2(t2), v3(t3), v4(t4), v5(t5) {}
};
struct Tuple2 {
    Union5 v0;
    static_array<Union6,2> v2;
    static_array<int,2> v4;
    Union1 v6;
    int v3;
    int v5;
    bool v1;
    __device__ Tuple2() = default;
    __device__ Tuple2(Union5 t0, bool t1, static_array<Union6,2> t2, int t3, static_array<int,2> t4, int t5, Union1 t6) : v0(t0), v1(t1), v2(t2), v3(t3), v4(t4), v5(t5), v6(t6) {}
};
struct Tuple3 {
    Union1 v1;
    int v0;
    __device__ Tuple3() = default;
    __device__ Tuple3(int t0, Union1 t1) : v0(t0), v1(t1) {}
};
struct Tuple4 {
    Union6 v1;
    int v0;
    __device__ Tuple4() = default;
    __device__ Tuple4(int t0, Union6 t1) : v0(t0), v1(t1) {}
};
struct Tuple5 {
    static_array<Union6,2> v0;
    int v1;
    int v2;
    __device__ Tuple5() = default;
    __device__ Tuple5(static_array<Union6,2> t0, int t1, int t2) : v0(t0), v1(t1), v2(t2) {}
};
struct StackMut0 {
    Union3 v1;
    static_array_list<Union7,32> v2;
    static_array<Union2,2> v3;
    curandStatePhilox4_32_10_t v4;
    Union8 v5;
    unsigned int v0;
    __device__ StackMut0() = default;
    __device__ StackMut0(unsigned int t0, Union3 t1, static_array_list<Union7,32> t2, static_array<Union2,2> t3, curandStatePhilox4_32_10_t t4, Union8 t5) : v0(t0), v1(t1), v2(t2), v3(t3), v4(t4), v5(t5) {}
};
struct Tuple6 {
    Union6 v0;
    unsigned int v1;
    __device__ Tuple6() = default;
    __device__ Tuple6(Union6 t0, unsigned int t1) : v0(t0), v1(t1) {}
};
struct Tuple7 {
    int v0;
    int v1;
    __device__ Tuple7() = default;
    __device__ Tuple7(int t0, int t1) : v0(t0), v1(t1) {}
};
struct Union9_0 { // C1of2
    Union1 v0;
    __device__ Union9_0(Union1 t0) : v0(t0) {}
    __device__ Union9_0() = delete;
};
struct Union9_1 { // C2of2
    Union6 v0;
    __device__ Union9_1(Union6 t0) : v0(t0) {}
    __device__ Union9_1() = delete;
};
struct Union9 {
    union {
        Union9_0 case0; // C1of2
        Union9_1 case1; // C2of2
    };
    unsigned char tag{255};
    __device__ Union9() {}
    __device__ Union9(Union9_0 t) : tag(0), case0(t) {} // C1of2
    __device__ Union9(Union9_1 t) : tag(1), case1(t) {} // C2of2
    __device__ Union9(Union9 & x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union9_0(x.case0); break; // C1of2
            case 1: new (&this->case1) Union9_1(x.case1); break; // C2of2
        }
    }
    __device__ Union9(Union9 && x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union9_0(std::move(x.case0)); break; // C1of2
            case 1: new (&this->case1) Union9_1(std::move(x.case1)); break; // C2of2
        }
    }
    __device__ Union9 & operator=(Union9 & x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = x.case0; break; // C1of2
                case 1: this->case1 = x.case1; break; // C2of2
            }
        } else {
            this->~Union9();
            new (this) Union9{x};
        }
        return *this;
    }
    __device__ Union9 & operator=(Union9 && x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = std::move(x.case0); break; // C1of2
                case 1: this->case1 = std::move(x.case1); break; // C2of2
            }
        } else {
            this->~Union9();
            new (this) Union9{std::move(x)};
        }
        return *this;
    }
    __device__ ~Union9() {
        switch(this->tag){
            case 0: this->case0.~Union9_0(); break; // C1of2
            case 1: this->case1.~Union9_1(); break; // C2of2
        }
        this->tag = 255;
    }
};
struct Union10_0 { // None
};
struct Union10_1 { // Some
    Union9 v0;
    __device__ Union10_1(Union9 t0) : v0(t0) {}
    __device__ Union10_1() = delete;
};
struct Union10 {
    union {
        Union10_0 case0; // None
        Union10_1 case1; // Some
    };
    unsigned char tag{255};
    __device__ Union10() {}
    __device__ Union10(Union10_0 t) : tag(0), case0(t) {} // None
    __device__ Union10(Union10_1 t) : tag(1), case1(t) {} // Some
    __device__ Union10(Union10 & x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union10_0(x.case0); break; // None
            case 1: new (&this->case1) Union10_1(x.case1); break; // Some
        }
    }
    __device__ Union10(Union10 && x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union10_0(std::move(x.case0)); break; // None
            case 1: new (&this->case1) Union10_1(std::move(x.case1)); break; // Some
        }
    }
    __device__ Union10 & operator=(Union10 & x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = x.case0; break; // None
                case 1: this->case1 = x.case1; break; // Some
            }
        } else {
            this->~Union10();
            new (this) Union10{x};
        }
        return *this;
    }
    __device__ Union10 & operator=(Union10 && x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = std::move(x.case0); break; // None
                case 1: this->case1 = std::move(x.case1); break; // Some
            }
        } else {
            this->~Union10();
            new (this) Union10{std::move(x)};
        }
        return *this;
    }
    __device__ ~Union10() {
        switch(this->tag){
            case 0: this->case0.~Union10_0(); break; // None
            case 1: this->case1.~Union10_1(); break; // Some
        }
        this->tag = 255;
    }
};
struct Union11_0 { // None
};
struct Union11_1 { // Some
    int v0;
    __device__ Union11_1(int t0) : v0(t0) {}
    __device__ Union11_1() = delete;
};
struct Union11 {
    union {
        Union11_0 case0; // None
        Union11_1 case1; // Some
    };
    unsigned char tag{255};
    __device__ Union11() {}
    __device__ Union11(Union11_0 t) : tag(0), case0(t) {} // None
    __device__ Union11(Union11_1 t) : tag(1), case1(t) {} // Some
    __device__ Union11(Union11 & x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union11_0(x.case0); break; // None
            case 1: new (&this->case1) Union11_1(x.case1); break; // Some
        }
    }
    __device__ Union11(Union11 && x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union11_0(std::move(x.case0)); break; // None
            case 1: new (&this->case1) Union11_1(std::move(x.case1)); break; // Some
        }
    }
    __device__ Union11 & operator=(Union11 & x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = x.case0; break; // None
                case 1: this->case1 = x.case1; break; // Some
            }
        } else {
            this->~Union11();
            new (this) Union11{x};
        }
        return *this;
    }
    __device__ Union11 & operator=(Union11 && x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = std::move(x.case0); break; // None
                case 1: this->case1 = std::move(x.case1); break; // Some
            }
        } else {
            this->~Union11();
            new (this) Union11{std::move(x)};
        }
        return *this;
    }
    __device__ ~Union11() {
        switch(this->tag){
            case 0: this->case0.~Union11_0(); break; // None
            case 1: this->case1.~Union11_1(); break; // Some
        }
        this->tag = 255;
    }
};
struct Closure0 {
    __device__ unsigned int operator()(unsigned int tup0, unsigned int tup1){
        unsigned int v0 = tup0; unsigned int v1 = tup1;
        unsigned int v2;
        v2 = v0 | v1;
        return v2;
    }
};
struct Tuple8 {
    float v0;
    int v1;
    __device__ Tuple8() = default;
    __device__ Tuple8(float t0, int t1) : v0(t0), v1(t1) {}
};
struct Closure1 {
    __device__ float operator()(float tup0, float tup1){
        float v0 = tup0; float v1 = tup1;
        float v2;
        v2 = v0 + v1;
        return v2;
    }
};
struct Closure2 {
    __device__ int operator()(int tup0, int tup1){
        int v0 = tup0; int v1 = tup1;
        int v2;
        v2 = v0 + v1;
        return v2;
    }
};
struct Tuple9 {
    int v0;
    float v1;
    __device__ Tuple9() = default;
    __device__ Tuple9(int t0, float t1) : v0(t0), v1(t1) {}
};
struct Closure3 {
    __device__ float operator()(float tup0, float tup1){
        float v0 = tup0; float v1 = tup1;
        float v2;
        v2 = v0 + v1;
        return v2;
    }
};
struct Tuple10 {
    float v0;
    bool v1;
    __device__ Tuple10() = default;
    __device__ Tuple10(float t0, bool t1) : v0(t0), v1(t1) {}
};
struct Closure4 {
    __device__ Tuple10 operator()(Tuple10 tup0, Tuple10 tup1){
        float v0 = tup0.v0; bool v1 = tup0.v1; float v2 = tup1.v0; bool v3 = tup1.v1;
        if (v1){
            if (v3){
                bool v4;
                v4 = v0 >= v2;
                float v5;
                if (v4){
                    v5 = v0;
                } else {
                    v5 = v2;
                }
                return Tuple10{v5, true};
            } else {
                return Tuple10{v0, v1};
            }
        } else {
            if (v3){
                return Tuple10{v2, v3};
            } else {
                return Tuple10{v0, v1};
            }
        }
    }
};
struct Closure5 {
    __device__ Tuple8 operator()(Tuple8 tup0, Tuple8 tup1){
        float v0 = tup0.v0; int v1 = tup0.v1; float v2 = tup1.v0; int v3 = tup1.v1;
        bool v4;
        v4 = v1 < v3;
        if (v4){
            return Tuple8{v0, v1};
        } else {
            return Tuple8{v2, v3};
        }
    }
};
struct Tuple11 {
    int v0;
    bool v1;
    __device__ Tuple11() = default;
    __device__ Tuple11(int t0, bool t1) : v0(t0), v1(t1) {}
};
struct Closure6 {
    __device__ Tuple11 operator()(Tuple11 tup0, Tuple11 tup1){
        int v0 = tup0.v0; bool v1 = tup0.v1; int v2 = tup1.v0; bool v3 = tup1.v1;
        if (v1){
            if (v3){
                bool v4;
                v4 = v0 < v2;
                int v5;
                if (v4){
                    v5 = v0;
                } else {
                    v5 = v2;
                }
                return Tuple11{v5, true};
            } else {
                return Tuple11{v0, v1};
            }
        } else {
            if (v3){
                return Tuple11{v2, v3};
            } else {
                return Tuple11{v0, v1};
            }
        }
    }
};
struct Closure7 {
    int v0;
    __device__ Tuple8 operator()(Tuple8 tup0, Tuple8 tup1){
        int & v0 = this->v0;
        float v1 = tup0.v0; int v2 = tup0.v1; float v3 = tup1.v0; int v4 = tup1.v1;
        bool v5;
        v5 = v2 == v0;
        if (v5){
            return Tuple8{v1, v2};
        } else {
            bool v6;
            v6 = v4 == v0;
            if (v6){
                return Tuple8{v3, v4};
            } else {
                return Tuple8{v1, v2};
            }
        }
    }
    __device__ Closure7(int _v0) : v0(_v0) { }
};
struct Union12_0 { // AA_Call
};
struct Union12_1 { // AA_Fold
};
struct Union12_2 { // AA_Raise
};
struct Union12 {
    union {
        Union12_0 case0; // AA_Call
        Union12_1 case1; // AA_Fold
        Union12_2 case2; // AA_Raise
    };
    unsigned char tag{255};
    __device__ Union12() {}
    __device__ Union12(Union12_0 t) : tag(0), case0(t) {} // AA_Call
    __device__ Union12(Union12_1 t) : tag(1), case1(t) {} // AA_Fold
    __device__ Union12(Union12_2 t) : tag(2), case2(t) {} // AA_Raise
    __device__ Union12(Union12 & x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union12_0(x.case0); break; // AA_Call
            case 1: new (&this->case1) Union12_1(x.case1); break; // AA_Fold
            case 2: new (&this->case2) Union12_2(x.case2); break; // AA_Raise
        }
    }
    __device__ Union12(Union12 && x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union12_0(std::move(x.case0)); break; // AA_Call
            case 1: new (&this->case1) Union12_1(std::move(x.case1)); break; // AA_Fold
            case 2: new (&this->case2) Union12_2(std::move(x.case2)); break; // AA_Raise
        }
    }
    __device__ Union12 & operator=(Union12 & x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = x.case0; break; // AA_Call
                case 1: this->case1 = x.case1; break; // AA_Fold
                case 2: this->case2 = x.case2; break; // AA_Raise
            }
        } else {
            this->~Union12();
            new (this) Union12{x};
        }
        return *this;
    }
    __device__ Union12 & operator=(Union12 && x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = std::move(x.case0); break; // AA_Call
                case 1: this->case1 = std::move(x.case1); break; // AA_Fold
                case 2: this->case2 = std::move(x.case2); break; // AA_Raise
            }
        } else {
            this->~Union12();
            new (this) Union12{std::move(x)};
        }
        return *this;
    }
    __device__ ~Union12() {
        switch(this->tag){
            case 0: this->case0.~Union12_0(); break; // AA_Call
            case 1: this->case1.~Union12_1(); break; // AA_Fold
            case 2: this->case2.~Union12_2(); break; // AA_Raise
        }
        this->tag = 255;
    }
};
struct Union13_0 { // Eq
};
struct Union13_1 { // Gt
};
struct Union13_2 { // Lt
};
struct Union13 {
    union {
        Union13_0 case0; // Eq
        Union13_1 case1; // Gt
        Union13_2 case2; // Lt
    };
    unsigned char tag{255};
    __device__ Union13() {}
    __device__ Union13(Union13_0 t) : tag(0), case0(t) {} // Eq
    __device__ Union13(Union13_1 t) : tag(1), case1(t) {} // Gt
    __device__ Union13(Union13_2 t) : tag(2), case2(t) {} // Lt
    __device__ Union13(Union13 & x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union13_0(x.case0); break; // Eq
            case 1: new (&this->case1) Union13_1(x.case1); break; // Gt
            case 2: new (&this->case2) Union13_2(x.case2); break; // Lt
        }
    }
    __device__ Union13(Union13 && x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union13_0(std::move(x.case0)); break; // Eq
            case 1: new (&this->case1) Union13_1(std::move(x.case1)); break; // Gt
            case 2: new (&this->case2) Union13_2(std::move(x.case2)); break; // Lt
        }
    }
    __device__ Union13 & operator=(Union13 & x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = x.case0; break; // Eq
                case 1: this->case1 = x.case1; break; // Gt
                case 2: this->case2 = x.case2; break; // Lt
            }
        } else {
            this->~Union13();
            new (this) Union13{x};
        }
        return *this;
    }
    __device__ Union13 & operator=(Union13 && x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = std::move(x.case0); break; // Eq
                case 1: this->case1 = std::move(x.case1); break; // Gt
                case 2: this->case2 = std::move(x.case2); break; // Lt
            }
        } else {
            this->~Union13();
            new (this) Union13{std::move(x)};
        }
        return *this;
    }
    __device__ ~Union13() {
        switch(this->tag){
            case 0: this->case0.~Union13_0(); break; // Eq
            case 1: this->case1.~Union13_1(); break; // Gt
            case 2: this->case2.~Union13_2(); break; // Lt
        }
        this->tag = 255;
    }
};
struct StackMut1 {
    cooperative_groups::grid_group v1;
    static_array_list<Union7,32> v2;
    static_array<Union2,2> v3;
    static_array<float,2> v4;
    curandStatePhilox4_32_10_t v5;
    unsigned int v0;
    __device__ StackMut1() = default;
    __device__ StackMut1(unsigned int t0, cooperative_groups::grid_group t1, static_array_list<Union7,32> t2, static_array<Union2,2> t3, static_array<float,2> t4, curandStatePhilox4_32_10_t t5) : v0(t0), v1(t1), v2(t2), v3(t3), v4(t4), v5(t5) {}
};
struct Union14_0 { // T_game_chance_community_card
    Union5 v0;
    static_array<Union6,2> v2;
    static_array<int,2> v4;
    Union6 v6;
    int v3;
    int v5;
    bool v1;
    __device__ Union14_0(Union5 t0, bool t1, static_array<Union6,2> t2, int t3, static_array<int,2> t4, int t5, Union6 t6) : v0(t0), v1(t1), v2(t2), v3(t3), v4(t4), v5(t5), v6(t6) {}
    __device__ Union14_0() = delete;
};
struct Union14_1 { // T_game_chance_init
    Union6 v0;
    Union6 v1;
    __device__ Union14_1(Union6 t0, Union6 t1) : v0(t0), v1(t1) {}
    __device__ Union14_1() = delete;
};
struct Union14_2 { // T_game_round
    Union5 v0;
    static_array<Union6,2> v2;
    static_array<int,2> v4;
    Union1 v6;
    int v3;
    int v5;
    bool v1;
    __device__ Union14_2(Union5 t0, bool t1, static_array<Union6,2> t2, int t3, static_array<int,2> t4, int t5, Union1 t6) : v0(t0), v1(t1), v2(t2), v3(t3), v4(t4), v5(t5), v6(t6) {}
    __device__ Union14_2() = delete;
};
struct Union14_3 { // T_none
};
struct Union14 {
    union {
        Union14_0 case0; // T_game_chance_community_card
        Union14_1 case1; // T_game_chance_init
        Union14_2 case2; // T_game_round
        Union14_3 case3; // T_none
    };
    unsigned char tag{255};
    __device__ Union14() {}
    __device__ Union14(Union14_0 t) : tag(0), case0(t) {} // T_game_chance_community_card
    __device__ Union14(Union14_1 t) : tag(1), case1(t) {} // T_game_chance_init
    __device__ Union14(Union14_2 t) : tag(2), case2(t) {} // T_game_round
    __device__ Union14(Union14_3 t) : tag(3), case3(t) {} // T_none
    __device__ Union14(Union14 & x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union14_0(x.case0); break; // T_game_chance_community_card
            case 1: new (&this->case1) Union14_1(x.case1); break; // T_game_chance_init
            case 2: new (&this->case2) Union14_2(x.case2); break; // T_game_round
            case 3: new (&this->case3) Union14_3(x.case3); break; // T_none
        }
    }
    __device__ Union14(Union14 && x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union14_0(std::move(x.case0)); break; // T_game_chance_community_card
            case 1: new (&this->case1) Union14_1(std::move(x.case1)); break; // T_game_chance_init
            case 2: new (&this->case2) Union14_2(std::move(x.case2)); break; // T_game_round
            case 3: new (&this->case3) Union14_3(std::move(x.case3)); break; // T_none
        }
    }
    __device__ Union14 & operator=(Union14 & x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = x.case0; break; // T_game_chance_community_card
                case 1: this->case1 = x.case1; break; // T_game_chance_init
                case 2: this->case2 = x.case2; break; // T_game_round
                case 3: this->case3 = x.case3; break; // T_none
            }
        } else {
            this->~Union14();
            new (this) Union14{x};
        }
        return *this;
    }
    __device__ Union14 & operator=(Union14 && x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = std::move(x.case0); break; // T_game_chance_community_card
                case 1: this->case1 = std::move(x.case1); break; // T_game_chance_init
                case 2: this->case2 = std::move(x.case2); break; // T_game_round
                case 3: this->case3 = std::move(x.case3); break; // T_none
            }
        } else {
            this->~Union14();
            new (this) Union14{std::move(x)};
        }
        return *this;
    }
    __device__ ~Union14() {
        switch(this->tag){
            case 0: this->case0.~Union14_0(); break; // T_game_chance_community_card
            case 1: this->case1.~Union14_1(); break; // T_game_chance_init
            case 2: this->case2.~Union14_2(); break; // T_game_round
            case 3: this->case3.~Union14_3(); break; // T_none
        }
        this->tag = 255;
    }
};
struct Tuple12 {
    double v1;
    int v0;
    __device__ Tuple12() = default;
    __device__ Tuple12(int t0, double t1) : v0(t0), v1(t1) {}
};
struct Closure8 {
    __device__ bool operator()(bool tup0, bool tup1){
        bool v0 = tup0; bool v1 = tup1;
        bool v2;
        v2 = v0 || v1;
        return v2;
    }
};
__device__ int f_1(unsigned char * v0){
    int * v1;
    v1 = (int *)(v0+0ull);
    int v3;
    v3 = v1[0];
    return v3;
}
__device__ void f_3(unsigned char * v0){
    return ;
}
__device__ Union1 f_2(unsigned char * v0){
    int v1;
    v1 = f_1(v0);
    unsigned char * v2;
    v2 = (unsigned char *)(v0+4ull);
    switch (v1) {
        case 0: {
            f_3(v2);
            return Union1{Union1_0{}};
            break;
        }
        case 1: {
            f_3(v2);
            return Union1{Union1_1{}};
            break;
        }
        case 2: {
            f_3(v2);
            return Union1{Union1_2{}};
            break;
        }
        default: {
            printf("%s\n", "Invalid tag.");
            __trap();
        }
    }
}
__device__ inline bool while_method_0(int v0){
    bool v1;
    v1 = v0 < 2;
    return v1;
}
__device__ Union2 f_5(unsigned char * v0){
    int v1;
    v1 = f_1(v0);
    unsigned char * v2;
    v2 = (unsigned char *)(v0+4ull);
    switch (v1) {
        case 0: {
            f_3(v2);
            return Union2{Union2_0{}};
            break;
        }
        case 1: {
            f_3(v2);
            return Union2{Union2_1{}};
            break;
        }
        case 2: {
            f_3(v2);
            return Union2{Union2_2{}};
            break;
        }
        default: {
            printf("%s\n", "Invalid tag.");
            __trap();
        }
    }
}
__device__ static_array<Union2,2> f_4(unsigned char * v0){
    static_array<Union2,2> v1;
    int v3;
    v3 = 0;
    while (while_method_0(v3)){
        unsigned long long v5;
        v5 = (unsigned long long)v3;
        unsigned long long v6;
        v6 = v5 * 4ull;
        unsigned char * v7;
        v7 = (unsigned char *)(v0+v6);
        Union2 v9;
        v9 = f_5(v7);
        v1[v3] = v9;
        v3 += 1 ;
    }
    return v1;
}
__device__ Union0 f_0(unsigned char * v0){
    int v1;
    v1 = f_1(v0);
    unsigned char * v2;
    v2 = (unsigned char *)(v0+8ull);
    switch (v1) {
        case 0: {
            Union1 v5;
            v5 = f_2(v2);
            return Union0{Union0_0{v5}};
            break;
        }
        case 1: {
            static_array<Union2,2> v7;
            v7 = f_4(v2);
            return Union0{Union0_1{v7}};
            break;
        }
        case 2: {
            f_3(v2);
            return Union0{Union0_2{}};
            break;
        }
        case 3: {
            f_3(v2);
            return Union0{Union0_3{}};
            break;
        }
        case 4: {
            f_3(v2);
            return Union0{Union0_4{}};
            break;
        }
        default: {
            printf("%s\n", "Invalid tag.");
            __trap();
        }
    }
}
__device__ unsigned int f_7(unsigned char * v0){
    unsigned int * v1;
    v1 = (unsigned int *)(v0+0ull);
    unsigned int v3;
    v3 = v1[0];
    return v3;
}
__device__ int f_8(unsigned char * v0){
    int * v1;
    v1 = (int *)(v0+4ull);
    int v3;
    v3 = v1[0];
    return v3;
}
__device__ Union6 f_11(unsigned char * v0){
    int v1;
    v1 = f_1(v0);
    unsigned char * v2;
    v2 = (unsigned char *)(v0+4ull);
    switch (v1) {
        case 0: {
            f_3(v2);
            return Union6{Union6_0{}};
            break;
        }
        case 1: {
            f_3(v2);
            return Union6{Union6_1{}};
            break;
        }
        case 2: {
            f_3(v2);
            return Union6{Union6_2{}};
            break;
        }
        default: {
            printf("%s\n", "Invalid tag.");
            __trap();
        }
    }
}
__device__ Tuple1 f_10(unsigned char * v0){
    int v1;
    v1 = f_1(v0);
    unsigned char * v2;
    v2 = (unsigned char *)(v0+4ull);
    Union5 v8;
    switch (v1) {
        case 0: {
            f_3(v2);
            v8 = Union5{Union5_0{}};
            break;
        }
        case 1: {
            Union6 v6;
            v6 = f_11(v2);
            v8 = Union5{Union5_1{v6}};
            break;
        }
        default: {
            printf("%s\n", "Invalid tag.");
            __trap();
        }
    }
    bool * v9;
    v9 = (bool *)(v0+8ull);
    bool v11;
    v11 = v9[0];
    static_array<Union6,2> v12;
    int v14;
    v14 = 0;
    while (while_method_0(v14)){
        unsigned long long v16;
        v16 = (unsigned long long)v14;
        unsigned long long v17;
        v17 = v16 * 4ull;
        unsigned long long v18;
        v18 = 12ull + v17;
        unsigned char * v19;
        v19 = (unsigned char *)(v0+v18);
        Union6 v21;
        v21 = f_11(v19);
        v12[v14] = v21;
        v14 += 1 ;
    }
    int * v22;
    v22 = (int *)(v0+20ull);
    int v24;
    v24 = v22[0];
    static_array<int,2> v25;
    int v27;
    v27 = 0;
    while (while_method_0(v27)){
        unsigned long long v29;
        v29 = (unsigned long long)v27;
        unsigned long long v30;
        v30 = v29 * 4ull;
        unsigned long long v31;
        v31 = 24ull + v30;
        unsigned char * v32;
        v32 = (unsigned char *)(v0+v31);
        int v34;
        v34 = f_1(v32);
        v25[v27] = v34;
        v27 += 1 ;
    }
    int * v35;
    v35 = (int *)(v0+32ull);
    int v37;
    v37 = v35[0];
    return Tuple1{v8, v11, v12, v24, v25, v37};
}
__device__ int f_13(unsigned char * v0){
    int * v1;
    v1 = (int *)(v0+36ull);
    int v3;
    v3 = v1[0];
    return v3;
}
__device__ Tuple2 f_12(unsigned char * v0){
    int v1;
    v1 = f_1(v0);
    unsigned char * v2;
    v2 = (unsigned char *)(v0+4ull);
    Union5 v8;
    switch (v1) {
        case 0: {
            f_3(v2);
            v8 = Union5{Union5_0{}};
            break;
        }
        case 1: {
            Union6 v6;
            v6 = f_11(v2);
            v8 = Union5{Union5_1{v6}};
            break;
        }
        default: {
            printf("%s\n", "Invalid tag.");
            __trap();
        }
    }
    bool * v9;
    v9 = (bool *)(v0+8ull);
    bool v11;
    v11 = v9[0];
    static_array<Union6,2> v12;
    int v14;
    v14 = 0;
    while (while_method_0(v14)){
        unsigned long long v16;
        v16 = (unsigned long long)v14;
        unsigned long long v17;
        v17 = v16 * 4ull;
        unsigned long long v18;
        v18 = 12ull + v17;
        unsigned char * v19;
        v19 = (unsigned char *)(v0+v18);
        Union6 v21;
        v21 = f_11(v19);
        v12[v14] = v21;
        v14 += 1 ;
    }
    int * v22;
    v22 = (int *)(v0+20ull);
    int v24;
    v24 = v22[0];
    static_array<int,2> v25;
    int v27;
    v27 = 0;
    while (while_method_0(v27)){
        unsigned long long v29;
        v29 = (unsigned long long)v27;
        unsigned long long v30;
        v30 = v29 * 4ull;
        unsigned long long v31;
        v31 = 24ull + v30;
        unsigned char * v32;
        v32 = (unsigned char *)(v0+v31);
        int v34;
        v34 = f_1(v32);
        v25[v27] = v34;
        v27 += 1 ;
    }
    int * v35;
    v35 = (int *)(v0+32ull);
    int v37;
    v37 = v35[0];
    int v38;
    v38 = f_13(v0);
    unsigned char * v39;
    v39 = (unsigned char *)(v0+40ull);
    Union1 v45;
    switch (v38) {
        case 0: {
            f_3(v39);
            v45 = Union1{Union1_0{}};
            break;
        }
        case 1: {
            f_3(v39);
            v45 = Union1{Union1_1{}};
            break;
        }
        case 2: {
            f_3(v39);
            v45 = Union1{Union1_2{}};
            break;
        }
        default: {
            printf("%s\n", "Invalid tag.");
            __trap();
        }
    }
    return Tuple2{v8, v11, v12, v24, v25, v37, v45};
}
__device__ Union4 f_9(unsigned char * v0){
    int v1;
    v1 = f_1(v0);
    unsigned char * v2;
    v2 = (unsigned char *)(v0+16ull);
    switch (v1) {
        case 0: {
            Union5 v5; bool v6; static_array<Union6,2> v7; int v8; static_array<int,2> v9; int v10;
            Tuple1 tmp0 = f_10(v2);
            v5 = tmp0.v0; v6 = tmp0.v1; v7 = tmp0.v2; v8 = tmp0.v3; v9 = tmp0.v4; v10 = tmp0.v5;
            return Union4{Union4_0{v5, v6, v7, v8, v9, v10}};
            break;
        }
        case 1: {
            f_3(v2);
            return Union4{Union4_1{}};
            break;
        }
        case 2: {
            Union5 v13; bool v14; static_array<Union6,2> v15; int v16; static_array<int,2> v17; int v18;
            Tuple1 tmp1 = f_10(v2);
            v13 = tmp1.v0; v14 = tmp1.v1; v15 = tmp1.v2; v16 = tmp1.v3; v17 = tmp1.v4; v18 = tmp1.v5;
            return Union4{Union4_2{v13, v14, v15, v16, v17, v18}};
            break;
        }
        case 3: {
            Union5 v20; bool v21; static_array<Union6,2> v22; int v23; static_array<int,2> v24; int v25; Union1 v26;
            Tuple2 tmp2 = f_12(v2);
            v20 = tmp2.v0; v21 = tmp2.v1; v22 = tmp2.v2; v23 = tmp2.v3; v24 = tmp2.v4; v25 = tmp2.v5; v26 = tmp2.v6;
            return Union4{Union4_3{v20, v21, v22, v23, v24, v25, v26}};
            break;
        }
        case 4: {
            Union5 v28; bool v29; static_array<Union6,2> v30; int v31; static_array<int,2> v32; int v33;
            Tuple1 tmp3 = f_10(v2);
            v28 = tmp3.v0; v29 = tmp3.v1; v30 = tmp3.v2; v31 = tmp3.v3; v32 = tmp3.v4; v33 = tmp3.v5;
            return Union4{Union4_4{v28, v29, v30, v31, v32, v33}};
            break;
        }
        case 5: {
            Union5 v35; bool v36; static_array<Union6,2> v37; int v38; static_array<int,2> v39; int v40;
            Tuple1 tmp4 = f_10(v2);
            v35 = tmp4.v0; v36 = tmp4.v1; v37 = tmp4.v2; v38 = tmp4.v3; v39 = tmp4.v4; v40 = tmp4.v5;
            return Union4{Union4_5{v35, v36, v37, v38, v39, v40}};
            break;
        }
        default: {
            printf("%s\n", "Invalid tag.");
            __trap();
        }
    }
}
__device__ int f_14(unsigned char * v0){
    int * v1;
    v1 = (int *)(v0+80ull);
    int v3;
    v3 = v1[0];
    return v3;
}
__device__ inline bool while_method_1(int v0, int v1){
    bool v2;
    v2 = v1 < v0;
    return v2;
}
__device__ Tuple3 f_16(unsigned char * v0){
    int * v1;
    v1 = (int *)(v0+0ull);
    int v3;
    v3 = v1[0];
    int v4;
    v4 = f_8(v0);
    unsigned char * v5;
    v5 = (unsigned char *)(v0+8ull);
    Union1 v11;
    switch (v4) {
        case 0: {
            f_3(v5);
            v11 = Union1{Union1_0{}};
            break;
        }
        case 1: {
            f_3(v5);
            v11 = Union1{Union1_1{}};
            break;
        }
        case 2: {
            f_3(v5);
            v11 = Union1{Union1_2{}};
            break;
        }
        default: {
            printf("%s\n", "Invalid tag.");
            __trap();
        }
    }
    return Tuple3{v3, v11};
}
__device__ Tuple4 f_17(unsigned char * v0){
    int * v1;
    v1 = (int *)(v0+0ull);
    int v3;
    v3 = v1[0];
    int v4;
    v4 = f_8(v0);
    unsigned char * v5;
    v5 = (unsigned char *)(v0+8ull);
    Union6 v11;
    switch (v4) {
        case 0: {
            f_3(v5);
            v11 = Union6{Union6_0{}};
            break;
        }
        case 1: {
            f_3(v5);
            v11 = Union6{Union6_1{}};
            break;
        }
        case 2: {
            f_3(v5);
            v11 = Union6{Union6_2{}};
            break;
        }
        default: {
            printf("%s\n", "Invalid tag.");
            __trap();
        }
    }
    return Tuple4{v3, v11};
}
__device__ Tuple5 f_18(unsigned char * v0){
    static_array<Union6,2> v1;
    int v3;
    v3 = 0;
    while (while_method_0(v3)){
        unsigned long long v5;
        v5 = (unsigned long long)v3;
        unsigned long long v6;
        v6 = v5 * 4ull;
        unsigned char * v7;
        v7 = (unsigned char *)(v0+v6);
        Union6 v9;
        v9 = f_11(v7);
        v1[v3] = v9;
        v3 += 1 ;
    }
    int * v10;
    v10 = (int *)(v0+8ull);
    int v12;
    v12 = v10[0];
    int * v13;
    v13 = (int *)(v0+12ull);
    int v15;
    v15 = v13[0];
    return Tuple5{v1, v12, v15};
}
__device__ Union7 f_15(unsigned char * v0){
    int v1;
    v1 = f_1(v0);
    unsigned char * v2;
    v2 = (unsigned char *)(v0+16ull);
    switch (v1) {
        case 0: {
            Union6 v5;
            v5 = f_11(v2);
            return Union7{Union7_0{v5}};
            break;
        }
        case 1: {
            int v7; Union1 v8;
            Tuple3 tmp5 = f_16(v2);
            v7 = tmp5.v0; v8 = tmp5.v1;
            return Union7{Union7_1{v7, v8}};
            break;
        }
        case 2: {
            int v10; Union6 v11;
            Tuple4 tmp6 = f_17(v2);
            v10 = tmp6.v0; v11 = tmp6.v1;
            return Union7{Union7_2{v10, v11}};
            break;
        }
        case 3: {
            static_array<Union6,2> v13; int v14; int v15;
            Tuple5 tmp7 = f_18(v2);
            v13 = tmp7.v0; v14 = tmp7.v1; v15 = tmp7.v2;
            return Union7{Union7_3{v13, v14, v15}};
            break;
        }
        default: {
            printf("%s\n", "Invalid tag.");
            __trap();
        }
    }
}
__device__ int f_19(unsigned char * v0){
    int * v1;
    v1 = (int *)(v0+1128ull);
    int v3;
    v3 = v1[0];
    return v3;
}
__device__ Tuple0 f_6(unsigned char * v0){
    unsigned int v1;
    v1 = f_7(v0);
    int v2;
    v2 = f_8(v0);
    unsigned char * v3;
    v3 = (unsigned char *)(v0+16ull);
    Union3 v9;
    switch (v2) {
        case 0: {
            f_3(v3);
            v9 = Union3{Union3_0{}};
            break;
        }
        case 1: {
            Union4 v7;
            v7 = f_9(v3);
            v9 = Union3{Union3_1{v7}};
            break;
        }
        default: {
            printf("%s\n", "Invalid tag.");
            __trap();
        }
    }
    static_array_list<Union7,32> v10;
    v10 = static_array_list<Union7,32>{};
    int v12;
    v12 = f_14(v0);
    v10.unsafe_set_length(v12);
    int v13;
    v13 = v10.length;
    int v14;
    v14 = 0;
    while (while_method_1(v13, v14)){
        unsigned long long v16;
        v16 = (unsigned long long)v14;
        unsigned long long v17;
        v17 = v16 * 32ull;
        unsigned long long v18;
        v18 = 96ull + v17;
        unsigned char * v19;
        v19 = (unsigned char *)(v0+v18);
        Union7 v21;
        v21 = f_15(v19);
        v10[v14] = v21;
        v14 += 1 ;
    }
    static_array<Union2,2> v22;
    int v24;
    v24 = 0;
    while (while_method_0(v24)){
        unsigned long long v26;
        v26 = (unsigned long long)v24;
        unsigned long long v27;
        v27 = v26 * 4ull;
        unsigned long long v28;
        v28 = 1120ull + v27;
        unsigned char * v29;
        v29 = (unsigned char *)(v0+v28);
        Union2 v31;
        v31 = f_5(v29);
        v22[v24] = v31;
        v24 += 1 ;
    }
    int v32;
    v32 = f_19(v0);
    unsigned char * v33;
    v33 = (unsigned char *)(v0+1136ull);
    Union8 v51;
    switch (v32) {
        case 0: {
            f_3(v33);
            v51 = Union8{Union8_0{}};
            break;
        }
        case 1: {
            Union5 v37; bool v38; static_array<Union6,2> v39; int v40; static_array<int,2> v41; int v42;
            Tuple1 tmp8 = f_10(v33);
            v37 = tmp8.v0; v38 = tmp8.v1; v39 = tmp8.v2; v40 = tmp8.v3; v41 = tmp8.v4; v42 = tmp8.v5;
            v51 = Union8{Union8_1{v37, v38, v39, v40, v41, v42}};
            break;
        }
        case 2: {
            Union5 v44; bool v45; static_array<Union6,2> v46; int v47; static_array<int,2> v48; int v49;
            Tuple1 tmp9 = f_10(v33);
            v44 = tmp9.v0; v45 = tmp9.v1; v46 = tmp9.v2; v47 = tmp9.v3; v48 = tmp9.v4; v49 = tmp9.v5;
            v51 = Union8{Union8_2{v44, v45, v46, v47, v48, v49}};
            break;
        }
        default: {
            printf("%s\n", "Invalid tag.");
            __trap();
        }
    }
    return Tuple0{v1, v9, v10, v22, v51};
}
__device__ inline bool while_method_2(Union3 v0){
    switch (v0.tag) {
        case 0: { // None
            return false;
            break;
        }
        case 1: { // Some
            Union4 v1 = v0.case1.v0;
            return true;
            break;
        }
        default: {
            assert("Invalid tag." && false); __trap();
        }
    }
}
__device__ unsigned int loop_21(unsigned int v0, curandStatePhilox4_32_10_t & v1){
    unsigned int v2;
    v2 = curand(&v1);
    unsigned int v3;
    v3 = v2 % v0;
    unsigned int v4;
    v4 = v2 - v3;
    unsigned int v5;
    v5 = 0u - v0;
    bool v6;
    v6 = v4 <= v5;
    if (v6){
        return v3;
    } else {
        return loop_21(v0, v1);
    }
}
__device__ Tuple6 draw_card_20(curandStatePhilox4_32_10_t & v0, unsigned int v1){
    int v2;
    v2 = __popc(v1);
    unsigned int v3;
    v3 = (unsigned int)v2;
    unsigned int v4;
    v4 = loop_21(v3, v0);
    int v5;
    v5 = (int)v4;
    int v6;
    v6 = __popc(v1);
    bool v7;
    v7 = v5 < v6;
    unsigned int v12;
    if (v7){
        int v8;
        v8 = v5 + 1;
        unsigned int v9;
        v9 = __fns(v1,0u,v8);
        v12 = v9;
    } else {
        int v10;
        v10 = v5 - v6;
        printf("%s\n", "Cannot find the n-th set bit.");
        __trap();
    }
    bool v13;
    v13 = 0u == v12;
    Union6 v31;
    if (v13){
        v31 = Union6{Union6_1{}};
    } else {
        bool v15;
        v15 = 1u == v12;
        if (v15){
            v31 = Union6{Union6_1{}};
        } else {
            bool v17;
            v17 = 2u == v12;
            if (v17){
                v31 = Union6{Union6_2{}};
            } else {
                bool v19;
                v19 = 3u == v12;
                if (v19){
                    v31 = Union6{Union6_2{}};
                } else {
                    bool v21;
                    v21 = 4u == v12;
                    if (v21){
                        v31 = Union6{Union6_0{}};
                    } else {
                        bool v23;
                        v23 = 5u == v12;
                        if (v23){
                            v31 = Union6{Union6_0{}};
                        } else {
                            printf("%s\n", "Invalid int in int_to_card.");
                            __trap();
                        }
                    }
                }
            }
        }
    }
    int v32;
    v32 = (int)v12;
    unsigned int v33;
    v33 = 1u << v32;
    unsigned int v34;
    v34 = v1 ^ v33;
    return Tuple6{v31, v34};
}
__device__ inline bool while_method_3(int v0){
    bool v1;
    v1 = v0 < 32768;
    return v1;
}
__device__ int int_range_22(int v0, int v1, curandStatePhilox4_32_10_t & v2){
    int v3;
    v3 = v0 - v1;
    unsigned int v4;
    v4 = (unsigned int)v3;
    unsigned int v5;
    v5 = loop_21(v4, v2);
    unsigned int v6;
    v6 = (unsigned int)v1;
    unsigned int v7;
    v7 = v5 + v6;
    int v8;
    v8 = (int)v7;
    return v8;
}
__device__ inline bool while_method_4(int v0){
    bool v1;
    v1 = v0 < 1;
    return v1;
}
__device__ inline bool while_method_5(int v0){
    bool v1;
    v1 = v0 < 8;
    return v1;
}
__device__ inline bool while_method_6(int v0){
    bool v1;
    v1 = v0 < 2;
    return v1;
}
__device__ inline bool while_method_7(int v0){
    bool v1;
    v1 = v0 < 16;
    return v1;
}
__device__ inline bool while_method_8(int v0){
    bool v1;
    v1 = v0 < 32;
    return v1;
}
__device__ inline bool while_method_9(int v0){
    bool v1;
    v1 = v0 < 4;
    return v1;
}
__device__ void method_23(unsigned int * v0, int v1, float * v2){
    int v3;
    v3 = blockIdx.x;
    assert("Tensor range check" && 0 <= v3 && v3 < 24);
    int v4;
    v4 = 32768 * v3;
    int v5;
    v5 = blockIdx.x;
    assert("Tensor range check" && 0 <= v5 && v5 < 24);
    int v6;
    v6 = 256 * v5;
    int v7;
    v7 = v6 + v1;
    int v8;
    v8 = threadIdx.x;
    bool v9;
    v9 = 0 <= v8;
    bool v10;
    v10 = v9 == false;
    if (v10){
        assert("The index needs to be zero or positive." && v9);
    } else {
    }
    int v12;
    v12 = v8 % 32;
    int v13;
    v13 = v8 / 32;
    bool v14;
    v14 = v13 < 8;
    bool v15;
    v15 = v14 == false;
    if (v15){
        assert("The last element of the projection dimensions needs to be greater than the index remainder." && v14);
    } else {
    }
    assert("Tensor range check" && 0 <= v13 && v13 < 8);
    assert("Tensor range check" && 0 <= v12 && v12 < 32);
    int v17;
    v17 = 4 * v12;
    int v18;
    v18 = v17 + v4;
    int v19;
    v19 = 128 * v13;
    int v20;
    v20 = v19 + v18;
    assert("Tensor range check" && 0 <= v13 && v13 < 8);
    int v21;
    v21 = v13 + v7;
    int v22;
    v22 = 0;
    while (while_method_8(v22)){
        assert("Tensor range check" && 0 <= v22 && v22 < 32);
        int v24;
        v24 = 1024 * v22;
        int v25;
        v25 = v24 + v20;
        float v26[4];
        int v27[4];
        int v28;
        v28 = 0;
        while (while_method_4(v28)){
            assert("Tensor range check" && 0 <= v28 && v28 < 1);
            int v30;
            v30 = 4 * v28;
            assert("Tensor range check" && 0 <= v28 && v28 < 1);
            int v31;
            v31 = 128 * v28;
            int v32;
            v32 = v31 + v25;
            int4* v33;
            v33 = reinterpret_cast<int4*>(v2 + v32);
            int4* v34;
            v34 = reinterpret_cast<int4*>(v26 + v30);
            assert("Pointer alignment check" && (unsigned long long)(v33) % 4 == 0 && (unsigned long long)(v34) % 4 == 0);
            *v34 = *v33;
            v28 += 1 ;
        }
        int v35;
        v35 = 0;
        while (while_method_4(v35)){
            int v37;
            v37 = 0;
            while (while_method_9(v37)){
                bool v39;
                v39 = 0 <= v37;
                bool v41;
                if (v39){
                    bool v40;
                    v40 = v37 < 4;
                    v41 = v40;
                } else {
                    v41 = false;
                }
                bool v42;
                v42 = v41 == false;
                if (v42){
                    assert("The indices should be inside the range of the dimension." && v41);
                } else {
                }
                bool v44;
                v44 = 0 <= v12;
                bool v46;
                if (v44){
                    bool v45;
                    v45 = v12 < 32;
                    v46 = v45;
                } else {
                    v46 = false;
                }
                bool v47;
                v47 = v46 == false;
                if (v47){
                    assert("The indices should be inside the range of the dimension." && v46);
                } else {
                }
                int v49;
                v49 = v12 * 4;
                int v50;
                v50 = v37 + v49;
                bool v51;
                v51 = 0 <= v35;
                bool v53;
                if (v51){
                    bool v52;
                    v52 = v35 < 1;
                    v53 = v52;
                } else {
                    v53 = false;
                }
                bool v54;
                v54 = v53 == false;
                if (v54){
                    assert("The indices should be inside the range of the dimension." && v53);
                } else {
                }
                int v56;
                v56 = v35 * 128;
                int v57;
                v57 = v50 + v56;
                assert("Tensor range check" && 0 <= v35 && v35 < 1);
                assert("Tensor range check" && 0 <= v37 && v37 < 4);
                int v58;
                v58 = 4 * v35;
                int v59;
                v59 = v58 + v37;
                v27[v59] = v57;
                v37 += 1 ;
            }
            v35 += 1 ;
        }
        bool v60;
        v60 = 0 <= v13;
        bool v61;
        v61 = v60 && v14;
        bool v62;
        v62 = v61 == false;
        if (v62){
            assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v61);
        } else {
        }
        bool v64;
        v64 = 0 <= v22;
        bool v66;
        if (v64){
            bool v65;
            v65 = v22 < 32;
            v66 = v65;
        } else {
            v66 = false;
        }
        bool v67;
        v67 = v66 == false;
        if (v67){
            assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v66);
        } else {
        }
        int v69;
        v69 = v22 * 8;
        int v70;
        v70 = v69 + v13;
        unsigned int v71[4];
        int v72;
        v72 = 0;
        while (while_method_4(v72)){
            int v74;
            v74 = 0;
            while (while_method_9(v74)){
                assert("Tensor range check" && 0 <= v72 && v72 < 1);
                assert("Tensor range check" && 0 <= v74 && v74 < 4);
                int v76;
                v76 = 4 * v72;
                int v77;
                v77 = v76 + v74;
                float v78;
                v78 = v26[v77];
                int v79;
                v79 = v27[v77];
                bool v80;
                v80 = v78 <= 0.0f;
                unsigned int v82;
                if (v80){
                    v82 = 0u;
                } else {
                    unsigned int v81;
                    v81 = 1u << v79;
                    v82 = v81;
                }
                assert("Tensor range check" && 0 <= v72 && v72 < 1);
                assert("Tensor range check" && 0 <= v74 && v74 < 4);
                v71[v77] = v82;
                v74 += 1 ;
            }
            v72 += 1 ;
        }
        unsigned int v83;
        v83 = 0u;
        int v84;
        v84 = 0;
        while (while_method_4(v84)){
            int v86;
            v86 = 0;
            while (while_method_9(v86)){
                assert("Tensor range check" && 0 <= v84 && v84 < 1);
                assert("Tensor range check" && 0 <= v86 && v86 < 4);
                int v88;
                v88 = 4 * v84;
                int v89;
                v89 = v88 + v86;
                unsigned int v90;
                v90 = v71[v89];
                unsigned int v91;
                v91 = v83 | v90;
                v83 = v91;
                v86 += 1 ;
            }
            v84 += 1 ;
        }
        auto v92 = cooperative_groups::coalesced_threads();
        int v93;
        v93 = threadIdx.x;
        int v94;
        v94 = v93 / 32;
        auto v95 = cooperative_groups::labeled_partition(v92,v94);
        Closure0 v96{};
        unsigned int v97;
        v97 = cooperative_groups::reduce(v95, v83, v96);
        unsigned int v98;
        v98 = v97 % 4096u;
        assert("Tensor range check" && 0 <= v22 && v22 < 32);
        int v99;
        v99 = 8 * v22;
        int v100;
        v100 = v99 + v21;
        v0[v100] = v98;
        v22 += 1 ;
    }
    __syncthreads();
    return ;
}
__device__ Tuple8 method_24(curandStatePhilox4_32_10_t & v0, int * v1, float * v2, float * v3, float * v4, float * v5, float * v6, float * v7, float * v8, int v9, int v10){
    assert("Tensor range check" && 0 <= v10 && v10 < 4);
    int v11;
    v11 = 16384 * v10;
    assert("Tensor range check" && 0 <= v9 && v9 < 4096);
    int v12;
    v12 = 4 * v9;
    int v13;
    v13 = v12 + v11;
    float * v14;
    v14 = v2+v13;
    float * v16;
    v16 = v3+v13;
    int v18;
    v18 = sizeof(float *);
    unsigned long long v19;
    v19 = (unsigned long long)v18;
    unsigned long long v20;
    v20 = 256ull * v19;
    unsigned long long v21;
    v21 = v20 + 16ull;
    unsigned long long v22;
    v22 = v21 - 1ull;
    unsigned long long v23;
    v23 = v22 % 16ull;
    unsigned long long v24;
    v24 = v22 - v23;
    unsigned long long v25;
    v25 = v24 + v20;
    unsigned long long v26;
    v26 = v25 + 16ull;
    unsigned long long v27;
    v27 = v26 - 1ull;
    unsigned long long v28;
    v28 = v27 % 16ull;
    unsigned long long v29;
    v29 = v27 - v28;
    unsigned long long v30;
    v30 = v29 + 1024ull;
    unsigned long long v31;
    v31 = v30 + 16ull;
    unsigned long long v32;
    v32 = v31 - 1ull;
    unsigned long long v33;
    v33 = v32 % 16ull;
    unsigned long long v34;
    v34 = v32 - v33;
    unsigned long long v35;
    v35 = v34 + 1024ull;
    bool v36;
    v36 = v35 <= 98304ull;
    bool v37;
    v37 = v36 == false;
    if (v37){
        assert("The dynamic shared memory is insufficient to allocate the tensor." && v36);
    } else {
    }
    extern __shared__ unsigned char v39[];
    bool v40;
    v40 = v35 <= v35;
    bool v41;
    v41 = v40 == false;
    if (v41){
        assert("The length of the partition has to be less than or equal to the length of the base array." && v40);
    } else {
    }
    float * * v43;
    v43 = reinterpret_cast<float * *>(&v39[0ull]);
    float * * v45;
    v45 = reinterpret_cast<float * *>(&v39[v24]);
    float * v47;
    v47 = reinterpret_cast<float *>(&v39[v29]);
    int * v49;
    v49 = reinterpret_cast<int *>(&v39[v34]);
    int v51;
    v51 = threadIdx.x;
    assert("Tensor range check" && 0 <= v51 && v51 < 256);
    v43[v51] = v14;
    v45[v51] = v16;
    __syncthreads();
    bool v52;
    v52 = 0 <= v51;
    bool v53;
    v53 = v52 == false;
    if (v53){
        assert("The index needs to be zero or positive." && v52);
    } else {
    }
    int v55;
    v55 = v51 % 1;
    bool v56;
    v56 = v51 < 256;
    bool v57;
    v57 = v56 == false;
    if (v57){
        assert("The last element of the projection dimensions needs to be greater than the index remainder." && v56);
    } else {
    }
    assert("Tensor range check" && 0 <= v51 && v51 < 256);
    int v59;
    v59 = 0;
    while (while_method_4(v59)){
        bool v61;
        v61 = v52 && v56;
        bool v62;
        v62 = v61 == false;
        if (v62){
            assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v61);
        } else {
        }
        bool v64;
        v64 = 0 <= v59;
        bool v66;
        if (v64){
            bool v65;
            v65 = v59 < 1;
            v66 = v65;
        } else {
            v66 = false;
        }
        bool v67;
        v67 = v66 == false;
        if (v67){
            assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v66);
        } else {
        }
        int v69;
        v69 = v59 * 256;
        int v70;
        v70 = v69 + v51;
        assert("Tensor range check" && 0 <= v59 && v59 < 1);
        int v71;
        v71 = 256 * v59;
        int v72;
        v72 = v71 + v51;
        float * v73;
        v73 = v43[v72];
        float * v74;
        v74 = v45[v72];
        int v75;
        v75 = blockIdx.x;
        int v76;
        v76 = v75 * 256;
        int v77;
        v77 = v76 + v70;
        assert("Tensor range check" && 0 <= v55 && v55 < 1);
        int v78;
        v78 = 4 * v55;
        float v79[4];
        float v80[4];
        int v81[4];
        int v82;
        v82 = 0;
        while (while_method_4(v82)){
            assert("Tensor range check" && 0 <= v82 && v82 < 1);
            int v84;
            v84 = 4 * v82;
            assert("Tensor range check" && 0 <= v82 && v82 < 1);
            int v85;
            v85 = v84 + v78;
            int4* v86;
            v86 = reinterpret_cast<int4*>(v73 + v85);
            int4* v87;
            v87 = reinterpret_cast<int4*>(v79 + v84);
            assert("Pointer alignment check" && (unsigned long long)(v86) % 4 == 0 && (unsigned long long)(v87) % 4 == 0);
            *v87 = *v86;
            int4* v88;
            v88 = reinterpret_cast<int4*>(v74 + v85);
            int4* v89;
            v89 = reinterpret_cast<int4*>(v80 + v84);
            assert("Pointer alignment check" && (unsigned long long)(v88) % 4 == 0 && (unsigned long long)(v89) % 4 == 0);
            *v89 = *v88;
            v82 += 1 ;
        }
        int v90;
        v90 = 0;
        while (while_method_4(v90)){
            int v92;
            v92 = 0;
            while (while_method_9(v92)){
                bool v94;
                v94 = 0 <= v92;
                bool v96;
                if (v94){
                    bool v95;
                    v95 = v92 < 4;
                    v96 = v95;
                } else {
                    v96 = false;
                }
                bool v97;
                v97 = v96 == false;
                if (v97){
                    assert("The indices should be inside the range of the dimension." && v96);
                } else {
                }
                bool v99;
                v99 = 0 <= v55;
                bool v101;
                if (v99){
                    bool v100;
                    v100 = v55 < 1;
                    v101 = v100;
                } else {
                    v101 = false;
                }
                bool v102;
                v102 = v101 == false;
                if (v102){
                    assert("The indices should be inside the range of the dimension." && v101);
                } else {
                }
                int v104;
                v104 = v55 * 4;
                int v105;
                v105 = v92 + v104;
                bool v106;
                v106 = 0 <= v90;
                bool v108;
                if (v106){
                    bool v107;
                    v107 = v90 < 1;
                    v108 = v107;
                } else {
                    v108 = false;
                }
                bool v109;
                v109 = v108 == false;
                if (v109){
                    assert("The indices should be inside the range of the dimension." && v108);
                } else {
                }
                int v111;
                v111 = v90 * 4;
                int v112;
                v112 = v105 + v111;
                assert("Tensor range check" && 0 <= v90 && v90 < 1);
                assert("Tensor range check" && 0 <= v92 && v92 < 4);
                int v113;
                v113 = 4 * v90;
                int v114;
                v114 = v113 + v92;
                v81[v114] = v112;
                v92 += 1 ;
            }
            v90 += 1 ;
        }
        bool v115[4];
        int v116;
        v116 = 0;
        while (while_method_4(v116)){
            int v118;
            v118 = 0;
            while (while_method_9(v118)){
                assert("Tensor range check" && 0 <= v116 && v116 < 1);
                assert("Tensor range check" && 0 <= v118 && v118 < 4);
                int v120;
                v120 = 4 * v116;
                int v121;
                v121 = v120 + v118;
                float v122;
                v122 = v79[v121];
                int v123;
                v123 = v81[v121];
                bool v124;
                v124 = v123 < 3;
                assert("Tensor range check" && 0 <= v116 && v116 < 1);
                assert("Tensor range check" && 0 <= v118 && v118 < 4);
                v115[v121] = v124;
                v118 += 1 ;
            }
            v116 += 1 ;
        }
        float v125[4];
        int v126;
        v126 = 0;
        while (while_method_4(v126)){
            int v128;
            v128 = 0;
            while (while_method_9(v128)){
                assert("Tensor range check" && 0 <= v126 && v126 < 1);
                assert("Tensor range check" && 0 <= v128 && v128 < 4);
                int v130;
                v130 = 4 * v126;
                int v131;
                v131 = v130 + v128;
                float v132;
                v132 = v79[v131];
                bool v133;
                v133 = v115[v131];
                float v136;
                if (v133){
                    bool v134;
                    v134 = 0.0f >= v132;
                    if (v134){
                        v136 = 0.0f;
                    } else {
                        v136 = v132;
                    }
                } else {
                    v136 = 0.0f;
                }
                assert("Tensor range check" && 0 <= v126 && v126 < 1);
                assert("Tensor range check" && 0 <= v128 && v128 < 4);
                v125[v131] = v136;
                v128 += 1 ;
            }
            v126 += 1 ;
        }
        float v137;
        v137 = 0.0f;
        int v138;
        v138 = 0;
        while (while_method_4(v138)){
            int v140;
            v140 = 0;
            while (while_method_9(v140)){
                assert("Tensor range check" && 0 <= v138 && v138 < 1);
                assert("Tensor range check" && 0 <= v140 && v140 < 4);
                int v142;
                v142 = 4 * v138;
                int v143;
                v143 = v142 + v140;
                float v144;
                v144 = v125[v143];
                float v145;
                v145 = v137 + v144;
                v137 = v145;
                v140 += 1 ;
            }
            v138 += 1 ;
        }
        auto v146 = cooperative_groups::coalesced_threads();
        int v147;
        v147 = threadIdx.x;
        auto v148 = cooperative_groups::labeled_partition(v146,v147);
        Closure1 v149{};
        float v150;
        v150 = cooperative_groups::reduce(v148, v137, v149);
        int v151[4];
        int v152;
        v152 = 0;
        while (while_method_4(v152)){
            int v154;
            v154 = 0;
            while (while_method_9(v154)){
                assert("Tensor range check" && 0 <= v152 && v152 < 1);
                assert("Tensor range check" && 0 <= v154 && v154 < 4);
                int v156;
                v156 = 4 * v152;
                int v157;
                v157 = v156 + v154;
                bool v158;
                v158 = v115[v157];
                int v159;
                if (v158){
                    v159 = 1;
                } else {
                    v159 = 0;
                }
                assert("Tensor range check" && 0 <= v152 && v152 < 1);
                assert("Tensor range check" && 0 <= v154 && v154 < 4);
                v151[v157] = v159;
                v154 += 1 ;
            }
            v152 += 1 ;
        }
        int v160;
        v160 = 0;
        int v161;
        v161 = 0;
        while (while_method_4(v161)){
            int v163;
            v163 = 0;
            while (while_method_9(v163)){
                assert("Tensor range check" && 0 <= v161 && v161 < 1);
                assert("Tensor range check" && 0 <= v163 && v163 < 4);
                int v165;
                v165 = 4 * v161;
                int v166;
                v166 = v165 + v163;
                int v167;
                v167 = v151[v166];
                int v168;
                v168 = v160 + v167;
                v160 = v168;
                v163 += 1 ;
            }
            v161 += 1 ;
        }
        auto v169 = cooperative_groups::coalesced_threads();
        int v170;
        v170 = threadIdx.x;
        auto v171 = cooperative_groups::labeled_partition(v169,v170);
        Closure2 v172{};
        int v173;
        v173 = cooperative_groups::reduce(v171, v160, v172);
        float v174;
        v174 = (float)v173;
        float v175;
        v175 = 1.0f / v174;
        float v176[4];
        int v177;
        v177 = 0;
        while (while_method_4(v177)){
            int v179;
            v179 = 0;
            while (while_method_9(v179)){
                assert("Tensor range check" && 0 <= v177 && v177 < 1);
                assert("Tensor range check" && 0 <= v179 && v179 < 4);
                int v181;
                v181 = 4 * v177;
                int v182;
                v182 = v181 + v179;
                float v183;
                v183 = v125[v182];
                bool v184;
                v184 = v115[v182];
                bool v185;
                v185 = v184 == false;
                float v190;
                if (v185){
                    v190 = 0.0f;
                } else {
                    bool v186;
                    v186 = v150 == 0.0f;
                    bool v187;
                    v187 = v186 != true;
                    if (v187){
                        float v188;
                        v188 = v183 / v150;
                        v190 = v188;
                    } else {
                        v190 = v175;
                    }
                }
                assert("Tensor range check" && 0 <= v177 && v177 < 1);
                assert("Tensor range check" && 0 <= v179 && v179 < 4);
                v176[v182] = v190;
                v179 += 1 ;
            }
            v177 += 1 ;
        }
        float v191[4];
        float v192;
        v192 = 0.0f;
        int v193;
        v193 = 0;
        while (while_method_4(v193)){
            assert("Tensor range check" && 0 <= v193 && v193 < 1);
            int v195;
            v195 = 4 * v193;
            assert("Tensor range check" && 0 <= v193 && v193 < 1);
            int v196; float v197;
            Tuple9 tmp15 = Tuple9{0, 0.0f};
            v196 = tmp15.v0; v197 = tmp15.v1;
            while (while_method_9(v196)){
                assert("Tensor range check" && 0 <= v196 && v196 < 4);
                int v199;
                v199 = v196 + v195;
                float v200;
                v200 = v176[v199];
                float v201;
                v201 = v197 + v200;
                v197 = v201;
                v196 += 1 ;
            }
            auto v202 = cooperative_groups::coalesced_threads();
            int v203;
            v203 = threadIdx.x;
            auto v204 = cooperative_groups::labeled_partition(v202,v203);
            Closure3 v205{};
            float v206;
            v206 = cooperative_groups::inclusive_scan(v204, v197, v205);
            float v207;
            v207 = v204.shfl_up(v206,1);
            bool v208;
            v208 = v204.thread_rank() == 0;
            float v209;
            if (v208){
                v209 = 0.0f;
            } else {
                v209 = v207;
            }
            float v210;
            v210 = v204.shfl(v206,v204.num_threads()-1);
            float v211;
            v211 = v192 + v209;
            int v212; float v213;
            Tuple9 tmp16 = Tuple9{0, v211};
            v212 = tmp16.v0; v213 = tmp16.v1;
            while (while_method_9(v212)){
                assert("Tensor range check" && 0 <= v212 && v212 < 4);
                int v215;
                v215 = v212 + v195;
                float v216;
                v216 = v176[v215];
                float v217;
                v217 = v213 + v216;
                assert("Tensor range check" && 0 <= v212 && v212 < 4);
                v191[v215] = v217;
                v213 = v217;
                v212 += 1 ;
            }
            float v218;
            v218 = v192 + v210;
            v192 = v218;
            v193 += 1 ;
        }
        float v219[4];
        bool v220[4];
        int v221;
        v221 = 0;
        while (while_method_4(v221)){
            int v223;
            v223 = 0;
            while (while_method_9(v223)){
                assert("Tensor range check" && 0 <= v221 && v221 < 1);
                assert("Tensor range check" && 0 <= v223 && v223 < 4);
                int v225;
                v225 = 4 * v221;
                int v226;
                v226 = v225 + v223;
                float v227;
                v227 = v191[v226];
                float v228;
                v228 = v176[v226];
                bool v229;
                v229 = v228 > 0.0f;
                assert("Tensor range check" && 0 <= v221 && v221 < 1);
                assert("Tensor range check" && 0 <= v223 && v223 < 4);
                v219[v226] = v227;
                v220[v226] = v229;
                v223 += 1 ;
            }
            v221 += 1 ;
        }
        float v230; bool v231;
        Tuple10 tmp17 = Tuple10{-1.0f / 0.0f, false};
        v230 = tmp17.v0; v231 = tmp17.v1;
        int v232;
        v232 = 0;
        while (while_method_4(v232)){
            int v234;
            v234 = 0;
            while (while_method_9(v234)){
                assert("Tensor range check" && 0 <= v232 && v232 < 1);
                assert("Tensor range check" && 0 <= v234 && v234 < 4);
                int v236;
                v236 = 4 * v232;
                int v237;
                v237 = v236 + v234;
                float v238;
                v238 = v219[v237];
                bool v239;
                v239 = v220[v237];
                float v246; bool v247;
                if (v231){
                    if (v239){
                        bool v240;
                        v240 = v230 >= v238;
                        float v241;
                        if (v240){
                            v241 = v230;
                        } else {
                            v241 = v238;
                        }
                        v246 = v241; v247 = true;
                    } else {
                        v246 = v230; v247 = v231;
                    }
                } else {
                    if (v239){
                        v246 = v238; v247 = v239;
                    } else {
                        v246 = v230; v247 = v231;
                    }
                }
                v230 = v246;
                v231 = v247;
                v234 += 1 ;
            }
            v232 += 1 ;
        }
        auto v248 = cooperative_groups::coalesced_threads();
        int v249;
        v249 = threadIdx.x;
        auto v250 = cooperative_groups::labeled_partition(v248,v249);
        Closure4 v251{};
        float v252; bool v253;
        Tuple10 tmp18 = cooperative_groups::reduce(v250, Tuple10{v230, v231}, v251);
        v252 = tmp18.v0; v253 = tmp18.v1;
        bool v254;
        v254 = v253 == false;
        if (v254){
            assert("The local reduce must be true." && v253);
        } else {
        }
        float v256[4];
        int v257[4];
        int v258;
        v258 = 0;
        while (while_method_4(v258)){
            int v260;
            v260 = 0;
            while (while_method_9(v260)){
                assert("Tensor range check" && 0 <= v258 && v258 < 1);
                assert("Tensor range check" && 0 <= v260 && v260 < 4);
                int v262;
                v262 = 4 * v258;
                int v263;
                v263 = v262 + v260;
                int v264;
                v264 = v81[v263];
                float v265;
                v265 = curand_uniform(&v0);
                assert("Tensor range check" && 0 <= v258 && v258 < 1);
                assert("Tensor range check" && 0 <= v260 && v260 < 4);
                v256[v263] = v265;
                v257[v263] = v264;
                v260 += 1 ;
            }
            v258 += 1 ;
        }
        float v266; int v267;
        Tuple8 tmp19 = Tuple8{0.0f, 2147483647};
        v266 = tmp19.v0; v267 = tmp19.v1;
        int v268;
        v268 = 0;
        while (while_method_4(v268)){
            int v270;
            v270 = 0;
            while (while_method_9(v270)){
                assert("Tensor range check" && 0 <= v268 && v268 < 1);
                assert("Tensor range check" && 0 <= v270 && v270 < 4);
                int v272;
                v272 = 4 * v268;
                int v273;
                v273 = v272 + v270;
                float v274;
                v274 = v256[v273];
                int v275;
                v275 = v257[v273];
                bool v276;
                v276 = v267 < v275;
                float v277; int v278;
                if (v276){
                    v277 = v266; v278 = v267;
                } else {
                    v277 = v274; v278 = v275;
                }
                v266 = v277;
                v267 = v278;
                v270 += 1 ;
            }
            v268 += 1 ;
        }
        auto v279 = cooperative_groups::coalesced_threads();
        int v280;
        v280 = threadIdx.x;
        auto v281 = cooperative_groups::labeled_partition(v279,v280);
        Closure5 v282{};
        float v283; int v284;
        Tuple8 tmp20 = cooperative_groups::reduce(v281, Tuple8{v266, v267}, v282);
        v283 = tmp20.v0; v284 = tmp20.v1;
        float v285;
        v285 = v252 * v283;
        int v286[4];
        bool v287[4];
        int v288;
        v288 = 0;
        while (while_method_4(v288)){
            int v290;
            v290 = 0;
            while (while_method_9(v290)){
                assert("Tensor range check" && 0 <= v288 && v288 < 1);
                assert("Tensor range check" && 0 <= v290 && v290 < 4);
                int v292;
                v292 = 4 * v288;
                int v293;
                v293 = v292 + v290;
                float v294;
                v294 = v219[v293];
                bool v295;
                v295 = v220[v293];
                int v296;
                v296 = v81[v293];
                int v299; bool v300;
                if (v295){
                    float v297;
                    v297 = v294 - v285;
                    bool v298;
                    v298 = v297 >= 0.0f;
                    v299 = v296; v300 = v298;
                } else {
                    v299 = 2147483647; v300 = false;
                }
                assert("Tensor range check" && 0 <= v288 && v288 < 1);
                assert("Tensor range check" && 0 <= v290 && v290 < 4);
                v286[v293] = v299;
                v287[v293] = v300;
                v290 += 1 ;
            }
            v288 += 1 ;
        }
        int v301; bool v302;
        Tuple11 tmp21 = Tuple11{2147483647, false};
        v301 = tmp21.v0; v302 = tmp21.v1;
        int v303;
        v303 = 0;
        while (while_method_4(v303)){
            int v305;
            v305 = 0;
            while (while_method_9(v305)){
                assert("Tensor range check" && 0 <= v303 && v303 < 1);
                assert("Tensor range check" && 0 <= v305 && v305 < 4);
                int v307;
                v307 = 4 * v303;
                int v308;
                v308 = v307 + v305;
                int v309;
                v309 = v286[v308];
                bool v310;
                v310 = v287[v308];
                int v317; bool v318;
                if (v302){
                    if (v310){
                        bool v311;
                        v311 = v301 < v309;
                        int v312;
                        if (v311){
                            v312 = v301;
                        } else {
                            v312 = v309;
                        }
                        v317 = v312; v318 = true;
                    } else {
                        v317 = v301; v318 = v302;
                    }
                } else {
                    if (v310){
                        v317 = v309; v318 = v310;
                    } else {
                        v317 = v301; v318 = v302;
                    }
                }
                v301 = v317;
                v302 = v318;
                v305 += 1 ;
            }
            v303 += 1 ;
        }
        auto v319 = cooperative_groups::coalesced_threads();
        int v320;
        v320 = threadIdx.x;
        auto v321 = cooperative_groups::labeled_partition(v319,v320);
        Closure6 v322{};
        int v323; bool v324;
        Tuple11 tmp22 = cooperative_groups::reduce(v321, Tuple11{v301, v302}, v322);
        v323 = tmp22.v0; v324 = tmp22.v1;
        bool v325;
        v325 = v324 == false;
        if (v325){
            assert("The local reduce must be true." && v324);
        } else {
        }
        bool v327[4];
        int v328;
        v328 = 0;
        while (while_method_4(v328)){
            int v330;
            v330 = 0;
            while (while_method_9(v330)){
                assert("Tensor range check" && 0 <= v328 && v328 < 1);
                assert("Tensor range check" && 0 <= v330 && v330 < 4);
                int v332;
                v332 = 4 * v328;
                int v333;
                v333 = v332 + v330;
                float v334;
                v334 = v80[v333];
                int v335;
                v335 = v81[v333];
                bool v336;
                v336 = v335 < 3;
                assert("Tensor range check" && 0 <= v328 && v328 < 1);
                assert("Tensor range check" && 0 <= v330 && v330 < 4);
                v327[v333] = v336;
                v330 += 1 ;
            }
            v328 += 1 ;
        }
        float v337[4];
        int v338;
        v338 = 0;
        while (while_method_4(v338)){
            int v340;
            v340 = 0;
            while (while_method_9(v340)){
                assert("Tensor range check" && 0 <= v338 && v338 < 1);
                assert("Tensor range check" && 0 <= v340 && v340 < 4);
                int v342;
                v342 = 4 * v338;
                int v343;
                v343 = v342 + v340;
                float v344;
                v344 = v80[v343];
                bool v345;
                v345 = v327[v343];
                float v348;
                if (v345){
                    bool v346;
                    v346 = 0.0f >= v344;
                    if (v346){
                        v348 = 0.0f;
                    } else {
                        v348 = v344;
                    }
                } else {
                    v348 = 0.0f;
                }
                assert("Tensor range check" && 0 <= v338 && v338 < 1);
                assert("Tensor range check" && 0 <= v340 && v340 < 4);
                v337[v343] = v348;
                v340 += 1 ;
            }
            v338 += 1 ;
        }
        float v349;
        v349 = 0.0f;
        int v350;
        v350 = 0;
        while (while_method_4(v350)){
            int v352;
            v352 = 0;
            while (while_method_9(v352)){
                assert("Tensor range check" && 0 <= v350 && v350 < 1);
                assert("Tensor range check" && 0 <= v352 && v352 < 4);
                int v354;
                v354 = 4 * v350;
                int v355;
                v355 = v354 + v352;
                float v356;
                v356 = v337[v355];
                float v357;
                v357 = v349 + v356;
                v349 = v357;
                v352 += 1 ;
            }
            v350 += 1 ;
        }
        auto v358 = cooperative_groups::coalesced_threads();
        int v359;
        v359 = threadIdx.x;
        auto v360 = cooperative_groups::labeled_partition(v358,v359);
        float v361;
        v361 = cooperative_groups::reduce(v360, v349, v149);
        int v362[4];
        int v363;
        v363 = 0;
        while (while_method_4(v363)){
            int v365;
            v365 = 0;
            while (while_method_9(v365)){
                assert("Tensor range check" && 0 <= v363 && v363 < 1);
                assert("Tensor range check" && 0 <= v365 && v365 < 4);
                int v367;
                v367 = 4 * v363;
                int v368;
                v368 = v367 + v365;
                bool v369;
                v369 = v327[v368];
                int v370;
                if (v369){
                    v370 = 1;
                } else {
                    v370 = 0;
                }
                assert("Tensor range check" && 0 <= v363 && v363 < 1);
                assert("Tensor range check" && 0 <= v365 && v365 < 4);
                v362[v368] = v370;
                v365 += 1 ;
            }
            v363 += 1 ;
        }
        int v371;
        v371 = 0;
        int v372;
        v372 = 0;
        while (while_method_4(v372)){
            int v374;
            v374 = 0;
            while (while_method_9(v374)){
                assert("Tensor range check" && 0 <= v372 && v372 < 1);
                assert("Tensor range check" && 0 <= v374 && v374 < 4);
                int v376;
                v376 = 4 * v372;
                int v377;
                v377 = v376 + v374;
                int v378;
                v378 = v362[v377];
                int v379;
                v379 = v371 + v378;
                v371 = v379;
                v374 += 1 ;
            }
            v372 += 1 ;
        }
        auto v380 = cooperative_groups::coalesced_threads();
        int v381;
        v381 = threadIdx.x;
        auto v382 = cooperative_groups::labeled_partition(v380,v381);
        int v383;
        v383 = cooperative_groups::reduce(v382, v371, v172);
        float v384;
        v384 = (float)v383;
        float v385;
        v385 = 1.0f / v384;
        float v386[4];
        int v387;
        v387 = 0;
        while (while_method_4(v387)){
            int v389;
            v389 = 0;
            while (while_method_9(v389)){
                assert("Tensor range check" && 0 <= v387 && v387 < 1);
                assert("Tensor range check" && 0 <= v389 && v389 < 4);
                int v391;
                v391 = 4 * v387;
                int v392;
                v392 = v391 + v389;
                float v393;
                v393 = v337[v392];
                bool v394;
                v394 = v327[v392];
                bool v395;
                v395 = v394 == false;
                float v400;
                if (v395){
                    v400 = 0.0f;
                } else {
                    bool v396;
                    v396 = v361 == 0.0f;
                    bool v397;
                    v397 = v396 != true;
                    if (v397){
                        float v398;
                        v398 = v393 / v361;
                        v400 = v398;
                    } else {
                        v400 = v385;
                    }
                }
                assert("Tensor range check" && 0 <= v387 && v387 < 1);
                assert("Tensor range check" && 0 <= v389 && v389 < 4);
                v386[v392] = v400;
                v389 += 1 ;
            }
            v387 += 1 ;
        }
        float v401; int v402;
        Tuple8 tmp23 = Tuple8{0.0f, 2147483647};
        v401 = tmp23.v0; v402 = tmp23.v1;
        int v403;
        v403 = 0;
        while (while_method_4(v403)){
            int v405;
            v405 = 0;
            while (while_method_9(v405)){
                assert("Tensor range check" && 0 <= v403 && v403 < 1);
                assert("Tensor range check" && 0 <= v405 && v405 < 4);
                int v407;
                v407 = 4 * v403;
                int v408;
                v408 = v407 + v405;
                float v409;
                v409 = v176[v408];
                int v410;
                v410 = v81[v408];
                bool v411;
                v411 = v402 == v323;
                float v415; int v416;
                if (v411){
                    v415 = v401; v416 = v402;
                } else {
                    bool v412;
                    v412 = v410 == v323;
                    if (v412){
                        v415 = v409; v416 = v410;
                    } else {
                        v415 = v401; v416 = v402;
                    }
                }
                v401 = v415;
                v402 = v416;
                v405 += 1 ;
            }
            v403 += 1 ;
        }
        auto v417 = cooperative_groups::coalesced_threads();
        int v418;
        v418 = threadIdx.x;
        auto v419 = cooperative_groups::labeled_partition(v417,v418);
        Closure7 v420{v323};
        float v421; int v422;
        Tuple8 tmp24 = cooperative_groups::reduce(v419, Tuple8{v401, v402}, v420);
        v421 = tmp24.v0; v422 = tmp24.v1;
        bool v423;
        v423 = v422 == 2147483647;
        bool v424;
        v424 = v423 != true;
        bool v425;
        v425 = v424 == false;
        if (v425){
            assert("Expected a valid action id in get_prob." && v424);
        } else {
        }
        int v427;
        v427 = 0;
        while (while_method_4(v427)){
            assert("Tensor range check" && 0 <= v427 && v427 < 1);
            assert("Tensor range check" && 0 <= v427 && v427 < 1);
            v427 += 1 ;
        }
        assert("Tensor range check" && 0 <= v70 && v70 < 256);
        v47[v70] = v421;
        v49[v70] = v323;
        v59 += 1 ;
    }
    __syncthreads();
    assert("Tensor range check" && 0 <= v51 && v51 < 256);
    float v429;
    v429 = v47[v51];
    int v430;
    v430 = v49[v51];
    __syncthreads();
    return Tuple8{v429, v430};
}
__device__ int tag_26(Union6 v0){
    switch (v0.tag) {
        case 0: { // Jack
            return 0;
            break;
        }
        case 1: { // King
            return 2;
            break;
        }
        case 2: { // Queen
            return 1;
            break;
        }
        default: {
            assert("Invalid tag." && false); __trap();
        }
    }
}
__device__ bool is_pair_27(int v0, int v1){
    bool v2;
    v2 = v1 == v0;
    return v2;
}
__device__ Tuple7 order_28(int v0, int v1){
    bool v2;
    v2 = v1 > v0;
    if (v2){
        return Tuple7{v1, v0};
    } else {
        return Tuple7{v0, v1};
    }
}
__device__ Union13 compare_hands_25(Union5 v0, bool v1, static_array<Union6,2> v2, int v3, static_array<int,2> v4, int v5){
    switch (v0.tag) {
        case 0: { // None
            printf("%s\n", "Expected the community card to be present in the table.");
            __trap();
            break;
        }
        case 1: { // Some
            Union6 v7 = v0.case1.v0;
            int v8;
            v8 = tag_26(v7);
            Union6 v9;
            v9 = v2[0];
            int v11;
            v11 = tag_26(v9);
            Union6 v12;
            v12 = v2[1];
            int v14;
            v14 = tag_26(v12);
            bool v15;
            v15 = is_pair_27(v8, v11);
            bool v16;
            v16 = is_pair_27(v8, v14);
            if (v15){
                if (v16){
                    bool v17;
                    v17 = v11 < v14;
                    if (v17){
                        return Union13{Union13_2{}};
                    } else {
                        bool v19;
                        v19 = v11 > v14;
                        if (v19){
                            return Union13{Union13_1{}};
                        } else {
                            return Union13{Union13_0{}};
                        }
                    }
                } else {
                    return Union13{Union13_1{}};
                }
            } else {
                if (v16){
                    return Union13{Union13_2{}};
                } else {
                    int v27; int v28;
                    Tuple7 tmp36 = order_28(v8, v11);
                    v27 = tmp36.v0; v28 = tmp36.v1;
                    int v29; int v30;
                    Tuple7 tmp37 = order_28(v8, v14);
                    v29 = tmp37.v0; v30 = tmp37.v1;
                    bool v31;
                    v31 = v27 < v29;
                    Union13 v37;
                    if (v31){
                        v37 = Union13{Union13_2{}};
                    } else {
                        bool v33;
                        v33 = v27 > v29;
                        if (v33){
                            v37 = Union13{Union13_1{}};
                        } else {
                            v37 = Union13{Union13_0{}};
                        }
                    }
                    bool v38;
                    switch (v37.tag) {
                        case 0: { // Eq
                            v38 = true;
                            break;
                        }
                        default: {
                            v38 = false;
                        }
                    }
                    if (v38){
                        bool v39;
                        v39 = v28 < v30;
                        if (v39){
                            return Union13{Union13_2{}};
                        } else {
                            bool v41;
                            v41 = v28 > v30;
                            if (v41){
                                return Union13{Union13_1{}};
                            } else {
                                return Union13{Union13_0{}};
                            }
                        }
                    } else {
                        return v37;
                    }
                }
            }
            break;
        }
        default: {
            assert("Invalid tag." && false); __trap();
        }
    }
}
__device__ void f_30(unsigned char * v0, unsigned int v1){
    unsigned int * v2;
    v2 = (unsigned int *)(v0+0ull);
    v2[0] = v1;
    return ;
}
__device__ void f_31(unsigned char * v0, int v1){
    int * v2;
    v2 = (int *)(v0+4ull);
    v2[0] = v1;
    return ;
}
__device__ void f_32(unsigned char * v0){
    return ;
}
__device__ void f_34(unsigned char * v0, int v1){
    int * v2;
    v2 = (int *)(v0+0ull);
    v2[0] = v1;
    return ;
}
__device__ void f_36(unsigned char * v0, Union6 v1){
    int v2;
    v2 = v1.tag;
    f_34(v0, v2);
    unsigned char * v3;
    v3 = (unsigned char *)(v0+4ull);
    switch (v1.tag) {
        case 0: { // Jack
            return f_32(v3);
            break;
        }
        case 1: { // King
            return f_32(v3);
            break;
        }
        case 2: { // Queen
            return f_32(v3);
            break;
        }
        default: {
            assert("Invalid tag." && false); __trap();
        }
    }
}
__device__ void f_35(unsigned char * v0, Union5 v1, bool v2, static_array<Union6,2> v3, int v4, static_array<int,2> v5, int v6){
    int v7;
    v7 = v1.tag;
    f_34(v0, v7);
    unsigned char * v8;
    v8 = (unsigned char *)(v0+4ull);
    switch (v1.tag) {
        case 0: { // None
            f_32(v8);
            break;
        }
        case 1: { // Some
            Union6 v10 = v1.case1.v0;
            f_36(v8, v10);
            break;
        }
        default: {
            assert("Invalid tag." && false); __trap();
        }
    }
    bool * v11;
    v11 = (bool *)(v0+8ull);
    v11[0] = v2;
    int v13;
    v13 = 0;
    while (while_method_0(v13)){
        unsigned long long v15;
        v15 = (unsigned long long)v13;
        unsigned long long v16;
        v16 = v15 * 4ull;
        unsigned long long v17;
        v17 = 12ull + v16;
        unsigned char * v18;
        v18 = (unsigned char *)(v0+v17);
        bool v20;
        v20 = 0 <= v13;
        bool v22;
        if (v20){
            bool v21;
            v21 = v13 < 2;
            v22 = v21;
        } else {
            v22 = false;
        }
        bool v23;
        v23 = v22 == false;
        if (v23){
            assert("Index must be in range." && v22);
        } else {
        }
        Union6 v25;
        v25 = v3[v13];
        f_36(v18, v25);
        v13 += 1 ;
    }
    int * v27;
    v27 = (int *)(v0+20ull);
    v27[0] = v4;
    int v29;
    v29 = 0;
    while (while_method_0(v29)){
        unsigned long long v31;
        v31 = (unsigned long long)v29;
        unsigned long long v32;
        v32 = v31 * 4ull;
        unsigned long long v33;
        v33 = 24ull + v32;
        unsigned char * v34;
        v34 = (unsigned char *)(v0+v33);
        bool v36;
        v36 = 0 <= v29;
        bool v38;
        if (v36){
            bool v37;
            v37 = v29 < 2;
            v38 = v37;
        } else {
            v38 = false;
        }
        bool v39;
        v39 = v38 == false;
        if (v39){
            assert("Index must be in range." && v38);
        } else {
        }
        int v41;
        v41 = v5[v29];
        f_34(v34, v41);
        v29 += 1 ;
    }
    int * v43;
    v43 = (int *)(v0+32ull);
    v43[0] = v6;
    return ;
}
__device__ void f_38(unsigned char * v0, int v1){
    int * v2;
    v2 = (int *)(v0+36ull);
    v2[0] = v1;
    return ;
}
__device__ void f_37(unsigned char * v0, Union5 v1, bool v2, static_array<Union6,2> v3, int v4, static_array<int,2> v5, int v6, Union1 v7){
    int v8;
    v8 = v1.tag;
    f_34(v0, v8);
    unsigned char * v9;
    v9 = (unsigned char *)(v0+4ull);
    switch (v1.tag) {
        case 0: { // None
            f_32(v9);
            break;
        }
        case 1: { // Some
            Union6 v11 = v1.case1.v0;
            f_36(v9, v11);
            break;
        }
        default: {
            assert("Invalid tag." && false); __trap();
        }
    }
    bool * v12;
    v12 = (bool *)(v0+8ull);
    v12[0] = v2;
    int v14;
    v14 = 0;
    while (while_method_0(v14)){
        unsigned long long v16;
        v16 = (unsigned long long)v14;
        unsigned long long v17;
        v17 = v16 * 4ull;
        unsigned long long v18;
        v18 = 12ull + v17;
        unsigned char * v19;
        v19 = (unsigned char *)(v0+v18);
        bool v21;
        v21 = 0 <= v14;
        bool v23;
        if (v21){
            bool v22;
            v22 = v14 < 2;
            v23 = v22;
        } else {
            v23 = false;
        }
        bool v24;
        v24 = v23 == false;
        if (v24){
            assert("Index must be in range." && v23);
        } else {
        }
        Union6 v26;
        v26 = v3[v14];
        f_36(v19, v26);
        v14 += 1 ;
    }
    int * v28;
    v28 = (int *)(v0+20ull);
    v28[0] = v4;
    int v30;
    v30 = 0;
    while (while_method_0(v30)){
        unsigned long long v32;
        v32 = (unsigned long long)v30;
        unsigned long long v33;
        v33 = v32 * 4ull;
        unsigned long long v34;
        v34 = 24ull + v33;
        unsigned char * v35;
        v35 = (unsigned char *)(v0+v34);
        bool v37;
        v37 = 0 <= v30;
        bool v39;
        if (v37){
            bool v38;
            v38 = v30 < 2;
            v39 = v38;
        } else {
            v39 = false;
        }
        bool v40;
        v40 = v39 == false;
        if (v40){
            assert("Index must be in range." && v39);
        } else {
        }
        int v42;
        v42 = v5[v30];
        f_34(v35, v42);
        v30 += 1 ;
    }
    int * v44;
    v44 = (int *)(v0+32ull);
    v44[0] = v6;
    int v46;
    v46 = v7.tag;
    f_38(v0, v46);
    unsigned char * v47;
    v47 = (unsigned char *)(v0+40ull);
    switch (v7.tag) {
        case 0: { // Call
            return f_32(v47);
            break;
        }
        case 1: { // Fold
            return f_32(v47);
            break;
        }
        case 2: { // Raise
            return f_32(v47);
            break;
        }
        default: {
            assert("Invalid tag." && false); __trap();
        }
    }
}
__device__ void f_33(unsigned char * v0, Union4 v1){
    int v2;
    v2 = v1.tag;
    f_34(v0, v2);
    unsigned char * v3;
    v3 = (unsigned char *)(v0+16ull);
    switch (v1.tag) {
        case 0: { // ChanceCommunityCard
            Union5 v5 = v1.case0.v0; bool v6 = v1.case0.v1; static_array<Union6,2> v7 = v1.case0.v2; int v8 = v1.case0.v3; static_array<int,2> v9 = v1.case0.v4; int v10 = v1.case0.v5;
            return f_35(v3, v5, v6, v7, v8, v9, v10);
            break;
        }
        case 1: { // ChanceInit
            return f_32(v3);
            break;
        }
        case 2: { // Round
            Union5 v11 = v1.case2.v0; bool v12 = v1.case2.v1; static_array<Union6,2> v13 = v1.case2.v2; int v14 = v1.case2.v3; static_array<int,2> v15 = v1.case2.v4; int v16 = v1.case2.v5;
            return f_35(v3, v11, v12, v13, v14, v15, v16);
            break;
        }
        case 3: { // RoundWithAction
            Union5 v17 = v1.case3.v0; bool v18 = v1.case3.v1; static_array<Union6,2> v19 = v1.case3.v2; int v20 = v1.case3.v3; static_array<int,2> v21 = v1.case3.v4; int v22 = v1.case3.v5; Union1 v23 = v1.case3.v6;
            return f_37(v3, v17, v18, v19, v20, v21, v22, v23);
            break;
        }
        case 4: { // TerminalCall
            Union5 v24 = v1.case4.v0; bool v25 = v1.case4.v1; static_array<Union6,2> v26 = v1.case4.v2; int v27 = v1.case4.v3; static_array<int,2> v28 = v1.case4.v4; int v29 = v1.case4.v5;
            return f_35(v3, v24, v25, v26, v27, v28, v29);
            break;
        }
        case 5: { // TerminalFold
            Union5 v30 = v1.case5.v0; bool v31 = v1.case5.v1; static_array<Union6,2> v32 = v1.case5.v2; int v33 = v1.case5.v3; static_array<int,2> v34 = v1.case5.v4; int v35 = v1.case5.v5;
            return f_35(v3, v30, v31, v32, v33, v34, v35);
            break;
        }
        default: {
            assert("Invalid tag." && false); __trap();
        }
    }
}
__device__ void f_39(unsigned char * v0, int v1){
    int * v2;
    v2 = (int *)(v0+80ull);
    v2[0] = v1;
    return ;
}
__device__ void f_41(unsigned char * v0, int v1, Union1 v2){
    int * v3;
    v3 = (int *)(v0+0ull);
    v3[0] = v1;
    int v5;
    v5 = v2.tag;
    f_31(v0, v5);
    unsigned char * v6;
    v6 = (unsigned char *)(v0+8ull);
    switch (v2.tag) {
        case 0: { // Call
            return f_32(v6);
            break;
        }
        case 1: { // Fold
            return f_32(v6);
            break;
        }
        case 2: { // Raise
            return f_32(v6);
            break;
        }
        default: {
            assert("Invalid tag." && false); __trap();
        }
    }
}
__device__ void f_42(unsigned char * v0, int v1, Union6 v2){
    int * v3;
    v3 = (int *)(v0+0ull);
    v3[0] = v1;
    int v5;
    v5 = v2.tag;
    f_31(v0, v5);
    unsigned char * v6;
    v6 = (unsigned char *)(v0+8ull);
    switch (v2.tag) {
        case 0: { // Jack
            return f_32(v6);
            break;
        }
        case 1: { // King
            return f_32(v6);
            break;
        }
        case 2: { // Queen
            return f_32(v6);
            break;
        }
        default: {
            assert("Invalid tag." && false); __trap();
        }
    }
}
__device__ void f_43(unsigned char * v0, static_array<Union6,2> v1, int v2, int v3){
    int v4;
    v4 = 0;
    while (while_method_0(v4)){
        unsigned long long v6;
        v6 = (unsigned long long)v4;
        unsigned long long v7;
        v7 = v6 * 4ull;
        unsigned char * v8;
        v8 = (unsigned char *)(v0+v7);
        bool v10;
        v10 = 0 <= v4;
        bool v12;
        if (v10){
            bool v11;
            v11 = v4 < 2;
            v12 = v11;
        } else {
            v12 = false;
        }
        bool v13;
        v13 = v12 == false;
        if (v13){
            assert("Index must be in range." && v12);
        } else {
        }
        Union6 v15;
        v15 = v1[v4];
        f_36(v8, v15);
        v4 += 1 ;
    }
    int * v17;
    v17 = (int *)(v0+8ull);
    v17[0] = v2;
    int * v19;
    v19 = (int *)(v0+12ull);
    v19[0] = v3;
    return ;
}
__device__ void f_40(unsigned char * v0, Union7 v1){
    int v2;
    v2 = v1.tag;
    f_34(v0, v2);
    unsigned char * v3;
    v3 = (unsigned char *)(v0+16ull);
    switch (v1.tag) {
        case 0: { // CommunityCardIs
            Union6 v5 = v1.case0.v0;
            return f_36(v3, v5);
            break;
        }
        case 1: { // PlayerAction
            int v6 = v1.case1.v0; Union1 v7 = v1.case1.v1;
            return f_41(v3, v6, v7);
            break;
        }
        case 2: { // PlayerGotCard
            int v8 = v1.case2.v0; Union6 v9 = v1.case2.v1;
            return f_42(v3, v8, v9);
            break;
        }
        case 3: { // Showdown
            static_array<Union6,2> v10 = v1.case3.v0; int v11 = v1.case3.v1; int v12 = v1.case3.v2;
            return f_43(v3, v10, v11, v12);
            break;
        }
        default: {
            assert("Invalid tag." && false); __trap();
        }
    }
}
__device__ void f_44(unsigned char * v0, Union2 v1){
    int v2;
    v2 = v1.tag;
    f_34(v0, v2);
    unsigned char * v3;
    v3 = (unsigned char *)(v0+4ull);
    switch (v1.tag) {
        case 0: { // Computer
            return f_32(v3);
            break;
        }
        case 1: { // Human
            return f_32(v3);
            break;
        }
        case 2: { // Random
            return f_32(v3);
            break;
        }
        default: {
            assert("Invalid tag." && false); __trap();
        }
    }
}
__device__ void f_45(unsigned char * v0, int v1){
    int * v2;
    v2 = (int *)(v0+1128ull);
    v2[0] = v1;
    return ;
}
__device__ void f_29(unsigned char * v0, unsigned int v1, Union3 v2, static_array_list<Union7,32> v3, static_array<Union2,2> v4, Union8 v5){
    f_30(v0, v1);
    int v6;
    v6 = v2.tag;
    f_31(v0, v6);
    unsigned char * v7;
    v7 = (unsigned char *)(v0+16ull);
    switch (v2.tag) {
        case 0: { // None
            f_32(v7);
            break;
        }
        case 1: { // Some
            Union4 v9 = v2.case1.v0;
            f_33(v7, v9);
            break;
        }
        default: {
            assert("Invalid tag." && false); __trap();
        }
    }
    int v10;
    v10 = v3.length;
    f_39(v0, v10);
    int v11;
    v11 = v3.length;
    int v12;
    v12 = 0;
    while (while_method_1(v11, v12)){
        unsigned long long v14;
        v14 = (unsigned long long)v12;
        unsigned long long v15;
        v15 = v14 * 32ull;
        unsigned long long v16;
        v16 = 96ull + v15;
        unsigned char * v17;
        v17 = (unsigned char *)(v0+v16);
        Union7 v19;
        v19 = v3[v12];
        f_40(v17, v19);
        v12 += 1 ;
    }
    int v21;
    v21 = 0;
    while (while_method_0(v21)){
        unsigned long long v23;
        v23 = (unsigned long long)v21;
        unsigned long long v24;
        v24 = v23 * 4ull;
        unsigned long long v25;
        v25 = 1120ull + v24;
        unsigned char * v26;
        v26 = (unsigned char *)(v0+v25);
        bool v28;
        v28 = 0 <= v21;
        bool v30;
        if (v28){
            bool v29;
            v29 = v21 < 2;
            v30 = v29;
        } else {
            v30 = false;
        }
        bool v31;
        v31 = v30 == false;
        if (v31){
            assert("Index must be in range." && v30);
        } else {
        }
        Union2 v33;
        v33 = v4[v21];
        f_44(v26, v33);
        v21 += 1 ;
    }
    int v35;
    v35 = v5.tag;
    f_45(v0, v35);
    unsigned char * v36;
    v36 = (unsigned char *)(v0+1136ull);
    switch (v5.tag) {
        case 0: { // GameNotStarted
            return f_32(v36);
            break;
        }
        case 1: { // GameOver
            Union5 v38 = v5.case1.v0; bool v39 = v5.case1.v1; static_array<Union6,2> v40 = v5.case1.v2; int v41 = v5.case1.v3; static_array<int,2> v42 = v5.case1.v4; int v43 = v5.case1.v5;
            return f_35(v36, v38, v39, v40, v41, v42, v43);
            break;
        }
        case 2: { // WaitingForActionFromPlayerId
            Union5 v44 = v5.case2.v0; bool v45 = v5.case2.v1; static_array<Union6,2> v46 = v5.case2.v2; int v47 = v5.case2.v3; static_array<int,2> v48 = v5.case2.v4; int v49 = v5.case2.v5;
            return f_35(v36, v44, v45, v46, v47, v48, v49);
            break;
        }
        default: {
            assert("Invalid tag." && false); __trap();
        }
    }
}
__device__ inline bool while_method_10(Union3 v0){
    switch (v0.tag) {
        case 0: { // None
            return false;
            break;
        }
        case 1: { // Some
            Union4 v1 = v0.case1.v0;
            return true;
            break;
        }
        default: {
            assert("Invalid tag." && false); __trap();
        }
    }
}
__device__ float method_47(int * v0, float * v1, float * v2, float * v3, float * v4, float * v5, float * v6, float * v7, int v8, int v9, int v10){
    assert("Tensor range check" && 0 <= v9 && v9 < 4);
    int v11;
    v11 = 16384 * v9;
    assert("Tensor range check" && 0 <= v8 && v8 < 4096);
    int v12;
    v12 = 4 * v8;
    int v13;
    v13 = v12 + v11;
    float * v14;
    v14 = v2+v13;
    int v16;
    v16 = sizeof(float *);
    unsigned long long v17;
    v17 = (unsigned long long)v16;
    unsigned long long v18;
    v18 = 256ull * v17;
    unsigned long long v19;
    v19 = 1024ull + v18;
    unsigned long long v20;
    v20 = v19 + 16ull;
    unsigned long long v21;
    v21 = v20 - 1ull;
    unsigned long long v22;
    v22 = v21 % 16ull;
    unsigned long long v23;
    v23 = v21 - v22;
    unsigned long long v24;
    v24 = v23 + 1024ull;
    bool v25;
    v25 = v24 <= 98304ull;
    bool v26;
    v26 = v25 == false;
    if (v26){
        assert("The dynamic shared memory is insufficient to allocate the tensor." && v25);
    } else {
    }
    extern __shared__ unsigned char v28[];
    bool v29;
    v29 = v24 <= v24;
    bool v30;
    v30 = v29 == false;
    if (v30){
        assert("The length of the partition has to be less than or equal to the length of the base array." && v29);
    } else {
    }
    int * v32;
    v32 = reinterpret_cast<int *>(&v28[0ull]);
    float * * v34;
    v34 = reinterpret_cast<float * *>(&v28[1024ull]);
    float * v36;
    v36 = reinterpret_cast<float *>(&v28[v23]);
    int v38;
    v38 = threadIdx.x;
    assert("Tensor range check" && 0 <= v38 && v38 < 256);
    v32[v38] = v10;
    v34[v38] = v14;
    __syncthreads();
    bool v39;
    v39 = 0 <= v38;
    bool v40;
    v40 = v39 == false;
    if (v40){
        assert("The index needs to be zero or positive." && v39);
    } else {
    }
    int v42;
    v42 = v38 % 1;
    bool v43;
    v43 = v38 < 256;
    bool v44;
    v44 = v43 == false;
    if (v44){
        assert("The last element of the projection dimensions needs to be greater than the index remainder." && v43);
    } else {
    }
    assert("Tensor range check" && 0 <= v38 && v38 < 256);
    int v46;
    v46 = 0;
    while (while_method_4(v46)){
        bool v48;
        v48 = v39 && v43;
        bool v49;
        v49 = v48 == false;
        if (v49){
            assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v48);
        } else {
        }
        bool v51;
        v51 = 0 <= v46;
        bool v53;
        if (v51){
            bool v52;
            v52 = v46 < 1;
            v53 = v52;
        } else {
            v53 = false;
        }
        bool v54;
        v54 = v53 == false;
        if (v54){
            assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v53);
        } else {
        }
        int v56;
        v56 = v46 * 256;
        int v57;
        v57 = v56 + v38;
        assert("Tensor range check" && 0 <= v46 && v46 < 1);
        int v58;
        v58 = 256 * v46;
        int v59;
        v59 = v58 + v38;
        int v60;
        v60 = v32[v59];
        float * v61;
        v61 = v34[v59];
        int v62;
        v62 = blockIdx.x;
        int v63;
        v63 = v62 * 256;
        int v64;
        v64 = v63 + v57;
        assert("Tensor range check" && 0 <= v42 && v42 < 1);
        int v65;
        v65 = 4 * v42;
        float v66[4];
        int v67[4];
        int v68;
        v68 = 0;
        while (while_method_4(v68)){
            assert("Tensor range check" && 0 <= v68 && v68 < 1);
            int v70;
            v70 = 4 * v68;
            assert("Tensor range check" && 0 <= v68 && v68 < 1);
            int v71;
            v71 = v70 + v65;
            int4* v72;
            v72 = reinterpret_cast<int4*>(v61 + v71);
            int4* v73;
            v73 = reinterpret_cast<int4*>(v66 + v70);
            assert("Pointer alignment check" && (unsigned long long)(v72) % 4 == 0 && (unsigned long long)(v73) % 4 == 0);
            *v73 = *v72;
            v68 += 1 ;
        }
        int v74;
        v74 = 0;
        while (while_method_4(v74)){
            int v76;
            v76 = 0;
            while (while_method_9(v76)){
                bool v78;
                v78 = 0 <= v76;
                bool v80;
                if (v78){
                    bool v79;
                    v79 = v76 < 4;
                    v80 = v79;
                } else {
                    v80 = false;
                }
                bool v81;
                v81 = v80 == false;
                if (v81){
                    assert("The indices should be inside the range of the dimension." && v80);
                } else {
                }
                bool v83;
                v83 = 0 <= v42;
                bool v85;
                if (v83){
                    bool v84;
                    v84 = v42 < 1;
                    v85 = v84;
                } else {
                    v85 = false;
                }
                bool v86;
                v86 = v85 == false;
                if (v86){
                    assert("The indices should be inside the range of the dimension." && v85);
                } else {
                }
                int v88;
                v88 = v42 * 4;
                int v89;
                v89 = v76 + v88;
                bool v90;
                v90 = 0 <= v74;
                bool v92;
                if (v90){
                    bool v91;
                    v91 = v74 < 1;
                    v92 = v91;
                } else {
                    v92 = false;
                }
                bool v93;
                v93 = v92 == false;
                if (v93){
                    assert("The indices should be inside the range of the dimension." && v92);
                } else {
                }
                int v95;
                v95 = v74 * 4;
                int v96;
                v96 = v89 + v95;
                assert("Tensor range check" && 0 <= v74 && v74 < 1);
                assert("Tensor range check" && 0 <= v76 && v76 < 4);
                int v97;
                v97 = 4 * v74;
                int v98;
                v98 = v97 + v76;
                v67[v98] = v96;
                v76 += 1 ;
            }
            v74 += 1 ;
        }
        bool v99[4];
        int v100;
        v100 = 0;
        while (while_method_4(v100)){
            int v102;
            v102 = 0;
            while (while_method_9(v102)){
                assert("Tensor range check" && 0 <= v100 && v100 < 1);
                assert("Tensor range check" && 0 <= v102 && v102 < 4);
                int v104;
                v104 = 4 * v100;
                int v105;
                v105 = v104 + v102;
                float v106;
                v106 = v66[v105];
                int v107;
                v107 = v67[v105];
                bool v108;
                v108 = v107 < 3;
                assert("Tensor range check" && 0 <= v100 && v100 < 1);
                assert("Tensor range check" && 0 <= v102 && v102 < 4);
                v99[v105] = v108;
                v102 += 1 ;
            }
            v100 += 1 ;
        }
        float v109[4];
        int v110;
        v110 = 0;
        while (while_method_4(v110)){
            int v112;
            v112 = 0;
            while (while_method_9(v112)){
                assert("Tensor range check" && 0 <= v110 && v110 < 1);
                assert("Tensor range check" && 0 <= v112 && v112 < 4);
                int v114;
                v114 = 4 * v110;
                int v115;
                v115 = v114 + v112;
                float v116;
                v116 = v66[v115];
                bool v117;
                v117 = v99[v115];
                float v120;
                if (v117){
                    bool v118;
                    v118 = 0.0f >= v116;
                    if (v118){
                        v120 = 0.0f;
                    } else {
                        v120 = v116;
                    }
                } else {
                    v120 = 0.0f;
                }
                assert("Tensor range check" && 0 <= v110 && v110 < 1);
                assert("Tensor range check" && 0 <= v112 && v112 < 4);
                v109[v115] = v120;
                v112 += 1 ;
            }
            v110 += 1 ;
        }
        float v121;
        v121 = 0.0f;
        int v122;
        v122 = 0;
        while (while_method_4(v122)){
            int v124;
            v124 = 0;
            while (while_method_9(v124)){
                assert("Tensor range check" && 0 <= v122 && v122 < 1);
                assert("Tensor range check" && 0 <= v124 && v124 < 4);
                int v126;
                v126 = 4 * v122;
                int v127;
                v127 = v126 + v124;
                float v128;
                v128 = v109[v127];
                float v129;
                v129 = v121 + v128;
                v121 = v129;
                v124 += 1 ;
            }
            v122 += 1 ;
        }
        auto v130 = cooperative_groups::coalesced_threads();
        int v131;
        v131 = threadIdx.x;
        auto v132 = cooperative_groups::labeled_partition(v130,v131);
        Closure1 v133{};
        float v134;
        v134 = cooperative_groups::reduce(v132, v121, v133);
        int v135[4];
        int v136;
        v136 = 0;
        while (while_method_4(v136)){
            int v138;
            v138 = 0;
            while (while_method_9(v138)){
                assert("Tensor range check" && 0 <= v136 && v136 < 1);
                assert("Tensor range check" && 0 <= v138 && v138 < 4);
                int v140;
                v140 = 4 * v136;
                int v141;
                v141 = v140 + v138;
                bool v142;
                v142 = v99[v141];
                int v143;
                if (v142){
                    v143 = 1;
                } else {
                    v143 = 0;
                }
                assert("Tensor range check" && 0 <= v136 && v136 < 1);
                assert("Tensor range check" && 0 <= v138 && v138 < 4);
                v135[v141] = v143;
                v138 += 1 ;
            }
            v136 += 1 ;
        }
        int v144;
        v144 = 0;
        int v145;
        v145 = 0;
        while (while_method_4(v145)){
            int v147;
            v147 = 0;
            while (while_method_9(v147)){
                assert("Tensor range check" && 0 <= v145 && v145 < 1);
                assert("Tensor range check" && 0 <= v147 && v147 < 4);
                int v149;
                v149 = 4 * v145;
                int v150;
                v150 = v149 + v147;
                int v151;
                v151 = v135[v150];
                int v152;
                v152 = v144 + v151;
                v144 = v152;
                v147 += 1 ;
            }
            v145 += 1 ;
        }
        auto v153 = cooperative_groups::coalesced_threads();
        int v154;
        v154 = threadIdx.x;
        auto v155 = cooperative_groups::labeled_partition(v153,v154);
        Closure2 v156{};
        int v157;
        v157 = cooperative_groups::reduce(v155, v144, v156);
        float v158;
        v158 = (float)v157;
        float v159;
        v159 = 1.0f / v158;
        float v160[4];
        int v161;
        v161 = 0;
        while (while_method_4(v161)){
            int v163;
            v163 = 0;
            while (while_method_9(v163)){
                assert("Tensor range check" && 0 <= v161 && v161 < 1);
                assert("Tensor range check" && 0 <= v163 && v163 < 4);
                int v165;
                v165 = 4 * v161;
                int v166;
                v166 = v165 + v163;
                float v167;
                v167 = v109[v166];
                bool v168;
                v168 = v99[v166];
                bool v169;
                v169 = v168 == false;
                float v174;
                if (v169){
                    v174 = 0.0f;
                } else {
                    bool v170;
                    v170 = v134 == 0.0f;
                    bool v171;
                    v171 = v170 != true;
                    if (v171){
                        float v172;
                        v172 = v167 / v134;
                        v174 = v172;
                    } else {
                        v174 = v159;
                    }
                }
                assert("Tensor range check" && 0 <= v161 && v161 < 1);
                assert("Tensor range check" && 0 <= v163 && v163 < 4);
                v160[v166] = v174;
                v163 += 1 ;
            }
            v161 += 1 ;
        }
        float v175; int v176;
        Tuple8 tmp42 = Tuple8{0.0f, 2147483647};
        v175 = tmp42.v0; v176 = tmp42.v1;
        int v177;
        v177 = 0;
        while (while_method_4(v177)){
            int v179;
            v179 = 0;
            while (while_method_9(v179)){
                assert("Tensor range check" && 0 <= v177 && v177 < 1);
                assert("Tensor range check" && 0 <= v179 && v179 < 4);
                int v181;
                v181 = 4 * v177;
                int v182;
                v182 = v181 + v179;
                float v183;
                v183 = v160[v182];
                int v184;
                v184 = v67[v182];
                bool v185;
                v185 = v176 == v60;
                float v189; int v190;
                if (v185){
                    v189 = v175; v190 = v176;
                } else {
                    bool v186;
                    v186 = v184 == v60;
                    if (v186){
                        v189 = v183; v190 = v184;
                    } else {
                        v189 = v175; v190 = v176;
                    }
                }
                v175 = v189;
                v176 = v190;
                v179 += 1 ;
            }
            v177 += 1 ;
        }
        auto v191 = cooperative_groups::coalesced_threads();
        int v192;
        v192 = threadIdx.x;
        auto v193 = cooperative_groups::labeled_partition(v191,v192);
        Closure7 v194{v60};
        float v195; int v196;
        Tuple8 tmp43 = cooperative_groups::reduce(v193, Tuple8{v175, v176}, v194);
        v195 = tmp43.v0; v196 = tmp43.v1;
        bool v197;
        v197 = v196 == 2147483647;
        bool v198;
        v198 = v197 != true;
        bool v199;
        v199 = v198 == false;
        if (v199){
            assert("Expected a valid action id in get_prob." && v198);
        } else {
        }
        int v201;
        v201 = 0;
        while (while_method_4(v201)){
            assert("Tensor range check" && 0 <= v201 && v201 < 1);
            assert("Tensor range check" && 0 <= v201 && v201 < 1);
            v201 += 1 ;
        }
        assert("Tensor range check" && 0 <= v57 && v57 < 256);
        v36[v57] = v195;
        v46 += 1 ;
    }
    __syncthreads();
    assert("Tensor range check" && 0 <= v38 && v38 < 256);
    float v203;
    v203 = v36[v38];
    __syncthreads();
    return v203;
}
__device__ void method_46(unsigned char * v0, unsigned char * v1, StackMut1 & v2, int v3, Union4 v4){
    v2.v0 = 63u;
    static_array<float,2> v5;
    v5[0] = 0.0f;
    v5[1] = 0.0f;
    v2.v4 = v5;
    static_array_list<Union7,32> & v7 = v2.v2;
    v7.unsafe_set_length(0);
    static_array<Union2,2> v8;
    Union2 v10;
    v10 = Union2{Union2_0{}};
    v8[0] = v10;
    Union2 v12;
    v12 = Union2{Union2_0{}};
    v8[1] = v12;
    int v14;
    v14 = v3 ^ 1;
    Union2 v15;
    v15 = Union2{Union2_2{}};
    v8[v14] = v15;
    v2.v3 = v8;
    static_array_list<Union7,32> & v17 = v2.v2;
    Union3 v18;
    v18 = Union3{Union3_1{v4}};
    Union3 v19;
    v19 = v18;
    while (while_method_10(v19)){
        Union3 v1006;
        switch (v19.tag) {
            case 0: { // None
                v1006 = Union3{Union3_0{}};
                break;
            }
            case 1: { // Some
                Union4 v21 = v19.case1.v0;
                Union14 v846;
                switch (v21.tag) {
                    case 0: { // ChanceCommunityCard
                        Union5 v815 = v21.case0.v0; bool v816 = v21.case0.v1; static_array<Union6,2> v817 = v21.case0.v2; int v818 = v21.case0.v3; static_array<int,2> v819 = v21.case0.v4; int v820 = v21.case0.v5;
                        curandStatePhilox4_32_10_t & v821 = v2.v5;
                        curandStatePhilox4_32_10_t & v822 = v821;
                        unsigned int & v823 = v2.v0;
                        Union6 v824; unsigned int v825;
                        Tuple6 tmp38 = draw_card_20(v822, v823);
                        v824 = tmp38.v0; v825 = tmp38.v1;
                        v2.v0 = v825;
                        Union7 v826;
                        v826 = Union7{Union7_0{v824}};
                        v17.push(v826);
                        v846 = Union14{Union14_0{v815, v816, v817, v818, v819, v820, v824}};
                        break;
                    }
                    case 1: { // ChanceInit
                        curandStatePhilox4_32_10_t & v828 = v2.v5;
                        curandStatePhilox4_32_10_t & v829 = v828;
                        unsigned int & v830 = v2.v0;
                        Union6 v831; unsigned int v832;
                        Tuple6 tmp39 = draw_card_20(v829, v830);
                        v831 = tmp39.v0; v832 = tmp39.v1;
                        v2.v0 = v832;
                        curandStatePhilox4_32_10_t & v833 = v2.v5;
                        curandStatePhilox4_32_10_t & v834 = v833;
                        unsigned int & v835 = v2.v0;
                        Union6 v836; unsigned int v837;
                        Tuple6 tmp40 = draw_card_20(v834, v835);
                        v836 = tmp40.v0; v837 = tmp40.v1;
                        v2.v0 = v837;
                        Union7 v838;
                        v838 = Union7{Union7_2{0, v831}};
                        v17.push(v838);
                        Union7 v839;
                        v839 = Union7{Union7_2{1, v836}};
                        v17.push(v839);
                        v846 = Union14{Union14_1{v831, v836}};
                        break;
                    }
                    case 2: { // Round
                        Union5 v71 = v21.case2.v0; bool v72 = v21.case2.v1; static_array<Union6,2> v73 = v21.case2.v2; int v74 = v21.case2.v3; static_array<int,2> v75 = v21.case2.v4; int v76 = v21.case2.v5;
                        static_array<Union2,2> & v77 = v2.v3;
                        bool v78;
                        v78 = 0 <= v74;
                        bool v80;
                        if (v78){
                            bool v79;
                            v79 = v74 < 2;
                            v80 = v79;
                        } else {
                            v80 = false;
                        }
                        bool v81;
                        v81 = v80 == false;
                        if (v81){
                            assert("Index must be in range." && v80);
                        } else {
                        }
                        Union2 v83;
                        v83 = v77[v74];
                        Union1 v803;
                        switch (v83.tag) {
                            case 0: { // Computer
                                static_array_list<Union7,32> & v86 = v2.v2;
                                curandStatePhilox4_32_10_t & v87 = v2.v5;
                                curandStatePhilox4_32_10_t & v88 = v87;
                                unsigned int * v89;
                                v89 = reinterpret_cast<unsigned int *>(&v0[6291456ull]);
                                float * v91;
                                v91 = reinterpret_cast<float *>(&v0[0ull]);
                                float * v93;
                                v93 = reinterpret_cast<float *>(&v0[0ull]);
                                int v95;
                                v95 = blockIdx.x;
                                assert("Tensor range check" && 0 <= v95 && v95 < 24);
                                int v96;
                                v96 = 32768 * v95;
                                int v97;
                                v97 = threadIdx.x;
                                int v98;
                                v98 = v97;
                                while (while_method_3(v98)){
                                    bool v100;
                                    v100 = 0 <= v98;
                                    bool v101;
                                    v101 = v100 == false;
                                    if (v101){
                                        assert("The index needs to be zero or positive." && v100);
                                    } else {
                                    }
                                    int v103;
                                    v103 = v98 % 128;
                                    int v104;
                                    v104 = v98 / 128;
                                    bool v105;
                                    v105 = v104 < 256;
                                    bool v106;
                                    v106 = v105 == false;
                                    if (v106){
                                        assert("The last element of the projection dimensions needs to be greater than the index remainder." && v105);
                                    } else {
                                    }
                                    assert("Tensor range check" && 0 <= v104 && v104 < 256);
                                    assert("Tensor range check" && 0 <= v103 && v103 < 128);
                                    int v108;
                                    v108 = v103 + v96;
                                    int v109;
                                    v109 = 128 * v104;
                                    int v110;
                                    v110 = v109 + v108;
                                    v93[v110] = 0.0f;
                                    v98 += 256 ;
                                }
                                __syncthreads();
                                int v111;
                                v111 = threadIdx.x;
                                assert("Tensor range check" && 0 <= v111 && v111 < 256);
                                int v112;
                                v112 = 128 * v111;
                                int v113;
                                v113 = v112 + v96;
                                static_array_list<Union9,10> v114;
                                v114 = static_array_list<Union9,10>{};
                                int v116;
                                v116 = v86.length;
                                int v117;
                                v117 = 0;
                                while (while_method_1(v116, v117)){
                                    Union7 v119;
                                    v119 = v86[v117];
                                    Union10 v138;
                                    switch (v119.tag) {
                                        case 0: { // CommunityCardIs
                                            Union6 v128 = v119.case0.v0;
                                            Union9 v129;
                                            v129 = Union9{Union9_1{v128}};
                                            v138 = Union10{Union10_1{v129}};
                                            break;
                                        }
                                        case 1: { // PlayerAction
                                            int v131 = v119.case1.v0; Union1 v132 = v119.case1.v1;
                                            Union9 v133;
                                            v133 = Union9{Union9_0{v132}};
                                            v138 = Union10{Union10_1{v133}};
                                            break;
                                        }
                                        case 2: { // PlayerGotCard
                                            int v121 = v119.case2.v0; Union6 v122 = v119.case2.v1;
                                            bool v123;
                                            v123 = v121 == v74;
                                            if (v123){
                                                Union9 v124;
                                                v124 = Union9{Union9_1{v122}};
                                                v138 = Union10{Union10_1{v124}};
                                            } else {
                                                v138 = Union10{Union10_0{}};
                                            }
                                            break;
                                        }
                                        default: {
                                            v138 = Union10{Union10_0{}};
                                        }
                                    }
                                    switch (v138.tag) {
                                        case 0: { // None
                                            break;
                                        }
                                        case 1: { // Some
                                            Union9 v139 = v138.case1.v0;
                                            v114.push(v139);
                                            break;
                                        }
                                        default: {
                                            assert("Invalid tag." && false); __trap();
                                        }
                                    }
                                    v117 += 1 ;
                                }
                                float * v140;
                                v140 = v93+v113;
                                int v142;
                                v142 = v114.length;
                                bool v143;
                                v143 = v142 == 0;
                                if (v143){
                                    v140[0] = 1.0f;
                                } else {
                                }
                                int v144;
                                v144 = v114.length;
                                int v145;
                                v145 = 0;
                                while (while_method_1(v144, v145)){
                                    Union9 v147;
                                    v147 = v114[v145];
                                    int v149;
                                    v149 = v145 * 6;
                                    int v150;
                                    v150 = 1 + v149;
                                    switch (v147.tag) {
                                        case 0: { // C1of2
                                            Union1 v151 = v147.case0.v0;
                                            switch (v151.tag) {
                                                case 0: { // Call
                                                    v140[v150] = 1.0f;
                                                    break;
                                                }
                                                case 1: { // Fold
                                                    int v152;
                                                    v152 = v150 + 1;
                                                    v140[v152] = 1.0f;
                                                    break;
                                                }
                                                case 2: { // Raise
                                                    int v153;
                                                    v153 = v150 + 2;
                                                    v140[v153] = 1.0f;
                                                    break;
                                                }
                                                default: {
                                                    assert("Invalid tag." && false); __trap();
                                                }
                                            }
                                            break;
                                        }
                                        case 1: { // C2of2
                                            Union6 v154 = v147.case1.v0;
                                            int v155;
                                            v155 = v150 + 3;
                                            switch (v154.tag) {
                                                case 0: { // Jack
                                                    v140[v155] = 1.0f;
                                                    break;
                                                }
                                                case 1: { // King
                                                    int v156;
                                                    v156 = v155 + 1;
                                                    v140[v156] = 1.0f;
                                                    break;
                                                }
                                                case 2: { // Queen
                                                    int v157;
                                                    v157 = v155 + 2;
                                                    v140[v157] = 1.0f;
                                                    break;
                                                }
                                                default: {
                                                    assert("Invalid tag." && false); __trap();
                                                }
                                            }
                                            break;
                                        }
                                        default: {
                                            assert("Invalid tag." && false); __trap();
                                        }
                                    }
                                    v145 += 1 ;
                                }
                                __syncthreads();
                                int v158;
                                v158 = 0;
                                while (while_method_9(v158)){
                                    float * v160;
                                    v160 = reinterpret_cast<float *>(&v0[0ull]);
                                    float * v162;
                                    v162 = reinterpret_cast<float *>(&v1[0ull]);
                                    assert("Tensor range check" && 0 <= v158 && v158 < 4);
                                    int v164;
                                    v164 = 16384 * v158;
                                    float * v165;
                                    v165 = reinterpret_cast<float *>(&v0[3145728ull]);
                                    int v167;
                                    v167 = blockIdx.x;
                                    assert("Tensor range check" && 0 <= v167 && v167 < 24);
                                    int v168;
                                    v168 = 32768 * v167;
                                    int v169;
                                    v169 = blockIdx.x;
                                    assert("Tensor range check" && 0 <= v169 && v169 < 24);
                                    int v170;
                                    v170 = 32768 * v169;
                                    cuda::pipeline<cuda::thread_scope_thread> v171 = cuda::make_pipeline();
                                    extern __shared__ unsigned char v172[];
                                    float * v173;
                                    v173 = reinterpret_cast<float *>(&v172[0ull]);
                                    float * v175;
                                    v175 = reinterpret_cast<float *>(&v172[34816ull]);
                                    float * v177;
                                    v177 = reinterpret_cast<float *>(&v172[0ull]);
                                    int v179;
                                    v179 = threadIdx.x;
                                    int v180;
                                    v180 = v179 / 32;
                                    bool v181;
                                    v181 = 0 <= v180;
                                    bool v182;
                                    v182 = v181 == false;
                                    if (v182){
                                        assert("The index needs to be zero or positive." && v181);
                                    } else {
                                    }
                                    int v184;
                                    v184 = v180 % 8;
                                    int v185;
                                    v185 = v180 / 8;
                                    bool v186;
                                    v186 = v185 < 1;
                                    bool v187;
                                    v187 = v186 == false;
                                    if (v187){
                                        assert("The last element of the projection dimensions needs to be greater than the index remainder." && v186);
                                    } else {
                                    }
                                    assert("Tensor range check" && 0 <= v185 && v185 < 1);
                                    assert("Tensor range check" && 0 <= v184 && v184 < 8);
                                    int v189;
                                    v189 = 16 * v184;
                                    int v190;
                                    v190 = 17408 * v185;
                                    int v191;
                                    v191 = v190 + v189;
                                    float * v192;
                                    v192 = v177+v191;
                                    assert("Tensor range check" && 0 <= v185 && v185 < 1);
                                    int v194;
                                    v194 = 8704 * v185;
                                    int v195;
                                    v195 = threadIdx.x;
                                    int v196;
                                    v196 = v195 % 32;
                                    bool v197;
                                    v197 = 0 <= v196;
                                    bool v198;
                                    v198 = v197 == false;
                                    if (v198){
                                        assert("The index needs to be zero or positive." && v197);
                                    } else {
                                    }
                                    int v200;
                                    v200 = v196 % 4;
                                    int v201;
                                    v201 = v196 / 4;
                                    bool v202;
                                    v202 = v201 < 8;
                                    bool v203;
                                    v203 = v202 == false;
                                    if (v203){
                                        assert("The last element of the projection dimensions needs to be greater than the index remainder." && v202);
                                    } else {
                                    }
                                    assert("Tensor range check" && 0 <= v201 && v201 < 8);
                                    assert("Tensor range check" && 0 <= v200 && v200 < 4);
                                    int v205;
                                    v205 = v200 + v194;
                                    int v206;
                                    v206 = 68 * v201;
                                    int v207;
                                    v207 = v206 + v205;
                                    float * v208;
                                    v208 = v173+v207;
                                    assert("Tensor range check" && 0 <= v184 && v184 < 8);
                                    int v210;
                                    v210 = 1088 * v184;
                                    int v211;
                                    v211 = threadIdx.x;
                                    int v212;
                                    v212 = v211 % 32;
                                    bool v213;
                                    v213 = 0 <= v212;
                                    bool v214;
                                    v214 = v213 == false;
                                    if (v214){
                                        assert("The index needs to be zero or positive." && v213);
                                    } else {
                                    }
                                    int v216;
                                    v216 = v212 % 4;
                                    int v217;
                                    v217 = v212 / 4;
                                    bool v218;
                                    v218 = v217 < 8;
                                    bool v219;
                                    v219 = v218 == false;
                                    if (v219){
                                        assert("The last element of the projection dimensions needs to be greater than the index remainder." && v218);
                                    } else {
                                    }
                                    assert("Tensor range check" && 0 <= v217 && v217 < 8);
                                    assert("Tensor range check" && 0 <= v216 && v216 < 4);
                                    int v221;
                                    v221 = v216 + v210;
                                    int v222;
                                    v222 = 68 * v217;
                                    int v223;
                                    v223 = v222 + v221;
                                    float * v224;
                                    v224 = v175+v223;
                                    wmma::fragment<wmma::accumulator, 16, 16, 8, float> v226[8];
                                    int v227;
                                    v227 = 0;
                                    while (while_method_0(v227)){
                                        int v229;
                                        v229 = 0;
                                        while (while_method_4(v229)){
                                            assert("Tensor range check" && 0 <= v227 && v227 < 2);
                                            assert("Tensor range check" && 0 <= v229 && v229 < 1);
                                            int v231;
                                            v231 = 128 * v229;
                                            int v232;
                                            v232 = v231 + v170;
                                            int v233;
                                            v233 = 16384 * v227;
                                            int v234;
                                            v234 = v233 + v232;
                                            float * v235;
                                            v235 = v165+v234;
                                            // Pushing the loop unrolling to: 0
                                            int v237;
                                            v237 = 0;
                                            #pragma unroll
                                            while (while_method_5(v237)){
                                                int v239;
                                                v239 = 0;
                                                #pragma unroll
                                                while (while_method_4(v239)){
                                                    assert("Tensor range check" && 0 <= v237 && v237 < 8);
                                                    assert("Tensor range check" && 0 <= v239 && v239 < 1);
                                                    int v241;
                                                    v241 = v237 + v239;
                                                    wmma::fragment<wmma::accumulator, 16, 16, 8, float> & v242 = v226[v241];
                                                    wmma::fill_fragment(v242, 0.0f);
                                                    v239 += 1 ;
                                                }
                                                v237 += 1 ;
                                            }
                                            // Poping the loop unrolling to: 0
                                            int v243;
                                            v243 = 0;
                                            while (while_method_6(v243)){
                                                int v245;
                                                v245 = v243 + 1;
                                                bool v246;
                                                v246 = v243 == 0;
                                                int v247;
                                                v247 = v243 % 2;
                                                bool v248;
                                                v248 = 0 <= v243;
                                                bool v249;
                                                v249 = v248 == false;
                                                if (v249){
                                                    assert("The index needs to be zero or positive." && v248);
                                                } else {
                                                }
                                                bool v251;
                                                v251 = v243 < 2;
                                                bool v252;
                                                v252 = v251 == false;
                                                if (v252){
                                                    assert("The last element of the projection dimensions needs to be greater than the index remainder." && v251);
                                                } else {
                                                }
                                                bool v254;
                                                v254 = v245 < 2;
                                                Union11 v260;
                                                if (v254){
                                                    bool v255;
                                                    v255 = 0 <= v245;
                                                    bool v256;
                                                    v256 = v255 == false;
                                                    if (v256){
                                                        assert("The index needs to be zero or positive." && v255);
                                                    } else {
                                                    }
                                                    v260 = Union11{Union11_1{v245}};
                                                } else {
                                                    v260 = Union11{Union11_0{}};
                                                }
                                                assert("Tensor range check" && 0 <= v227 && v227 < 2);
                                                int v261;
                                                v261 = v233 + v168;
                                                assert("Tensor range check" && 0 <= v243 && v243 < 2);
                                                int v262;
                                                v262 = 64 * v243;
                                                int v263;
                                                v263 = v262 + v261;
                                                float * v264;
                                                v264 = v160+v263;
                                                assert("Tensor range check" && 0 <= v229 && v229 < 1);
                                                int v266;
                                                v266 = 16384 * v229;
                                                int v267;
                                                v267 = v266 + v164;
                                                if (v246){
                                                    assert("Tensor range check" && 0 <= v243 && v243 < 2);
                                                    int v268;
                                                    v268 = v262 + v267;
                                                    float * v269;
                                                    v269 = v162+v268;
                                                    // Pushing the loop unrolling to: 0
                                                    v171.producer_acquire();
                                                    int v271;
                                                    v271 = threadIdx.x;
                                                    bool v272;
                                                    v272 = 0 <= v271;
                                                    bool v273;
                                                    v273 = v272 == false;
                                                    if (v273){
                                                        assert("The index needs to be zero or positive." && v272);
                                                    } else {
                                                    }
                                                    int v275;
                                                    v275 = v271 % 16;
                                                    int v276;
                                                    v276 = v271 / 16;
                                                    bool v277;
                                                    v277 = v276 < 16;
                                                    bool v278;
                                                    v278 = v277 == false;
                                                    if (v278){
                                                        assert("The last element of the projection dimensions needs to be greater than the index remainder." && v277);
                                                    } else {
                                                    }
                                                    assert("Tensor range check" && 0 <= v276 && v276 < 16);
                                                    assert("Tensor range check" && 0 <= v275 && v275 < 16);
                                                    int v280;
                                                    v280 = 4 * v275;
                                                    int v281;
                                                    v281 = 68 * v276;
                                                    int v282;
                                                    v282 = v281 + v280;
                                                    int v283;
                                                    v283 = 128 * v276;
                                                    int v284;
                                                    v284 = v283 + v280;
                                                    float * v285;
                                                    v285 = v175+v282;
                                                    float * v287;
                                                    v287 = v269+v284;
                                                    int v289;
                                                    v289 = 0;
                                                    #pragma unroll
                                                    while (while_method_5(v289)){
                                                        int v291;
                                                        v291 = 0;
                                                        #pragma unroll
                                                        while (while_method_4(v291)){
                                                            assert("Tensor range check" && 0 <= v289 && v289 < 8);
                                                            assert("Tensor range check" && 0 <= v291 && v291 < 1);
                                                            int v293;
                                                            v293 = 64 * v291;
                                                            int v294;
                                                            v294 = 1088 * v289;
                                                            int v295;
                                                            v295 = v294 + v293;
                                                            int v296;
                                                            v296 = 2048 * v289;
                                                            int v297;
                                                            v297 = v296 + v293;
                                                            constexpr int v298 = sizeof(float) * 4;
                                                            assert("Pointer alignment check" && (unsigned long long)(v287 + v297) % v298 == 0 && (unsigned long long)(v285 + v295) % v298 == 0);
                                                            cuda::memcpy_async(v285 + v295, v287 + v297, cuda::aligned_size_t<v298>(v298), v171);
                                                            v291 += 1 ;
                                                        }
                                                        v289 += 1 ;
                                                    }
                                                    v171.producer_commit();
                                                    // Poping the loop unrolling to: 0
                                                } else {
                                                }
                                                // Pushing the loop unrolling to: 0
                                                int v299;
                                                v299 = threadIdx.x;
                                                bool v300;
                                                v300 = 0 <= v299;
                                                bool v301;
                                                v301 = v300 == false;
                                                if (v301){
                                                    assert("The index needs to be zero or positive." && v300);
                                                } else {
                                                }
                                                int v303;
                                                v303 = v299 % 16;
                                                int v304;
                                                v304 = v299 / 16;
                                                bool v305;
                                                v305 = v304 < 16;
                                                bool v306;
                                                v306 = v305 == false;
                                                if (v306){
                                                    assert("The last element of the projection dimensions needs to be greater than the index remainder." && v305);
                                                } else {
                                                }
                                                assert("Tensor range check" && 0 <= v304 && v304 < 16);
                                                assert("Tensor range check" && 0 <= v303 && v303 < 16);
                                                int v308;
                                                v308 = 4 * v303;
                                                int v309;
                                                v309 = 68 * v304;
                                                int v310;
                                                v310 = v309 + v308;
                                                int v311;
                                                v311 = 128 * v304;
                                                int v312;
                                                v312 = v311 + v308;
                                                float * v313;
                                                v313 = v173+v310;
                                                float * v315;
                                                v315 = v264+v312;
                                                int v317;
                                                v317 = 0;
                                                #pragma unroll
                                                while (while_method_5(v317)){
                                                    int v319;
                                                    v319 = 0;
                                                    #pragma unroll
                                                    while (while_method_4(v319)){
                                                        assert("Tensor range check" && 0 <= v317 && v317 < 8);
                                                        assert("Tensor range check" && 0 <= v319 && v319 < 1);
                                                        int v321;
                                                        v321 = 64 * v319;
                                                        int v322;
                                                        v322 = 1088 * v317;
                                                        int v323;
                                                        v323 = v322 + v321;
                                                        int v324;
                                                        v324 = 2048 * v317;
                                                        int v325;
                                                        v325 = v324 + v321;
                                                        int4* v326;
                                                        v326 = reinterpret_cast<int4*>(v315 + v325);
                                                        int4* v327;
                                                        v327 = reinterpret_cast<int4*>(v313 + v323);
                                                        assert("Pointer alignment check" && (unsigned long long)(v326) % 4 == 0 && (unsigned long long)(v327) % 4 == 0);
                                                        *v327 = *v326;
                                                        v319 += 1 ;
                                                    }
                                                    v317 += 1 ;
                                                }
                                                // Poping the loop unrolling to: 0
                                                wmma::fragment<wmma::matrix_a, 16, 16, 8, wmma::precision::tf32, wmma::row_major> v328[1];
                                                wmma::fragment<wmma::matrix_b, 16, 16, 8, wmma::precision::tf32, wmma::col_major> v329[8];
                                                cuda::pipeline_consumer_wait_prior<0>(v171);;
                                                __syncthreads();
                                                // Pushing the loop unrolling to: 0
                                                int v330;
                                                v330 = 0;
                                                #pragma unroll
                                                while (while_method_4(v330)){
                                                    int v332;
                                                    v332 = 0;
                                                    #pragma unroll
                                                    while (while_method_5(v332)){
                                                        assert("Tensor range check" && 0 <= v330 && v330 < 1);
                                                        assert("Tensor range check" && 0 <= v332 && v332 < 8);
                                                        int v334;
                                                        v334 = 8 * v330;
                                                        int v335;
                                                        v335 = v334 + v332;
                                                        wmma::fragment<wmma::matrix_b, 16, 16, 8, wmma::precision::tf32, wmma::col_major> & v336 = v329[v335];
                                                        assert("Tensor range check" && 0 <= v330 && v330 < 1);
                                                        int v337;
                                                        v337 = 1088 * v330;
                                                        assert("Tensor range check" && 0 <= v332 && v332 < 8);
                                                        int v338;
                                                        v338 = 8 * v332;
                                                        int v339;
                                                        v339 = v338 + v337;
                                                        int v340;
                                                        v340 = 0;
                                                        #pragma unroll
                                                        while (while_method_0(v340)){
                                                            int v342;
                                                            v342 = 0;
                                                            #pragma unroll
                                                            while (while_method_0(v342)){
                                                                assert("Tensor range check" && 0 <= v340 && v340 < 2);
                                                                assert("Tensor range check" && 0 <= v342 && v342 < 2);
                                                                int v344;
                                                                v344 = 4 * v342;
                                                                int v345;
                                                                v345 = v344 + v339;
                                                                int v346;
                                                                v346 = 544 * v340;
                                                                int v347;
                                                                v347 = v346 + v345;
                                                                float v348;
                                                                v348 = v224[v347];
                                                                bool v349;
                                                                v349 = 0 <= v342;
                                                                bool v351;
                                                                if (v349){
                                                                    bool v350;
                                                                    v350 = v342 < 2;
                                                                    v351 = v350;
                                                                } else {
                                                                    v351 = false;
                                                                }
                                                                bool v352;
                                                                v352 = v351 == false;
                                                                if (v352){
                                                                    assert("The indices should be inside the range of the dimension." && v351);
                                                                } else {
                                                                }
                                                                bool v354;
                                                                v354 = 0 <= v340;
                                                                bool v356;
                                                                if (v354){
                                                                    bool v355;
                                                                    v355 = v340 < 2;
                                                                    v356 = v355;
                                                                } else {
                                                                    v356 = false;
                                                                }
                                                                bool v357;
                                                                v357 = v356 == false;
                                                                if (v357){
                                                                    assert("The indices should be inside the range of the dimension." && v356);
                                                                } else {
                                                                }
                                                                int v359;
                                                                v359 = v340 * 2;
                                                                int v360;
                                                                v360 = v342 + v359;
                                                                v336.x[v360] = wmma::__float_to_tf32(v348);
                                                                v342 += 1 ;
                                                            }
                                                            v340 += 1 ;
                                                        }
                                                        v332 += 1 ;
                                                    }
                                                    v330 += 1 ;
                                                }
                                                // Poping the loop unrolling to: 0
                                                v171.consumer_release();
                                                switch (v260.tag) {
                                                    case 0: { // None
                                                        break;
                                                    }
                                                    case 1: { // Some
                                                        int v361 = v260.case1.v0;
                                                        assert("Tensor range check" && 0 <= v361 && v361 < 2);
                                                        int v362;
                                                        v362 = 64 * v361;
                                                        int v363;
                                                        v363 = v362 + v267;
                                                        float * v364;
                                                        v364 = v162+v363;
                                                        __syncthreads();
                                                        // Pushing the loop unrolling to: 0
                                                        v171.producer_acquire();
                                                        int v366;
                                                        v366 = threadIdx.x;
                                                        bool v367;
                                                        v367 = 0 <= v366;
                                                        bool v368;
                                                        v368 = v367 == false;
                                                        if (v368){
                                                            assert("The index needs to be zero or positive." && v367);
                                                        } else {
                                                        }
                                                        int v370;
                                                        v370 = v366 % 16;
                                                        int v371;
                                                        v371 = v366 / 16;
                                                        bool v372;
                                                        v372 = v371 < 16;
                                                        bool v373;
                                                        v373 = v372 == false;
                                                        if (v373){
                                                            assert("The last element of the projection dimensions needs to be greater than the index remainder." && v372);
                                                        } else {
                                                        }
                                                        assert("Tensor range check" && 0 <= v371 && v371 < 16);
                                                        assert("Tensor range check" && 0 <= v370 && v370 < 16);
                                                        int v375;
                                                        v375 = 4 * v370;
                                                        int v376;
                                                        v376 = 68 * v371;
                                                        int v377;
                                                        v377 = v376 + v375;
                                                        int v378;
                                                        v378 = 128 * v371;
                                                        int v379;
                                                        v379 = v378 + v375;
                                                        float * v380;
                                                        v380 = v175+v377;
                                                        float * v382;
                                                        v382 = v364+v379;
                                                        int v384;
                                                        v384 = 0;
                                                        #pragma unroll
                                                        while (while_method_5(v384)){
                                                            int v386;
                                                            v386 = 0;
                                                            #pragma unroll
                                                            while (while_method_4(v386)){
                                                                assert("Tensor range check" && 0 <= v384 && v384 < 8);
                                                                assert("Tensor range check" && 0 <= v386 && v386 < 1);
                                                                int v388;
                                                                v388 = 64 * v386;
                                                                int v389;
                                                                v389 = 1088 * v384;
                                                                int v390;
                                                                v390 = v389 + v388;
                                                                int v391;
                                                                v391 = 2048 * v384;
                                                                int v392;
                                                                v392 = v391 + v388;
                                                                constexpr int v393 = sizeof(float) * 4;
                                                                assert("Pointer alignment check" && (unsigned long long)(v382 + v392) % v393 == 0 && (unsigned long long)(v380 + v390) % v393 == 0);
                                                                cuda::memcpy_async(v380 + v390, v382 + v392, cuda::aligned_size_t<v393>(v393), v171);
                                                                v386 += 1 ;
                                                            }
                                                            v384 += 1 ;
                                                        }
                                                        v171.producer_commit();
                                                        // Poping the loop unrolling to: 0
                                                        break;
                                                    }
                                                    default: {
                                                        assert("Invalid tag." && false); __trap();
                                                    }
                                                }
                                                // Pushing the loop unrolling to: 0
                                                int v394;
                                                v394 = 0;
                                                #pragma unroll
                                                while (while_method_5(v394)){
                                                    int v396;
                                                    v396 = 0;
                                                    #pragma unroll
                                                    while (while_method_5(v396)){
                                                        wmma::fragment<wmma::matrix_a, 16, 16, 8, wmma::precision::tf32, wmma::row_major> & v398 = v328[0];
                                                        assert("Tensor range check" && 0 <= v394 && v394 < 8);
                                                        int v399;
                                                        v399 = 1088 * v394;
                                                        assert("Tensor range check" && 0 <= v396 && v396 < 8);
                                                        int v400;
                                                        v400 = 8 * v396;
                                                        int v401;
                                                        v401 = v400 + v399;
                                                        int v402;
                                                        v402 = 0;
                                                        #pragma unroll
                                                        while (while_method_0(v402)){
                                                            int v404;
                                                            v404 = 0;
                                                            #pragma unroll
                                                            while (while_method_0(v404)){
                                                                assert("Tensor range check" && 0 <= v402 && v402 < 2);
                                                                assert("Tensor range check" && 0 <= v404 && v404 < 2);
                                                                int v406;
                                                                v406 = 544 * v404;
                                                                int v407;
                                                                v407 = v406 + v401;
                                                                int v408;
                                                                v408 = 4 * v402;
                                                                int v409;
                                                                v409 = v408 + v407;
                                                                float v410;
                                                                v410 = v208[v409];
                                                                bool v411;
                                                                v411 = 0 <= v404;
                                                                bool v413;
                                                                if (v411){
                                                                    bool v412;
                                                                    v412 = v404 < 2;
                                                                    v413 = v412;
                                                                } else {
                                                                    v413 = false;
                                                                }
                                                                bool v414;
                                                                v414 = v413 == false;
                                                                if (v414){
                                                                    assert("The indices should be inside the range of the dimension." && v413);
                                                                } else {
                                                                }
                                                                bool v416;
                                                                v416 = 0 <= v402;
                                                                bool v418;
                                                                if (v416){
                                                                    bool v417;
                                                                    v417 = v402 < 2;
                                                                    v418 = v417;
                                                                } else {
                                                                    v418 = false;
                                                                }
                                                                bool v419;
                                                                v419 = v418 == false;
                                                                if (v419){
                                                                    assert("The indices should be inside the range of the dimension." && v418);
                                                                } else {
                                                                }
                                                                int v421;
                                                                v421 = v402 * 2;
                                                                int v422;
                                                                v422 = v404 + v421;
                                                                v398.x[v422] = wmma::__float_to_tf32(v410);
                                                                v404 += 1 ;
                                                            }
                                                            v402 += 1 ;
                                                        }
                                                        int v423;
                                                        v423 = 0;
                                                        #pragma unroll
                                                        while (while_method_4(v423)){
                                                            assert("Tensor range check" && 0 <= v394 && v394 < 8);
                                                            assert("Tensor range check" && 0 <= v423 && v423 < 1);
                                                            int v425;
                                                            v425 = v394 + v423;
                                                            wmma::fragment<wmma::accumulator, 16, 16, 8, float> & v426 = v226[v425];
                                                            assert("Tensor range check" && 0 <= v423 && v423 < 1);
                                                            assert("Tensor range check" && 0 <= v396 && v396 < 8);
                                                            int v427;
                                                            v427 = 8 * v423;
                                                            int v428;
                                                            v428 = v427 + v396;
                                                            wmma::fragment<wmma::matrix_b, 16, 16, 8, wmma::precision::tf32, wmma::col_major> & v429 = v329[v428];
                                                            wmma::mma_sync(v426, v398, v429, v426);
                                                            v423 += 1 ;
                                                        }
                                                        v396 += 1 ;
                                                    }
                                                    v394 += 1 ;
                                                }
                                                // Poping the loop unrolling to: 0
                                                __syncthreads();
                                                v243 = v245;
                                            }
                                            // Pushing the loop unrolling to: 0
                                            int v430;
                                            v430 = 0;
                                            #pragma unroll
                                            while (while_method_5(v430)){
                                                int v432;
                                                v432 = 0;
                                                #pragma unroll
                                                while (while_method_4(v432)){
                                                    assert("Tensor range check" && 0 <= v430 && v430 < 8);
                                                    assert("Tensor range check" && 0 <= v432 && v432 < 1);
                                                    int v434;
                                                    v434 = v430 + v432;
                                                    wmma::fragment<wmma::accumulator, 16, 16, 8, float> & v435 = v226[v434];
                                                    assert("Tensor range check" && 0 <= v430 && v430 < 8);
                                                    assert("Tensor range check" && 0 <= v432 && v432 < 1);
                                                    int v436;
                                                    v436 = 16 * v432;
                                                    int v437;
                                                    v437 = 2176 * v430;
                                                    int v438;
                                                    v438 = v437 + v436;
                                                    float * v439;
                                                    v439 = v192+v438;
                                                    wmma::store_matrix_sync(v439, v435, 136, wmma::mem_row_major);
                                                    v432 += 1 ;
                                                }
                                                v430 += 1 ;
                                            }
                                            // Poping the loop unrolling to: 0
                                            __syncthreads();
                                            // Pushing the loop unrolling to: 0
                                            int v441;
                                            v441 = threadIdx.x;
                                            bool v442;
                                            v442 = 0 <= v441;
                                            bool v443;
                                            v443 = v442 == false;
                                            if (v443){
                                                assert("The index needs to be zero or positive." && v442);
                                            } else {
                                            }
                                            int v445;
                                            v445 = v441 % 32;
                                            int v446;
                                            v446 = v441 / 32;
                                            bool v447;
                                            v447 = v446 < 8;
                                            bool v448;
                                            v448 = v447 == false;
                                            if (v448){
                                                assert("The last element of the projection dimensions needs to be greater than the index remainder." && v447);
                                            } else {
                                            }
                                            assert("Tensor range check" && 0 <= v446 && v446 < 8);
                                            assert("Tensor range check" && 0 <= v445 && v445 < 32);
                                            int v450;
                                            v450 = 4 * v445;
                                            int v451;
                                            v451 = 128 * v446;
                                            int v452;
                                            v452 = v451 + v450;
                                            int v453;
                                            v453 = 136 * v446;
                                            int v454;
                                            v454 = v453 + v450;
                                            float * v455;
                                            v455 = v235+v452;
                                            float * v457;
                                            v457 = v177+v454;
                                            int v459;
                                            v459 = 0;
                                            #pragma unroll
                                            while (while_method_7(v459)){
                                                int v461;
                                                v461 = 0;
                                                #pragma unroll
                                                while (while_method_4(v461)){
                                                    assert("Tensor range check" && 0 <= v459 && v459 < 16);
                                                    assert("Tensor range check" && 0 <= v461 && v461 < 1);
                                                    int v463;
                                                    v463 = 128 * v461;
                                                    int v464;
                                                    v464 = 1024 * v459;
                                                    int v465;
                                                    v465 = v464 + v463;
                                                    int v466;
                                                    v466 = 1088 * v459;
                                                    int v467;
                                                    v467 = v466 + v463;
                                                    int4* v468;
                                                    v468 = reinterpret_cast<int4*>(v457 + v467);
                                                    int4* v469;
                                                    v469 = reinterpret_cast<int4*>(v455 + v465);
                                                    assert("Pointer alignment check" && (unsigned long long)(v468) % 4 == 0 && (unsigned long long)(v469) % 4 == 0);
                                                    *v469 = *v468;
                                                    v461 += 1 ;
                                                }
                                                v459 += 1 ;
                                            }
                                            // Poping the loop unrolling to: 0
                                            __syncthreads();
                                            v229 += 1 ;
                                        }
                                        v227 += 1 ;
                                    }
                                    unsigned int * v470;
                                    v470 = reinterpret_cast<unsigned int *>(&v0[6291456ull]);
                                    assert("Tensor range check" && 0 <= v158 && v158 < 4);
                                    int v472;
                                    v472 = 6144 * v158;
                                    method_23(v470, v472, v165);
                                    int * v473;
                                    v473 = reinterpret_cast<int *>(&v1[262144ull]);
                                    float * v475;
                                    v475 = reinterpret_cast<float *>(&v1[262160ull]);
                                    float * v477;
                                    v477 = reinterpret_cast<float *>(&v1[524304ull]);
                                    float * v479;
                                    v479 = reinterpret_cast<float *>(&v1[786448ull]);
                                    float * v481;
                                    v481 = reinterpret_cast<float *>(&v1[1048592ull]);
                                    float * v483;
                                    v483 = reinterpret_cast<float *>(&v1[1310736ull]);
                                    float * v485;
                                    v485 = reinterpret_cast<float *>(&v1[1572880ull]);
                                    float * v487;
                                    v487 = reinterpret_cast<float *>(&v1[1835024ull]);
                                    int * v489;
                                    v489 = reinterpret_cast<int *>(&v0[6389760ull]);
                                    float * v491;
                                    v491 = reinterpret_cast<float *>(&v0[7962624ull]);
                                    int * v493;
                                    v493 = reinterpret_cast<int *>(&v0[9535488ull]);
                                    int * v495;
                                    v495 = reinterpret_cast<int *>(&v0[11108352ull]);
                                    double * v497;
                                    v497 = reinterpret_cast<double *>(&v0[12681216ull]);
                                    double * v499;
                                    v499 = reinterpret_cast<double *>(&v0[18972672ull]);
                                    double * v501;
                                    v501 = reinterpret_cast<double *>(&v1[2097168ull]);
                                    double * v503;
                                    v503 = reinterpret_cast<double *>(&v1[2490384ull]);
                                    int * v505;
                                    v505 = reinterpret_cast<int *>(&v1[2883600ull]);
                                    v158 += 1 ;
                                }
                                __syncthreads();
                                int * v507;
                                v507 = reinterpret_cast<int *>(&v1[262144ull]);
                                float * v509;
                                v509 = reinterpret_cast<float *>(&v1[262160ull]);
                                float * v511;
                                v511 = reinterpret_cast<float *>(&v1[524304ull]);
                                float * v513;
                                v513 = reinterpret_cast<float *>(&v1[786448ull]);
                                float * v515;
                                v515 = reinterpret_cast<float *>(&v1[1048592ull]);
                                float * v517;
                                v517 = reinterpret_cast<float *>(&v1[1310736ull]);
                                float * v519;
                                v519 = reinterpret_cast<float *>(&v1[1572880ull]);
                                float * v521;
                                v521 = reinterpret_cast<float *>(&v1[1835024ull]);
                                int v523;
                                v523 = v507[0];
                                unsigned int * v524;
                                v524 = reinterpret_cast<unsigned int *>(&v0[6291456ull]);
                                int v526;
                                v526 = blockIdx.x;
                                int v527;
                                v527 = threadIdx.x;
                                assert("Tensor range check" && 0 <= v523 && v523 < 4);
                                assert("Tensor range check" && 0 <= v526 && v526 < 24);
                                assert("Tensor range check" && 0 <= v527 && v527 < 256);
                                int v528;
                                v528 = 256 * v526;
                                int v529;
                                v529 = v528 + v527;
                                int v530;
                                v530 = 6144 * v523;
                                int v531;
                                v531 = v530 + v529;
                                unsigned int v532;
                                v532 = v524[v531];
                                int v533;
                                v533 = (int)v532;
                                float v534; int v535;
                                Tuple8 tmp41 = method_24(v88, v507, v509, v511, v513, v515, v517, v519, v521, v533, v523);
                                v534 = tmp41.v0; v535 = tmp41.v1;
                                extern __shared__ unsigned char v536[];
                                float * v537;
                                v537 = reinterpret_cast<float *>(&v536[0ull]);
                                int * v539;
                                v539 = reinterpret_cast<int *>(&v536[16ull]);
                                int v541;
                                v541 = threadIdx.x;
                                bool v542;
                                v542 = v541 == 0;
                                if (v542){
                                    v537[0] = v534;
                                    v539[0] = v535;
                                } else {
                                }
                                __syncthreads();
                                float v543;
                                v543 = v537[0];
                                int v544;
                                v544 = v539[0];
                                __syncthreads();
                                double * v545;
                                v545 = reinterpret_cast<double *>(&v1[2097168ull]);
                                double * v547;
                                v547 = reinterpret_cast<double *>(&v1[2490384ull]);
                                int * v549;
                                v549 = reinterpret_cast<int *>(&v1[2883600ull]);
                                int * v551;
                                v551 = reinterpret_cast<int *>(&v0[6389760ull]);
                                float * v553;
                                v553 = reinterpret_cast<float *>(&v0[7962624ull]);
                                int * v555;
                                v555 = reinterpret_cast<int *>(&v0[9535488ull]);
                                int * v557;
                                v557 = reinterpret_cast<int *>(&v0[11108352ull]);
                                double * v559;
                                v559 = reinterpret_cast<double *>(&v0[12681216ull]);
                                double * v561;
                                v561 = reinterpret_cast<double *>(&v0[18972672ull]);
                                int v563;
                                v563 = threadIdx.x;
                                int v564;
                                v564 = blockIdx.x;
                                int v565;
                                v565 = v564 * 256;
                                int v566;
                                v566 = v563 + v565;
                                int v567;
                                v567 = 0;
                                while (while_method_9(v567)){
                                    unsigned int * v569;
                                    v569 = reinterpret_cast<unsigned int *>(&v0[6291456ull]);
                                    int v571;
                                    v571 = blockIdx.x;
                                    int v572;
                                    v572 = threadIdx.x;
                                    assert("Tensor range check" && 0 <= v567 && v567 < 4);
                                    assert("Tensor range check" && 0 <= v571 && v571 < 24);
                                    assert("Tensor range check" && 0 <= v572 && v572 < 256);
                                    int v573;
                                    v573 = 256 * v571;
                                    int v574;
                                    v574 = v573 + v572;
                                    int v575;
                                    v575 = 6144 * v567;
                                    int v576;
                                    v576 = v575 + v574;
                                    unsigned int v577;
                                    v577 = v569[v576];
                                    int v578;
                                    v578 = (int)v577;
                                    float v579;
                                    v579 = method_47(v507, v509, v511, v513, v515, v517, v519, v521, v578, v567, v544);
                                    assert("Tensor range check" && 0 <= v567 && v567 < 4);
                                    assert("Tensor range check" && 0 <= v566 && v566 < 6144);
                                    int v580;
                                    v580 = v575 + v566;
                                    int v581;
                                    v581 = v549[v580];
                                    int v582;
                                    v582 = v581 + 1;
                                    assert("Tensor range check" && 0 <= v567 && v567 < 4);
                                    assert("Tensor range check" && 0 <= v566 && v566 < 6144);
                                    v549[v580] = v582;
                                    assert("Tensor range check" && 0 <= v567 && v567 < 4);
                                    assert("Tensor range check" && 0 <= v581 && v581 < 16);
                                    assert("Tensor range check" && 0 <= v566 && v566 < 6144);
                                    int v583;
                                    v583 = 6144 * v581;
                                    int v584;
                                    v584 = v583 + v566;
                                    int v585;
                                    v585 = 98304 * v567;
                                    int v586;
                                    v586 = v585 + v584;
                                    v551[v586] = v544;
                                    v553[v586] = v543;
                                    v555[v586] = v74;
                                    v557[v586] = v578;
                                    assert("Tensor range check" && 0 <= v567 && v567 < 4);
                                    int v587;
                                    v587 = 12288 * v567;
                                    assert("Tensor range check" && 0 <= v566 && v566 < 6144);
                                    int v588;
                                    v588 = 2 * v566;
                                    int v589;
                                    v589 = v588 + v587;
                                    assert("Tensor range check" && 0 <= v567 && v567 < 4);
                                    int v590;
                                    v590 = 196608 * v567;
                                    assert("Tensor range check" && 0 <= v581 && v581 < 16);
                                    int v591;
                                    v591 = 12288 * v581;
                                    int v592;
                                    v592 = v591 + v590;
                                    assert("Tensor range check" && 0 <= v566 && v566 < 6144);
                                    int v593;
                                    v593 = v588 + v592;
                                    double * v594;
                                    v594 = v545+v589;
                                    double * v596;
                                    v596 = v547+v589;
                                    double * v598;
                                    v598 = v559+v593;
                                    double * v600;
                                    v600 = v561+v593;
                                    int v602;
                                    v602 = sizeof(double *);
                                    unsigned long long v603;
                                    v603 = (unsigned long long)v602;
                                    unsigned long long v604;
                                    v604 = 256ull * v603;
                                    unsigned long long v605;
                                    v605 = v604 + 16ull;
                                    unsigned long long v606;
                                    v606 = v605 - 1ull;
                                    unsigned long long v607;
                                    v607 = v606 % 16ull;
                                    unsigned long long v608;
                                    v608 = v606 - v607;
                                    unsigned long long v609;
                                    v609 = v608 + v604;
                                    unsigned long long v610;
                                    v610 = v609 + 16ull;
                                    unsigned long long v611;
                                    v611 = v610 - 1ull;
                                    unsigned long long v612;
                                    v612 = v611 % 16ull;
                                    unsigned long long v613;
                                    v613 = v611 - v612;
                                    unsigned long long v614;
                                    v614 = v613 + v604;
                                    unsigned long long v615;
                                    v615 = v614 + 16ull;
                                    unsigned long long v616;
                                    v616 = v615 - 1ull;
                                    unsigned long long v617;
                                    v617 = v616 % 16ull;
                                    unsigned long long v618;
                                    v618 = v616 - v617;
                                    unsigned long long v619;
                                    v619 = v618 + v604;
                                    bool v620;
                                    v620 = v619 <= 98304ull;
                                    bool v621;
                                    v621 = v620 == false;
                                    if (v621){
                                        assert("The dynamic shared memory is insufficient to allocate the tensor." && v620);
                                    } else {
                                    }
                                    extern __shared__ unsigned char v623[];
                                    bool v624;
                                    v624 = v619 <= v619;
                                    bool v625;
                                    v625 = v624 == false;
                                    if (v625){
                                        assert("The length of the partition has to be less than or equal to the length of the base array." && v624);
                                    } else {
                                    }
                                    double * * v627;
                                    v627 = reinterpret_cast<double * *>(&v623[0ull]);
                                    double * * v629;
                                    v629 = reinterpret_cast<double * *>(&v623[v608]);
                                    double * * v631;
                                    v631 = reinterpret_cast<double * *>(&v623[v613]);
                                    double * * v633;
                                    v633 = reinterpret_cast<double * *>(&v623[v618]);
                                    int v635;
                                    v635 = threadIdx.x;
                                    assert("Tensor range check" && 0 <= v635 && v635 < 256);
                                    v627[v635] = v594;
                                    v629[v635] = v596;
                                    v631[v635] = v598;
                                    v633[v635] = v600;
                                    __syncthreads();
                                    bool v636;
                                    v636 = 0 <= v635;
                                    bool v637;
                                    v637 = v636 == false;
                                    if (v637){
                                        assert("The index needs to be zero or positive." && v636);
                                    } else {
                                    }
                                    int v639;
                                    v639 = v635 % 1;
                                    bool v640;
                                    v640 = v635 < 256;
                                    bool v641;
                                    v641 = v640 == false;
                                    if (v641){
                                        assert("The last element of the projection dimensions needs to be greater than the index remainder." && v640);
                                    } else {
                                    }
                                    assert("Tensor range check" && 0 <= v635 && v635 < 256);
                                    int v643;
                                    v643 = 0;
                                    while (while_method_4(v643)){
                                        bool v645;
                                        v645 = v636 && v640;
                                        bool v646;
                                        v646 = v645 == false;
                                        if (v646){
                                            assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v645);
                                        } else {
                                        }
                                        bool v648;
                                        v648 = 0 <= v643;
                                        bool v650;
                                        if (v648){
                                            bool v649;
                                            v649 = v643 < 1;
                                            v650 = v649;
                                        } else {
                                            v650 = false;
                                        }
                                        bool v651;
                                        v651 = v650 == false;
                                        if (v651){
                                            assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v650);
                                        } else {
                                        }
                                        int v653;
                                        v653 = v643 * 256;
                                        int v654;
                                        v654 = v653 + v635;
                                        assert("Tensor range check" && 0 <= v643 && v643 < 1);
                                        int v655;
                                        v655 = 256 * v643;
                                        int v656;
                                        v656 = v655 + v635;
                                        double * v657;
                                        v657 = v627[v656];
                                        double * v658;
                                        v658 = v629[v656];
                                        double * v659;
                                        v659 = v631[v656];
                                        double * v660;
                                        v660 = v633[v656];
                                        int v661;
                                        v661 = blockIdx.x;
                                        int v662;
                                        v662 = v661 * 256;
                                        int v663;
                                        v663 = v662 + v654;
                                        assert("Tensor range check" && 0 <= v639 && v639 < 1);
                                        int v664;
                                        v664 = 2 * v639;
                                        double v665[2];
                                        double v666[2];
                                        int v667[2];
                                        int v668;
                                        v668 = 0;
                                        while (while_method_4(v668)){
                                            assert("Tensor range check" && 0 <= v668 && v668 < 1);
                                            int v670;
                                            v670 = 2 * v668;
                                            assert("Tensor range check" && 0 <= v668 && v668 < 1);
                                            int v671;
                                            v671 = v670 + v664;
                                            int4* v672;
                                            v672 = reinterpret_cast<int4*>(v657 + v671);
                                            int4* v673;
                                            v673 = reinterpret_cast<int4*>(v665 + v670);
                                            assert("Pointer alignment check" && (unsigned long long)(v672) % 2 == 0 && (unsigned long long)(v673) % 2 == 0);
                                            *v673 = *v672;
                                            int4* v674;
                                            v674 = reinterpret_cast<int4*>(v658 + v671);
                                            int4* v675;
                                            v675 = reinterpret_cast<int4*>(v666 + v670);
                                            assert("Pointer alignment check" && (unsigned long long)(v674) % 2 == 0 && (unsigned long long)(v675) % 2 == 0);
                                            *v675 = *v674;
                                            v668 += 1 ;
                                        }
                                        int v676;
                                        v676 = 0;
                                        while (while_method_4(v676)){
                                            int v678;
                                            v678 = 0;
                                            while (while_method_0(v678)){
                                                bool v680;
                                                v680 = 0 <= v678;
                                                bool v682;
                                                if (v680){
                                                    bool v681;
                                                    v681 = v678 < 2;
                                                    v682 = v681;
                                                } else {
                                                    v682 = false;
                                                }
                                                bool v683;
                                                v683 = v682 == false;
                                                if (v683){
                                                    assert("The indices should be inside the range of the dimension." && v682);
                                                } else {
                                                }
                                                bool v685;
                                                v685 = 0 <= v639;
                                                bool v687;
                                                if (v685){
                                                    bool v686;
                                                    v686 = v639 < 1;
                                                    v687 = v686;
                                                } else {
                                                    v687 = false;
                                                }
                                                bool v688;
                                                v688 = v687 == false;
                                                if (v688){
                                                    assert("The indices should be inside the range of the dimension." && v687);
                                                } else {
                                                }
                                                int v690;
                                                v690 = v639 * 2;
                                                int v691;
                                                v691 = v678 + v690;
                                                bool v692;
                                                v692 = 0 <= v676;
                                                bool v694;
                                                if (v692){
                                                    bool v693;
                                                    v693 = v676 < 1;
                                                    v694 = v693;
                                                } else {
                                                    v694 = false;
                                                }
                                                bool v695;
                                                v695 = v694 == false;
                                                if (v695){
                                                    assert("The indices should be inside the range of the dimension." && v694);
                                                } else {
                                                }
                                                int v697;
                                                v697 = v676 * 2;
                                                int v698;
                                                v698 = v691 + v697;
                                                assert("Tensor range check" && 0 <= v676 && v676 < 1);
                                                assert("Tensor range check" && 0 <= v678 && v678 < 2);
                                                int v699;
                                                v699 = 2 * v676;
                                                int v700;
                                                v700 = v699 + v678;
                                                v667[v700] = v698;
                                                v678 += 1 ;
                                            }
                                            v676 += 1 ;
                                        }
                                        int v701;
                                        v701 = 0;
                                        while (while_method_4(v701)){
                                            assert("Tensor range check" && 0 <= v701 && v701 < 1);
                                            int v703;
                                            v703 = 2 * v701;
                                            int v704;
                                            v704 = v703 + v664;
                                            assert("Tensor range check" && 0 <= v701 && v701 < 1);
                                            int4* v705;
                                            v705 = reinterpret_cast<int4*>(v665 + v703);
                                            int4* v706;
                                            v706 = reinterpret_cast<int4*>(v659 + v704);
                                            assert("Pointer alignment check" && (unsigned long long)(v705) % 2 == 0 && (unsigned long long)(v706) % 2 == 0);
                                            *v706 = *v705;
                                            int4* v707;
                                            v707 = reinterpret_cast<int4*>(v666 + v703);
                                            int4* v708;
                                            v708 = reinterpret_cast<int4*>(v660 + v704);
                                            assert("Pointer alignment check" && (unsigned long long)(v707) % 2 == 0 && (unsigned long long)(v708) % 2 == 0);
                                            *v708 = *v707;
                                            v701 += 1 ;
                                        }
                                        assert("Tensor range check" && 0 <= v654 && v654 < 256);
                                        v643 += 1 ;
                                    }
                                    __syncthreads();
                                    assert("Tensor range check" && 0 <= v635 && v635 < 256);
                                    __syncthreads();
                                    double v709;
                                    v709 = (double)v543;
                                    double v710;
                                    v710 = log(v709);
                                    double v711;
                                    v711 = (double)v579;
                                    double v712;
                                    v712 = log(v711);
                                    assert("Tensor range check" && 0 <= v567 && v567 < 4);
                                    assert("Tensor range check" && 0 <= v566 && v566 < 6144);
                                    assert("Tensor range check" && 0 <= v74 && v74 < 2);
                                    int v713;
                                    v713 = v588 + v74;
                                    int v714;
                                    v714 = v587 + v713;
                                    double v715;
                                    v715 = v545[v714];
                                    double v716;
                                    v716 = v547[v714];
                                    double v717;
                                    v717 = v712 + v715;
                                    double v718;
                                    v718 = v710 + v716;
                                    assert("Tensor range check" && 0 <= v567 && v567 < 4);
                                    assert("Tensor range check" && 0 <= v566 && v566 < 6144);
                                    assert("Tensor range check" && 0 <= v74 && v74 < 2);
                                    v545[v714] = v717;
                                    v547[v714] = v718;
                                    v567 += 1 ;
                                }
                                bool v719;
                                v719 = 0 == v544;
                                Union12 v728;
                                if (v719){
                                    v728 = Union12{Union12_1{}};
                                } else {
                                    bool v721;
                                    v721 = 1 == v544;
                                    if (v721){
                                        v728 = Union12{Union12_0{}};
                                    } else {
                                        bool v723;
                                        v723 = 2 == v544;
                                        if (v723){
                                            v728 = Union12{Union12_2{}};
                                        } else {
                                            printf("%s\n", "Invalid output id in the Leduc model.");
                                            __trap();
                                        }
                                    }
                                }
                                switch (v728.tag) {
                                    case 0: { // AA_Call
                                        v803 = Union1{Union1_0{}};
                                        break;
                                    }
                                    case 1: { // AA_Fold
                                        int v729;
                                        v729 = v75[0];
                                        int v731; int v732;
                                        Tuple7 tmp44 = Tuple7{1, v729};
                                        v731 = tmp44.v0; v732 = tmp44.v1;
                                        while (while_method_0(v731)){
                                            bool v734;
                                            v734 = 0 <= v731;
                                            bool v736;
                                            if (v734){
                                                bool v735;
                                                v735 = v731 < 2;
                                                v736 = v735;
                                            } else {
                                                v736 = false;
                                            }
                                            bool v737;
                                            v737 = v736 == false;
                                            if (v737){
                                                assert("Index must be in range." && v736);
                                            } else {
                                            }
                                            int v739;
                                            v739 = v75[v731];
                                            bool v741;
                                            v741 = v732 >= v739;
                                            int v742;
                                            if (v741){
                                                v742 = v732;
                                            } else {
                                                v742 = v739;
                                            }
                                            v732 = v742;
                                            v731 += 1 ;
                                        }
                                        bool v744;
                                        if (v78){
                                            bool v743;
                                            v743 = v74 < 2;
                                            v744 = v743;
                                        } else {
                                            v744 = false;
                                        }
                                        bool v745;
                                        v745 = v744 == false;
                                        if (v745){
                                            assert("Index must be in range." && v744);
                                        } else {
                                        }
                                        int v747;
                                        v747 = v75[v74];
                                        bool v749;
                                        v749 = v747 == v732;
                                        if (v749){
                                            v803 = Union1{Union1_0{}};
                                        } else {
                                            v803 = Union1{Union1_1{}};
                                        }
                                        break;
                                    }
                                    case 2: { // AA_Raise
                                        bool v754;
                                        v754 = v76 > 0;
                                        if (v754){
                                            v803 = Union1{Union1_2{}};
                                        } else {
                                            v803 = Union1{Union1_0{}};
                                        }
                                        break;
                                    }
                                    default: {
                                        assert("Invalid tag." && false); __trap();
                                    }
                                }
                                break;
                            }
                            case 1: { // Human
                                printf("%s\n", "Humans aren't allowed during training.");
                                __trap();
                                break;
                            }
                            case 2: { // Random
                                curandStatePhilox4_32_10_t & v761 = v2.v5;
                                curandStatePhilox4_32_10_t & v762 = v761;
                                static_array_list<Union1,3> v763;
                                v763 = static_array_list<Union1,3>{};
                                v763.unsafe_set_length(1);
                                Union1 v765;
                                v765 = Union1{Union1_0{}};
                                v763[0] = v765;
                                int v767;
                                v767 = v75[0];
                                int v769;
                                v769 = v75[1];
                                bool v771;
                                v771 = v767 == v769;
                                bool v772;
                                v772 = v771 != true;
                                if (v772){
                                    Union1 v773;
                                    v773 = Union1{Union1_1{}};
                                    v763.push(v773);
                                } else {
                                }
                                bool v774;
                                v774 = v76 > 0;
                                if (v774){
                                    Union1 v775;
                                    v775 = Union1{Union1_2{}};
                                    v763.push(v775);
                                } else {
                                }
                                int v776;
                                v776 = v763.length;
                                int v777;
                                v777 = v776 - 1;
                                int v778;
                                v778 = 0;
                                while (while_method_1(v777, v778)){
                                    int v780;
                                    v780 = v763.length;
                                    int v781;
                                    v781 = int_range_22(v780, v778, v762);
                                    Union1 v782;
                                    v782 = v763[v778];
                                    Union1 v784;
                                    v784 = v763[v781];
                                    v763[v778] = v784;
                                    v763[v781] = v782;
                                    v778 += 1 ;
                                }
                                Union1 v786;
                                v786 = v763.pop();
                                int v787;
                                v787 = sizeof(Union1);
                                unsigned long long v788;
                                v788 = (unsigned long long)v787;
                                bool v789;
                                v789 = v788 <= 98304ull;
                                bool v790;
                                v790 = v789 == false;
                                if (v790){
                                    assert("The dynamic shared memory is insufficient to allocate the tensor." && v789);
                                } else {
                                }
                                extern __shared__ unsigned char v792[];
                                bool v793;
                                v793 = v788 <= v788;
                                bool v794;
                                v794 = v793 == false;
                                if (v794){
                                    assert("The length of the partition has to be less than or equal to the length of the base array." && v793);
                                } else {
                                }
                                Union1 * v796;
                                v796 = reinterpret_cast<Union1 *>(&v792[0ull]);
                                int v798;
                                v798 = threadIdx.x;
                                bool v799;
                                v799 = v798 == 0;
                                if (v799){
                                    v796[0] = v786;
                                } else {
                                }
                                __syncthreads();
                                Union1 v800;
                                v800 = v796[0];
                                __syncthreads();
                                v803 = v800;
                                break;
                            }
                            default: {
                                assert("Invalid tag." && false); __trap();
                            }
                        }
                        Union7 v804;
                        v804 = Union7{Union7_1{v74, v803}};
                        v17.push(v804);
                        v846 = Union14{Union14_2{v71, v72, v73, v74, v75, v76, v803}};
                        break;
                    }
                    case 3: { // RoundWithAction
                        Union5 v806 = v21.case3.v0; bool v807 = v21.case3.v1; static_array<Union6,2> v808 = v21.case3.v2; int v809 = v21.case3.v3; static_array<int,2> v810 = v21.case3.v4; int v811 = v21.case3.v5; Union1 v812 = v21.case3.v6;
                        Union7 v813;
                        v813 = Union7{Union7_1{v809, v812}};
                        v17.push(v813);
                        v846 = Union14{Union14_2{v806, v807, v808, v809, v810, v811, v812}};
                        break;
                    }
                    case 4: { // TerminalCall
                        Union5 v42 = v21.case4.v0; bool v43 = v21.case4.v1; static_array<Union6,2> v44 = v21.case4.v2; int v45 = v21.case4.v3; static_array<int,2> v46 = v21.case4.v4; int v47 = v21.case4.v5;
                        bool v48;
                        v48 = 0 <= v45;
                        bool v50;
                        if (v48){
                            bool v49;
                            v49 = v45 < 2;
                            v50 = v49;
                        } else {
                            v50 = false;
                        }
                        bool v51;
                        v51 = v50 == false;
                        if (v51){
                            assert("Index must be in range." && v50);
                        } else {
                        }
                        int v53;
                        v53 = v46[v45];
                        Union13 v55;
                        v55 = compare_hands_25(v42, v43, v44, v45, v46, v47);
                        int v60; int v61;
                        switch (v55.tag) {
                            case 0: { // Eq
                                v60 = 0; v61 = -1;
                                break;
                            }
                            case 1: { // Gt
                                v60 = v53; v61 = 0;
                                break;
                            }
                            case 2: { // Lt
                                v60 = v53; v61 = 1;
                                break;
                            }
                            default: {
                                assert("Invalid tag." && false); __trap();
                            }
                        }
                        int v62;
                        v62 = -v61;
                        bool v63;
                        v63 = v61 >= v62;
                        int v64;
                        if (v63){
                            v64 = v61;
                        } else {
                            v64 = v62;
                        }
                        float v65;
                        v65 = (float)v60;
                        static_array<float,2> & v66 = v2.v4;
                        v66[v64] = v65;
                        int v67;
                        v67 = v64 ^ 1;
                        float v68;
                        v68 = -v65;
                        v66[v67] = v68;
                        Union7 v69;
                        v69 = Union7{Union7_3{v44, v60, v61}};
                        v17.push(v69);
                        v846 = Union14{Union14_3{}};
                        break;
                    }
                    case 5: { // TerminalFold
                        Union5 v22 = v21.case5.v0; bool v23 = v21.case5.v1; static_array<Union6,2> v24 = v21.case5.v2; int v25 = v21.case5.v3; static_array<int,2> v26 = v21.case5.v4; int v27 = v21.case5.v5;
                        bool v28;
                        v28 = 0 <= v25;
                        bool v30;
                        if (v28){
                            bool v29;
                            v29 = v25 < 2;
                            v30 = v29;
                        } else {
                            v30 = false;
                        }
                        bool v31;
                        v31 = v30 == false;
                        if (v31){
                            assert("Index must be in range." && v30);
                        } else {
                        }
                        int v33;
                        v33 = v26[v25];
                        int v35;
                        v35 = -v33;
                        float v36;
                        v36 = (float)v35;
                        static_array<float,2> & v37 = v2.v4;
                        v37[v25] = v36;
                        int v38;
                        v38 = v25 ^ 1;
                        float v39;
                        v39 = -v36;
                        v37[v38] = v39;
                        Union7 v40;
                        v40 = Union7{Union7_3{v24, v33, v38}};
                        v17.push(v40);
                        v846 = Union14{Union14_3{}};
                        break;
                    }
                    default: {
                        assert("Invalid tag." && false); __trap();
                    }
                }
                switch (v846.tag) {
                    case 0: { // T_game_chance_community_card
                        Union5 v848 = v846.case0.v0; bool v849 = v846.case0.v1; static_array<Union6,2> v850 = v846.case0.v2; int v851 = v846.case0.v3; static_array<int,2> v852 = v846.case0.v4; int v853 = v846.case0.v5; Union6 v854 = v846.case0.v6;
                        int v855;
                        v855 = 2;
                        int v856; int v857;
                        Tuple7 tmp45 = Tuple7{0, 0};
                        v856 = tmp45.v0; v857 = tmp45.v1;
                        while (while_method_0(v856)){
                            bool v859;
                            v859 = 0 <= v856;
                            bool v861;
                            if (v859){
                                bool v860;
                                v860 = v856 < 2;
                                v861 = v860;
                            } else {
                                v861 = false;
                            }
                            bool v862;
                            v862 = v861 == false;
                            if (v862){
                                assert("Index must be in range." && v861);
                            } else {
                            }
                            int v864;
                            v864 = v852[v856];
                            bool v866;
                            v866 = v857 >= v864;
                            int v867;
                            if (v866){
                                v867 = v857;
                            } else {
                                v867 = v864;
                            }
                            v857 = v867;
                            v856 += 1 ;
                        }
                        static_array<int,2> v868;
                        int v870;
                        v870 = 0;
                        while (while_method_0(v870)){
                            v868[v870] = v857;
                            v870 += 1 ;
                        }
                        Union5 v872;
                        v872 = Union5{Union5_1{v854}};
                        Union4 v873;
                        v873 = Union4{Union4_2{v872, true, v850, 0, v868, v855}};
                        v1006 = Union3{Union3_1{v873}};
                        break;
                    }
                    case 1: { // T_game_chance_init
                        Union6 v875 = v846.case1.v0; Union6 v876 = v846.case1.v1;
                        int v877;
                        v877 = 2;
                        static_array<int,2> v878;
                        v878[0] = 1;
                        v878[1] = 1;
                        static_array<Union6,2> v880;
                        v880[0] = v875;
                        v880[1] = v876;
                        Union5 v882;
                        v882 = Union5{Union5_0{}};
                        Union4 v883;
                        v883 = Union4{Union4_2{v882, true, v880, 0, v878, v877}};
                        v1006 = Union3{Union3_1{v883}};
                        break;
                    }
                    case 2: { // T_game_round
                        Union5 v885 = v846.case2.v0; bool v886 = v846.case2.v1; static_array<Union6,2> v887 = v846.case2.v2; int v888 = v846.case2.v3; static_array<int,2> v889 = v846.case2.v4; int v890 = v846.case2.v5; Union1 v891 = v846.case2.v6;
                        Union4 v998;
                        switch (v885.tag) {
                            case 0: { // None
                                switch (v891.tag) {
                                    case 0: { // Call
                                        if (v886){
                                            int v954;
                                            v954 = v888 ^ 1;
                                            v998 = Union4{Union4_2{v885, false, v887, v954, v889, v890}};
                                        } else {
                                            v998 = Union4{Union4_0{v885, v886, v887, v888, v889, v890}};
                                        }
                                        break;
                                    }
                                    case 1: { // Fold
                                        v998 = Union4{Union4_5{v885, v886, v887, v888, v889, v890}};
                                        break;
                                    }
                                    case 2: { // Raise
                                        bool v958;
                                        v958 = v890 > 0;
                                        if (v958){
                                            int v959;
                                            v959 = v888 ^ 1;
                                            int v960;
                                            v960 = -1 + v890;
                                            int v961; int v962;
                                            Tuple7 tmp46 = Tuple7{0, 0};
                                            v961 = tmp46.v0; v962 = tmp46.v1;
                                            while (while_method_0(v961)){
                                                bool v964;
                                                v964 = 0 <= v961;
                                                bool v966;
                                                if (v964){
                                                    bool v965;
                                                    v965 = v961 < 2;
                                                    v966 = v965;
                                                } else {
                                                    v966 = false;
                                                }
                                                bool v967;
                                                v967 = v966 == false;
                                                if (v967){
                                                    assert("Index must be in range." && v966);
                                                } else {
                                                }
                                                int v969;
                                                v969 = v889[v961];
                                                bool v971;
                                                v971 = v962 >= v969;
                                                int v972;
                                                if (v971){
                                                    v972 = v962;
                                                } else {
                                                    v972 = v969;
                                                }
                                                v962 = v972;
                                                v961 += 1 ;
                                            }
                                            static_array<int,2> v973;
                                            int v975;
                                            v975 = 0;
                                            while (while_method_0(v975)){
                                                v973[v975] = v962;
                                                v975 += 1 ;
                                            }
                                            static_array<int,2> v977;
                                            int v979;
                                            v979 = 0;
                                            while (while_method_0(v979)){
                                                bool v981;
                                                v981 = 0 <= v979;
                                                bool v983;
                                                if (v981){
                                                    bool v982;
                                                    v982 = v979 < 2;
                                                    v983 = v982;
                                                } else {
                                                    v983 = false;
                                                }
                                                bool v984;
                                                v984 = v983 == false;
                                                if (v984){
                                                    assert("Index must be in range." && v983);
                                                } else {
                                                }
                                                int v986;
                                                v986 = v973[v979];
                                                bool v988;
                                                v988 = v979 == v888;
                                                int v990;
                                                if (v988){
                                                    int v989;
                                                    v989 = v986 + 2;
                                                    v990 = v989;
                                                } else {
                                                    v990 = v986;
                                                }
                                                v977[v979] = v990;
                                                v979 += 1 ;
                                            }
                                            v998 = Union4{Union4_2{v885, false, v887, v959, v977, v960}};
                                        } else {
                                            printf("%s\n", "Invalid action. The number of raises left is not positive.");
                                            __trap();
                                        }
                                        break;
                                    }
                                    default: {
                                        assert("Invalid tag." && false); __trap();
                                    }
                                }
                                break;
                            }
                            case 1: { // Some
                                Union6 v892 = v885.case1.v0;
                                switch (v891.tag) {
                                    case 0: { // Call
                                        if (v886){
                                            int v894;
                                            v894 = v888 ^ 1;
                                            v998 = Union4{Union4_2{v885, false, v887, v894, v889, v890}};
                                        } else {
                                            int v896; int v897;
                                            Tuple7 tmp47 = Tuple7{0, 0};
                                            v896 = tmp47.v0; v897 = tmp47.v1;
                                            while (while_method_0(v896)){
                                                bool v899;
                                                v899 = 0 <= v896;
                                                bool v901;
                                                if (v899){
                                                    bool v900;
                                                    v900 = v896 < 2;
                                                    v901 = v900;
                                                } else {
                                                    v901 = false;
                                                }
                                                bool v902;
                                                v902 = v901 == false;
                                                if (v902){
                                                    assert("Index must be in range." && v901);
                                                } else {
                                                }
                                                int v904;
                                                v904 = v889[v896];
                                                bool v906;
                                                v906 = v897 >= v904;
                                                int v907;
                                                if (v906){
                                                    v907 = v897;
                                                } else {
                                                    v907 = v904;
                                                }
                                                v897 = v907;
                                                v896 += 1 ;
                                            }
                                            static_array<int,2> v908;
                                            int v910;
                                            v910 = 0;
                                            while (while_method_0(v910)){
                                                v908[v910] = v897;
                                                v910 += 1 ;
                                            }
                                            v998 = Union4{Union4_4{v885, v886, v887, v888, v908, v890}};
                                        }
                                        break;
                                    }
                                    case 1: { // Fold
                                        v998 = Union4{Union4_5{v885, v886, v887, v888, v889, v890}};
                                        break;
                                    }
                                    case 2: { // Raise
                                        bool v914;
                                        v914 = v890 > 0;
                                        if (v914){
                                            int v915;
                                            v915 = v888 ^ 1;
                                            int v916;
                                            v916 = -1 + v890;
                                            int v917; int v918;
                                            Tuple7 tmp48 = Tuple7{0, 0};
                                            v917 = tmp48.v0; v918 = tmp48.v1;
                                            while (while_method_0(v917)){
                                                bool v920;
                                                v920 = 0 <= v917;
                                                bool v922;
                                                if (v920){
                                                    bool v921;
                                                    v921 = v917 < 2;
                                                    v922 = v921;
                                                } else {
                                                    v922 = false;
                                                }
                                                bool v923;
                                                v923 = v922 == false;
                                                if (v923){
                                                    assert("Index must be in range." && v922);
                                                } else {
                                                }
                                                int v925;
                                                v925 = v889[v917];
                                                bool v927;
                                                v927 = v918 >= v925;
                                                int v928;
                                                if (v927){
                                                    v928 = v918;
                                                } else {
                                                    v928 = v925;
                                                }
                                                v918 = v928;
                                                v917 += 1 ;
                                            }
                                            static_array<int,2> v929;
                                            int v931;
                                            v931 = 0;
                                            while (while_method_0(v931)){
                                                v929[v931] = v918;
                                                v931 += 1 ;
                                            }
                                            static_array<int,2> v933;
                                            int v935;
                                            v935 = 0;
                                            while (while_method_0(v935)){
                                                bool v937;
                                                v937 = 0 <= v935;
                                                bool v939;
                                                if (v937){
                                                    bool v938;
                                                    v938 = v935 < 2;
                                                    v939 = v938;
                                                } else {
                                                    v939 = false;
                                                }
                                                bool v940;
                                                v940 = v939 == false;
                                                if (v940){
                                                    assert("Index must be in range." && v939);
                                                } else {
                                                }
                                                int v942;
                                                v942 = v929[v935];
                                                bool v944;
                                                v944 = v935 == v888;
                                                int v946;
                                                if (v944){
                                                    int v945;
                                                    v945 = v942 + 4;
                                                    v946 = v945;
                                                } else {
                                                    v946 = v942;
                                                }
                                                v933[v935] = v946;
                                                v935 += 1 ;
                                            }
                                            v998 = Union4{Union4_2{v885, false, v887, v915, v933, v916}};
                                        } else {
                                            printf("%s\n", "Invalid action. The number of raises left is not positive.");
                                            __trap();
                                        }
                                        break;
                                    }
                                    default: {
                                        assert("Invalid tag." && false); __trap();
                                    }
                                }
                                break;
                            }
                            default: {
                                assert("Invalid tag." && false); __trap();
                            }
                        }
                        v1006 = Union3{Union3_1{v998}};
                        break;
                    }
                    case 3: { // T_none
                        v1006 = Union3{Union3_0{}};
                        break;
                    }
                    default: {
                        assert("Invalid tag." && false); __trap();
                    }
                }
                break;
            }
            default: {
                assert("Invalid tag." && false); __trap();
            }
        }
        v19 = v1006;
    }
    return ;
}
__device__ inline bool while_method_11(int v0){
    bool v1;
    v1 = v0 > 0;
    return v1;
}
__device__ inline bool while_method_12(int v0){
    bool v1;
    v1 = v0 < 64;
    return v1;
}
__device__ void method_48(unsigned char * v0, unsigned char * v1, StackMut1 & v2, Union4 v3){
    v2.v0 = 63u;
    static_array<float,2> v4;
    v4[0] = 0.0f;
    v4[1] = 0.0f;
    v2.v4 = v4;
    static_array_list<Union7,32> & v6 = v2.v2;
    v6.unsafe_set_length(0);
    static_array<Union2,2> v7;
    Union2 v9;
    v9 = Union2{Union2_0{}};
    v7[0] = v9;
    Union2 v11;
    v11 = Union2{Union2_0{}};
    v7[1] = v11;
    v2.v3 = v7;
    static_array_list<Union7,32> & v13 = v2.v2;
    Union3 v14;
    v14 = Union3{Union3_1{v3}};
    Union3 v15;
    v15 = v14;
    while (while_method_10(v15)){
        Union3 v1002;
        switch (v15.tag) {
            case 0: { // None
                v1002 = Union3{Union3_0{}};
                break;
            }
            case 1: { // Some
                Union4 v17 = v15.case1.v0;
                Union14 v842;
                switch (v17.tag) {
                    case 0: { // ChanceCommunityCard
                        Union5 v811 = v17.case0.v0; bool v812 = v17.case0.v1; static_array<Union6,2> v813 = v17.case0.v2; int v814 = v17.case0.v3; static_array<int,2> v815 = v17.case0.v4; int v816 = v17.case0.v5;
                        curandStatePhilox4_32_10_t & v817 = v2.v5;
                        curandStatePhilox4_32_10_t & v818 = v817;
                        unsigned int & v819 = v2.v0;
                        Union6 v820; unsigned int v821;
                        Tuple6 tmp53 = draw_card_20(v818, v819);
                        v820 = tmp53.v0; v821 = tmp53.v1;
                        v2.v0 = v821;
                        Union7 v822;
                        v822 = Union7{Union7_0{v820}};
                        v13.push(v822);
                        v842 = Union14{Union14_0{v811, v812, v813, v814, v815, v816, v820}};
                        break;
                    }
                    case 1: { // ChanceInit
                        curandStatePhilox4_32_10_t & v824 = v2.v5;
                        curandStatePhilox4_32_10_t & v825 = v824;
                        unsigned int & v826 = v2.v0;
                        Union6 v827; unsigned int v828;
                        Tuple6 tmp54 = draw_card_20(v825, v826);
                        v827 = tmp54.v0; v828 = tmp54.v1;
                        v2.v0 = v828;
                        curandStatePhilox4_32_10_t & v829 = v2.v5;
                        curandStatePhilox4_32_10_t & v830 = v829;
                        unsigned int & v831 = v2.v0;
                        Union6 v832; unsigned int v833;
                        Tuple6 tmp55 = draw_card_20(v830, v831);
                        v832 = tmp55.v0; v833 = tmp55.v1;
                        v2.v0 = v833;
                        Union7 v834;
                        v834 = Union7{Union7_2{0, v827}};
                        v13.push(v834);
                        Union7 v835;
                        v835 = Union7{Union7_2{1, v832}};
                        v13.push(v835);
                        v842 = Union14{Union14_1{v827, v832}};
                        break;
                    }
                    case 2: { // Round
                        Union5 v67 = v17.case2.v0; bool v68 = v17.case2.v1; static_array<Union6,2> v69 = v17.case2.v2; int v70 = v17.case2.v3; static_array<int,2> v71 = v17.case2.v4; int v72 = v17.case2.v5;
                        static_array<Union2,2> & v73 = v2.v3;
                        bool v74;
                        v74 = 0 <= v70;
                        bool v76;
                        if (v74){
                            bool v75;
                            v75 = v70 < 2;
                            v76 = v75;
                        } else {
                            v76 = false;
                        }
                        bool v77;
                        v77 = v76 == false;
                        if (v77){
                            assert("Index must be in range." && v76);
                        } else {
                        }
                        Union2 v79;
                        v79 = v73[v70];
                        Union1 v799;
                        switch (v79.tag) {
                            case 0: { // Computer
                                static_array_list<Union7,32> & v82 = v2.v2;
                                curandStatePhilox4_32_10_t & v83 = v2.v5;
                                curandStatePhilox4_32_10_t & v84 = v83;
                                unsigned int * v85;
                                v85 = reinterpret_cast<unsigned int *>(&v0[6291456ull]);
                                float * v87;
                                v87 = reinterpret_cast<float *>(&v0[0ull]);
                                float * v89;
                                v89 = reinterpret_cast<float *>(&v0[0ull]);
                                int v91;
                                v91 = blockIdx.x;
                                assert("Tensor range check" && 0 <= v91 && v91 < 24);
                                int v92;
                                v92 = 32768 * v91;
                                int v93;
                                v93 = threadIdx.x;
                                int v94;
                                v94 = v93;
                                while (while_method_3(v94)){
                                    bool v96;
                                    v96 = 0 <= v94;
                                    bool v97;
                                    v97 = v96 == false;
                                    if (v97){
                                        assert("The index needs to be zero or positive." && v96);
                                    } else {
                                    }
                                    int v99;
                                    v99 = v94 % 128;
                                    int v100;
                                    v100 = v94 / 128;
                                    bool v101;
                                    v101 = v100 < 256;
                                    bool v102;
                                    v102 = v101 == false;
                                    if (v102){
                                        assert("The last element of the projection dimensions needs to be greater than the index remainder." && v101);
                                    } else {
                                    }
                                    assert("Tensor range check" && 0 <= v100 && v100 < 256);
                                    assert("Tensor range check" && 0 <= v99 && v99 < 128);
                                    int v104;
                                    v104 = v99 + v92;
                                    int v105;
                                    v105 = 128 * v100;
                                    int v106;
                                    v106 = v105 + v104;
                                    v89[v106] = 0.0f;
                                    v94 += 256 ;
                                }
                                __syncthreads();
                                int v107;
                                v107 = threadIdx.x;
                                assert("Tensor range check" && 0 <= v107 && v107 < 256);
                                int v108;
                                v108 = 128 * v107;
                                int v109;
                                v109 = v108 + v92;
                                static_array_list<Union9,10> v110;
                                v110 = static_array_list<Union9,10>{};
                                int v112;
                                v112 = v82.length;
                                int v113;
                                v113 = 0;
                                while (while_method_1(v112, v113)){
                                    Union7 v115;
                                    v115 = v82[v113];
                                    Union10 v134;
                                    switch (v115.tag) {
                                        case 0: { // CommunityCardIs
                                            Union6 v124 = v115.case0.v0;
                                            Union9 v125;
                                            v125 = Union9{Union9_1{v124}};
                                            v134 = Union10{Union10_1{v125}};
                                            break;
                                        }
                                        case 1: { // PlayerAction
                                            int v127 = v115.case1.v0; Union1 v128 = v115.case1.v1;
                                            Union9 v129;
                                            v129 = Union9{Union9_0{v128}};
                                            v134 = Union10{Union10_1{v129}};
                                            break;
                                        }
                                        case 2: { // PlayerGotCard
                                            int v117 = v115.case2.v0; Union6 v118 = v115.case2.v1;
                                            bool v119;
                                            v119 = v117 == v70;
                                            if (v119){
                                                Union9 v120;
                                                v120 = Union9{Union9_1{v118}};
                                                v134 = Union10{Union10_1{v120}};
                                            } else {
                                                v134 = Union10{Union10_0{}};
                                            }
                                            break;
                                        }
                                        default: {
                                            v134 = Union10{Union10_0{}};
                                        }
                                    }
                                    switch (v134.tag) {
                                        case 0: { // None
                                            break;
                                        }
                                        case 1: { // Some
                                            Union9 v135 = v134.case1.v0;
                                            v110.push(v135);
                                            break;
                                        }
                                        default: {
                                            assert("Invalid tag." && false); __trap();
                                        }
                                    }
                                    v113 += 1 ;
                                }
                                float * v136;
                                v136 = v89+v109;
                                int v138;
                                v138 = v110.length;
                                bool v139;
                                v139 = v138 == 0;
                                if (v139){
                                    v136[0] = 1.0f;
                                } else {
                                }
                                int v140;
                                v140 = v110.length;
                                int v141;
                                v141 = 0;
                                while (while_method_1(v140, v141)){
                                    Union9 v143;
                                    v143 = v110[v141];
                                    int v145;
                                    v145 = v141 * 6;
                                    int v146;
                                    v146 = 1 + v145;
                                    switch (v143.tag) {
                                        case 0: { // C1of2
                                            Union1 v147 = v143.case0.v0;
                                            switch (v147.tag) {
                                                case 0: { // Call
                                                    v136[v146] = 1.0f;
                                                    break;
                                                }
                                                case 1: { // Fold
                                                    int v148;
                                                    v148 = v146 + 1;
                                                    v136[v148] = 1.0f;
                                                    break;
                                                }
                                                case 2: { // Raise
                                                    int v149;
                                                    v149 = v146 + 2;
                                                    v136[v149] = 1.0f;
                                                    break;
                                                }
                                                default: {
                                                    assert("Invalid tag." && false); __trap();
                                                }
                                            }
                                            break;
                                        }
                                        case 1: { // C2of2
                                            Union6 v150 = v143.case1.v0;
                                            int v151;
                                            v151 = v146 + 3;
                                            switch (v150.tag) {
                                                case 0: { // Jack
                                                    v136[v151] = 1.0f;
                                                    break;
                                                }
                                                case 1: { // King
                                                    int v152;
                                                    v152 = v151 + 1;
                                                    v136[v152] = 1.0f;
                                                    break;
                                                }
                                                case 2: { // Queen
                                                    int v153;
                                                    v153 = v151 + 2;
                                                    v136[v153] = 1.0f;
                                                    break;
                                                }
                                                default: {
                                                    assert("Invalid tag." && false); __trap();
                                                }
                                            }
                                            break;
                                        }
                                        default: {
                                            assert("Invalid tag." && false); __trap();
                                        }
                                    }
                                    v141 += 1 ;
                                }
                                __syncthreads();
                                int v154;
                                v154 = 0;
                                while (while_method_9(v154)){
                                    float * v156;
                                    v156 = reinterpret_cast<float *>(&v0[0ull]);
                                    float * v158;
                                    v158 = reinterpret_cast<float *>(&v1[0ull]);
                                    assert("Tensor range check" && 0 <= v154 && v154 < 4);
                                    int v160;
                                    v160 = 16384 * v154;
                                    float * v161;
                                    v161 = reinterpret_cast<float *>(&v0[3145728ull]);
                                    int v163;
                                    v163 = blockIdx.x;
                                    assert("Tensor range check" && 0 <= v163 && v163 < 24);
                                    int v164;
                                    v164 = 32768 * v163;
                                    int v165;
                                    v165 = blockIdx.x;
                                    assert("Tensor range check" && 0 <= v165 && v165 < 24);
                                    int v166;
                                    v166 = 32768 * v165;
                                    cuda::pipeline<cuda::thread_scope_thread> v167 = cuda::make_pipeline();
                                    extern __shared__ unsigned char v168[];
                                    float * v169;
                                    v169 = reinterpret_cast<float *>(&v168[0ull]);
                                    float * v171;
                                    v171 = reinterpret_cast<float *>(&v168[34816ull]);
                                    float * v173;
                                    v173 = reinterpret_cast<float *>(&v168[0ull]);
                                    int v175;
                                    v175 = threadIdx.x;
                                    int v176;
                                    v176 = v175 / 32;
                                    bool v177;
                                    v177 = 0 <= v176;
                                    bool v178;
                                    v178 = v177 == false;
                                    if (v178){
                                        assert("The index needs to be zero or positive." && v177);
                                    } else {
                                    }
                                    int v180;
                                    v180 = v176 % 8;
                                    int v181;
                                    v181 = v176 / 8;
                                    bool v182;
                                    v182 = v181 < 1;
                                    bool v183;
                                    v183 = v182 == false;
                                    if (v183){
                                        assert("The last element of the projection dimensions needs to be greater than the index remainder." && v182);
                                    } else {
                                    }
                                    assert("Tensor range check" && 0 <= v181 && v181 < 1);
                                    assert("Tensor range check" && 0 <= v180 && v180 < 8);
                                    int v185;
                                    v185 = 16 * v180;
                                    int v186;
                                    v186 = 17408 * v181;
                                    int v187;
                                    v187 = v186 + v185;
                                    float * v188;
                                    v188 = v173+v187;
                                    assert("Tensor range check" && 0 <= v181 && v181 < 1);
                                    int v190;
                                    v190 = 8704 * v181;
                                    int v191;
                                    v191 = threadIdx.x;
                                    int v192;
                                    v192 = v191 % 32;
                                    bool v193;
                                    v193 = 0 <= v192;
                                    bool v194;
                                    v194 = v193 == false;
                                    if (v194){
                                        assert("The index needs to be zero or positive." && v193);
                                    } else {
                                    }
                                    int v196;
                                    v196 = v192 % 4;
                                    int v197;
                                    v197 = v192 / 4;
                                    bool v198;
                                    v198 = v197 < 8;
                                    bool v199;
                                    v199 = v198 == false;
                                    if (v199){
                                        assert("The last element of the projection dimensions needs to be greater than the index remainder." && v198);
                                    } else {
                                    }
                                    assert("Tensor range check" && 0 <= v197 && v197 < 8);
                                    assert("Tensor range check" && 0 <= v196 && v196 < 4);
                                    int v201;
                                    v201 = v196 + v190;
                                    int v202;
                                    v202 = 68 * v197;
                                    int v203;
                                    v203 = v202 + v201;
                                    float * v204;
                                    v204 = v169+v203;
                                    assert("Tensor range check" && 0 <= v180 && v180 < 8);
                                    int v206;
                                    v206 = 1088 * v180;
                                    int v207;
                                    v207 = threadIdx.x;
                                    int v208;
                                    v208 = v207 % 32;
                                    bool v209;
                                    v209 = 0 <= v208;
                                    bool v210;
                                    v210 = v209 == false;
                                    if (v210){
                                        assert("The index needs to be zero or positive." && v209);
                                    } else {
                                    }
                                    int v212;
                                    v212 = v208 % 4;
                                    int v213;
                                    v213 = v208 / 4;
                                    bool v214;
                                    v214 = v213 < 8;
                                    bool v215;
                                    v215 = v214 == false;
                                    if (v215){
                                        assert("The last element of the projection dimensions needs to be greater than the index remainder." && v214);
                                    } else {
                                    }
                                    assert("Tensor range check" && 0 <= v213 && v213 < 8);
                                    assert("Tensor range check" && 0 <= v212 && v212 < 4);
                                    int v217;
                                    v217 = v212 + v206;
                                    int v218;
                                    v218 = 68 * v213;
                                    int v219;
                                    v219 = v218 + v217;
                                    float * v220;
                                    v220 = v171+v219;
                                    wmma::fragment<wmma::accumulator, 16, 16, 8, float> v222[8];
                                    int v223;
                                    v223 = 0;
                                    while (while_method_0(v223)){
                                        int v225;
                                        v225 = 0;
                                        while (while_method_4(v225)){
                                            assert("Tensor range check" && 0 <= v223 && v223 < 2);
                                            assert("Tensor range check" && 0 <= v225 && v225 < 1);
                                            int v227;
                                            v227 = 128 * v225;
                                            int v228;
                                            v228 = v227 + v166;
                                            int v229;
                                            v229 = 16384 * v223;
                                            int v230;
                                            v230 = v229 + v228;
                                            float * v231;
                                            v231 = v161+v230;
                                            // Pushing the loop unrolling to: 0
                                            int v233;
                                            v233 = 0;
                                            #pragma unroll
                                            while (while_method_5(v233)){
                                                int v235;
                                                v235 = 0;
                                                #pragma unroll
                                                while (while_method_4(v235)){
                                                    assert("Tensor range check" && 0 <= v233 && v233 < 8);
                                                    assert("Tensor range check" && 0 <= v235 && v235 < 1);
                                                    int v237;
                                                    v237 = v233 + v235;
                                                    wmma::fragment<wmma::accumulator, 16, 16, 8, float> & v238 = v222[v237];
                                                    wmma::fill_fragment(v238, 0.0f);
                                                    v235 += 1 ;
                                                }
                                                v233 += 1 ;
                                            }
                                            // Poping the loop unrolling to: 0
                                            int v239;
                                            v239 = 0;
                                            while (while_method_6(v239)){
                                                int v241;
                                                v241 = v239 + 1;
                                                bool v242;
                                                v242 = v239 == 0;
                                                int v243;
                                                v243 = v239 % 2;
                                                bool v244;
                                                v244 = 0 <= v239;
                                                bool v245;
                                                v245 = v244 == false;
                                                if (v245){
                                                    assert("The index needs to be zero or positive." && v244);
                                                } else {
                                                }
                                                bool v247;
                                                v247 = v239 < 2;
                                                bool v248;
                                                v248 = v247 == false;
                                                if (v248){
                                                    assert("The last element of the projection dimensions needs to be greater than the index remainder." && v247);
                                                } else {
                                                }
                                                bool v250;
                                                v250 = v241 < 2;
                                                Union11 v256;
                                                if (v250){
                                                    bool v251;
                                                    v251 = 0 <= v241;
                                                    bool v252;
                                                    v252 = v251 == false;
                                                    if (v252){
                                                        assert("The index needs to be zero or positive." && v251);
                                                    } else {
                                                    }
                                                    v256 = Union11{Union11_1{v241}};
                                                } else {
                                                    v256 = Union11{Union11_0{}};
                                                }
                                                assert("Tensor range check" && 0 <= v223 && v223 < 2);
                                                int v257;
                                                v257 = v229 + v164;
                                                assert("Tensor range check" && 0 <= v239 && v239 < 2);
                                                int v258;
                                                v258 = 64 * v239;
                                                int v259;
                                                v259 = v258 + v257;
                                                float * v260;
                                                v260 = v156+v259;
                                                assert("Tensor range check" && 0 <= v225 && v225 < 1);
                                                int v262;
                                                v262 = 16384 * v225;
                                                int v263;
                                                v263 = v262 + v160;
                                                if (v242){
                                                    assert("Tensor range check" && 0 <= v239 && v239 < 2);
                                                    int v264;
                                                    v264 = v258 + v263;
                                                    float * v265;
                                                    v265 = v158+v264;
                                                    // Pushing the loop unrolling to: 0
                                                    v167.producer_acquire();
                                                    int v267;
                                                    v267 = threadIdx.x;
                                                    bool v268;
                                                    v268 = 0 <= v267;
                                                    bool v269;
                                                    v269 = v268 == false;
                                                    if (v269){
                                                        assert("The index needs to be zero or positive." && v268);
                                                    } else {
                                                    }
                                                    int v271;
                                                    v271 = v267 % 16;
                                                    int v272;
                                                    v272 = v267 / 16;
                                                    bool v273;
                                                    v273 = v272 < 16;
                                                    bool v274;
                                                    v274 = v273 == false;
                                                    if (v274){
                                                        assert("The last element of the projection dimensions needs to be greater than the index remainder." && v273);
                                                    } else {
                                                    }
                                                    assert("Tensor range check" && 0 <= v272 && v272 < 16);
                                                    assert("Tensor range check" && 0 <= v271 && v271 < 16);
                                                    int v276;
                                                    v276 = 4 * v271;
                                                    int v277;
                                                    v277 = 68 * v272;
                                                    int v278;
                                                    v278 = v277 + v276;
                                                    int v279;
                                                    v279 = 128 * v272;
                                                    int v280;
                                                    v280 = v279 + v276;
                                                    float * v281;
                                                    v281 = v171+v278;
                                                    float * v283;
                                                    v283 = v265+v280;
                                                    int v285;
                                                    v285 = 0;
                                                    #pragma unroll
                                                    while (while_method_5(v285)){
                                                        int v287;
                                                        v287 = 0;
                                                        #pragma unroll
                                                        while (while_method_4(v287)){
                                                            assert("Tensor range check" && 0 <= v285 && v285 < 8);
                                                            assert("Tensor range check" && 0 <= v287 && v287 < 1);
                                                            int v289;
                                                            v289 = 64 * v287;
                                                            int v290;
                                                            v290 = 1088 * v285;
                                                            int v291;
                                                            v291 = v290 + v289;
                                                            int v292;
                                                            v292 = 2048 * v285;
                                                            int v293;
                                                            v293 = v292 + v289;
                                                            constexpr int v294 = sizeof(float) * 4;
                                                            assert("Pointer alignment check" && (unsigned long long)(v283 + v293) % v294 == 0 && (unsigned long long)(v281 + v291) % v294 == 0);
                                                            cuda::memcpy_async(v281 + v291, v283 + v293, cuda::aligned_size_t<v294>(v294), v167);
                                                            v287 += 1 ;
                                                        }
                                                        v285 += 1 ;
                                                    }
                                                    v167.producer_commit();
                                                    // Poping the loop unrolling to: 0
                                                } else {
                                                }
                                                // Pushing the loop unrolling to: 0
                                                int v295;
                                                v295 = threadIdx.x;
                                                bool v296;
                                                v296 = 0 <= v295;
                                                bool v297;
                                                v297 = v296 == false;
                                                if (v297){
                                                    assert("The index needs to be zero or positive." && v296);
                                                } else {
                                                }
                                                int v299;
                                                v299 = v295 % 16;
                                                int v300;
                                                v300 = v295 / 16;
                                                bool v301;
                                                v301 = v300 < 16;
                                                bool v302;
                                                v302 = v301 == false;
                                                if (v302){
                                                    assert("The last element of the projection dimensions needs to be greater than the index remainder." && v301);
                                                } else {
                                                }
                                                assert("Tensor range check" && 0 <= v300 && v300 < 16);
                                                assert("Tensor range check" && 0 <= v299 && v299 < 16);
                                                int v304;
                                                v304 = 4 * v299;
                                                int v305;
                                                v305 = 68 * v300;
                                                int v306;
                                                v306 = v305 + v304;
                                                int v307;
                                                v307 = 128 * v300;
                                                int v308;
                                                v308 = v307 + v304;
                                                float * v309;
                                                v309 = v169+v306;
                                                float * v311;
                                                v311 = v260+v308;
                                                int v313;
                                                v313 = 0;
                                                #pragma unroll
                                                while (while_method_5(v313)){
                                                    int v315;
                                                    v315 = 0;
                                                    #pragma unroll
                                                    while (while_method_4(v315)){
                                                        assert("Tensor range check" && 0 <= v313 && v313 < 8);
                                                        assert("Tensor range check" && 0 <= v315 && v315 < 1);
                                                        int v317;
                                                        v317 = 64 * v315;
                                                        int v318;
                                                        v318 = 1088 * v313;
                                                        int v319;
                                                        v319 = v318 + v317;
                                                        int v320;
                                                        v320 = 2048 * v313;
                                                        int v321;
                                                        v321 = v320 + v317;
                                                        int4* v322;
                                                        v322 = reinterpret_cast<int4*>(v311 + v321);
                                                        int4* v323;
                                                        v323 = reinterpret_cast<int4*>(v309 + v319);
                                                        assert("Pointer alignment check" && (unsigned long long)(v322) % 4 == 0 && (unsigned long long)(v323) % 4 == 0);
                                                        *v323 = *v322;
                                                        v315 += 1 ;
                                                    }
                                                    v313 += 1 ;
                                                }
                                                // Poping the loop unrolling to: 0
                                                wmma::fragment<wmma::matrix_a, 16, 16, 8, wmma::precision::tf32, wmma::row_major> v324[1];
                                                wmma::fragment<wmma::matrix_b, 16, 16, 8, wmma::precision::tf32, wmma::col_major> v325[8];
                                                cuda::pipeline_consumer_wait_prior<0>(v167);;
                                                __syncthreads();
                                                // Pushing the loop unrolling to: 0
                                                int v326;
                                                v326 = 0;
                                                #pragma unroll
                                                while (while_method_4(v326)){
                                                    int v328;
                                                    v328 = 0;
                                                    #pragma unroll
                                                    while (while_method_5(v328)){
                                                        assert("Tensor range check" && 0 <= v326 && v326 < 1);
                                                        assert("Tensor range check" && 0 <= v328 && v328 < 8);
                                                        int v330;
                                                        v330 = 8 * v326;
                                                        int v331;
                                                        v331 = v330 + v328;
                                                        wmma::fragment<wmma::matrix_b, 16, 16, 8, wmma::precision::tf32, wmma::col_major> & v332 = v325[v331];
                                                        assert("Tensor range check" && 0 <= v326 && v326 < 1);
                                                        int v333;
                                                        v333 = 1088 * v326;
                                                        assert("Tensor range check" && 0 <= v328 && v328 < 8);
                                                        int v334;
                                                        v334 = 8 * v328;
                                                        int v335;
                                                        v335 = v334 + v333;
                                                        int v336;
                                                        v336 = 0;
                                                        #pragma unroll
                                                        while (while_method_0(v336)){
                                                            int v338;
                                                            v338 = 0;
                                                            #pragma unroll
                                                            while (while_method_0(v338)){
                                                                assert("Tensor range check" && 0 <= v336 && v336 < 2);
                                                                assert("Tensor range check" && 0 <= v338 && v338 < 2);
                                                                int v340;
                                                                v340 = 4 * v338;
                                                                int v341;
                                                                v341 = v340 + v335;
                                                                int v342;
                                                                v342 = 544 * v336;
                                                                int v343;
                                                                v343 = v342 + v341;
                                                                float v344;
                                                                v344 = v220[v343];
                                                                bool v345;
                                                                v345 = 0 <= v338;
                                                                bool v347;
                                                                if (v345){
                                                                    bool v346;
                                                                    v346 = v338 < 2;
                                                                    v347 = v346;
                                                                } else {
                                                                    v347 = false;
                                                                }
                                                                bool v348;
                                                                v348 = v347 == false;
                                                                if (v348){
                                                                    assert("The indices should be inside the range of the dimension." && v347);
                                                                } else {
                                                                }
                                                                bool v350;
                                                                v350 = 0 <= v336;
                                                                bool v352;
                                                                if (v350){
                                                                    bool v351;
                                                                    v351 = v336 < 2;
                                                                    v352 = v351;
                                                                } else {
                                                                    v352 = false;
                                                                }
                                                                bool v353;
                                                                v353 = v352 == false;
                                                                if (v353){
                                                                    assert("The indices should be inside the range of the dimension." && v352);
                                                                } else {
                                                                }
                                                                int v355;
                                                                v355 = v336 * 2;
                                                                int v356;
                                                                v356 = v338 + v355;
                                                                v332.x[v356] = wmma::__float_to_tf32(v344);
                                                                v338 += 1 ;
                                                            }
                                                            v336 += 1 ;
                                                        }
                                                        v328 += 1 ;
                                                    }
                                                    v326 += 1 ;
                                                }
                                                // Poping the loop unrolling to: 0
                                                v167.consumer_release();
                                                switch (v256.tag) {
                                                    case 0: { // None
                                                        break;
                                                    }
                                                    case 1: { // Some
                                                        int v357 = v256.case1.v0;
                                                        assert("Tensor range check" && 0 <= v357 && v357 < 2);
                                                        int v358;
                                                        v358 = 64 * v357;
                                                        int v359;
                                                        v359 = v358 + v263;
                                                        float * v360;
                                                        v360 = v158+v359;
                                                        __syncthreads();
                                                        // Pushing the loop unrolling to: 0
                                                        v167.producer_acquire();
                                                        int v362;
                                                        v362 = threadIdx.x;
                                                        bool v363;
                                                        v363 = 0 <= v362;
                                                        bool v364;
                                                        v364 = v363 == false;
                                                        if (v364){
                                                            assert("The index needs to be zero or positive." && v363);
                                                        } else {
                                                        }
                                                        int v366;
                                                        v366 = v362 % 16;
                                                        int v367;
                                                        v367 = v362 / 16;
                                                        bool v368;
                                                        v368 = v367 < 16;
                                                        bool v369;
                                                        v369 = v368 == false;
                                                        if (v369){
                                                            assert("The last element of the projection dimensions needs to be greater than the index remainder." && v368);
                                                        } else {
                                                        }
                                                        assert("Tensor range check" && 0 <= v367 && v367 < 16);
                                                        assert("Tensor range check" && 0 <= v366 && v366 < 16);
                                                        int v371;
                                                        v371 = 4 * v366;
                                                        int v372;
                                                        v372 = 68 * v367;
                                                        int v373;
                                                        v373 = v372 + v371;
                                                        int v374;
                                                        v374 = 128 * v367;
                                                        int v375;
                                                        v375 = v374 + v371;
                                                        float * v376;
                                                        v376 = v171+v373;
                                                        float * v378;
                                                        v378 = v360+v375;
                                                        int v380;
                                                        v380 = 0;
                                                        #pragma unroll
                                                        while (while_method_5(v380)){
                                                            int v382;
                                                            v382 = 0;
                                                            #pragma unroll
                                                            while (while_method_4(v382)){
                                                                assert("Tensor range check" && 0 <= v380 && v380 < 8);
                                                                assert("Tensor range check" && 0 <= v382 && v382 < 1);
                                                                int v384;
                                                                v384 = 64 * v382;
                                                                int v385;
                                                                v385 = 1088 * v380;
                                                                int v386;
                                                                v386 = v385 + v384;
                                                                int v387;
                                                                v387 = 2048 * v380;
                                                                int v388;
                                                                v388 = v387 + v384;
                                                                constexpr int v389 = sizeof(float) * 4;
                                                                assert("Pointer alignment check" && (unsigned long long)(v378 + v388) % v389 == 0 && (unsigned long long)(v376 + v386) % v389 == 0);
                                                                cuda::memcpy_async(v376 + v386, v378 + v388, cuda::aligned_size_t<v389>(v389), v167);
                                                                v382 += 1 ;
                                                            }
                                                            v380 += 1 ;
                                                        }
                                                        v167.producer_commit();
                                                        // Poping the loop unrolling to: 0
                                                        break;
                                                    }
                                                    default: {
                                                        assert("Invalid tag." && false); __trap();
                                                    }
                                                }
                                                // Pushing the loop unrolling to: 0
                                                int v390;
                                                v390 = 0;
                                                #pragma unroll
                                                while (while_method_5(v390)){
                                                    int v392;
                                                    v392 = 0;
                                                    #pragma unroll
                                                    while (while_method_5(v392)){
                                                        wmma::fragment<wmma::matrix_a, 16, 16, 8, wmma::precision::tf32, wmma::row_major> & v394 = v324[0];
                                                        assert("Tensor range check" && 0 <= v390 && v390 < 8);
                                                        int v395;
                                                        v395 = 1088 * v390;
                                                        assert("Tensor range check" && 0 <= v392 && v392 < 8);
                                                        int v396;
                                                        v396 = 8 * v392;
                                                        int v397;
                                                        v397 = v396 + v395;
                                                        int v398;
                                                        v398 = 0;
                                                        #pragma unroll
                                                        while (while_method_0(v398)){
                                                            int v400;
                                                            v400 = 0;
                                                            #pragma unroll
                                                            while (while_method_0(v400)){
                                                                assert("Tensor range check" && 0 <= v398 && v398 < 2);
                                                                assert("Tensor range check" && 0 <= v400 && v400 < 2);
                                                                int v402;
                                                                v402 = 544 * v400;
                                                                int v403;
                                                                v403 = v402 + v397;
                                                                int v404;
                                                                v404 = 4 * v398;
                                                                int v405;
                                                                v405 = v404 + v403;
                                                                float v406;
                                                                v406 = v204[v405];
                                                                bool v407;
                                                                v407 = 0 <= v400;
                                                                bool v409;
                                                                if (v407){
                                                                    bool v408;
                                                                    v408 = v400 < 2;
                                                                    v409 = v408;
                                                                } else {
                                                                    v409 = false;
                                                                }
                                                                bool v410;
                                                                v410 = v409 == false;
                                                                if (v410){
                                                                    assert("The indices should be inside the range of the dimension." && v409);
                                                                } else {
                                                                }
                                                                bool v412;
                                                                v412 = 0 <= v398;
                                                                bool v414;
                                                                if (v412){
                                                                    bool v413;
                                                                    v413 = v398 < 2;
                                                                    v414 = v413;
                                                                } else {
                                                                    v414 = false;
                                                                }
                                                                bool v415;
                                                                v415 = v414 == false;
                                                                if (v415){
                                                                    assert("The indices should be inside the range of the dimension." && v414);
                                                                } else {
                                                                }
                                                                int v417;
                                                                v417 = v398 * 2;
                                                                int v418;
                                                                v418 = v400 + v417;
                                                                v394.x[v418] = wmma::__float_to_tf32(v406);
                                                                v400 += 1 ;
                                                            }
                                                            v398 += 1 ;
                                                        }
                                                        int v419;
                                                        v419 = 0;
                                                        #pragma unroll
                                                        while (while_method_4(v419)){
                                                            assert("Tensor range check" && 0 <= v390 && v390 < 8);
                                                            assert("Tensor range check" && 0 <= v419 && v419 < 1);
                                                            int v421;
                                                            v421 = v390 + v419;
                                                            wmma::fragment<wmma::accumulator, 16, 16, 8, float> & v422 = v222[v421];
                                                            assert("Tensor range check" && 0 <= v419 && v419 < 1);
                                                            assert("Tensor range check" && 0 <= v392 && v392 < 8);
                                                            int v423;
                                                            v423 = 8 * v419;
                                                            int v424;
                                                            v424 = v423 + v392;
                                                            wmma::fragment<wmma::matrix_b, 16, 16, 8, wmma::precision::tf32, wmma::col_major> & v425 = v325[v424];
                                                            wmma::mma_sync(v422, v394, v425, v422);
                                                            v419 += 1 ;
                                                        }
                                                        v392 += 1 ;
                                                    }
                                                    v390 += 1 ;
                                                }
                                                // Poping the loop unrolling to: 0
                                                __syncthreads();
                                                v239 = v241;
                                            }
                                            // Pushing the loop unrolling to: 0
                                            int v426;
                                            v426 = 0;
                                            #pragma unroll
                                            while (while_method_5(v426)){
                                                int v428;
                                                v428 = 0;
                                                #pragma unroll
                                                while (while_method_4(v428)){
                                                    assert("Tensor range check" && 0 <= v426 && v426 < 8);
                                                    assert("Tensor range check" && 0 <= v428 && v428 < 1);
                                                    int v430;
                                                    v430 = v426 + v428;
                                                    wmma::fragment<wmma::accumulator, 16, 16, 8, float> & v431 = v222[v430];
                                                    assert("Tensor range check" && 0 <= v426 && v426 < 8);
                                                    assert("Tensor range check" && 0 <= v428 && v428 < 1);
                                                    int v432;
                                                    v432 = 16 * v428;
                                                    int v433;
                                                    v433 = 2176 * v426;
                                                    int v434;
                                                    v434 = v433 + v432;
                                                    float * v435;
                                                    v435 = v188+v434;
                                                    wmma::store_matrix_sync(v435, v431, 136, wmma::mem_row_major);
                                                    v428 += 1 ;
                                                }
                                                v426 += 1 ;
                                            }
                                            // Poping the loop unrolling to: 0
                                            __syncthreads();
                                            // Pushing the loop unrolling to: 0
                                            int v437;
                                            v437 = threadIdx.x;
                                            bool v438;
                                            v438 = 0 <= v437;
                                            bool v439;
                                            v439 = v438 == false;
                                            if (v439){
                                                assert("The index needs to be zero or positive." && v438);
                                            } else {
                                            }
                                            int v441;
                                            v441 = v437 % 32;
                                            int v442;
                                            v442 = v437 / 32;
                                            bool v443;
                                            v443 = v442 < 8;
                                            bool v444;
                                            v444 = v443 == false;
                                            if (v444){
                                                assert("The last element of the projection dimensions needs to be greater than the index remainder." && v443);
                                            } else {
                                            }
                                            assert("Tensor range check" && 0 <= v442 && v442 < 8);
                                            assert("Tensor range check" && 0 <= v441 && v441 < 32);
                                            int v446;
                                            v446 = 4 * v441;
                                            int v447;
                                            v447 = 128 * v442;
                                            int v448;
                                            v448 = v447 + v446;
                                            int v449;
                                            v449 = 136 * v442;
                                            int v450;
                                            v450 = v449 + v446;
                                            float * v451;
                                            v451 = v231+v448;
                                            float * v453;
                                            v453 = v173+v450;
                                            int v455;
                                            v455 = 0;
                                            #pragma unroll
                                            while (while_method_7(v455)){
                                                int v457;
                                                v457 = 0;
                                                #pragma unroll
                                                while (while_method_4(v457)){
                                                    assert("Tensor range check" && 0 <= v455 && v455 < 16);
                                                    assert("Tensor range check" && 0 <= v457 && v457 < 1);
                                                    int v459;
                                                    v459 = 128 * v457;
                                                    int v460;
                                                    v460 = 1024 * v455;
                                                    int v461;
                                                    v461 = v460 + v459;
                                                    int v462;
                                                    v462 = 1088 * v455;
                                                    int v463;
                                                    v463 = v462 + v459;
                                                    int4* v464;
                                                    v464 = reinterpret_cast<int4*>(v453 + v463);
                                                    int4* v465;
                                                    v465 = reinterpret_cast<int4*>(v451 + v461);
                                                    assert("Pointer alignment check" && (unsigned long long)(v464) % 4 == 0 && (unsigned long long)(v465) % 4 == 0);
                                                    *v465 = *v464;
                                                    v457 += 1 ;
                                                }
                                                v455 += 1 ;
                                            }
                                            // Poping the loop unrolling to: 0
                                            __syncthreads();
                                            v225 += 1 ;
                                        }
                                        v223 += 1 ;
                                    }
                                    unsigned int * v466;
                                    v466 = reinterpret_cast<unsigned int *>(&v0[6291456ull]);
                                    assert("Tensor range check" && 0 <= v154 && v154 < 4);
                                    int v468;
                                    v468 = 6144 * v154;
                                    method_23(v466, v468, v161);
                                    int * v469;
                                    v469 = reinterpret_cast<int *>(&v1[262144ull]);
                                    float * v471;
                                    v471 = reinterpret_cast<float *>(&v1[262160ull]);
                                    float * v473;
                                    v473 = reinterpret_cast<float *>(&v1[524304ull]);
                                    float * v475;
                                    v475 = reinterpret_cast<float *>(&v1[786448ull]);
                                    float * v477;
                                    v477 = reinterpret_cast<float *>(&v1[1048592ull]);
                                    float * v479;
                                    v479 = reinterpret_cast<float *>(&v1[1310736ull]);
                                    float * v481;
                                    v481 = reinterpret_cast<float *>(&v1[1572880ull]);
                                    float * v483;
                                    v483 = reinterpret_cast<float *>(&v1[1835024ull]);
                                    int * v485;
                                    v485 = reinterpret_cast<int *>(&v0[6389760ull]);
                                    float * v487;
                                    v487 = reinterpret_cast<float *>(&v0[7962624ull]);
                                    int * v489;
                                    v489 = reinterpret_cast<int *>(&v0[9535488ull]);
                                    int * v491;
                                    v491 = reinterpret_cast<int *>(&v0[11108352ull]);
                                    double * v493;
                                    v493 = reinterpret_cast<double *>(&v0[12681216ull]);
                                    double * v495;
                                    v495 = reinterpret_cast<double *>(&v0[18972672ull]);
                                    double * v497;
                                    v497 = reinterpret_cast<double *>(&v1[2097168ull]);
                                    double * v499;
                                    v499 = reinterpret_cast<double *>(&v1[2490384ull]);
                                    int * v501;
                                    v501 = reinterpret_cast<int *>(&v1[2883600ull]);
                                    v154 += 1 ;
                                }
                                __syncthreads();
                                int * v503;
                                v503 = reinterpret_cast<int *>(&v1[262144ull]);
                                float * v505;
                                v505 = reinterpret_cast<float *>(&v1[262160ull]);
                                float * v507;
                                v507 = reinterpret_cast<float *>(&v1[524304ull]);
                                float * v509;
                                v509 = reinterpret_cast<float *>(&v1[786448ull]);
                                float * v511;
                                v511 = reinterpret_cast<float *>(&v1[1048592ull]);
                                float * v513;
                                v513 = reinterpret_cast<float *>(&v1[1310736ull]);
                                float * v515;
                                v515 = reinterpret_cast<float *>(&v1[1572880ull]);
                                float * v517;
                                v517 = reinterpret_cast<float *>(&v1[1835024ull]);
                                int v519;
                                v519 = v503[0];
                                unsigned int * v520;
                                v520 = reinterpret_cast<unsigned int *>(&v0[6291456ull]);
                                int v522;
                                v522 = blockIdx.x;
                                int v523;
                                v523 = threadIdx.x;
                                assert("Tensor range check" && 0 <= v519 && v519 < 4);
                                assert("Tensor range check" && 0 <= v522 && v522 < 24);
                                assert("Tensor range check" && 0 <= v523 && v523 < 256);
                                int v524;
                                v524 = 256 * v522;
                                int v525;
                                v525 = v524 + v523;
                                int v526;
                                v526 = 6144 * v519;
                                int v527;
                                v527 = v526 + v525;
                                unsigned int v528;
                                v528 = v520[v527];
                                int v529;
                                v529 = (int)v528;
                                float v530; int v531;
                                Tuple8 tmp56 = method_24(v84, v503, v505, v507, v509, v511, v513, v515, v517, v529, v519);
                                v530 = tmp56.v0; v531 = tmp56.v1;
                                extern __shared__ unsigned char v532[];
                                float * v533;
                                v533 = reinterpret_cast<float *>(&v532[0ull]);
                                int * v535;
                                v535 = reinterpret_cast<int *>(&v532[16ull]);
                                int v537;
                                v537 = threadIdx.x;
                                bool v538;
                                v538 = v537 == 0;
                                if (v538){
                                    v533[0] = v530;
                                    v535[0] = v531;
                                } else {
                                }
                                __syncthreads();
                                float v539;
                                v539 = v533[0];
                                int v540;
                                v540 = v535[0];
                                __syncthreads();
                                double * v541;
                                v541 = reinterpret_cast<double *>(&v1[2097168ull]);
                                double * v543;
                                v543 = reinterpret_cast<double *>(&v1[2490384ull]);
                                int * v545;
                                v545 = reinterpret_cast<int *>(&v1[2883600ull]);
                                int * v547;
                                v547 = reinterpret_cast<int *>(&v0[6389760ull]);
                                float * v549;
                                v549 = reinterpret_cast<float *>(&v0[7962624ull]);
                                int * v551;
                                v551 = reinterpret_cast<int *>(&v0[9535488ull]);
                                int * v553;
                                v553 = reinterpret_cast<int *>(&v0[11108352ull]);
                                double * v555;
                                v555 = reinterpret_cast<double *>(&v0[12681216ull]);
                                double * v557;
                                v557 = reinterpret_cast<double *>(&v0[18972672ull]);
                                int v559;
                                v559 = threadIdx.x;
                                int v560;
                                v560 = blockIdx.x;
                                int v561;
                                v561 = v560 * 256;
                                int v562;
                                v562 = v559 + v561;
                                int v563;
                                v563 = 0;
                                while (while_method_9(v563)){
                                    unsigned int * v565;
                                    v565 = reinterpret_cast<unsigned int *>(&v0[6291456ull]);
                                    int v567;
                                    v567 = blockIdx.x;
                                    int v568;
                                    v568 = threadIdx.x;
                                    assert("Tensor range check" && 0 <= v563 && v563 < 4);
                                    assert("Tensor range check" && 0 <= v567 && v567 < 24);
                                    assert("Tensor range check" && 0 <= v568 && v568 < 256);
                                    int v569;
                                    v569 = 256 * v567;
                                    int v570;
                                    v570 = v569 + v568;
                                    int v571;
                                    v571 = 6144 * v563;
                                    int v572;
                                    v572 = v571 + v570;
                                    unsigned int v573;
                                    v573 = v565[v572];
                                    int v574;
                                    v574 = (int)v573;
                                    float v575;
                                    v575 = method_47(v503, v505, v507, v509, v511, v513, v515, v517, v574, v563, v540);
                                    assert("Tensor range check" && 0 <= v563 && v563 < 4);
                                    assert("Tensor range check" && 0 <= v562 && v562 < 6144);
                                    int v576;
                                    v576 = v571 + v562;
                                    int v577;
                                    v577 = v545[v576];
                                    int v578;
                                    v578 = v577 + 1;
                                    assert("Tensor range check" && 0 <= v563 && v563 < 4);
                                    assert("Tensor range check" && 0 <= v562 && v562 < 6144);
                                    v545[v576] = v578;
                                    assert("Tensor range check" && 0 <= v563 && v563 < 4);
                                    assert("Tensor range check" && 0 <= v577 && v577 < 16);
                                    assert("Tensor range check" && 0 <= v562 && v562 < 6144);
                                    int v579;
                                    v579 = 6144 * v577;
                                    int v580;
                                    v580 = v579 + v562;
                                    int v581;
                                    v581 = 98304 * v563;
                                    int v582;
                                    v582 = v581 + v580;
                                    v547[v582] = v540;
                                    v549[v582] = v539;
                                    v551[v582] = v70;
                                    v553[v582] = v574;
                                    assert("Tensor range check" && 0 <= v563 && v563 < 4);
                                    int v583;
                                    v583 = 12288 * v563;
                                    assert("Tensor range check" && 0 <= v562 && v562 < 6144);
                                    int v584;
                                    v584 = 2 * v562;
                                    int v585;
                                    v585 = v584 + v583;
                                    assert("Tensor range check" && 0 <= v563 && v563 < 4);
                                    int v586;
                                    v586 = 196608 * v563;
                                    assert("Tensor range check" && 0 <= v577 && v577 < 16);
                                    int v587;
                                    v587 = 12288 * v577;
                                    int v588;
                                    v588 = v587 + v586;
                                    assert("Tensor range check" && 0 <= v562 && v562 < 6144);
                                    int v589;
                                    v589 = v584 + v588;
                                    double * v590;
                                    v590 = v541+v585;
                                    double * v592;
                                    v592 = v543+v585;
                                    double * v594;
                                    v594 = v555+v589;
                                    double * v596;
                                    v596 = v557+v589;
                                    int v598;
                                    v598 = sizeof(double *);
                                    unsigned long long v599;
                                    v599 = (unsigned long long)v598;
                                    unsigned long long v600;
                                    v600 = 256ull * v599;
                                    unsigned long long v601;
                                    v601 = v600 + 16ull;
                                    unsigned long long v602;
                                    v602 = v601 - 1ull;
                                    unsigned long long v603;
                                    v603 = v602 % 16ull;
                                    unsigned long long v604;
                                    v604 = v602 - v603;
                                    unsigned long long v605;
                                    v605 = v604 + v600;
                                    unsigned long long v606;
                                    v606 = v605 + 16ull;
                                    unsigned long long v607;
                                    v607 = v606 - 1ull;
                                    unsigned long long v608;
                                    v608 = v607 % 16ull;
                                    unsigned long long v609;
                                    v609 = v607 - v608;
                                    unsigned long long v610;
                                    v610 = v609 + v600;
                                    unsigned long long v611;
                                    v611 = v610 + 16ull;
                                    unsigned long long v612;
                                    v612 = v611 - 1ull;
                                    unsigned long long v613;
                                    v613 = v612 % 16ull;
                                    unsigned long long v614;
                                    v614 = v612 - v613;
                                    unsigned long long v615;
                                    v615 = v614 + v600;
                                    bool v616;
                                    v616 = v615 <= 98304ull;
                                    bool v617;
                                    v617 = v616 == false;
                                    if (v617){
                                        assert("The dynamic shared memory is insufficient to allocate the tensor." && v616);
                                    } else {
                                    }
                                    extern __shared__ unsigned char v619[];
                                    bool v620;
                                    v620 = v615 <= v615;
                                    bool v621;
                                    v621 = v620 == false;
                                    if (v621){
                                        assert("The length of the partition has to be less than or equal to the length of the base array." && v620);
                                    } else {
                                    }
                                    double * * v623;
                                    v623 = reinterpret_cast<double * *>(&v619[0ull]);
                                    double * * v625;
                                    v625 = reinterpret_cast<double * *>(&v619[v604]);
                                    double * * v627;
                                    v627 = reinterpret_cast<double * *>(&v619[v609]);
                                    double * * v629;
                                    v629 = reinterpret_cast<double * *>(&v619[v614]);
                                    int v631;
                                    v631 = threadIdx.x;
                                    assert("Tensor range check" && 0 <= v631 && v631 < 256);
                                    v623[v631] = v590;
                                    v625[v631] = v592;
                                    v627[v631] = v594;
                                    v629[v631] = v596;
                                    __syncthreads();
                                    bool v632;
                                    v632 = 0 <= v631;
                                    bool v633;
                                    v633 = v632 == false;
                                    if (v633){
                                        assert("The index needs to be zero or positive." && v632);
                                    } else {
                                    }
                                    int v635;
                                    v635 = v631 % 1;
                                    bool v636;
                                    v636 = v631 < 256;
                                    bool v637;
                                    v637 = v636 == false;
                                    if (v637){
                                        assert("The last element of the projection dimensions needs to be greater than the index remainder." && v636);
                                    } else {
                                    }
                                    assert("Tensor range check" && 0 <= v631 && v631 < 256);
                                    int v639;
                                    v639 = 0;
                                    while (while_method_4(v639)){
                                        bool v641;
                                        v641 = v632 && v636;
                                        bool v642;
                                        v642 = v641 == false;
                                        if (v642){
                                            assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v641);
                                        } else {
                                        }
                                        bool v644;
                                        v644 = 0 <= v639;
                                        bool v646;
                                        if (v644){
                                            bool v645;
                                            v645 = v639 < 1;
                                            v646 = v645;
                                        } else {
                                            v646 = false;
                                        }
                                        bool v647;
                                        v647 = v646 == false;
                                        if (v647){
                                            assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v646);
                                        } else {
                                        }
                                        int v649;
                                        v649 = v639 * 256;
                                        int v650;
                                        v650 = v649 + v631;
                                        assert("Tensor range check" && 0 <= v639 && v639 < 1);
                                        int v651;
                                        v651 = 256 * v639;
                                        int v652;
                                        v652 = v651 + v631;
                                        double * v653;
                                        v653 = v623[v652];
                                        double * v654;
                                        v654 = v625[v652];
                                        double * v655;
                                        v655 = v627[v652];
                                        double * v656;
                                        v656 = v629[v652];
                                        int v657;
                                        v657 = blockIdx.x;
                                        int v658;
                                        v658 = v657 * 256;
                                        int v659;
                                        v659 = v658 + v650;
                                        assert("Tensor range check" && 0 <= v635 && v635 < 1);
                                        int v660;
                                        v660 = 2 * v635;
                                        double v661[2];
                                        double v662[2];
                                        int v663[2];
                                        int v664;
                                        v664 = 0;
                                        while (while_method_4(v664)){
                                            assert("Tensor range check" && 0 <= v664 && v664 < 1);
                                            int v666;
                                            v666 = 2 * v664;
                                            assert("Tensor range check" && 0 <= v664 && v664 < 1);
                                            int v667;
                                            v667 = v666 + v660;
                                            int4* v668;
                                            v668 = reinterpret_cast<int4*>(v653 + v667);
                                            int4* v669;
                                            v669 = reinterpret_cast<int4*>(v661 + v666);
                                            assert("Pointer alignment check" && (unsigned long long)(v668) % 2 == 0 && (unsigned long long)(v669) % 2 == 0);
                                            *v669 = *v668;
                                            int4* v670;
                                            v670 = reinterpret_cast<int4*>(v654 + v667);
                                            int4* v671;
                                            v671 = reinterpret_cast<int4*>(v662 + v666);
                                            assert("Pointer alignment check" && (unsigned long long)(v670) % 2 == 0 && (unsigned long long)(v671) % 2 == 0);
                                            *v671 = *v670;
                                            v664 += 1 ;
                                        }
                                        int v672;
                                        v672 = 0;
                                        while (while_method_4(v672)){
                                            int v674;
                                            v674 = 0;
                                            while (while_method_0(v674)){
                                                bool v676;
                                                v676 = 0 <= v674;
                                                bool v678;
                                                if (v676){
                                                    bool v677;
                                                    v677 = v674 < 2;
                                                    v678 = v677;
                                                } else {
                                                    v678 = false;
                                                }
                                                bool v679;
                                                v679 = v678 == false;
                                                if (v679){
                                                    assert("The indices should be inside the range of the dimension." && v678);
                                                } else {
                                                }
                                                bool v681;
                                                v681 = 0 <= v635;
                                                bool v683;
                                                if (v681){
                                                    bool v682;
                                                    v682 = v635 < 1;
                                                    v683 = v682;
                                                } else {
                                                    v683 = false;
                                                }
                                                bool v684;
                                                v684 = v683 == false;
                                                if (v684){
                                                    assert("The indices should be inside the range of the dimension." && v683);
                                                } else {
                                                }
                                                int v686;
                                                v686 = v635 * 2;
                                                int v687;
                                                v687 = v674 + v686;
                                                bool v688;
                                                v688 = 0 <= v672;
                                                bool v690;
                                                if (v688){
                                                    bool v689;
                                                    v689 = v672 < 1;
                                                    v690 = v689;
                                                } else {
                                                    v690 = false;
                                                }
                                                bool v691;
                                                v691 = v690 == false;
                                                if (v691){
                                                    assert("The indices should be inside the range of the dimension." && v690);
                                                } else {
                                                }
                                                int v693;
                                                v693 = v672 * 2;
                                                int v694;
                                                v694 = v687 + v693;
                                                assert("Tensor range check" && 0 <= v672 && v672 < 1);
                                                assert("Tensor range check" && 0 <= v674 && v674 < 2);
                                                int v695;
                                                v695 = 2 * v672;
                                                int v696;
                                                v696 = v695 + v674;
                                                v663[v696] = v694;
                                                v674 += 1 ;
                                            }
                                            v672 += 1 ;
                                        }
                                        int v697;
                                        v697 = 0;
                                        while (while_method_4(v697)){
                                            assert("Tensor range check" && 0 <= v697 && v697 < 1);
                                            int v699;
                                            v699 = 2 * v697;
                                            int v700;
                                            v700 = v699 + v660;
                                            assert("Tensor range check" && 0 <= v697 && v697 < 1);
                                            int4* v701;
                                            v701 = reinterpret_cast<int4*>(v661 + v699);
                                            int4* v702;
                                            v702 = reinterpret_cast<int4*>(v655 + v700);
                                            assert("Pointer alignment check" && (unsigned long long)(v701) % 2 == 0 && (unsigned long long)(v702) % 2 == 0);
                                            *v702 = *v701;
                                            int4* v703;
                                            v703 = reinterpret_cast<int4*>(v662 + v699);
                                            int4* v704;
                                            v704 = reinterpret_cast<int4*>(v656 + v700);
                                            assert("Pointer alignment check" && (unsigned long long)(v703) % 2 == 0 && (unsigned long long)(v704) % 2 == 0);
                                            *v704 = *v703;
                                            v697 += 1 ;
                                        }
                                        assert("Tensor range check" && 0 <= v650 && v650 < 256);
                                        v639 += 1 ;
                                    }
                                    __syncthreads();
                                    assert("Tensor range check" && 0 <= v631 && v631 < 256);
                                    __syncthreads();
                                    double v705;
                                    v705 = (double)v539;
                                    double v706;
                                    v706 = log(v705);
                                    double v707;
                                    v707 = (double)v575;
                                    double v708;
                                    v708 = log(v707);
                                    assert("Tensor range check" && 0 <= v563 && v563 < 4);
                                    assert("Tensor range check" && 0 <= v562 && v562 < 6144);
                                    assert("Tensor range check" && 0 <= v70 && v70 < 2);
                                    int v709;
                                    v709 = v584 + v70;
                                    int v710;
                                    v710 = v583 + v709;
                                    double v711;
                                    v711 = v541[v710];
                                    double v712;
                                    v712 = v543[v710];
                                    double v713;
                                    v713 = v708 + v711;
                                    double v714;
                                    v714 = v706 + v712;
                                    assert("Tensor range check" && 0 <= v563 && v563 < 4);
                                    assert("Tensor range check" && 0 <= v562 && v562 < 6144);
                                    assert("Tensor range check" && 0 <= v70 && v70 < 2);
                                    v541[v710] = v713;
                                    v543[v710] = v714;
                                    v563 += 1 ;
                                }
                                bool v715;
                                v715 = 0 == v540;
                                Union12 v724;
                                if (v715){
                                    v724 = Union12{Union12_1{}};
                                } else {
                                    bool v717;
                                    v717 = 1 == v540;
                                    if (v717){
                                        v724 = Union12{Union12_0{}};
                                    } else {
                                        bool v719;
                                        v719 = 2 == v540;
                                        if (v719){
                                            v724 = Union12{Union12_2{}};
                                        } else {
                                            printf("%s\n", "Invalid output id in the Leduc model.");
                                            __trap();
                                        }
                                    }
                                }
                                switch (v724.tag) {
                                    case 0: { // AA_Call
                                        v799 = Union1{Union1_0{}};
                                        break;
                                    }
                                    case 1: { // AA_Fold
                                        int v725;
                                        v725 = v71[0];
                                        int v727; int v728;
                                        Tuple7 tmp57 = Tuple7{1, v725};
                                        v727 = tmp57.v0; v728 = tmp57.v1;
                                        while (while_method_0(v727)){
                                            bool v730;
                                            v730 = 0 <= v727;
                                            bool v732;
                                            if (v730){
                                                bool v731;
                                                v731 = v727 < 2;
                                                v732 = v731;
                                            } else {
                                                v732 = false;
                                            }
                                            bool v733;
                                            v733 = v732 == false;
                                            if (v733){
                                                assert("Index must be in range." && v732);
                                            } else {
                                            }
                                            int v735;
                                            v735 = v71[v727];
                                            bool v737;
                                            v737 = v728 >= v735;
                                            int v738;
                                            if (v737){
                                                v738 = v728;
                                            } else {
                                                v738 = v735;
                                            }
                                            v728 = v738;
                                            v727 += 1 ;
                                        }
                                        bool v740;
                                        if (v74){
                                            bool v739;
                                            v739 = v70 < 2;
                                            v740 = v739;
                                        } else {
                                            v740 = false;
                                        }
                                        bool v741;
                                        v741 = v740 == false;
                                        if (v741){
                                            assert("Index must be in range." && v740);
                                        } else {
                                        }
                                        int v743;
                                        v743 = v71[v70];
                                        bool v745;
                                        v745 = v743 == v728;
                                        if (v745){
                                            v799 = Union1{Union1_0{}};
                                        } else {
                                            v799 = Union1{Union1_1{}};
                                        }
                                        break;
                                    }
                                    case 2: { // AA_Raise
                                        bool v750;
                                        v750 = v72 > 0;
                                        if (v750){
                                            v799 = Union1{Union1_2{}};
                                        } else {
                                            v799 = Union1{Union1_0{}};
                                        }
                                        break;
                                    }
                                    default: {
                                        assert("Invalid tag." && false); __trap();
                                    }
                                }
                                break;
                            }
                            case 1: { // Human
                                printf("%s\n", "Humans aren't allowed during training.");
                                __trap();
                                break;
                            }
                            case 2: { // Random
                                curandStatePhilox4_32_10_t & v757 = v2.v5;
                                curandStatePhilox4_32_10_t & v758 = v757;
                                static_array_list<Union1,3> v759;
                                v759 = static_array_list<Union1,3>{};
                                v759.unsafe_set_length(1);
                                Union1 v761;
                                v761 = Union1{Union1_0{}};
                                v759[0] = v761;
                                int v763;
                                v763 = v71[0];
                                int v765;
                                v765 = v71[1];
                                bool v767;
                                v767 = v763 == v765;
                                bool v768;
                                v768 = v767 != true;
                                if (v768){
                                    Union1 v769;
                                    v769 = Union1{Union1_1{}};
                                    v759.push(v769);
                                } else {
                                }
                                bool v770;
                                v770 = v72 > 0;
                                if (v770){
                                    Union1 v771;
                                    v771 = Union1{Union1_2{}};
                                    v759.push(v771);
                                } else {
                                }
                                int v772;
                                v772 = v759.length;
                                int v773;
                                v773 = v772 - 1;
                                int v774;
                                v774 = 0;
                                while (while_method_1(v773, v774)){
                                    int v776;
                                    v776 = v759.length;
                                    int v777;
                                    v777 = int_range_22(v776, v774, v758);
                                    Union1 v778;
                                    v778 = v759[v774];
                                    Union1 v780;
                                    v780 = v759[v777];
                                    v759[v774] = v780;
                                    v759[v777] = v778;
                                    v774 += 1 ;
                                }
                                Union1 v782;
                                v782 = v759.pop();
                                int v783;
                                v783 = sizeof(Union1);
                                unsigned long long v784;
                                v784 = (unsigned long long)v783;
                                bool v785;
                                v785 = v784 <= 98304ull;
                                bool v786;
                                v786 = v785 == false;
                                if (v786){
                                    assert("The dynamic shared memory is insufficient to allocate the tensor." && v785);
                                } else {
                                }
                                extern __shared__ unsigned char v788[];
                                bool v789;
                                v789 = v784 <= v784;
                                bool v790;
                                v790 = v789 == false;
                                if (v790){
                                    assert("The length of the partition has to be less than or equal to the length of the base array." && v789);
                                } else {
                                }
                                Union1 * v792;
                                v792 = reinterpret_cast<Union1 *>(&v788[0ull]);
                                int v794;
                                v794 = threadIdx.x;
                                bool v795;
                                v795 = v794 == 0;
                                if (v795){
                                    v792[0] = v782;
                                } else {
                                }
                                __syncthreads();
                                Union1 v796;
                                v796 = v792[0];
                                __syncthreads();
                                v799 = v796;
                                break;
                            }
                            default: {
                                assert("Invalid tag." && false); __trap();
                            }
                        }
                        Union7 v800;
                        v800 = Union7{Union7_1{v70, v799}};
                        v13.push(v800);
                        v842 = Union14{Union14_2{v67, v68, v69, v70, v71, v72, v799}};
                        break;
                    }
                    case 3: { // RoundWithAction
                        Union5 v802 = v17.case3.v0; bool v803 = v17.case3.v1; static_array<Union6,2> v804 = v17.case3.v2; int v805 = v17.case3.v3; static_array<int,2> v806 = v17.case3.v4; int v807 = v17.case3.v5; Union1 v808 = v17.case3.v6;
                        Union7 v809;
                        v809 = Union7{Union7_1{v805, v808}};
                        v13.push(v809);
                        v842 = Union14{Union14_2{v802, v803, v804, v805, v806, v807, v808}};
                        break;
                    }
                    case 4: { // TerminalCall
                        Union5 v38 = v17.case4.v0; bool v39 = v17.case4.v1; static_array<Union6,2> v40 = v17.case4.v2; int v41 = v17.case4.v3; static_array<int,2> v42 = v17.case4.v4; int v43 = v17.case4.v5;
                        bool v44;
                        v44 = 0 <= v41;
                        bool v46;
                        if (v44){
                            bool v45;
                            v45 = v41 < 2;
                            v46 = v45;
                        } else {
                            v46 = false;
                        }
                        bool v47;
                        v47 = v46 == false;
                        if (v47){
                            assert("Index must be in range." && v46);
                        } else {
                        }
                        int v49;
                        v49 = v42[v41];
                        Union13 v51;
                        v51 = compare_hands_25(v38, v39, v40, v41, v42, v43);
                        int v56; int v57;
                        switch (v51.tag) {
                            case 0: { // Eq
                                v56 = 0; v57 = -1;
                                break;
                            }
                            case 1: { // Gt
                                v56 = v49; v57 = 0;
                                break;
                            }
                            case 2: { // Lt
                                v56 = v49; v57 = 1;
                                break;
                            }
                            default: {
                                assert("Invalid tag." && false); __trap();
                            }
                        }
                        int v58;
                        v58 = -v57;
                        bool v59;
                        v59 = v57 >= v58;
                        int v60;
                        if (v59){
                            v60 = v57;
                        } else {
                            v60 = v58;
                        }
                        float v61;
                        v61 = (float)v56;
                        static_array<float,2> & v62 = v2.v4;
                        v62[v60] = v61;
                        int v63;
                        v63 = v60 ^ 1;
                        float v64;
                        v64 = -v61;
                        v62[v63] = v64;
                        Union7 v65;
                        v65 = Union7{Union7_3{v40, v56, v57}};
                        v13.push(v65);
                        v842 = Union14{Union14_3{}};
                        break;
                    }
                    case 5: { // TerminalFold
                        Union5 v18 = v17.case5.v0; bool v19 = v17.case5.v1; static_array<Union6,2> v20 = v17.case5.v2; int v21 = v17.case5.v3; static_array<int,2> v22 = v17.case5.v4; int v23 = v17.case5.v5;
                        bool v24;
                        v24 = 0 <= v21;
                        bool v26;
                        if (v24){
                            bool v25;
                            v25 = v21 < 2;
                            v26 = v25;
                        } else {
                            v26 = false;
                        }
                        bool v27;
                        v27 = v26 == false;
                        if (v27){
                            assert("Index must be in range." && v26);
                        } else {
                        }
                        int v29;
                        v29 = v22[v21];
                        int v31;
                        v31 = -v29;
                        float v32;
                        v32 = (float)v31;
                        static_array<float,2> & v33 = v2.v4;
                        v33[v21] = v32;
                        int v34;
                        v34 = v21 ^ 1;
                        float v35;
                        v35 = -v32;
                        v33[v34] = v35;
                        Union7 v36;
                        v36 = Union7{Union7_3{v20, v29, v34}};
                        v13.push(v36);
                        v842 = Union14{Union14_3{}};
                        break;
                    }
                    default: {
                        assert("Invalid tag." && false); __trap();
                    }
                }
                switch (v842.tag) {
                    case 0: { // T_game_chance_community_card
                        Union5 v844 = v842.case0.v0; bool v845 = v842.case0.v1; static_array<Union6,2> v846 = v842.case0.v2; int v847 = v842.case0.v3; static_array<int,2> v848 = v842.case0.v4; int v849 = v842.case0.v5; Union6 v850 = v842.case0.v6;
                        int v851;
                        v851 = 2;
                        int v852; int v853;
                        Tuple7 tmp58 = Tuple7{0, 0};
                        v852 = tmp58.v0; v853 = tmp58.v1;
                        while (while_method_0(v852)){
                            bool v855;
                            v855 = 0 <= v852;
                            bool v857;
                            if (v855){
                                bool v856;
                                v856 = v852 < 2;
                                v857 = v856;
                            } else {
                                v857 = false;
                            }
                            bool v858;
                            v858 = v857 == false;
                            if (v858){
                                assert("Index must be in range." && v857);
                            } else {
                            }
                            int v860;
                            v860 = v848[v852];
                            bool v862;
                            v862 = v853 >= v860;
                            int v863;
                            if (v862){
                                v863 = v853;
                            } else {
                                v863 = v860;
                            }
                            v853 = v863;
                            v852 += 1 ;
                        }
                        static_array<int,2> v864;
                        int v866;
                        v866 = 0;
                        while (while_method_0(v866)){
                            v864[v866] = v853;
                            v866 += 1 ;
                        }
                        Union5 v868;
                        v868 = Union5{Union5_1{v850}};
                        Union4 v869;
                        v869 = Union4{Union4_2{v868, true, v846, 0, v864, v851}};
                        v1002 = Union3{Union3_1{v869}};
                        break;
                    }
                    case 1: { // T_game_chance_init
                        Union6 v871 = v842.case1.v0; Union6 v872 = v842.case1.v1;
                        int v873;
                        v873 = 2;
                        static_array<int,2> v874;
                        v874[0] = 1;
                        v874[1] = 1;
                        static_array<Union6,2> v876;
                        v876[0] = v871;
                        v876[1] = v872;
                        Union5 v878;
                        v878 = Union5{Union5_0{}};
                        Union4 v879;
                        v879 = Union4{Union4_2{v878, true, v876, 0, v874, v873}};
                        v1002 = Union3{Union3_1{v879}};
                        break;
                    }
                    case 2: { // T_game_round
                        Union5 v881 = v842.case2.v0; bool v882 = v842.case2.v1; static_array<Union6,2> v883 = v842.case2.v2; int v884 = v842.case2.v3; static_array<int,2> v885 = v842.case2.v4; int v886 = v842.case2.v5; Union1 v887 = v842.case2.v6;
                        Union4 v994;
                        switch (v881.tag) {
                            case 0: { // None
                                switch (v887.tag) {
                                    case 0: { // Call
                                        if (v882){
                                            int v950;
                                            v950 = v884 ^ 1;
                                            v994 = Union4{Union4_2{v881, false, v883, v950, v885, v886}};
                                        } else {
                                            v994 = Union4{Union4_0{v881, v882, v883, v884, v885, v886}};
                                        }
                                        break;
                                    }
                                    case 1: { // Fold
                                        v994 = Union4{Union4_5{v881, v882, v883, v884, v885, v886}};
                                        break;
                                    }
                                    case 2: { // Raise
                                        bool v954;
                                        v954 = v886 > 0;
                                        if (v954){
                                            int v955;
                                            v955 = v884 ^ 1;
                                            int v956;
                                            v956 = -1 + v886;
                                            int v957; int v958;
                                            Tuple7 tmp59 = Tuple7{0, 0};
                                            v957 = tmp59.v0; v958 = tmp59.v1;
                                            while (while_method_0(v957)){
                                                bool v960;
                                                v960 = 0 <= v957;
                                                bool v962;
                                                if (v960){
                                                    bool v961;
                                                    v961 = v957 < 2;
                                                    v962 = v961;
                                                } else {
                                                    v962 = false;
                                                }
                                                bool v963;
                                                v963 = v962 == false;
                                                if (v963){
                                                    assert("Index must be in range." && v962);
                                                } else {
                                                }
                                                int v965;
                                                v965 = v885[v957];
                                                bool v967;
                                                v967 = v958 >= v965;
                                                int v968;
                                                if (v967){
                                                    v968 = v958;
                                                } else {
                                                    v968 = v965;
                                                }
                                                v958 = v968;
                                                v957 += 1 ;
                                            }
                                            static_array<int,2> v969;
                                            int v971;
                                            v971 = 0;
                                            while (while_method_0(v971)){
                                                v969[v971] = v958;
                                                v971 += 1 ;
                                            }
                                            static_array<int,2> v973;
                                            int v975;
                                            v975 = 0;
                                            while (while_method_0(v975)){
                                                bool v977;
                                                v977 = 0 <= v975;
                                                bool v979;
                                                if (v977){
                                                    bool v978;
                                                    v978 = v975 < 2;
                                                    v979 = v978;
                                                } else {
                                                    v979 = false;
                                                }
                                                bool v980;
                                                v980 = v979 == false;
                                                if (v980){
                                                    assert("Index must be in range." && v979);
                                                } else {
                                                }
                                                int v982;
                                                v982 = v969[v975];
                                                bool v984;
                                                v984 = v975 == v884;
                                                int v986;
                                                if (v984){
                                                    int v985;
                                                    v985 = v982 + 2;
                                                    v986 = v985;
                                                } else {
                                                    v986 = v982;
                                                }
                                                v973[v975] = v986;
                                                v975 += 1 ;
                                            }
                                            v994 = Union4{Union4_2{v881, false, v883, v955, v973, v956}};
                                        } else {
                                            printf("%s\n", "Invalid action. The number of raises left is not positive.");
                                            __trap();
                                        }
                                        break;
                                    }
                                    default: {
                                        assert("Invalid tag." && false); __trap();
                                    }
                                }
                                break;
                            }
                            case 1: { // Some
                                Union6 v888 = v881.case1.v0;
                                switch (v887.tag) {
                                    case 0: { // Call
                                        if (v882){
                                            int v890;
                                            v890 = v884 ^ 1;
                                            v994 = Union4{Union4_2{v881, false, v883, v890, v885, v886}};
                                        } else {
                                            int v892; int v893;
                                            Tuple7 tmp60 = Tuple7{0, 0};
                                            v892 = tmp60.v0; v893 = tmp60.v1;
                                            while (while_method_0(v892)){
                                                bool v895;
                                                v895 = 0 <= v892;
                                                bool v897;
                                                if (v895){
                                                    bool v896;
                                                    v896 = v892 < 2;
                                                    v897 = v896;
                                                } else {
                                                    v897 = false;
                                                }
                                                bool v898;
                                                v898 = v897 == false;
                                                if (v898){
                                                    assert("Index must be in range." && v897);
                                                } else {
                                                }
                                                int v900;
                                                v900 = v885[v892];
                                                bool v902;
                                                v902 = v893 >= v900;
                                                int v903;
                                                if (v902){
                                                    v903 = v893;
                                                } else {
                                                    v903 = v900;
                                                }
                                                v893 = v903;
                                                v892 += 1 ;
                                            }
                                            static_array<int,2> v904;
                                            int v906;
                                            v906 = 0;
                                            while (while_method_0(v906)){
                                                v904[v906] = v893;
                                                v906 += 1 ;
                                            }
                                            v994 = Union4{Union4_4{v881, v882, v883, v884, v904, v886}};
                                        }
                                        break;
                                    }
                                    case 1: { // Fold
                                        v994 = Union4{Union4_5{v881, v882, v883, v884, v885, v886}};
                                        break;
                                    }
                                    case 2: { // Raise
                                        bool v910;
                                        v910 = v886 > 0;
                                        if (v910){
                                            int v911;
                                            v911 = v884 ^ 1;
                                            int v912;
                                            v912 = -1 + v886;
                                            int v913; int v914;
                                            Tuple7 tmp61 = Tuple7{0, 0};
                                            v913 = tmp61.v0; v914 = tmp61.v1;
                                            while (while_method_0(v913)){
                                                bool v916;
                                                v916 = 0 <= v913;
                                                bool v918;
                                                if (v916){
                                                    bool v917;
                                                    v917 = v913 < 2;
                                                    v918 = v917;
                                                } else {
                                                    v918 = false;
                                                }
                                                bool v919;
                                                v919 = v918 == false;
                                                if (v919){
                                                    assert("Index must be in range." && v918);
                                                } else {
                                                }
                                                int v921;
                                                v921 = v885[v913];
                                                bool v923;
                                                v923 = v914 >= v921;
                                                int v924;
                                                if (v923){
                                                    v924 = v914;
                                                } else {
                                                    v924 = v921;
                                                }
                                                v914 = v924;
                                                v913 += 1 ;
                                            }
                                            static_array<int,2> v925;
                                            int v927;
                                            v927 = 0;
                                            while (while_method_0(v927)){
                                                v925[v927] = v914;
                                                v927 += 1 ;
                                            }
                                            static_array<int,2> v929;
                                            int v931;
                                            v931 = 0;
                                            while (while_method_0(v931)){
                                                bool v933;
                                                v933 = 0 <= v931;
                                                bool v935;
                                                if (v933){
                                                    bool v934;
                                                    v934 = v931 < 2;
                                                    v935 = v934;
                                                } else {
                                                    v935 = false;
                                                }
                                                bool v936;
                                                v936 = v935 == false;
                                                if (v936){
                                                    assert("Index must be in range." && v935);
                                                } else {
                                                }
                                                int v938;
                                                v938 = v925[v931];
                                                bool v940;
                                                v940 = v931 == v884;
                                                int v942;
                                                if (v940){
                                                    int v941;
                                                    v941 = v938 + 4;
                                                    v942 = v941;
                                                } else {
                                                    v942 = v938;
                                                }
                                                v929[v931] = v942;
                                                v931 += 1 ;
                                            }
                                            v994 = Union4{Union4_2{v881, false, v883, v911, v929, v912}};
                                        } else {
                                            printf("%s\n", "Invalid action. The number of raises left is not positive.");
                                            __trap();
                                        }
                                        break;
                                    }
                                    default: {
                                        assert("Invalid tag." && false); __trap();
                                    }
                                }
                                break;
                            }
                            default: {
                                assert("Invalid tag." && false); __trap();
                            }
                        }
                        v1002 = Union3{Union3_1{v994}};
                        break;
                    }
                    case 3: { // T_none
                        v1002 = Union3{Union3_0{}};
                        break;
                    }
                    default: {
                        assert("Invalid tag." && false); __trap();
                    }
                }
                break;
            }
            default: {
                assert("Invalid tag." && false); __trap();
            }
        }
        v15 = v1002;
    }
    return ;
}
__device__ float method_50(int * v0, float * v1, float * v2, float * v3, float * v4, float * v5, float * v6, float * v7, int v8, int v9, int v10){
    assert("Tensor range check" && 0 <= v9 && v9 < 4);
    int v11;
    v11 = 16384 * v9;
    assert("Tensor range check" && 0 <= v8 && v8 < 4096);
    int v12;
    v12 = 4 * v8;
    int v13;
    v13 = v12 + v11;
    float * v14;
    v14 = v1+v13;
    int v16;
    v16 = sizeof(float *);
    unsigned long long v17;
    v17 = (unsigned long long)v16;
    unsigned long long v18;
    v18 = 256ull * v17;
    unsigned long long v19;
    v19 = 1024ull + v18;
    unsigned long long v20;
    v20 = v19 + 16ull;
    unsigned long long v21;
    v21 = v20 - 1ull;
    unsigned long long v22;
    v22 = v21 % 16ull;
    unsigned long long v23;
    v23 = v21 - v22;
    unsigned long long v24;
    v24 = v23 + 1024ull;
    bool v25;
    v25 = v24 <= 98304ull;
    bool v26;
    v26 = v25 == false;
    if (v26){
        assert("The dynamic shared memory is insufficient to allocate the tensor." && v25);
    } else {
    }
    extern __shared__ unsigned char v28[];
    bool v29;
    v29 = v24 <= v24;
    bool v30;
    v30 = v29 == false;
    if (v30){
        assert("The length of the partition has to be less than or equal to the length of the base array." && v29);
    } else {
    }
    int * v32;
    v32 = reinterpret_cast<int *>(&v28[0ull]);
    float * * v34;
    v34 = reinterpret_cast<float * *>(&v28[1024ull]);
    float * v36;
    v36 = reinterpret_cast<float *>(&v28[v23]);
    int v38;
    v38 = threadIdx.x;
    assert("Tensor range check" && 0 <= v38 && v38 < 256);
    v32[v38] = v10;
    v34[v38] = v14;
    __syncthreads();
    bool v39;
    v39 = 0 <= v38;
    bool v40;
    v40 = v39 == false;
    if (v40){
        assert("The index needs to be zero or positive." && v39);
    } else {
    }
    int v42;
    v42 = v38 % 1;
    bool v43;
    v43 = v38 < 256;
    bool v44;
    v44 = v43 == false;
    if (v44){
        assert("The last element of the projection dimensions needs to be greater than the index remainder." && v43);
    } else {
    }
    assert("Tensor range check" && 0 <= v38 && v38 < 256);
    int v46;
    v46 = 0;
    while (while_method_4(v46)){
        bool v48;
        v48 = v39 && v43;
        bool v49;
        v49 = v48 == false;
        if (v49){
            assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v48);
        } else {
        }
        bool v51;
        v51 = 0 <= v46;
        bool v53;
        if (v51){
            bool v52;
            v52 = v46 < 1;
            v53 = v52;
        } else {
            v53 = false;
        }
        bool v54;
        v54 = v53 == false;
        if (v54){
            assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v53);
        } else {
        }
        int v56;
        v56 = v46 * 256;
        int v57;
        v57 = v56 + v38;
        assert("Tensor range check" && 0 <= v46 && v46 < 1);
        int v58;
        v58 = 256 * v46;
        int v59;
        v59 = v58 + v38;
        int v60;
        v60 = v32[v59];
        float * v61;
        v61 = v34[v59];
        int v62;
        v62 = blockIdx.x;
        int v63;
        v63 = v62 * 256;
        int v64;
        v64 = v63 + v57;
        assert("Tensor range check" && 0 <= v42 && v42 < 1);
        int v65;
        v65 = 4 * v42;
        float v66[4];
        int v67[4];
        int v68;
        v68 = 0;
        while (while_method_4(v68)){
            assert("Tensor range check" && 0 <= v68 && v68 < 1);
            int v70;
            v70 = 4 * v68;
            assert("Tensor range check" && 0 <= v68 && v68 < 1);
            int v71;
            v71 = v70 + v65;
            int4* v72;
            v72 = reinterpret_cast<int4*>(v61 + v71);
            int4* v73;
            v73 = reinterpret_cast<int4*>(v66 + v70);
            assert("Pointer alignment check" && (unsigned long long)(v72) % 4 == 0 && (unsigned long long)(v73) % 4 == 0);
            *v73 = *v72;
            v68 += 1 ;
        }
        int v74;
        v74 = 0;
        while (while_method_4(v74)){
            int v76;
            v76 = 0;
            while (while_method_9(v76)){
                bool v78;
                v78 = 0 <= v76;
                bool v80;
                if (v78){
                    bool v79;
                    v79 = v76 < 4;
                    v80 = v79;
                } else {
                    v80 = false;
                }
                bool v81;
                v81 = v80 == false;
                if (v81){
                    assert("The indices should be inside the range of the dimension." && v80);
                } else {
                }
                bool v83;
                v83 = 0 <= v42;
                bool v85;
                if (v83){
                    bool v84;
                    v84 = v42 < 1;
                    v85 = v84;
                } else {
                    v85 = false;
                }
                bool v86;
                v86 = v85 == false;
                if (v86){
                    assert("The indices should be inside the range of the dimension." && v85);
                } else {
                }
                int v88;
                v88 = v42 * 4;
                int v89;
                v89 = v76 + v88;
                bool v90;
                v90 = 0 <= v74;
                bool v92;
                if (v90){
                    bool v91;
                    v91 = v74 < 1;
                    v92 = v91;
                } else {
                    v92 = false;
                }
                bool v93;
                v93 = v92 == false;
                if (v93){
                    assert("The indices should be inside the range of the dimension." && v92);
                } else {
                }
                int v95;
                v95 = v74 * 4;
                int v96;
                v96 = v89 + v95;
                assert("Tensor range check" && 0 <= v74 && v74 < 1);
                assert("Tensor range check" && 0 <= v76 && v76 < 4);
                int v97;
                v97 = 4 * v74;
                int v98;
                v98 = v97 + v76;
                v67[v98] = v96;
                v76 += 1 ;
            }
            v74 += 1 ;
        }
        bool v99[4];
        int v100;
        v100 = 0;
        while (while_method_4(v100)){
            int v102;
            v102 = 0;
            while (while_method_9(v102)){
                assert("Tensor range check" && 0 <= v100 && v100 < 1);
                assert("Tensor range check" && 0 <= v102 && v102 < 4);
                int v104;
                v104 = 4 * v100;
                int v105;
                v105 = v104 + v102;
                float v106;
                v106 = v66[v105];
                int v107;
                v107 = v67[v105];
                bool v108;
                v108 = v107 < 3;
                assert("Tensor range check" && 0 <= v100 && v100 < 1);
                assert("Tensor range check" && 0 <= v102 && v102 < 4);
                v99[v105] = v108;
                v102 += 1 ;
            }
            v100 += 1 ;
        }
        float v109[4];
        int v110;
        v110 = 0;
        while (while_method_4(v110)){
            int v112;
            v112 = 0;
            while (while_method_9(v112)){
                assert("Tensor range check" && 0 <= v110 && v110 < 1);
                assert("Tensor range check" && 0 <= v112 && v112 < 4);
                int v114;
                v114 = 4 * v110;
                int v115;
                v115 = v114 + v112;
                float v116;
                v116 = v66[v115];
                bool v117;
                v117 = v99[v115];
                float v120;
                if (v117){
                    bool v118;
                    v118 = 0.0f >= v116;
                    if (v118){
                        v120 = 0.0f;
                    } else {
                        v120 = v116;
                    }
                } else {
                    v120 = 0.0f;
                }
                assert("Tensor range check" && 0 <= v110 && v110 < 1);
                assert("Tensor range check" && 0 <= v112 && v112 < 4);
                v109[v115] = v120;
                v112 += 1 ;
            }
            v110 += 1 ;
        }
        float v121;
        v121 = 0.0f;
        int v122;
        v122 = 0;
        while (while_method_4(v122)){
            int v124;
            v124 = 0;
            while (while_method_9(v124)){
                assert("Tensor range check" && 0 <= v122 && v122 < 1);
                assert("Tensor range check" && 0 <= v124 && v124 < 4);
                int v126;
                v126 = 4 * v122;
                int v127;
                v127 = v126 + v124;
                float v128;
                v128 = v109[v127];
                float v129;
                v129 = v121 + v128;
                v121 = v129;
                v124 += 1 ;
            }
            v122 += 1 ;
        }
        auto v130 = cooperative_groups::coalesced_threads();
        int v131;
        v131 = threadIdx.x;
        auto v132 = cooperative_groups::labeled_partition(v130,v131);
        Closure1 v133{};
        float v134;
        v134 = cooperative_groups::reduce(v132, v121, v133);
        int v135[4];
        int v136;
        v136 = 0;
        while (while_method_4(v136)){
            int v138;
            v138 = 0;
            while (while_method_9(v138)){
                assert("Tensor range check" && 0 <= v136 && v136 < 1);
                assert("Tensor range check" && 0 <= v138 && v138 < 4);
                int v140;
                v140 = 4 * v136;
                int v141;
                v141 = v140 + v138;
                bool v142;
                v142 = v99[v141];
                int v143;
                if (v142){
                    v143 = 1;
                } else {
                    v143 = 0;
                }
                assert("Tensor range check" && 0 <= v136 && v136 < 1);
                assert("Tensor range check" && 0 <= v138 && v138 < 4);
                v135[v141] = v143;
                v138 += 1 ;
            }
            v136 += 1 ;
        }
        int v144;
        v144 = 0;
        int v145;
        v145 = 0;
        while (while_method_4(v145)){
            int v147;
            v147 = 0;
            while (while_method_9(v147)){
                assert("Tensor range check" && 0 <= v145 && v145 < 1);
                assert("Tensor range check" && 0 <= v147 && v147 < 4);
                int v149;
                v149 = 4 * v145;
                int v150;
                v150 = v149 + v147;
                int v151;
                v151 = v135[v150];
                int v152;
                v152 = v144 + v151;
                v144 = v152;
                v147 += 1 ;
            }
            v145 += 1 ;
        }
        auto v153 = cooperative_groups::coalesced_threads();
        int v154;
        v154 = threadIdx.x;
        auto v155 = cooperative_groups::labeled_partition(v153,v154);
        Closure2 v156{};
        int v157;
        v157 = cooperative_groups::reduce(v155, v144, v156);
        float v158;
        v158 = (float)v157;
        float v159;
        v159 = 1.0f / v158;
        float v160[4];
        int v161;
        v161 = 0;
        while (while_method_4(v161)){
            int v163;
            v163 = 0;
            while (while_method_9(v163)){
                assert("Tensor range check" && 0 <= v161 && v161 < 1);
                assert("Tensor range check" && 0 <= v163 && v163 < 4);
                int v165;
                v165 = 4 * v161;
                int v166;
                v166 = v165 + v163;
                float v167;
                v167 = v109[v166];
                bool v168;
                v168 = v99[v166];
                bool v169;
                v169 = v168 == false;
                float v174;
                if (v169){
                    v174 = 0.0f;
                } else {
                    bool v170;
                    v170 = v134 == 0.0f;
                    bool v171;
                    v171 = v170 != true;
                    if (v171){
                        float v172;
                        v172 = v167 / v134;
                        v174 = v172;
                    } else {
                        v174 = v159;
                    }
                }
                assert("Tensor range check" && 0 <= v161 && v161 < 1);
                assert("Tensor range check" && 0 <= v163 && v163 < 4);
                v160[v166] = v174;
                v163 += 1 ;
            }
            v161 += 1 ;
        }
        float v175; int v176;
        Tuple8 tmp66 = Tuple8{0.0f, 2147483647};
        v175 = tmp66.v0; v176 = tmp66.v1;
        int v177;
        v177 = 0;
        while (while_method_4(v177)){
            int v179;
            v179 = 0;
            while (while_method_9(v179)){
                assert("Tensor range check" && 0 <= v177 && v177 < 1);
                assert("Tensor range check" && 0 <= v179 && v179 < 4);
                int v181;
                v181 = 4 * v177;
                int v182;
                v182 = v181 + v179;
                float v183;
                v183 = v160[v182];
                int v184;
                v184 = v67[v182];
                bool v185;
                v185 = v176 == v60;
                float v189; int v190;
                if (v185){
                    v189 = v175; v190 = v176;
                } else {
                    bool v186;
                    v186 = v184 == v60;
                    if (v186){
                        v189 = v183; v190 = v184;
                    } else {
                        v189 = v175; v190 = v176;
                    }
                }
                v175 = v189;
                v176 = v190;
                v179 += 1 ;
            }
            v177 += 1 ;
        }
        auto v191 = cooperative_groups::coalesced_threads();
        int v192;
        v192 = threadIdx.x;
        auto v193 = cooperative_groups::labeled_partition(v191,v192);
        Closure7 v194{v60};
        float v195; int v196;
        Tuple8 tmp67 = cooperative_groups::reduce(v193, Tuple8{v175, v176}, v194);
        v195 = tmp67.v0; v196 = tmp67.v1;
        bool v197;
        v197 = v196 == 2147483647;
        bool v198;
        v198 = v197 != true;
        bool v199;
        v199 = v198 == false;
        if (v199){
            assert("Expected a valid action id in get_prob." && v198);
        } else {
        }
        int v201;
        v201 = 0;
        while (while_method_4(v201)){
            assert("Tensor range check" && 0 <= v201 && v201 < 1);
            assert("Tensor range check" && 0 <= v201 && v201 < 1);
            v201 += 1 ;
        }
        assert("Tensor range check" && 0 <= v57 && v57 < 256);
        v36[v57] = v195;
        v46 += 1 ;
    }
    __syncthreads();
    assert("Tensor range check" && 0 <= v38 && v38 < 256);
    float v203;
    v203 = v36[v38];
    __syncthreads();
    return v203;
}
__device__ void method_49(unsigned char * v0, unsigned char * v1, StackMut1 & v2, Union4 v3){
    v2.v0 = 63u;
    static_array<float,2> v4;
    v4[0] = 0.0f;
    v4[1] = 0.0f;
    v2.v4 = v4;
    static_array_list<Union7,32> & v6 = v2.v2;
    v6.unsafe_set_length(0);
    static_array<Union2,2> v7;
    Union2 v9;
    v9 = Union2{Union2_0{}};
    v7[0] = v9;
    Union2 v11;
    v11 = Union2{Union2_0{}};
    v7[1] = v11;
    v2.v3 = v7;
    static_array_list<Union7,32> & v13 = v2.v2;
    Union3 v14;
    v14 = Union3{Union3_1{v3}};
    Union3 v15;
    v15 = v14;
    while (while_method_10(v15)){
        Union3 v883;
        switch (v15.tag) {
            case 0: { // None
                v883 = Union3{Union3_0{}};
                break;
            }
            case 1: { // Some
                Union4 v17 = v15.case1.v0;
                Union14 v723;
                switch (v17.tag) {
                    case 0: { // ChanceCommunityCard
                        Union5 v692 = v17.case0.v0; bool v693 = v17.case0.v1; static_array<Union6,2> v694 = v17.case0.v2; int v695 = v17.case0.v3; static_array<int,2> v696 = v17.case0.v4; int v697 = v17.case0.v5;
                        curandStatePhilox4_32_10_t & v698 = v2.v5;
                        curandStatePhilox4_32_10_t & v699 = v698;
                        unsigned int & v700 = v2.v0;
                        Union6 v701; unsigned int v702;
                        Tuple6 tmp62 = draw_card_20(v699, v700);
                        v701 = tmp62.v0; v702 = tmp62.v1;
                        v2.v0 = v702;
                        Union7 v703;
                        v703 = Union7{Union7_0{v701}};
                        v13.push(v703);
                        v723 = Union14{Union14_0{v692, v693, v694, v695, v696, v697, v701}};
                        break;
                    }
                    case 1: { // ChanceInit
                        curandStatePhilox4_32_10_t & v705 = v2.v5;
                        curandStatePhilox4_32_10_t & v706 = v705;
                        unsigned int & v707 = v2.v0;
                        Union6 v708; unsigned int v709;
                        Tuple6 tmp63 = draw_card_20(v706, v707);
                        v708 = tmp63.v0; v709 = tmp63.v1;
                        v2.v0 = v709;
                        curandStatePhilox4_32_10_t & v710 = v2.v5;
                        curandStatePhilox4_32_10_t & v711 = v710;
                        unsigned int & v712 = v2.v0;
                        Union6 v713; unsigned int v714;
                        Tuple6 tmp64 = draw_card_20(v711, v712);
                        v713 = tmp64.v0; v714 = tmp64.v1;
                        v2.v0 = v714;
                        Union7 v715;
                        v715 = Union7{Union7_2{0, v708}};
                        v13.push(v715);
                        Union7 v716;
                        v716 = Union7{Union7_2{1, v713}};
                        v13.push(v716);
                        v723 = Union14{Union14_1{v708, v713}};
                        break;
                    }
                    case 2: { // Round
                        Union5 v67 = v17.case2.v0; bool v68 = v17.case2.v1; static_array<Union6,2> v69 = v17.case2.v2; int v70 = v17.case2.v3; static_array<int,2> v71 = v17.case2.v4; int v72 = v17.case2.v5;
                        static_array<Union2,2> & v73 = v2.v3;
                        bool v74;
                        v74 = 0 <= v70;
                        bool v76;
                        if (v74){
                            bool v75;
                            v75 = v70 < 2;
                            v76 = v75;
                        } else {
                            v76 = false;
                        }
                        bool v77;
                        v77 = v76 == false;
                        if (v77){
                            assert("Index must be in range." && v76);
                        } else {
                        }
                        Union2 v79;
                        v79 = v73[v70];
                        Union1 v680;
                        switch (v79.tag) {
                            case 0: { // Computer
                                static_array_list<Union7,32> & v82 = v2.v2;
                                curandStatePhilox4_32_10_t & v83 = v2.v5;
                                curandStatePhilox4_32_10_t & v84 = v83;
                                unsigned int * v85;
                                v85 = reinterpret_cast<unsigned int *>(&v0[6291456ull]);
                                float * v87;
                                v87 = reinterpret_cast<float *>(&v0[0ull]);
                                float * v89;
                                v89 = reinterpret_cast<float *>(&v0[0ull]);
                                int v91;
                                v91 = blockIdx.x;
                                assert("Tensor range check" && 0 <= v91 && v91 < 24);
                                int v92;
                                v92 = 32768 * v91;
                                int v93;
                                v93 = threadIdx.x;
                                int v94;
                                v94 = v93;
                                while (while_method_3(v94)){
                                    bool v96;
                                    v96 = 0 <= v94;
                                    bool v97;
                                    v97 = v96 == false;
                                    if (v97){
                                        assert("The index needs to be zero or positive." && v96);
                                    } else {
                                    }
                                    int v99;
                                    v99 = v94 % 128;
                                    int v100;
                                    v100 = v94 / 128;
                                    bool v101;
                                    v101 = v100 < 256;
                                    bool v102;
                                    v102 = v101 == false;
                                    if (v102){
                                        assert("The last element of the projection dimensions needs to be greater than the index remainder." && v101);
                                    } else {
                                    }
                                    assert("Tensor range check" && 0 <= v100 && v100 < 256);
                                    assert("Tensor range check" && 0 <= v99 && v99 < 128);
                                    int v104;
                                    v104 = v99 + v92;
                                    int v105;
                                    v105 = 128 * v100;
                                    int v106;
                                    v106 = v105 + v104;
                                    v89[v106] = 0.0f;
                                    v94 += 256 ;
                                }
                                __syncthreads();
                                int v107;
                                v107 = threadIdx.x;
                                assert("Tensor range check" && 0 <= v107 && v107 < 256);
                                int v108;
                                v108 = 128 * v107;
                                int v109;
                                v109 = v108 + v92;
                                static_array_list<Union9,10> v110;
                                v110 = static_array_list<Union9,10>{};
                                int v112;
                                v112 = v82.length;
                                int v113;
                                v113 = 0;
                                while (while_method_1(v112, v113)){
                                    Union7 v115;
                                    v115 = v82[v113];
                                    Union10 v134;
                                    switch (v115.tag) {
                                        case 0: { // CommunityCardIs
                                            Union6 v124 = v115.case0.v0;
                                            Union9 v125;
                                            v125 = Union9{Union9_1{v124}};
                                            v134 = Union10{Union10_1{v125}};
                                            break;
                                        }
                                        case 1: { // PlayerAction
                                            int v127 = v115.case1.v0; Union1 v128 = v115.case1.v1;
                                            Union9 v129;
                                            v129 = Union9{Union9_0{v128}};
                                            v134 = Union10{Union10_1{v129}};
                                            break;
                                        }
                                        case 2: { // PlayerGotCard
                                            int v117 = v115.case2.v0; Union6 v118 = v115.case2.v1;
                                            bool v119;
                                            v119 = v117 == v70;
                                            if (v119){
                                                Union9 v120;
                                                v120 = Union9{Union9_1{v118}};
                                                v134 = Union10{Union10_1{v120}};
                                            } else {
                                                v134 = Union10{Union10_0{}};
                                            }
                                            break;
                                        }
                                        default: {
                                            v134 = Union10{Union10_0{}};
                                        }
                                    }
                                    switch (v134.tag) {
                                        case 0: { // None
                                            break;
                                        }
                                        case 1: { // Some
                                            Union9 v135 = v134.case1.v0;
                                            v110.push(v135);
                                            break;
                                        }
                                        default: {
                                            assert("Invalid tag." && false); __trap();
                                        }
                                    }
                                    v113 += 1 ;
                                }
                                float * v136;
                                v136 = v89+v109;
                                int v138;
                                v138 = v110.length;
                                bool v139;
                                v139 = v138 == 0;
                                if (v139){
                                    v136[0] = 1.0f;
                                } else {
                                }
                                int v140;
                                v140 = v110.length;
                                int v141;
                                v141 = 0;
                                while (while_method_1(v140, v141)){
                                    Union9 v143;
                                    v143 = v110[v141];
                                    int v145;
                                    v145 = v141 * 6;
                                    int v146;
                                    v146 = 1 + v145;
                                    switch (v143.tag) {
                                        case 0: { // C1of2
                                            Union1 v147 = v143.case0.v0;
                                            switch (v147.tag) {
                                                case 0: { // Call
                                                    v136[v146] = 1.0f;
                                                    break;
                                                }
                                                case 1: { // Fold
                                                    int v148;
                                                    v148 = v146 + 1;
                                                    v136[v148] = 1.0f;
                                                    break;
                                                }
                                                case 2: { // Raise
                                                    int v149;
                                                    v149 = v146 + 2;
                                                    v136[v149] = 1.0f;
                                                    break;
                                                }
                                                default: {
                                                    assert("Invalid tag." && false); __trap();
                                                }
                                            }
                                            break;
                                        }
                                        case 1: { // C2of2
                                            Union6 v150 = v143.case1.v0;
                                            int v151;
                                            v151 = v146 + 3;
                                            switch (v150.tag) {
                                                case 0: { // Jack
                                                    v136[v151] = 1.0f;
                                                    break;
                                                }
                                                case 1: { // King
                                                    int v152;
                                                    v152 = v151 + 1;
                                                    v136[v152] = 1.0f;
                                                    break;
                                                }
                                                case 2: { // Queen
                                                    int v153;
                                                    v153 = v151 + 2;
                                                    v136[v153] = 1.0f;
                                                    break;
                                                }
                                                default: {
                                                    assert("Invalid tag." && false); __trap();
                                                }
                                            }
                                            break;
                                        }
                                        default: {
                                            assert("Invalid tag." && false); __trap();
                                        }
                                    }
                                    v141 += 1 ;
                                }
                                __syncthreads();
                                int v154;
                                v154 = 0;
                                while (while_method_9(v154)){
                                    float * v156;
                                    v156 = reinterpret_cast<float *>(&v0[0ull]);
                                    float * v158;
                                    v158 = reinterpret_cast<float *>(&v1[0ull]);
                                    assert("Tensor range check" && 0 <= v154 && v154 < 4);
                                    int v160;
                                    v160 = 16384 * v154;
                                    float * v161;
                                    v161 = reinterpret_cast<float *>(&v0[3145728ull]);
                                    int v163;
                                    v163 = blockIdx.x;
                                    assert("Tensor range check" && 0 <= v163 && v163 < 24);
                                    int v164;
                                    v164 = 32768 * v163;
                                    int v165;
                                    v165 = blockIdx.x;
                                    assert("Tensor range check" && 0 <= v165 && v165 < 24);
                                    int v166;
                                    v166 = 32768 * v165;
                                    cuda::pipeline<cuda::thread_scope_thread> v167 = cuda::make_pipeline();
                                    extern __shared__ unsigned char v168[];
                                    float * v169;
                                    v169 = reinterpret_cast<float *>(&v168[0ull]);
                                    float * v171;
                                    v171 = reinterpret_cast<float *>(&v168[34816ull]);
                                    float * v173;
                                    v173 = reinterpret_cast<float *>(&v168[0ull]);
                                    int v175;
                                    v175 = threadIdx.x;
                                    int v176;
                                    v176 = v175 / 32;
                                    bool v177;
                                    v177 = 0 <= v176;
                                    bool v178;
                                    v178 = v177 == false;
                                    if (v178){
                                        assert("The index needs to be zero or positive." && v177);
                                    } else {
                                    }
                                    int v180;
                                    v180 = v176 % 8;
                                    int v181;
                                    v181 = v176 / 8;
                                    bool v182;
                                    v182 = v181 < 1;
                                    bool v183;
                                    v183 = v182 == false;
                                    if (v183){
                                        assert("The last element of the projection dimensions needs to be greater than the index remainder." && v182);
                                    } else {
                                    }
                                    assert("Tensor range check" && 0 <= v181 && v181 < 1);
                                    assert("Tensor range check" && 0 <= v180 && v180 < 8);
                                    int v185;
                                    v185 = 16 * v180;
                                    int v186;
                                    v186 = 17408 * v181;
                                    int v187;
                                    v187 = v186 + v185;
                                    float * v188;
                                    v188 = v173+v187;
                                    assert("Tensor range check" && 0 <= v181 && v181 < 1);
                                    int v190;
                                    v190 = 8704 * v181;
                                    int v191;
                                    v191 = threadIdx.x;
                                    int v192;
                                    v192 = v191 % 32;
                                    bool v193;
                                    v193 = 0 <= v192;
                                    bool v194;
                                    v194 = v193 == false;
                                    if (v194){
                                        assert("The index needs to be zero or positive." && v193);
                                    } else {
                                    }
                                    int v196;
                                    v196 = v192 % 4;
                                    int v197;
                                    v197 = v192 / 4;
                                    bool v198;
                                    v198 = v197 < 8;
                                    bool v199;
                                    v199 = v198 == false;
                                    if (v199){
                                        assert("The last element of the projection dimensions needs to be greater than the index remainder." && v198);
                                    } else {
                                    }
                                    assert("Tensor range check" && 0 <= v197 && v197 < 8);
                                    assert("Tensor range check" && 0 <= v196 && v196 < 4);
                                    int v201;
                                    v201 = v196 + v190;
                                    int v202;
                                    v202 = 68 * v197;
                                    int v203;
                                    v203 = v202 + v201;
                                    float * v204;
                                    v204 = v169+v203;
                                    assert("Tensor range check" && 0 <= v180 && v180 < 8);
                                    int v206;
                                    v206 = 1088 * v180;
                                    int v207;
                                    v207 = threadIdx.x;
                                    int v208;
                                    v208 = v207 % 32;
                                    bool v209;
                                    v209 = 0 <= v208;
                                    bool v210;
                                    v210 = v209 == false;
                                    if (v210){
                                        assert("The index needs to be zero or positive." && v209);
                                    } else {
                                    }
                                    int v212;
                                    v212 = v208 % 4;
                                    int v213;
                                    v213 = v208 / 4;
                                    bool v214;
                                    v214 = v213 < 8;
                                    bool v215;
                                    v215 = v214 == false;
                                    if (v215){
                                        assert("The last element of the projection dimensions needs to be greater than the index remainder." && v214);
                                    } else {
                                    }
                                    assert("Tensor range check" && 0 <= v213 && v213 < 8);
                                    assert("Tensor range check" && 0 <= v212 && v212 < 4);
                                    int v217;
                                    v217 = v212 + v206;
                                    int v218;
                                    v218 = 68 * v213;
                                    int v219;
                                    v219 = v218 + v217;
                                    float * v220;
                                    v220 = v171+v219;
                                    wmma::fragment<wmma::accumulator, 16, 16, 8, float> v222[8];
                                    int v223;
                                    v223 = 0;
                                    while (while_method_0(v223)){
                                        int v225;
                                        v225 = 0;
                                        while (while_method_4(v225)){
                                            assert("Tensor range check" && 0 <= v223 && v223 < 2);
                                            assert("Tensor range check" && 0 <= v225 && v225 < 1);
                                            int v227;
                                            v227 = 128 * v225;
                                            int v228;
                                            v228 = v227 + v166;
                                            int v229;
                                            v229 = 16384 * v223;
                                            int v230;
                                            v230 = v229 + v228;
                                            float * v231;
                                            v231 = v161+v230;
                                            // Pushing the loop unrolling to: 0
                                            int v233;
                                            v233 = 0;
                                            #pragma unroll
                                            while (while_method_5(v233)){
                                                int v235;
                                                v235 = 0;
                                                #pragma unroll
                                                while (while_method_4(v235)){
                                                    assert("Tensor range check" && 0 <= v233 && v233 < 8);
                                                    assert("Tensor range check" && 0 <= v235 && v235 < 1);
                                                    int v237;
                                                    v237 = v233 + v235;
                                                    wmma::fragment<wmma::accumulator, 16, 16, 8, float> & v238 = v222[v237];
                                                    wmma::fill_fragment(v238, 0.0f);
                                                    v235 += 1 ;
                                                }
                                                v233 += 1 ;
                                            }
                                            // Poping the loop unrolling to: 0
                                            int v239;
                                            v239 = 0;
                                            while (while_method_6(v239)){
                                                int v241;
                                                v241 = v239 + 1;
                                                bool v242;
                                                v242 = v239 == 0;
                                                int v243;
                                                v243 = v239 % 2;
                                                bool v244;
                                                v244 = 0 <= v239;
                                                bool v245;
                                                v245 = v244 == false;
                                                if (v245){
                                                    assert("The index needs to be zero or positive." && v244);
                                                } else {
                                                }
                                                bool v247;
                                                v247 = v239 < 2;
                                                bool v248;
                                                v248 = v247 == false;
                                                if (v248){
                                                    assert("The last element of the projection dimensions needs to be greater than the index remainder." && v247);
                                                } else {
                                                }
                                                bool v250;
                                                v250 = v241 < 2;
                                                Union11 v256;
                                                if (v250){
                                                    bool v251;
                                                    v251 = 0 <= v241;
                                                    bool v252;
                                                    v252 = v251 == false;
                                                    if (v252){
                                                        assert("The index needs to be zero or positive." && v251);
                                                    } else {
                                                    }
                                                    v256 = Union11{Union11_1{v241}};
                                                } else {
                                                    v256 = Union11{Union11_0{}};
                                                }
                                                assert("Tensor range check" && 0 <= v223 && v223 < 2);
                                                int v257;
                                                v257 = v229 + v164;
                                                assert("Tensor range check" && 0 <= v239 && v239 < 2);
                                                int v258;
                                                v258 = 64 * v239;
                                                int v259;
                                                v259 = v258 + v257;
                                                float * v260;
                                                v260 = v156+v259;
                                                assert("Tensor range check" && 0 <= v225 && v225 < 1);
                                                int v262;
                                                v262 = 16384 * v225;
                                                int v263;
                                                v263 = v262 + v160;
                                                if (v242){
                                                    assert("Tensor range check" && 0 <= v239 && v239 < 2);
                                                    int v264;
                                                    v264 = v258 + v263;
                                                    float * v265;
                                                    v265 = v158+v264;
                                                    // Pushing the loop unrolling to: 0
                                                    v167.producer_acquire();
                                                    int v267;
                                                    v267 = threadIdx.x;
                                                    bool v268;
                                                    v268 = 0 <= v267;
                                                    bool v269;
                                                    v269 = v268 == false;
                                                    if (v269){
                                                        assert("The index needs to be zero or positive." && v268);
                                                    } else {
                                                    }
                                                    int v271;
                                                    v271 = v267 % 16;
                                                    int v272;
                                                    v272 = v267 / 16;
                                                    bool v273;
                                                    v273 = v272 < 16;
                                                    bool v274;
                                                    v274 = v273 == false;
                                                    if (v274){
                                                        assert("The last element of the projection dimensions needs to be greater than the index remainder." && v273);
                                                    } else {
                                                    }
                                                    assert("Tensor range check" && 0 <= v272 && v272 < 16);
                                                    assert("Tensor range check" && 0 <= v271 && v271 < 16);
                                                    int v276;
                                                    v276 = 4 * v271;
                                                    int v277;
                                                    v277 = 68 * v272;
                                                    int v278;
                                                    v278 = v277 + v276;
                                                    int v279;
                                                    v279 = 128 * v272;
                                                    int v280;
                                                    v280 = v279 + v276;
                                                    float * v281;
                                                    v281 = v171+v278;
                                                    float * v283;
                                                    v283 = v265+v280;
                                                    int v285;
                                                    v285 = 0;
                                                    #pragma unroll
                                                    while (while_method_5(v285)){
                                                        int v287;
                                                        v287 = 0;
                                                        #pragma unroll
                                                        while (while_method_4(v287)){
                                                            assert("Tensor range check" && 0 <= v285 && v285 < 8);
                                                            assert("Tensor range check" && 0 <= v287 && v287 < 1);
                                                            int v289;
                                                            v289 = 64 * v287;
                                                            int v290;
                                                            v290 = 1088 * v285;
                                                            int v291;
                                                            v291 = v290 + v289;
                                                            int v292;
                                                            v292 = 2048 * v285;
                                                            int v293;
                                                            v293 = v292 + v289;
                                                            constexpr int v294 = sizeof(float) * 4;
                                                            assert("Pointer alignment check" && (unsigned long long)(v283 + v293) % v294 == 0 && (unsigned long long)(v281 + v291) % v294 == 0);
                                                            cuda::memcpy_async(v281 + v291, v283 + v293, cuda::aligned_size_t<v294>(v294), v167);
                                                            v287 += 1 ;
                                                        }
                                                        v285 += 1 ;
                                                    }
                                                    v167.producer_commit();
                                                    // Poping the loop unrolling to: 0
                                                } else {
                                                }
                                                // Pushing the loop unrolling to: 0
                                                int v295;
                                                v295 = threadIdx.x;
                                                bool v296;
                                                v296 = 0 <= v295;
                                                bool v297;
                                                v297 = v296 == false;
                                                if (v297){
                                                    assert("The index needs to be zero or positive." && v296);
                                                } else {
                                                }
                                                int v299;
                                                v299 = v295 % 16;
                                                int v300;
                                                v300 = v295 / 16;
                                                bool v301;
                                                v301 = v300 < 16;
                                                bool v302;
                                                v302 = v301 == false;
                                                if (v302){
                                                    assert("The last element of the projection dimensions needs to be greater than the index remainder." && v301);
                                                } else {
                                                }
                                                assert("Tensor range check" && 0 <= v300 && v300 < 16);
                                                assert("Tensor range check" && 0 <= v299 && v299 < 16);
                                                int v304;
                                                v304 = 4 * v299;
                                                int v305;
                                                v305 = 68 * v300;
                                                int v306;
                                                v306 = v305 + v304;
                                                int v307;
                                                v307 = 128 * v300;
                                                int v308;
                                                v308 = v307 + v304;
                                                float * v309;
                                                v309 = v169+v306;
                                                float * v311;
                                                v311 = v260+v308;
                                                int v313;
                                                v313 = 0;
                                                #pragma unroll
                                                while (while_method_5(v313)){
                                                    int v315;
                                                    v315 = 0;
                                                    #pragma unroll
                                                    while (while_method_4(v315)){
                                                        assert("Tensor range check" && 0 <= v313 && v313 < 8);
                                                        assert("Tensor range check" && 0 <= v315 && v315 < 1);
                                                        int v317;
                                                        v317 = 64 * v315;
                                                        int v318;
                                                        v318 = 1088 * v313;
                                                        int v319;
                                                        v319 = v318 + v317;
                                                        int v320;
                                                        v320 = 2048 * v313;
                                                        int v321;
                                                        v321 = v320 + v317;
                                                        int4* v322;
                                                        v322 = reinterpret_cast<int4*>(v311 + v321);
                                                        int4* v323;
                                                        v323 = reinterpret_cast<int4*>(v309 + v319);
                                                        assert("Pointer alignment check" && (unsigned long long)(v322) % 4 == 0 && (unsigned long long)(v323) % 4 == 0);
                                                        *v323 = *v322;
                                                        v315 += 1 ;
                                                    }
                                                    v313 += 1 ;
                                                }
                                                // Poping the loop unrolling to: 0
                                                wmma::fragment<wmma::matrix_a, 16, 16, 8, wmma::precision::tf32, wmma::row_major> v324[1];
                                                wmma::fragment<wmma::matrix_b, 16, 16, 8, wmma::precision::tf32, wmma::col_major> v325[8];
                                                cuda::pipeline_consumer_wait_prior<0>(v167);;
                                                __syncthreads();
                                                // Pushing the loop unrolling to: 0
                                                int v326;
                                                v326 = 0;
                                                #pragma unroll
                                                while (while_method_4(v326)){
                                                    int v328;
                                                    v328 = 0;
                                                    #pragma unroll
                                                    while (while_method_5(v328)){
                                                        assert("Tensor range check" && 0 <= v326 && v326 < 1);
                                                        assert("Tensor range check" && 0 <= v328 && v328 < 8);
                                                        int v330;
                                                        v330 = 8 * v326;
                                                        int v331;
                                                        v331 = v330 + v328;
                                                        wmma::fragment<wmma::matrix_b, 16, 16, 8, wmma::precision::tf32, wmma::col_major> & v332 = v325[v331];
                                                        assert("Tensor range check" && 0 <= v326 && v326 < 1);
                                                        int v333;
                                                        v333 = 1088 * v326;
                                                        assert("Tensor range check" && 0 <= v328 && v328 < 8);
                                                        int v334;
                                                        v334 = 8 * v328;
                                                        int v335;
                                                        v335 = v334 + v333;
                                                        int v336;
                                                        v336 = 0;
                                                        #pragma unroll
                                                        while (while_method_0(v336)){
                                                            int v338;
                                                            v338 = 0;
                                                            #pragma unroll
                                                            while (while_method_0(v338)){
                                                                assert("Tensor range check" && 0 <= v336 && v336 < 2);
                                                                assert("Tensor range check" && 0 <= v338 && v338 < 2);
                                                                int v340;
                                                                v340 = 4 * v338;
                                                                int v341;
                                                                v341 = v340 + v335;
                                                                int v342;
                                                                v342 = 544 * v336;
                                                                int v343;
                                                                v343 = v342 + v341;
                                                                float v344;
                                                                v344 = v220[v343];
                                                                bool v345;
                                                                v345 = 0 <= v338;
                                                                bool v347;
                                                                if (v345){
                                                                    bool v346;
                                                                    v346 = v338 < 2;
                                                                    v347 = v346;
                                                                } else {
                                                                    v347 = false;
                                                                }
                                                                bool v348;
                                                                v348 = v347 == false;
                                                                if (v348){
                                                                    assert("The indices should be inside the range of the dimension." && v347);
                                                                } else {
                                                                }
                                                                bool v350;
                                                                v350 = 0 <= v336;
                                                                bool v352;
                                                                if (v350){
                                                                    bool v351;
                                                                    v351 = v336 < 2;
                                                                    v352 = v351;
                                                                } else {
                                                                    v352 = false;
                                                                }
                                                                bool v353;
                                                                v353 = v352 == false;
                                                                if (v353){
                                                                    assert("The indices should be inside the range of the dimension." && v352);
                                                                } else {
                                                                }
                                                                int v355;
                                                                v355 = v336 * 2;
                                                                int v356;
                                                                v356 = v338 + v355;
                                                                v332.x[v356] = wmma::__float_to_tf32(v344);
                                                                v338 += 1 ;
                                                            }
                                                            v336 += 1 ;
                                                        }
                                                        v328 += 1 ;
                                                    }
                                                    v326 += 1 ;
                                                }
                                                // Poping the loop unrolling to: 0
                                                v167.consumer_release();
                                                switch (v256.tag) {
                                                    case 0: { // None
                                                        break;
                                                    }
                                                    case 1: { // Some
                                                        int v357 = v256.case1.v0;
                                                        assert("Tensor range check" && 0 <= v357 && v357 < 2);
                                                        int v358;
                                                        v358 = 64 * v357;
                                                        int v359;
                                                        v359 = v358 + v263;
                                                        float * v360;
                                                        v360 = v158+v359;
                                                        __syncthreads();
                                                        // Pushing the loop unrolling to: 0
                                                        v167.producer_acquire();
                                                        int v362;
                                                        v362 = threadIdx.x;
                                                        bool v363;
                                                        v363 = 0 <= v362;
                                                        bool v364;
                                                        v364 = v363 == false;
                                                        if (v364){
                                                            assert("The index needs to be zero or positive." && v363);
                                                        } else {
                                                        }
                                                        int v366;
                                                        v366 = v362 % 16;
                                                        int v367;
                                                        v367 = v362 / 16;
                                                        bool v368;
                                                        v368 = v367 < 16;
                                                        bool v369;
                                                        v369 = v368 == false;
                                                        if (v369){
                                                            assert("The last element of the projection dimensions needs to be greater than the index remainder." && v368);
                                                        } else {
                                                        }
                                                        assert("Tensor range check" && 0 <= v367 && v367 < 16);
                                                        assert("Tensor range check" && 0 <= v366 && v366 < 16);
                                                        int v371;
                                                        v371 = 4 * v366;
                                                        int v372;
                                                        v372 = 68 * v367;
                                                        int v373;
                                                        v373 = v372 + v371;
                                                        int v374;
                                                        v374 = 128 * v367;
                                                        int v375;
                                                        v375 = v374 + v371;
                                                        float * v376;
                                                        v376 = v171+v373;
                                                        float * v378;
                                                        v378 = v360+v375;
                                                        int v380;
                                                        v380 = 0;
                                                        #pragma unroll
                                                        while (while_method_5(v380)){
                                                            int v382;
                                                            v382 = 0;
                                                            #pragma unroll
                                                            while (while_method_4(v382)){
                                                                assert("Tensor range check" && 0 <= v380 && v380 < 8);
                                                                assert("Tensor range check" && 0 <= v382 && v382 < 1);
                                                                int v384;
                                                                v384 = 64 * v382;
                                                                int v385;
                                                                v385 = 1088 * v380;
                                                                int v386;
                                                                v386 = v385 + v384;
                                                                int v387;
                                                                v387 = 2048 * v380;
                                                                int v388;
                                                                v388 = v387 + v384;
                                                                constexpr int v389 = sizeof(float) * 4;
                                                                assert("Pointer alignment check" && (unsigned long long)(v378 + v388) % v389 == 0 && (unsigned long long)(v376 + v386) % v389 == 0);
                                                                cuda::memcpy_async(v376 + v386, v378 + v388, cuda::aligned_size_t<v389>(v389), v167);
                                                                v382 += 1 ;
                                                            }
                                                            v380 += 1 ;
                                                        }
                                                        v167.producer_commit();
                                                        // Poping the loop unrolling to: 0
                                                        break;
                                                    }
                                                    default: {
                                                        assert("Invalid tag." && false); __trap();
                                                    }
                                                }
                                                // Pushing the loop unrolling to: 0
                                                int v390;
                                                v390 = 0;
                                                #pragma unroll
                                                while (while_method_5(v390)){
                                                    int v392;
                                                    v392 = 0;
                                                    #pragma unroll
                                                    while (while_method_5(v392)){
                                                        wmma::fragment<wmma::matrix_a, 16, 16, 8, wmma::precision::tf32, wmma::row_major> & v394 = v324[0];
                                                        assert("Tensor range check" && 0 <= v390 && v390 < 8);
                                                        int v395;
                                                        v395 = 1088 * v390;
                                                        assert("Tensor range check" && 0 <= v392 && v392 < 8);
                                                        int v396;
                                                        v396 = 8 * v392;
                                                        int v397;
                                                        v397 = v396 + v395;
                                                        int v398;
                                                        v398 = 0;
                                                        #pragma unroll
                                                        while (while_method_0(v398)){
                                                            int v400;
                                                            v400 = 0;
                                                            #pragma unroll
                                                            while (while_method_0(v400)){
                                                                assert("Tensor range check" && 0 <= v398 && v398 < 2);
                                                                assert("Tensor range check" && 0 <= v400 && v400 < 2);
                                                                int v402;
                                                                v402 = 544 * v400;
                                                                int v403;
                                                                v403 = v402 + v397;
                                                                int v404;
                                                                v404 = 4 * v398;
                                                                int v405;
                                                                v405 = v404 + v403;
                                                                float v406;
                                                                v406 = v204[v405];
                                                                bool v407;
                                                                v407 = 0 <= v400;
                                                                bool v409;
                                                                if (v407){
                                                                    bool v408;
                                                                    v408 = v400 < 2;
                                                                    v409 = v408;
                                                                } else {
                                                                    v409 = false;
                                                                }
                                                                bool v410;
                                                                v410 = v409 == false;
                                                                if (v410){
                                                                    assert("The indices should be inside the range of the dimension." && v409);
                                                                } else {
                                                                }
                                                                bool v412;
                                                                v412 = 0 <= v398;
                                                                bool v414;
                                                                if (v412){
                                                                    bool v413;
                                                                    v413 = v398 < 2;
                                                                    v414 = v413;
                                                                } else {
                                                                    v414 = false;
                                                                }
                                                                bool v415;
                                                                v415 = v414 == false;
                                                                if (v415){
                                                                    assert("The indices should be inside the range of the dimension." && v414);
                                                                } else {
                                                                }
                                                                int v417;
                                                                v417 = v398 * 2;
                                                                int v418;
                                                                v418 = v400 + v417;
                                                                v394.x[v418] = wmma::__float_to_tf32(v406);
                                                                v400 += 1 ;
                                                            }
                                                            v398 += 1 ;
                                                        }
                                                        int v419;
                                                        v419 = 0;
                                                        #pragma unroll
                                                        while (while_method_4(v419)){
                                                            assert("Tensor range check" && 0 <= v390 && v390 < 8);
                                                            assert("Tensor range check" && 0 <= v419 && v419 < 1);
                                                            int v421;
                                                            v421 = v390 + v419;
                                                            wmma::fragment<wmma::accumulator, 16, 16, 8, float> & v422 = v222[v421];
                                                            assert("Tensor range check" && 0 <= v419 && v419 < 1);
                                                            assert("Tensor range check" && 0 <= v392 && v392 < 8);
                                                            int v423;
                                                            v423 = 8 * v419;
                                                            int v424;
                                                            v424 = v423 + v392;
                                                            wmma::fragment<wmma::matrix_b, 16, 16, 8, wmma::precision::tf32, wmma::col_major> & v425 = v325[v424];
                                                            wmma::mma_sync(v422, v394, v425, v422);
                                                            v419 += 1 ;
                                                        }
                                                        v392 += 1 ;
                                                    }
                                                    v390 += 1 ;
                                                }
                                                // Poping the loop unrolling to: 0
                                                __syncthreads();
                                                v239 = v241;
                                            }
                                            // Pushing the loop unrolling to: 0
                                            int v426;
                                            v426 = 0;
                                            #pragma unroll
                                            while (while_method_5(v426)){
                                                int v428;
                                                v428 = 0;
                                                #pragma unroll
                                                while (while_method_4(v428)){
                                                    assert("Tensor range check" && 0 <= v426 && v426 < 8);
                                                    assert("Tensor range check" && 0 <= v428 && v428 < 1);
                                                    int v430;
                                                    v430 = v426 + v428;
                                                    wmma::fragment<wmma::accumulator, 16, 16, 8, float> & v431 = v222[v430];
                                                    assert("Tensor range check" && 0 <= v426 && v426 < 8);
                                                    assert("Tensor range check" && 0 <= v428 && v428 < 1);
                                                    int v432;
                                                    v432 = 16 * v428;
                                                    int v433;
                                                    v433 = 2176 * v426;
                                                    int v434;
                                                    v434 = v433 + v432;
                                                    float * v435;
                                                    v435 = v188+v434;
                                                    wmma::store_matrix_sync(v435, v431, 136, wmma::mem_row_major);
                                                    v428 += 1 ;
                                                }
                                                v426 += 1 ;
                                            }
                                            // Poping the loop unrolling to: 0
                                            __syncthreads();
                                            // Pushing the loop unrolling to: 0
                                            int v437;
                                            v437 = threadIdx.x;
                                            bool v438;
                                            v438 = 0 <= v437;
                                            bool v439;
                                            v439 = v438 == false;
                                            if (v439){
                                                assert("The index needs to be zero or positive." && v438);
                                            } else {
                                            }
                                            int v441;
                                            v441 = v437 % 32;
                                            int v442;
                                            v442 = v437 / 32;
                                            bool v443;
                                            v443 = v442 < 8;
                                            bool v444;
                                            v444 = v443 == false;
                                            if (v444){
                                                assert("The last element of the projection dimensions needs to be greater than the index remainder." && v443);
                                            } else {
                                            }
                                            assert("Tensor range check" && 0 <= v442 && v442 < 8);
                                            assert("Tensor range check" && 0 <= v441 && v441 < 32);
                                            int v446;
                                            v446 = 4 * v441;
                                            int v447;
                                            v447 = 128 * v442;
                                            int v448;
                                            v448 = v447 + v446;
                                            int v449;
                                            v449 = 136 * v442;
                                            int v450;
                                            v450 = v449 + v446;
                                            float * v451;
                                            v451 = v231+v448;
                                            float * v453;
                                            v453 = v173+v450;
                                            int v455;
                                            v455 = 0;
                                            #pragma unroll
                                            while (while_method_7(v455)){
                                                int v457;
                                                v457 = 0;
                                                #pragma unroll
                                                while (while_method_4(v457)){
                                                    assert("Tensor range check" && 0 <= v455 && v455 < 16);
                                                    assert("Tensor range check" && 0 <= v457 && v457 < 1);
                                                    int v459;
                                                    v459 = 128 * v457;
                                                    int v460;
                                                    v460 = 1024 * v455;
                                                    int v461;
                                                    v461 = v460 + v459;
                                                    int v462;
                                                    v462 = 1088 * v455;
                                                    int v463;
                                                    v463 = v462 + v459;
                                                    int4* v464;
                                                    v464 = reinterpret_cast<int4*>(v453 + v463);
                                                    int4* v465;
                                                    v465 = reinterpret_cast<int4*>(v451 + v461);
                                                    assert("Pointer alignment check" && (unsigned long long)(v464) % 4 == 0 && (unsigned long long)(v465) % 4 == 0);
                                                    *v465 = *v464;
                                                    v457 += 1 ;
                                                }
                                                v455 += 1 ;
                                            }
                                            // Poping the loop unrolling to: 0
                                            __syncthreads();
                                            v225 += 1 ;
                                        }
                                        v223 += 1 ;
                                    }
                                    unsigned int * v466;
                                    v466 = reinterpret_cast<unsigned int *>(&v0[6291456ull]);
                                    assert("Tensor range check" && 0 <= v154 && v154 < 4);
                                    int v468;
                                    v468 = 6144 * v154;
                                    method_23(v466, v468, v161);
                                    int * v469;
                                    v469 = reinterpret_cast<int *>(&v1[262144ull]);
                                    float * v471;
                                    v471 = reinterpret_cast<float *>(&v1[262160ull]);
                                    float * v473;
                                    v473 = reinterpret_cast<float *>(&v1[524304ull]);
                                    float * v475;
                                    v475 = reinterpret_cast<float *>(&v1[786448ull]);
                                    float * v477;
                                    v477 = reinterpret_cast<float *>(&v1[1048592ull]);
                                    float * v479;
                                    v479 = reinterpret_cast<float *>(&v1[1310736ull]);
                                    float * v481;
                                    v481 = reinterpret_cast<float *>(&v1[1572880ull]);
                                    float * v483;
                                    v483 = reinterpret_cast<float *>(&v1[1835024ull]);
                                    int * v485;
                                    v485 = reinterpret_cast<int *>(&v0[6389760ull]);
                                    float * v487;
                                    v487 = reinterpret_cast<float *>(&v0[7962624ull]);
                                    int * v489;
                                    v489 = reinterpret_cast<int *>(&v0[9535488ull]);
                                    int * v491;
                                    v491 = reinterpret_cast<int *>(&v0[11108352ull]);
                                    double * v493;
                                    v493 = reinterpret_cast<double *>(&v0[12681216ull]);
                                    double * v495;
                                    v495 = reinterpret_cast<double *>(&v0[18972672ull]);
                                    double * v497;
                                    v497 = reinterpret_cast<double *>(&v1[2097168ull]);
                                    double * v499;
                                    v499 = reinterpret_cast<double *>(&v1[2490384ull]);
                                    int * v501;
                                    v501 = reinterpret_cast<int *>(&v1[2883600ull]);
                                    v154 += 1 ;
                                }
                                __syncthreads();
                                int * v503;
                                v503 = reinterpret_cast<int *>(&v1[262144ull]);
                                float * v505;
                                v505 = reinterpret_cast<float *>(&v1[262160ull]);
                                float * v507;
                                v507 = reinterpret_cast<float *>(&v1[524304ull]);
                                float * v509;
                                v509 = reinterpret_cast<float *>(&v1[786448ull]);
                                float * v511;
                                v511 = reinterpret_cast<float *>(&v1[1048592ull]);
                                float * v513;
                                v513 = reinterpret_cast<float *>(&v1[1310736ull]);
                                float * v515;
                                v515 = reinterpret_cast<float *>(&v1[1572880ull]);
                                float * v517;
                                v517 = reinterpret_cast<float *>(&v1[1835024ull]);
                                int v519;
                                v519 = 0;
                                int v520;
                                v520 = 4;
                                int v521;
                                v521 = int_range_22(v520, v519, v84);
                                extern __shared__ unsigned char v522[];
                                int * v523;
                                v523 = reinterpret_cast<int *>(&v522[0ull]);
                                int v525;
                                v525 = threadIdx.x;
                                bool v526;
                                v526 = v525 == 0;
                                if (v526){
                                    v523[0] = v521;
                                } else {
                                }
                                __syncthreads();
                                int v527;
                                v527 = v523[0];
                                __syncthreads();
                                unsigned int * v528;
                                v528 = reinterpret_cast<unsigned int *>(&v0[6291456ull]);
                                int v530;
                                v530 = blockIdx.x;
                                int v531;
                                v531 = threadIdx.x;
                                assert("Tensor range check" && 0 <= v527 && v527 < 4);
                                assert("Tensor range check" && 0 <= v530 && v530 < 24);
                                assert("Tensor range check" && 0 <= v531 && v531 < 256);
                                int v532;
                                v532 = 256 * v530;
                                int v533;
                                v533 = v532 + v531;
                                int v534;
                                v534 = 6144 * v527;
                                int v535;
                                v535 = v534 + v533;
                                unsigned int v536;
                                v536 = v528[v535];
                                int v537;
                                v537 = (int)v536;
                                float v538; int v539;
                                Tuple8 tmp65 = method_24(v84, v503, v505, v507, v509, v511, v513, v515, v517, v537, v527);
                                v538 = tmp65.v0; v539 = tmp65.v1;
                                extern __shared__ unsigned char v540[];
                                float * v541;
                                v541 = reinterpret_cast<float *>(&v540[0ull]);
                                int * v543;
                                v543 = reinterpret_cast<int *>(&v540[16ull]);
                                int v545;
                                v545 = threadIdx.x;
                                bool v546;
                                v546 = v545 == 0;
                                if (v546){
                                    v541[0] = v538;
                                    v543[0] = v539;
                                } else {
                                }
                                __syncthreads();
                                float v547;
                                v547 = v541[0];
                                int v548;
                                v548 = v543[0];
                                __syncthreads();
                                double * v549;
                                v549 = reinterpret_cast<double *>(&v1[2097168ull]);
                                double * v551;
                                v551 = reinterpret_cast<double *>(&v1[2490384ull]);
                                int * v553;
                                v553 = reinterpret_cast<int *>(&v1[2883600ull]);
                                int * v555;
                                v555 = reinterpret_cast<int *>(&v0[6389760ull]);
                                float * v557;
                                v557 = reinterpret_cast<float *>(&v0[7962624ull]);
                                int * v559;
                                v559 = reinterpret_cast<int *>(&v0[9535488ull]);
                                int * v561;
                                v561 = reinterpret_cast<int *>(&v0[11108352ull]);
                                double * v563;
                                v563 = reinterpret_cast<double *>(&v0[12681216ull]);
                                double * v565;
                                v565 = reinterpret_cast<double *>(&v0[18972672ull]);
                                int v567;
                                v567 = threadIdx.x;
                                int v568;
                                v568 = blockIdx.x;
                                int v569;
                                v569 = v568 * 256;
                                int v570;
                                v570 = v567 + v569;
                                int v571;
                                v571 = 0;
                                while (while_method_9(v571)){
                                    unsigned int * v573;
                                    v573 = reinterpret_cast<unsigned int *>(&v0[6291456ull]);
                                    int v575;
                                    v575 = blockIdx.x;
                                    int v576;
                                    v576 = threadIdx.x;
                                    assert("Tensor range check" && 0 <= v571 && v571 < 4);
                                    assert("Tensor range check" && 0 <= v575 && v575 < 24);
                                    assert("Tensor range check" && 0 <= v576 && v576 < 256);
                                    int v577;
                                    v577 = 256 * v575;
                                    int v578;
                                    v578 = v577 + v576;
                                    int v579;
                                    v579 = 6144 * v571;
                                    int v580;
                                    v580 = v579 + v578;
                                    unsigned int v581;
                                    v581 = v573[v580];
                                    int v582;
                                    v582 = (int)v581;
                                    float v583;
                                    v583 = method_50(v503, v505, v507, v509, v511, v513, v515, v517, v582, v571, v548);
                                    double v584;
                                    v584 = (double)v547;
                                    double v585;
                                    v585 = log(v584);
                                    double v586;
                                    v586 = (double)v583;
                                    double v587;
                                    v587 = log(v586);
                                    assert("Tensor range check" && 0 <= v571 && v571 < 4);
                                    assert("Tensor range check" && 0 <= v570 && v570 < 6144);
                                    assert("Tensor range check" && 0 <= v70 && v70 < 2);
                                    int v588;
                                    v588 = 2 * v570;
                                    int v589;
                                    v589 = v588 + v70;
                                    int v590;
                                    v590 = 12288 * v571;
                                    int v591;
                                    v591 = v590 + v589;
                                    double v592;
                                    v592 = v549[v591];
                                    double v593;
                                    v593 = v551[v591];
                                    double v594;
                                    v594 = v587 + v592;
                                    double v595;
                                    v595 = v585 + v593;
                                    assert("Tensor range check" && 0 <= v571 && v571 < 4);
                                    assert("Tensor range check" && 0 <= v570 && v570 < 6144);
                                    assert("Tensor range check" && 0 <= v70 && v70 < 2);
                                    v549[v591] = v594;
                                    v551[v591] = v595;
                                    v571 += 1 ;
                                }
                                bool v596;
                                v596 = 0 == v548;
                                Union12 v605;
                                if (v596){
                                    v605 = Union12{Union12_1{}};
                                } else {
                                    bool v598;
                                    v598 = 1 == v548;
                                    if (v598){
                                        v605 = Union12{Union12_0{}};
                                    } else {
                                        bool v600;
                                        v600 = 2 == v548;
                                        if (v600){
                                            v605 = Union12{Union12_2{}};
                                        } else {
                                            printf("%s\n", "Invalid output id in the Leduc model.");
                                            __trap();
                                        }
                                    }
                                }
                                switch (v605.tag) {
                                    case 0: { // AA_Call
                                        v680 = Union1{Union1_0{}};
                                        break;
                                    }
                                    case 1: { // AA_Fold
                                        int v606;
                                        v606 = v71[0];
                                        int v608; int v609;
                                        Tuple7 tmp68 = Tuple7{1, v606};
                                        v608 = tmp68.v0; v609 = tmp68.v1;
                                        while (while_method_0(v608)){
                                            bool v611;
                                            v611 = 0 <= v608;
                                            bool v613;
                                            if (v611){
                                                bool v612;
                                                v612 = v608 < 2;
                                                v613 = v612;
                                            } else {
                                                v613 = false;
                                            }
                                            bool v614;
                                            v614 = v613 == false;
                                            if (v614){
                                                assert("Index must be in range." && v613);
                                            } else {
                                            }
                                            int v616;
                                            v616 = v71[v608];
                                            bool v618;
                                            v618 = v609 >= v616;
                                            int v619;
                                            if (v618){
                                                v619 = v609;
                                            } else {
                                                v619 = v616;
                                            }
                                            v609 = v619;
                                            v608 += 1 ;
                                        }
                                        bool v621;
                                        if (v74){
                                            bool v620;
                                            v620 = v70 < 2;
                                            v621 = v620;
                                        } else {
                                            v621 = false;
                                        }
                                        bool v622;
                                        v622 = v621 == false;
                                        if (v622){
                                            assert("Index must be in range." && v621);
                                        } else {
                                        }
                                        int v624;
                                        v624 = v71[v70];
                                        bool v626;
                                        v626 = v624 == v609;
                                        if (v626){
                                            v680 = Union1{Union1_0{}};
                                        } else {
                                            v680 = Union1{Union1_1{}};
                                        }
                                        break;
                                    }
                                    case 2: { // AA_Raise
                                        bool v631;
                                        v631 = v72 > 0;
                                        if (v631){
                                            v680 = Union1{Union1_2{}};
                                        } else {
                                            v680 = Union1{Union1_0{}};
                                        }
                                        break;
                                    }
                                    default: {
                                        assert("Invalid tag." && false); __trap();
                                    }
                                }
                                break;
                            }
                            case 1: { // Human
                                printf("%s\n", "Humans aren't allowed during training.");
                                __trap();
                                break;
                            }
                            case 2: { // Random
                                curandStatePhilox4_32_10_t & v638 = v2.v5;
                                curandStatePhilox4_32_10_t & v639 = v638;
                                static_array_list<Union1,3> v640;
                                v640 = static_array_list<Union1,3>{};
                                v640.unsafe_set_length(1);
                                Union1 v642;
                                v642 = Union1{Union1_0{}};
                                v640[0] = v642;
                                int v644;
                                v644 = v71[0];
                                int v646;
                                v646 = v71[1];
                                bool v648;
                                v648 = v644 == v646;
                                bool v649;
                                v649 = v648 != true;
                                if (v649){
                                    Union1 v650;
                                    v650 = Union1{Union1_1{}};
                                    v640.push(v650);
                                } else {
                                }
                                bool v651;
                                v651 = v72 > 0;
                                if (v651){
                                    Union1 v652;
                                    v652 = Union1{Union1_2{}};
                                    v640.push(v652);
                                } else {
                                }
                                int v653;
                                v653 = v640.length;
                                int v654;
                                v654 = v653 - 1;
                                int v655;
                                v655 = 0;
                                while (while_method_1(v654, v655)){
                                    int v657;
                                    v657 = v640.length;
                                    int v658;
                                    v658 = int_range_22(v657, v655, v639);
                                    Union1 v659;
                                    v659 = v640[v655];
                                    Union1 v661;
                                    v661 = v640[v658];
                                    v640[v655] = v661;
                                    v640[v658] = v659;
                                    v655 += 1 ;
                                }
                                Union1 v663;
                                v663 = v640.pop();
                                int v664;
                                v664 = sizeof(Union1);
                                unsigned long long v665;
                                v665 = (unsigned long long)v664;
                                bool v666;
                                v666 = v665 <= 98304ull;
                                bool v667;
                                v667 = v666 == false;
                                if (v667){
                                    assert("The dynamic shared memory is insufficient to allocate the tensor." && v666);
                                } else {
                                }
                                extern __shared__ unsigned char v669[];
                                bool v670;
                                v670 = v665 <= v665;
                                bool v671;
                                v671 = v670 == false;
                                if (v671){
                                    assert("The length of the partition has to be less than or equal to the length of the base array." && v670);
                                } else {
                                }
                                Union1 * v673;
                                v673 = reinterpret_cast<Union1 *>(&v669[0ull]);
                                int v675;
                                v675 = threadIdx.x;
                                bool v676;
                                v676 = v675 == 0;
                                if (v676){
                                    v673[0] = v663;
                                } else {
                                }
                                __syncthreads();
                                Union1 v677;
                                v677 = v673[0];
                                __syncthreads();
                                v680 = v677;
                                break;
                            }
                            default: {
                                assert("Invalid tag." && false); __trap();
                            }
                        }
                        Union7 v681;
                        v681 = Union7{Union7_1{v70, v680}};
                        v13.push(v681);
                        v723 = Union14{Union14_2{v67, v68, v69, v70, v71, v72, v680}};
                        break;
                    }
                    case 3: { // RoundWithAction
                        Union5 v683 = v17.case3.v0; bool v684 = v17.case3.v1; static_array<Union6,2> v685 = v17.case3.v2; int v686 = v17.case3.v3; static_array<int,2> v687 = v17.case3.v4; int v688 = v17.case3.v5; Union1 v689 = v17.case3.v6;
                        Union7 v690;
                        v690 = Union7{Union7_1{v686, v689}};
                        v13.push(v690);
                        v723 = Union14{Union14_2{v683, v684, v685, v686, v687, v688, v689}};
                        break;
                    }
                    case 4: { // TerminalCall
                        Union5 v38 = v17.case4.v0; bool v39 = v17.case4.v1; static_array<Union6,2> v40 = v17.case4.v2; int v41 = v17.case4.v3; static_array<int,2> v42 = v17.case4.v4; int v43 = v17.case4.v5;
                        bool v44;
                        v44 = 0 <= v41;
                        bool v46;
                        if (v44){
                            bool v45;
                            v45 = v41 < 2;
                            v46 = v45;
                        } else {
                            v46 = false;
                        }
                        bool v47;
                        v47 = v46 == false;
                        if (v47){
                            assert("Index must be in range." && v46);
                        } else {
                        }
                        int v49;
                        v49 = v42[v41];
                        Union13 v51;
                        v51 = compare_hands_25(v38, v39, v40, v41, v42, v43);
                        int v56; int v57;
                        switch (v51.tag) {
                            case 0: { // Eq
                                v56 = 0; v57 = -1;
                                break;
                            }
                            case 1: { // Gt
                                v56 = v49; v57 = 0;
                                break;
                            }
                            case 2: { // Lt
                                v56 = v49; v57 = 1;
                                break;
                            }
                            default: {
                                assert("Invalid tag." && false); __trap();
                            }
                        }
                        int v58;
                        v58 = -v57;
                        bool v59;
                        v59 = v57 >= v58;
                        int v60;
                        if (v59){
                            v60 = v57;
                        } else {
                            v60 = v58;
                        }
                        float v61;
                        v61 = (float)v56;
                        static_array<float,2> & v62 = v2.v4;
                        v62[v60] = v61;
                        int v63;
                        v63 = v60 ^ 1;
                        float v64;
                        v64 = -v61;
                        v62[v63] = v64;
                        Union7 v65;
                        v65 = Union7{Union7_3{v40, v56, v57}};
                        v13.push(v65);
                        v723 = Union14{Union14_3{}};
                        break;
                    }
                    case 5: { // TerminalFold
                        Union5 v18 = v17.case5.v0; bool v19 = v17.case5.v1; static_array<Union6,2> v20 = v17.case5.v2; int v21 = v17.case5.v3; static_array<int,2> v22 = v17.case5.v4; int v23 = v17.case5.v5;
                        bool v24;
                        v24 = 0 <= v21;
                        bool v26;
                        if (v24){
                            bool v25;
                            v25 = v21 < 2;
                            v26 = v25;
                        } else {
                            v26 = false;
                        }
                        bool v27;
                        v27 = v26 == false;
                        if (v27){
                            assert("Index must be in range." && v26);
                        } else {
                        }
                        int v29;
                        v29 = v22[v21];
                        int v31;
                        v31 = -v29;
                        float v32;
                        v32 = (float)v31;
                        static_array<float,2> & v33 = v2.v4;
                        v33[v21] = v32;
                        int v34;
                        v34 = v21 ^ 1;
                        float v35;
                        v35 = -v32;
                        v33[v34] = v35;
                        Union7 v36;
                        v36 = Union7{Union7_3{v20, v29, v34}};
                        v13.push(v36);
                        v723 = Union14{Union14_3{}};
                        break;
                    }
                    default: {
                        assert("Invalid tag." && false); __trap();
                    }
                }
                switch (v723.tag) {
                    case 0: { // T_game_chance_community_card
                        Union5 v725 = v723.case0.v0; bool v726 = v723.case0.v1; static_array<Union6,2> v727 = v723.case0.v2; int v728 = v723.case0.v3; static_array<int,2> v729 = v723.case0.v4; int v730 = v723.case0.v5; Union6 v731 = v723.case0.v6;
                        int v732;
                        v732 = 2;
                        int v733; int v734;
                        Tuple7 tmp69 = Tuple7{0, 0};
                        v733 = tmp69.v0; v734 = tmp69.v1;
                        while (while_method_0(v733)){
                            bool v736;
                            v736 = 0 <= v733;
                            bool v738;
                            if (v736){
                                bool v737;
                                v737 = v733 < 2;
                                v738 = v737;
                            } else {
                                v738 = false;
                            }
                            bool v739;
                            v739 = v738 == false;
                            if (v739){
                                assert("Index must be in range." && v738);
                            } else {
                            }
                            int v741;
                            v741 = v729[v733];
                            bool v743;
                            v743 = v734 >= v741;
                            int v744;
                            if (v743){
                                v744 = v734;
                            } else {
                                v744 = v741;
                            }
                            v734 = v744;
                            v733 += 1 ;
                        }
                        static_array<int,2> v745;
                        int v747;
                        v747 = 0;
                        while (while_method_0(v747)){
                            v745[v747] = v734;
                            v747 += 1 ;
                        }
                        Union5 v749;
                        v749 = Union5{Union5_1{v731}};
                        Union4 v750;
                        v750 = Union4{Union4_2{v749, true, v727, 0, v745, v732}};
                        v883 = Union3{Union3_1{v750}};
                        break;
                    }
                    case 1: { // T_game_chance_init
                        Union6 v752 = v723.case1.v0; Union6 v753 = v723.case1.v1;
                        int v754;
                        v754 = 2;
                        static_array<int,2> v755;
                        v755[0] = 1;
                        v755[1] = 1;
                        static_array<Union6,2> v757;
                        v757[0] = v752;
                        v757[1] = v753;
                        Union5 v759;
                        v759 = Union5{Union5_0{}};
                        Union4 v760;
                        v760 = Union4{Union4_2{v759, true, v757, 0, v755, v754}};
                        v883 = Union3{Union3_1{v760}};
                        break;
                    }
                    case 2: { // T_game_round
                        Union5 v762 = v723.case2.v0; bool v763 = v723.case2.v1; static_array<Union6,2> v764 = v723.case2.v2; int v765 = v723.case2.v3; static_array<int,2> v766 = v723.case2.v4; int v767 = v723.case2.v5; Union1 v768 = v723.case2.v6;
                        Union4 v875;
                        switch (v762.tag) {
                            case 0: { // None
                                switch (v768.tag) {
                                    case 0: { // Call
                                        if (v763){
                                            int v831;
                                            v831 = v765 ^ 1;
                                            v875 = Union4{Union4_2{v762, false, v764, v831, v766, v767}};
                                        } else {
                                            v875 = Union4{Union4_0{v762, v763, v764, v765, v766, v767}};
                                        }
                                        break;
                                    }
                                    case 1: { // Fold
                                        v875 = Union4{Union4_5{v762, v763, v764, v765, v766, v767}};
                                        break;
                                    }
                                    case 2: { // Raise
                                        bool v835;
                                        v835 = v767 > 0;
                                        if (v835){
                                            int v836;
                                            v836 = v765 ^ 1;
                                            int v837;
                                            v837 = -1 + v767;
                                            int v838; int v839;
                                            Tuple7 tmp70 = Tuple7{0, 0};
                                            v838 = tmp70.v0; v839 = tmp70.v1;
                                            while (while_method_0(v838)){
                                                bool v841;
                                                v841 = 0 <= v838;
                                                bool v843;
                                                if (v841){
                                                    bool v842;
                                                    v842 = v838 < 2;
                                                    v843 = v842;
                                                } else {
                                                    v843 = false;
                                                }
                                                bool v844;
                                                v844 = v843 == false;
                                                if (v844){
                                                    assert("Index must be in range." && v843);
                                                } else {
                                                }
                                                int v846;
                                                v846 = v766[v838];
                                                bool v848;
                                                v848 = v839 >= v846;
                                                int v849;
                                                if (v848){
                                                    v849 = v839;
                                                } else {
                                                    v849 = v846;
                                                }
                                                v839 = v849;
                                                v838 += 1 ;
                                            }
                                            static_array<int,2> v850;
                                            int v852;
                                            v852 = 0;
                                            while (while_method_0(v852)){
                                                v850[v852] = v839;
                                                v852 += 1 ;
                                            }
                                            static_array<int,2> v854;
                                            int v856;
                                            v856 = 0;
                                            while (while_method_0(v856)){
                                                bool v858;
                                                v858 = 0 <= v856;
                                                bool v860;
                                                if (v858){
                                                    bool v859;
                                                    v859 = v856 < 2;
                                                    v860 = v859;
                                                } else {
                                                    v860 = false;
                                                }
                                                bool v861;
                                                v861 = v860 == false;
                                                if (v861){
                                                    assert("Index must be in range." && v860);
                                                } else {
                                                }
                                                int v863;
                                                v863 = v850[v856];
                                                bool v865;
                                                v865 = v856 == v765;
                                                int v867;
                                                if (v865){
                                                    int v866;
                                                    v866 = v863 + 2;
                                                    v867 = v866;
                                                } else {
                                                    v867 = v863;
                                                }
                                                v854[v856] = v867;
                                                v856 += 1 ;
                                            }
                                            v875 = Union4{Union4_2{v762, false, v764, v836, v854, v837}};
                                        } else {
                                            printf("%s\n", "Invalid action. The number of raises left is not positive.");
                                            __trap();
                                        }
                                        break;
                                    }
                                    default: {
                                        assert("Invalid tag." && false); __trap();
                                    }
                                }
                                break;
                            }
                            case 1: { // Some
                                Union6 v769 = v762.case1.v0;
                                switch (v768.tag) {
                                    case 0: { // Call
                                        if (v763){
                                            int v771;
                                            v771 = v765 ^ 1;
                                            v875 = Union4{Union4_2{v762, false, v764, v771, v766, v767}};
                                        } else {
                                            int v773; int v774;
                                            Tuple7 tmp71 = Tuple7{0, 0};
                                            v773 = tmp71.v0; v774 = tmp71.v1;
                                            while (while_method_0(v773)){
                                                bool v776;
                                                v776 = 0 <= v773;
                                                bool v778;
                                                if (v776){
                                                    bool v777;
                                                    v777 = v773 < 2;
                                                    v778 = v777;
                                                } else {
                                                    v778 = false;
                                                }
                                                bool v779;
                                                v779 = v778 == false;
                                                if (v779){
                                                    assert("Index must be in range." && v778);
                                                } else {
                                                }
                                                int v781;
                                                v781 = v766[v773];
                                                bool v783;
                                                v783 = v774 >= v781;
                                                int v784;
                                                if (v783){
                                                    v784 = v774;
                                                } else {
                                                    v784 = v781;
                                                }
                                                v774 = v784;
                                                v773 += 1 ;
                                            }
                                            static_array<int,2> v785;
                                            int v787;
                                            v787 = 0;
                                            while (while_method_0(v787)){
                                                v785[v787] = v774;
                                                v787 += 1 ;
                                            }
                                            v875 = Union4{Union4_4{v762, v763, v764, v765, v785, v767}};
                                        }
                                        break;
                                    }
                                    case 1: { // Fold
                                        v875 = Union4{Union4_5{v762, v763, v764, v765, v766, v767}};
                                        break;
                                    }
                                    case 2: { // Raise
                                        bool v791;
                                        v791 = v767 > 0;
                                        if (v791){
                                            int v792;
                                            v792 = v765 ^ 1;
                                            int v793;
                                            v793 = -1 + v767;
                                            int v794; int v795;
                                            Tuple7 tmp72 = Tuple7{0, 0};
                                            v794 = tmp72.v0; v795 = tmp72.v1;
                                            while (while_method_0(v794)){
                                                bool v797;
                                                v797 = 0 <= v794;
                                                bool v799;
                                                if (v797){
                                                    bool v798;
                                                    v798 = v794 < 2;
                                                    v799 = v798;
                                                } else {
                                                    v799 = false;
                                                }
                                                bool v800;
                                                v800 = v799 == false;
                                                if (v800){
                                                    assert("Index must be in range." && v799);
                                                } else {
                                                }
                                                int v802;
                                                v802 = v766[v794];
                                                bool v804;
                                                v804 = v795 >= v802;
                                                int v805;
                                                if (v804){
                                                    v805 = v795;
                                                } else {
                                                    v805 = v802;
                                                }
                                                v795 = v805;
                                                v794 += 1 ;
                                            }
                                            static_array<int,2> v806;
                                            int v808;
                                            v808 = 0;
                                            while (while_method_0(v808)){
                                                v806[v808] = v795;
                                                v808 += 1 ;
                                            }
                                            static_array<int,2> v810;
                                            int v812;
                                            v812 = 0;
                                            while (while_method_0(v812)){
                                                bool v814;
                                                v814 = 0 <= v812;
                                                bool v816;
                                                if (v814){
                                                    bool v815;
                                                    v815 = v812 < 2;
                                                    v816 = v815;
                                                } else {
                                                    v816 = false;
                                                }
                                                bool v817;
                                                v817 = v816 == false;
                                                if (v817){
                                                    assert("Index must be in range." && v816);
                                                } else {
                                                }
                                                int v819;
                                                v819 = v806[v812];
                                                bool v821;
                                                v821 = v812 == v765;
                                                int v823;
                                                if (v821){
                                                    int v822;
                                                    v822 = v819 + 4;
                                                    v823 = v822;
                                                } else {
                                                    v823 = v819;
                                                }
                                                v810[v812] = v823;
                                                v812 += 1 ;
                                            }
                                            v875 = Union4{Union4_2{v762, false, v764, v792, v810, v793}};
                                        } else {
                                            printf("%s\n", "Invalid action. The number of raises left is not positive.");
                                            __trap();
                                        }
                                        break;
                                    }
                                    default: {
                                        assert("Invalid tag." && false); __trap();
                                    }
                                }
                                break;
                            }
                            default: {
                                assert("Invalid tag." && false); __trap();
                            }
                        }
                        v883 = Union3{Union3_1{v875}};
                        break;
                    }
                    case 3: { // T_none
                        v883 = Union3{Union3_0{}};
                        break;
                    }
                    default: {
                        assert("Invalid tag." && false); __trap();
                    }
                }
                break;
            }
            default: {
                assert("Invalid tag." && false); __trap();
            }
        }
        v15 = v883;
    }
    return ;
}
extern "C" __global__ void entry0(unsigned char * v0, unsigned char * v1, unsigned char * v2, unsigned long long v3, unsigned char * v4, unsigned long long v5) {
    Union0 v6;
    v6 = f_0(v1);
    unsigned int v7; Union3 v8; static_array_list<Union7,32> v9; static_array<Union2,2> v10; Union8 v11;
    Tuple0 tmp10 = f_6(v0);
    v7 = tmp10.v0; v8 = tmp10.v1; v9 = tmp10.v2; v10 = tmp10.v3; v11 = tmp10.v4;
    unsigned long long v12;
    v12 = clock64();
    int v13;
    v13 = threadIdx.x;
    int v14;
    v14 = blockIdx.x;
    int v15;
    v15 = v14 * 256;
    int v16;
    v16 = v13 + v15;
    unsigned long long v17;
    v17 = (unsigned long long)v16;
    curandStatePhilox4_32_10_t v18;
    curand_init(v12,v17,0ull,&v18);
    curandStatePhilox4_32_10_t & v19 = v18;
    StackMut0 v20{v7, v8, v9, v10, v19, v11};
    Union3 v57;
    switch (v6.tag) {
        case 0: { // ActionSelected
            Union1 v35 = v6.case0.v0;
            Union3 & v36 = v20.v1;
            switch (v36.tag) {
                case 0: { // None
                    printf("%s\n", "The game hasn't been started in ActionSelected.");
                    __trap();
                    break;
                }
                case 1: { // Some
                    Union4 v37 = v36.case1.v0;
                    switch (v37.tag) {
                        case 2: { // Round
                            Union5 v38 = v37.case2.v0; bool v39 = v37.case2.v1; static_array<Union6,2> v40 = v37.case2.v2; int v41 = v37.case2.v3; static_array<int,2> v42 = v37.case2.v4; int v43 = v37.case2.v5;
                            Union4 v44;
                            v44 = Union4{Union4_3{v38, v39, v40, v41, v42, v43, v35}};
                            v57 = Union3{Union3_1{v44}};
                            break;
                        }
                        default: {
                            printf("%s\n", "Unexpected game node in ActionSelected.");
                            __trap();
                        }
                    }
                    break;
                }
                default: {
                    assert("Invalid tag." && false); __trap();
                }
            }
            break;
        }
        case 1: { // PlayerChanged
            static_array<Union2,2> v33 = v6.case1.v0;
            v20.v3 = v33;
            v57 = Union3{Union3_0{}};
            break;
        }
        case 2: { // StartGame
            static_array<Union2,2> v21;
            Union2 v23;
            v23 = Union2{Union2_0{}};
            v21[0] = v23;
            Union2 v25;
            v25 = Union2{Union2_1{}};
            v21[1] = v25;
            static_array_list<Union7,32> v27;
            v27 = static_array_list<Union7,32>{};
            Union8 v29;
            v29 = Union8{Union8_0{}};
            v20.v5 = v29;
            Union3 v30;
            v30 = Union3{Union3_0{}};
            v20.v1 = v30;
            v20.v0 = 63u;
            v20.v2 = v27;
            Union4 v31;
            v31 = Union4{Union4_1{}};
            v57 = Union3{Union3_1{v31}};
            break;
        }
        case 3: { // StartTrainingVsRando
            printf("%s\n", "Training is not supported in the `event_loop_play` function.");
            __trap();
            break;
        }
        case 4: { // StartTrainingVsSelf
            printf("%s\n", "Training is not supported in the `event_loop_play` function.");
            __trap();
            break;
        }
        default: {
            assert("Invalid tag." && false); __trap();
        }
    }
    switch (v57.tag) {
        case 0: { // None
            break;
        }
        case 1: { // Some
            Union4 v58 = v57.case1.v0;
            static_array_list<Union7,32> & v59 = v20.v2;
            Union3 v60;
            v60 = Union3{Union3_1{v58}};
            Union3 v61;
            v61 = v60;
            while (while_method_2(v61)){
                Union3 v1075;
                switch (v61.tag) {
                    case 0: { // None
                        v1075 = Union3{Union3_0{}};
                        break;
                    }
                    case 1: { // Some
                        Union4 v63 = v61.case1.v0;
                        switch (v63.tag) {
                            case 0: { // ChanceCommunityCard
                                Union5 v1015 = v63.case0.v0; bool v1016 = v63.case0.v1; static_array<Union6,2> v1017 = v63.case0.v2; int v1018 = v63.case0.v3; static_array<int,2> v1019 = v63.case0.v4; int v1020 = v63.case0.v5;
                                curandStatePhilox4_32_10_t & v1021 = v20.v4;
                                curandStatePhilox4_32_10_t & v1022 = v1021;
                                unsigned int & v1023 = v20.v0;
                                Union6 v1024; unsigned int v1025;
                                Tuple6 tmp11 = draw_card_20(v1022, v1023);
                                v1024 = tmp11.v0; v1025 = tmp11.v1;
                                v20.v0 = v1025;
                                Union7 v1026;
                                v1026 = Union7{Union7_0{v1024}};
                                v59.push(v1026);
                                int v1027;
                                v1027 = 2;
                                int v1028; int v1029;
                                Tuple7 tmp12 = Tuple7{0, 0};
                                v1028 = tmp12.v0; v1029 = tmp12.v1;
                                while (while_method_0(v1028)){
                                    bool v1031;
                                    v1031 = 0 <= v1028;
                                    bool v1033;
                                    if (v1031){
                                        bool v1032;
                                        v1032 = v1028 < 2;
                                        v1033 = v1032;
                                    } else {
                                        v1033 = false;
                                    }
                                    bool v1034;
                                    v1034 = v1033 == false;
                                    if (v1034){
                                        assert("Index must be in range." && v1033);
                                    } else {
                                    }
                                    int v1036;
                                    v1036 = v1019[v1028];
                                    bool v1038;
                                    v1038 = v1029 >= v1036;
                                    int v1039;
                                    if (v1038){
                                        v1039 = v1029;
                                    } else {
                                        v1039 = v1036;
                                    }
                                    v1029 = v1039;
                                    v1028 += 1 ;
                                }
                                static_array<int,2> v1040;
                                int v1042;
                                v1042 = 0;
                                while (while_method_0(v1042)){
                                    v1040[v1042] = v1029;
                                    v1042 += 1 ;
                                }
                                Union5 v1044;
                                v1044 = Union5{Union5_1{v1024}};
                                Union4 v1045;
                                v1045 = Union4{Union4_2{v1044, true, v1017, 0, v1040, v1027}};
                                v1075 = Union3{Union3_1{v1045}};
                                break;
                            }
                            case 1: { // ChanceInit
                                curandStatePhilox4_32_10_t & v1047 = v20.v4;
                                curandStatePhilox4_32_10_t & v1048 = v1047;
                                unsigned int & v1049 = v20.v0;
                                Union6 v1050; unsigned int v1051;
                                Tuple6 tmp13 = draw_card_20(v1048, v1049);
                                v1050 = tmp13.v0; v1051 = tmp13.v1;
                                v20.v0 = v1051;
                                curandStatePhilox4_32_10_t & v1052 = v20.v4;
                                curandStatePhilox4_32_10_t & v1053 = v1052;
                                unsigned int & v1054 = v20.v0;
                                Union6 v1055; unsigned int v1056;
                                Tuple6 tmp14 = draw_card_20(v1053, v1054);
                                v1055 = tmp14.v0; v1056 = tmp14.v1;
                                v20.v0 = v1056;
                                Union7 v1057;
                                v1057 = Union7{Union7_2{0, v1050}};
                                v59.push(v1057);
                                Union7 v1058;
                                v1058 = Union7{Union7_2{1, v1055}};
                                v59.push(v1058);
                                int v1059;
                                v1059 = 2;
                                static_array<int,2> v1060;
                                v1060[0] = 1;
                                v1060[1] = 1;
                                static_array<Union6,2> v1062;
                                v1062[0] = v1050;
                                v1062[1] = v1055;
                                Union5 v1064;
                                v1064 = Union5{Union5_0{}};
                                Union4 v1065;
                                v1065 = Union4{Union4_2{v1064, true, v1062, 0, v1060, v1059}};
                                v1075 = Union3{Union3_1{v1065}};
                                break;
                            }
                            case 2: { // Round
                                Union5 v106 = v63.case2.v0; bool v107 = v63.case2.v1; static_array<Union6,2> v108 = v63.case2.v2; int v109 = v63.case2.v3; static_array<int,2> v110 = v63.case2.v4; int v111 = v63.case2.v5;
                                static_array<Union2,2> & v112 = v20.v3;
                                bool v113;
                                v113 = 0 <= v109;
                                bool v115;
                                if (v113){
                                    bool v114;
                                    v114 = v109 < 2;
                                    v115 = v114;
                                } else {
                                    v115 = false;
                                }
                                bool v116;
                                v116 = v115 == false;
                                if (v116){
                                    assert("Index must be in range." && v115);
                                } else {
                                }
                                Union2 v118;
                                v118 = v112[v109];
                                switch (v118.tag) {
                                    case 0: { // Computer
                                        bool v120;
                                        v120 = 2981904ull == v5;
                                        bool v121;
                                        v121 = v120 == false;
                                        if (v121){
                                            assert("The params needs to have matching offsets." && v120);
                                        } else {
                                        }
                                        bool v123;
                                        v123 = 25264128ull == v3;
                                        bool v124;
                                        v124 = v123 == false;
                                        if (v124){
                                            assert("The outputs needs to have matching offsets." && v123);
                                        } else {
                                        }
                                        static_array_list<Union7,32> & v126 = v20.v2;
                                        curandStatePhilox4_32_10_t & v127 = v20.v4;
                                        curandStatePhilox4_32_10_t & v128 = v127;
                                        unsigned int * v129;
                                        v129 = reinterpret_cast<unsigned int *>(&v2[6291456ull]);
                                        float * v131;
                                        v131 = reinterpret_cast<float *>(&v2[0ull]);
                                        float * v133;
                                        v133 = reinterpret_cast<float *>(&v2[0ull]);
                                        int v135;
                                        v135 = blockIdx.x;
                                        assert("Tensor range check" && 0 <= v135 && v135 < 24);
                                        int v136;
                                        v136 = 32768 * v135;
                                        int v137;
                                        v137 = threadIdx.x;
                                        int v138;
                                        v138 = v137;
                                        while (while_method_3(v138)){
                                            bool v140;
                                            v140 = 0 <= v138;
                                            bool v141;
                                            v141 = v140 == false;
                                            if (v141){
                                                assert("The index needs to be zero or positive." && v140);
                                            } else {
                                            }
                                            int v143;
                                            v143 = v138 % 128;
                                            int v144;
                                            v144 = v138 / 128;
                                            bool v145;
                                            v145 = v144 < 256;
                                            bool v146;
                                            v146 = v145 == false;
                                            if (v146){
                                                assert("The last element of the projection dimensions needs to be greater than the index remainder." && v145);
                                            } else {
                                            }
                                            assert("Tensor range check" && 0 <= v144 && v144 < 256);
                                            assert("Tensor range check" && 0 <= v143 && v143 < 128);
                                            int v148;
                                            v148 = v143 + v136;
                                            int v149;
                                            v149 = 128 * v144;
                                            int v150;
                                            v150 = v149 + v148;
                                            v133[v150] = 0.0f;
                                            v138 += 256 ;
                                        }
                                        __syncthreads();
                                        int v151;
                                        v151 = threadIdx.x;
                                        assert("Tensor range check" && 0 <= v151 && v151 < 256);
                                        int v152;
                                        v152 = 128 * v151;
                                        int v153;
                                        v153 = v152 + v136;
                                        static_array_list<Union9,10> v154;
                                        v154 = static_array_list<Union9,10>{};
                                        int v156;
                                        v156 = v126.length;
                                        int v157;
                                        v157 = 0;
                                        while (while_method_1(v156, v157)){
                                            Union7 v159;
                                            v159 = v126[v157];
                                            Union10 v178;
                                            switch (v159.tag) {
                                                case 0: { // CommunityCardIs
                                                    Union6 v168 = v159.case0.v0;
                                                    Union9 v169;
                                                    v169 = Union9{Union9_1{v168}};
                                                    v178 = Union10{Union10_1{v169}};
                                                    break;
                                                }
                                                case 1: { // PlayerAction
                                                    int v171 = v159.case1.v0; Union1 v172 = v159.case1.v1;
                                                    Union9 v173;
                                                    v173 = Union9{Union9_0{v172}};
                                                    v178 = Union10{Union10_1{v173}};
                                                    break;
                                                }
                                                case 2: { // PlayerGotCard
                                                    int v161 = v159.case2.v0; Union6 v162 = v159.case2.v1;
                                                    bool v163;
                                                    v163 = v161 == v109;
                                                    if (v163){
                                                        Union9 v164;
                                                        v164 = Union9{Union9_1{v162}};
                                                        v178 = Union10{Union10_1{v164}};
                                                    } else {
                                                        v178 = Union10{Union10_0{}};
                                                    }
                                                    break;
                                                }
                                                default: {
                                                    v178 = Union10{Union10_0{}};
                                                }
                                            }
                                            switch (v178.tag) {
                                                case 0: { // None
                                                    break;
                                                }
                                                case 1: { // Some
                                                    Union9 v179 = v178.case1.v0;
                                                    v154.push(v179);
                                                    break;
                                                }
                                                default: {
                                                    assert("Invalid tag." && false); __trap();
                                                }
                                            }
                                            v157 += 1 ;
                                        }
                                        float * v180;
                                        v180 = v133+v153;
                                        int v182;
                                        v182 = v154.length;
                                        bool v183;
                                        v183 = v182 == 0;
                                        if (v183){
                                            v180[0] = 1.0f;
                                        } else {
                                        }
                                        int v184;
                                        v184 = v154.length;
                                        int v185;
                                        v185 = 0;
                                        while (while_method_1(v184, v185)){
                                            Union9 v187;
                                            v187 = v154[v185];
                                            int v189;
                                            v189 = v185 * 6;
                                            int v190;
                                            v190 = 1 + v189;
                                            switch (v187.tag) {
                                                case 0: { // C1of2
                                                    Union1 v191 = v187.case0.v0;
                                                    switch (v191.tag) {
                                                        case 0: { // Call
                                                            v180[v190] = 1.0f;
                                                            break;
                                                        }
                                                        case 1: { // Fold
                                                            int v192;
                                                            v192 = v190 + 1;
                                                            v180[v192] = 1.0f;
                                                            break;
                                                        }
                                                        case 2: { // Raise
                                                            int v193;
                                                            v193 = v190 + 2;
                                                            v180[v193] = 1.0f;
                                                            break;
                                                        }
                                                        default: {
                                                            assert("Invalid tag." && false); __trap();
                                                        }
                                                    }
                                                    break;
                                                }
                                                case 1: { // C2of2
                                                    Union6 v194 = v187.case1.v0;
                                                    int v195;
                                                    v195 = v190 + 3;
                                                    switch (v194.tag) {
                                                        case 0: { // Jack
                                                            v180[v195] = 1.0f;
                                                            break;
                                                        }
                                                        case 1: { // King
                                                            int v196;
                                                            v196 = v195 + 1;
                                                            v180[v196] = 1.0f;
                                                            break;
                                                        }
                                                        case 2: { // Queen
                                                            int v197;
                                                            v197 = v195 + 2;
                                                            v180[v197] = 1.0f;
                                                            break;
                                                        }
                                                        default: {
                                                            assert("Invalid tag." && false); __trap();
                                                        }
                                                    }
                                                    break;
                                                }
                                                default: {
                                                    assert("Invalid tag." && false); __trap();
                                                }
                                            }
                                            v185 += 1 ;
                                        }
                                        __syncthreads();
                                        int v198;
                                        v198 = 0;
                                        int v199;
                                        v199 = 4;
                                        int v200;
                                        v200 = int_range_22(v199, v198, v128);
                                        extern __shared__ unsigned char v201[];
                                        int * v202;
                                        v202 = reinterpret_cast<int *>(&v201[0ull]);
                                        int v204;
                                        v204 = threadIdx.x;
                                        bool v205;
                                        v205 = v204 == 0;
                                        if (v205){
                                            v202[0] = v200;
                                        } else {
                                        }
                                        __syncthreads();
                                        int v206;
                                        v206 = v202[0];
                                        __syncthreads();
                                        float * v207;
                                        v207 = reinterpret_cast<float *>(&v2[0ull]);
                                        float * v209;
                                        v209 = reinterpret_cast<float *>(&v4[0ull]);
                                        assert("Tensor range check" && 0 <= v206 && v206 < 4);
                                        int v211;
                                        v211 = 16384 * v206;
                                        float * v212;
                                        v212 = reinterpret_cast<float *>(&v2[3145728ull]);
                                        int v214;
                                        v214 = blockIdx.x;
                                        assert("Tensor range check" && 0 <= v214 && v214 < 24);
                                        int v215;
                                        v215 = 32768 * v214;
                                        int v216;
                                        v216 = blockIdx.x;
                                        assert("Tensor range check" && 0 <= v216 && v216 < 24);
                                        int v217;
                                        v217 = 32768 * v216;
                                        cuda::pipeline<cuda::thread_scope_thread> v218 = cuda::make_pipeline();
                                        extern __shared__ unsigned char v219[];
                                        float * v220;
                                        v220 = reinterpret_cast<float *>(&v219[0ull]);
                                        float * v222;
                                        v222 = reinterpret_cast<float *>(&v219[34816ull]);
                                        float * v224;
                                        v224 = reinterpret_cast<float *>(&v219[0ull]);
                                        int v226;
                                        v226 = threadIdx.x;
                                        int v227;
                                        v227 = v226 / 32;
                                        bool v228;
                                        v228 = 0 <= v227;
                                        bool v229;
                                        v229 = v228 == false;
                                        if (v229){
                                            assert("The index needs to be zero or positive." && v228);
                                        } else {
                                        }
                                        int v231;
                                        v231 = v227 % 8;
                                        int v232;
                                        v232 = v227 / 8;
                                        bool v233;
                                        v233 = v232 < 1;
                                        bool v234;
                                        v234 = v233 == false;
                                        if (v234){
                                            assert("The last element of the projection dimensions needs to be greater than the index remainder." && v233);
                                        } else {
                                        }
                                        assert("Tensor range check" && 0 <= v232 && v232 < 1);
                                        assert("Tensor range check" && 0 <= v231 && v231 < 8);
                                        int v236;
                                        v236 = 16 * v231;
                                        int v237;
                                        v237 = 17408 * v232;
                                        int v238;
                                        v238 = v237 + v236;
                                        float * v239;
                                        v239 = v224+v238;
                                        assert("Tensor range check" && 0 <= v232 && v232 < 1);
                                        int v241;
                                        v241 = 8704 * v232;
                                        int v242;
                                        v242 = threadIdx.x;
                                        int v243;
                                        v243 = v242 % 32;
                                        bool v244;
                                        v244 = 0 <= v243;
                                        bool v245;
                                        v245 = v244 == false;
                                        if (v245){
                                            assert("The index needs to be zero or positive." && v244);
                                        } else {
                                        }
                                        int v247;
                                        v247 = v243 % 4;
                                        int v248;
                                        v248 = v243 / 4;
                                        bool v249;
                                        v249 = v248 < 8;
                                        bool v250;
                                        v250 = v249 == false;
                                        if (v250){
                                            assert("The last element of the projection dimensions needs to be greater than the index remainder." && v249);
                                        } else {
                                        }
                                        assert("Tensor range check" && 0 <= v248 && v248 < 8);
                                        assert("Tensor range check" && 0 <= v247 && v247 < 4);
                                        int v252;
                                        v252 = v247 + v241;
                                        int v253;
                                        v253 = 68 * v248;
                                        int v254;
                                        v254 = v253 + v252;
                                        float * v255;
                                        v255 = v220+v254;
                                        assert("Tensor range check" && 0 <= v231 && v231 < 8);
                                        int v257;
                                        v257 = 1088 * v231;
                                        int v258;
                                        v258 = threadIdx.x;
                                        int v259;
                                        v259 = v258 % 32;
                                        bool v260;
                                        v260 = 0 <= v259;
                                        bool v261;
                                        v261 = v260 == false;
                                        if (v261){
                                            assert("The index needs to be zero or positive." && v260);
                                        } else {
                                        }
                                        int v263;
                                        v263 = v259 % 4;
                                        int v264;
                                        v264 = v259 / 4;
                                        bool v265;
                                        v265 = v264 < 8;
                                        bool v266;
                                        v266 = v265 == false;
                                        if (v266){
                                            assert("The last element of the projection dimensions needs to be greater than the index remainder." && v265);
                                        } else {
                                        }
                                        assert("Tensor range check" && 0 <= v264 && v264 < 8);
                                        assert("Tensor range check" && 0 <= v263 && v263 < 4);
                                        int v268;
                                        v268 = v263 + v257;
                                        int v269;
                                        v269 = 68 * v264;
                                        int v270;
                                        v270 = v269 + v268;
                                        float * v271;
                                        v271 = v222+v270;
                                        wmma::fragment<wmma::accumulator, 16, 16, 8, float> v273[8];
                                        int v274;
                                        v274 = 0;
                                        while (while_method_0(v274)){
                                            int v276;
                                            v276 = 0;
                                            while (while_method_4(v276)){
                                                assert("Tensor range check" && 0 <= v274 && v274 < 2);
                                                assert("Tensor range check" && 0 <= v276 && v276 < 1);
                                                int v278;
                                                v278 = 128 * v276;
                                                int v279;
                                                v279 = v278 + v217;
                                                int v280;
                                                v280 = 16384 * v274;
                                                int v281;
                                                v281 = v280 + v279;
                                                float * v282;
                                                v282 = v212+v281;
                                                // Pushing the loop unrolling to: 0
                                                int v284;
                                                v284 = 0;
                                                #pragma unroll
                                                while (while_method_5(v284)){
                                                    int v286;
                                                    v286 = 0;
                                                    #pragma unroll
                                                    while (while_method_4(v286)){
                                                        assert("Tensor range check" && 0 <= v284 && v284 < 8);
                                                        assert("Tensor range check" && 0 <= v286 && v286 < 1);
                                                        int v288;
                                                        v288 = v284 + v286;
                                                        wmma::fragment<wmma::accumulator, 16, 16, 8, float> & v289 = v273[v288];
                                                        wmma::fill_fragment(v289, 0.0f);
                                                        v286 += 1 ;
                                                    }
                                                    v284 += 1 ;
                                                }
                                                // Poping the loop unrolling to: 0
                                                int v290;
                                                v290 = 0;
                                                while (while_method_6(v290)){
                                                    int v292;
                                                    v292 = v290 + 1;
                                                    bool v293;
                                                    v293 = v290 == 0;
                                                    int v294;
                                                    v294 = v290 % 2;
                                                    bool v295;
                                                    v295 = 0 <= v290;
                                                    bool v296;
                                                    v296 = v295 == false;
                                                    if (v296){
                                                        assert("The index needs to be zero or positive." && v295);
                                                    } else {
                                                    }
                                                    bool v298;
                                                    v298 = v290 < 2;
                                                    bool v299;
                                                    v299 = v298 == false;
                                                    if (v299){
                                                        assert("The last element of the projection dimensions needs to be greater than the index remainder." && v298);
                                                    } else {
                                                    }
                                                    bool v301;
                                                    v301 = v292 < 2;
                                                    Union11 v307;
                                                    if (v301){
                                                        bool v302;
                                                        v302 = 0 <= v292;
                                                        bool v303;
                                                        v303 = v302 == false;
                                                        if (v303){
                                                            assert("The index needs to be zero or positive." && v302);
                                                        } else {
                                                        }
                                                        v307 = Union11{Union11_1{v292}};
                                                    } else {
                                                        v307 = Union11{Union11_0{}};
                                                    }
                                                    assert("Tensor range check" && 0 <= v274 && v274 < 2);
                                                    int v308;
                                                    v308 = v280 + v215;
                                                    assert("Tensor range check" && 0 <= v290 && v290 < 2);
                                                    int v309;
                                                    v309 = 64 * v290;
                                                    int v310;
                                                    v310 = v309 + v308;
                                                    float * v311;
                                                    v311 = v207+v310;
                                                    assert("Tensor range check" && 0 <= v276 && v276 < 1);
                                                    int v313;
                                                    v313 = 16384 * v276;
                                                    int v314;
                                                    v314 = v313 + v211;
                                                    if (v293){
                                                        assert("Tensor range check" && 0 <= v290 && v290 < 2);
                                                        int v315;
                                                        v315 = v309 + v314;
                                                        float * v316;
                                                        v316 = v209+v315;
                                                        // Pushing the loop unrolling to: 0
                                                        v218.producer_acquire();
                                                        int v318;
                                                        v318 = threadIdx.x;
                                                        bool v319;
                                                        v319 = 0 <= v318;
                                                        bool v320;
                                                        v320 = v319 == false;
                                                        if (v320){
                                                            assert("The index needs to be zero or positive." && v319);
                                                        } else {
                                                        }
                                                        int v322;
                                                        v322 = v318 % 16;
                                                        int v323;
                                                        v323 = v318 / 16;
                                                        bool v324;
                                                        v324 = v323 < 16;
                                                        bool v325;
                                                        v325 = v324 == false;
                                                        if (v325){
                                                            assert("The last element of the projection dimensions needs to be greater than the index remainder." && v324);
                                                        } else {
                                                        }
                                                        assert("Tensor range check" && 0 <= v323 && v323 < 16);
                                                        assert("Tensor range check" && 0 <= v322 && v322 < 16);
                                                        int v327;
                                                        v327 = 4 * v322;
                                                        int v328;
                                                        v328 = 68 * v323;
                                                        int v329;
                                                        v329 = v328 + v327;
                                                        int v330;
                                                        v330 = 128 * v323;
                                                        int v331;
                                                        v331 = v330 + v327;
                                                        float * v332;
                                                        v332 = v222+v329;
                                                        float * v334;
                                                        v334 = v316+v331;
                                                        int v336;
                                                        v336 = 0;
                                                        #pragma unroll
                                                        while (while_method_5(v336)){
                                                            int v338;
                                                            v338 = 0;
                                                            #pragma unroll
                                                            while (while_method_4(v338)){
                                                                assert("Tensor range check" && 0 <= v336 && v336 < 8);
                                                                assert("Tensor range check" && 0 <= v338 && v338 < 1);
                                                                int v340;
                                                                v340 = 64 * v338;
                                                                int v341;
                                                                v341 = 1088 * v336;
                                                                int v342;
                                                                v342 = v341 + v340;
                                                                int v343;
                                                                v343 = 2048 * v336;
                                                                int v344;
                                                                v344 = v343 + v340;
                                                                constexpr int v345 = sizeof(float) * 4;
                                                                assert("Pointer alignment check" && (unsigned long long)(v334 + v344) % v345 == 0 && (unsigned long long)(v332 + v342) % v345 == 0);
                                                                cuda::memcpy_async(v332 + v342, v334 + v344, cuda::aligned_size_t<v345>(v345), v218);
                                                                v338 += 1 ;
                                                            }
                                                            v336 += 1 ;
                                                        }
                                                        v218.producer_commit();
                                                        // Poping the loop unrolling to: 0
                                                    } else {
                                                    }
                                                    // Pushing the loop unrolling to: 0
                                                    int v346;
                                                    v346 = threadIdx.x;
                                                    bool v347;
                                                    v347 = 0 <= v346;
                                                    bool v348;
                                                    v348 = v347 == false;
                                                    if (v348){
                                                        assert("The index needs to be zero or positive." && v347);
                                                    } else {
                                                    }
                                                    int v350;
                                                    v350 = v346 % 16;
                                                    int v351;
                                                    v351 = v346 / 16;
                                                    bool v352;
                                                    v352 = v351 < 16;
                                                    bool v353;
                                                    v353 = v352 == false;
                                                    if (v353){
                                                        assert("The last element of the projection dimensions needs to be greater than the index remainder." && v352);
                                                    } else {
                                                    }
                                                    assert("Tensor range check" && 0 <= v351 && v351 < 16);
                                                    assert("Tensor range check" && 0 <= v350 && v350 < 16);
                                                    int v355;
                                                    v355 = 4 * v350;
                                                    int v356;
                                                    v356 = 68 * v351;
                                                    int v357;
                                                    v357 = v356 + v355;
                                                    int v358;
                                                    v358 = 128 * v351;
                                                    int v359;
                                                    v359 = v358 + v355;
                                                    float * v360;
                                                    v360 = v220+v357;
                                                    float * v362;
                                                    v362 = v311+v359;
                                                    int v364;
                                                    v364 = 0;
                                                    #pragma unroll
                                                    while (while_method_5(v364)){
                                                        int v366;
                                                        v366 = 0;
                                                        #pragma unroll
                                                        while (while_method_4(v366)){
                                                            assert("Tensor range check" && 0 <= v364 && v364 < 8);
                                                            assert("Tensor range check" && 0 <= v366 && v366 < 1);
                                                            int v368;
                                                            v368 = 64 * v366;
                                                            int v369;
                                                            v369 = 1088 * v364;
                                                            int v370;
                                                            v370 = v369 + v368;
                                                            int v371;
                                                            v371 = 2048 * v364;
                                                            int v372;
                                                            v372 = v371 + v368;
                                                            int4* v373;
                                                            v373 = reinterpret_cast<int4*>(v362 + v372);
                                                            int4* v374;
                                                            v374 = reinterpret_cast<int4*>(v360 + v370);
                                                            assert("Pointer alignment check" && (unsigned long long)(v373) % 4 == 0 && (unsigned long long)(v374) % 4 == 0);
                                                            *v374 = *v373;
                                                            v366 += 1 ;
                                                        }
                                                        v364 += 1 ;
                                                    }
                                                    // Poping the loop unrolling to: 0
                                                    wmma::fragment<wmma::matrix_a, 16, 16, 8, wmma::precision::tf32, wmma::row_major> v375[1];
                                                    wmma::fragment<wmma::matrix_b, 16, 16, 8, wmma::precision::tf32, wmma::col_major> v376[8];
                                                    cuda::pipeline_consumer_wait_prior<0>(v218);;
                                                    __syncthreads();
                                                    // Pushing the loop unrolling to: 0
                                                    int v377;
                                                    v377 = 0;
                                                    #pragma unroll
                                                    while (while_method_4(v377)){
                                                        int v379;
                                                        v379 = 0;
                                                        #pragma unroll
                                                        while (while_method_5(v379)){
                                                            assert("Tensor range check" && 0 <= v377 && v377 < 1);
                                                            assert("Tensor range check" && 0 <= v379 && v379 < 8);
                                                            int v381;
                                                            v381 = 8 * v377;
                                                            int v382;
                                                            v382 = v381 + v379;
                                                            wmma::fragment<wmma::matrix_b, 16, 16, 8, wmma::precision::tf32, wmma::col_major> & v383 = v376[v382];
                                                            assert("Tensor range check" && 0 <= v377 && v377 < 1);
                                                            int v384;
                                                            v384 = 1088 * v377;
                                                            assert("Tensor range check" && 0 <= v379 && v379 < 8);
                                                            int v385;
                                                            v385 = 8 * v379;
                                                            int v386;
                                                            v386 = v385 + v384;
                                                            int v387;
                                                            v387 = 0;
                                                            #pragma unroll
                                                            while (while_method_0(v387)){
                                                                int v389;
                                                                v389 = 0;
                                                                #pragma unroll
                                                                while (while_method_0(v389)){
                                                                    assert("Tensor range check" && 0 <= v387 && v387 < 2);
                                                                    assert("Tensor range check" && 0 <= v389 && v389 < 2);
                                                                    int v391;
                                                                    v391 = 4 * v389;
                                                                    int v392;
                                                                    v392 = v391 + v386;
                                                                    int v393;
                                                                    v393 = 544 * v387;
                                                                    int v394;
                                                                    v394 = v393 + v392;
                                                                    float v395;
                                                                    v395 = v271[v394];
                                                                    bool v396;
                                                                    v396 = 0 <= v389;
                                                                    bool v398;
                                                                    if (v396){
                                                                        bool v397;
                                                                        v397 = v389 < 2;
                                                                        v398 = v397;
                                                                    } else {
                                                                        v398 = false;
                                                                    }
                                                                    bool v399;
                                                                    v399 = v398 == false;
                                                                    if (v399){
                                                                        assert("The indices should be inside the range of the dimension." && v398);
                                                                    } else {
                                                                    }
                                                                    bool v401;
                                                                    v401 = 0 <= v387;
                                                                    bool v403;
                                                                    if (v401){
                                                                        bool v402;
                                                                        v402 = v387 < 2;
                                                                        v403 = v402;
                                                                    } else {
                                                                        v403 = false;
                                                                    }
                                                                    bool v404;
                                                                    v404 = v403 == false;
                                                                    if (v404){
                                                                        assert("The indices should be inside the range of the dimension." && v403);
                                                                    } else {
                                                                    }
                                                                    int v406;
                                                                    v406 = v387 * 2;
                                                                    int v407;
                                                                    v407 = v389 + v406;
                                                                    v383.x[v407] = wmma::__float_to_tf32(v395);
                                                                    v389 += 1 ;
                                                                }
                                                                v387 += 1 ;
                                                            }
                                                            v379 += 1 ;
                                                        }
                                                        v377 += 1 ;
                                                    }
                                                    // Poping the loop unrolling to: 0
                                                    v218.consumer_release();
                                                    switch (v307.tag) {
                                                        case 0: { // None
                                                            break;
                                                        }
                                                        case 1: { // Some
                                                            int v408 = v307.case1.v0;
                                                            assert("Tensor range check" && 0 <= v408 && v408 < 2);
                                                            int v409;
                                                            v409 = 64 * v408;
                                                            int v410;
                                                            v410 = v409 + v314;
                                                            float * v411;
                                                            v411 = v209+v410;
                                                            __syncthreads();
                                                            // Pushing the loop unrolling to: 0
                                                            v218.producer_acquire();
                                                            int v413;
                                                            v413 = threadIdx.x;
                                                            bool v414;
                                                            v414 = 0 <= v413;
                                                            bool v415;
                                                            v415 = v414 == false;
                                                            if (v415){
                                                                assert("The index needs to be zero or positive." && v414);
                                                            } else {
                                                            }
                                                            int v417;
                                                            v417 = v413 % 16;
                                                            int v418;
                                                            v418 = v413 / 16;
                                                            bool v419;
                                                            v419 = v418 < 16;
                                                            bool v420;
                                                            v420 = v419 == false;
                                                            if (v420){
                                                                assert("The last element of the projection dimensions needs to be greater than the index remainder." && v419);
                                                            } else {
                                                            }
                                                            assert("Tensor range check" && 0 <= v418 && v418 < 16);
                                                            assert("Tensor range check" && 0 <= v417 && v417 < 16);
                                                            int v422;
                                                            v422 = 4 * v417;
                                                            int v423;
                                                            v423 = 68 * v418;
                                                            int v424;
                                                            v424 = v423 + v422;
                                                            int v425;
                                                            v425 = 128 * v418;
                                                            int v426;
                                                            v426 = v425 + v422;
                                                            float * v427;
                                                            v427 = v222+v424;
                                                            float * v429;
                                                            v429 = v411+v426;
                                                            int v431;
                                                            v431 = 0;
                                                            #pragma unroll
                                                            while (while_method_5(v431)){
                                                                int v433;
                                                                v433 = 0;
                                                                #pragma unroll
                                                                while (while_method_4(v433)){
                                                                    assert("Tensor range check" && 0 <= v431 && v431 < 8);
                                                                    assert("Tensor range check" && 0 <= v433 && v433 < 1);
                                                                    int v435;
                                                                    v435 = 64 * v433;
                                                                    int v436;
                                                                    v436 = 1088 * v431;
                                                                    int v437;
                                                                    v437 = v436 + v435;
                                                                    int v438;
                                                                    v438 = 2048 * v431;
                                                                    int v439;
                                                                    v439 = v438 + v435;
                                                                    constexpr int v440 = sizeof(float) * 4;
                                                                    assert("Pointer alignment check" && (unsigned long long)(v429 + v439) % v440 == 0 && (unsigned long long)(v427 + v437) % v440 == 0);
                                                                    cuda::memcpy_async(v427 + v437, v429 + v439, cuda::aligned_size_t<v440>(v440), v218);
                                                                    v433 += 1 ;
                                                                }
                                                                v431 += 1 ;
                                                            }
                                                            v218.producer_commit();
                                                            // Poping the loop unrolling to: 0
                                                            break;
                                                        }
                                                        default: {
                                                            assert("Invalid tag." && false); __trap();
                                                        }
                                                    }
                                                    // Pushing the loop unrolling to: 0
                                                    int v441;
                                                    v441 = 0;
                                                    #pragma unroll
                                                    while (while_method_5(v441)){
                                                        int v443;
                                                        v443 = 0;
                                                        #pragma unroll
                                                        while (while_method_5(v443)){
                                                            wmma::fragment<wmma::matrix_a, 16, 16, 8, wmma::precision::tf32, wmma::row_major> & v445 = v375[0];
                                                            assert("Tensor range check" && 0 <= v441 && v441 < 8);
                                                            int v446;
                                                            v446 = 1088 * v441;
                                                            assert("Tensor range check" && 0 <= v443 && v443 < 8);
                                                            int v447;
                                                            v447 = 8 * v443;
                                                            int v448;
                                                            v448 = v447 + v446;
                                                            int v449;
                                                            v449 = 0;
                                                            #pragma unroll
                                                            while (while_method_0(v449)){
                                                                int v451;
                                                                v451 = 0;
                                                                #pragma unroll
                                                                while (while_method_0(v451)){
                                                                    assert("Tensor range check" && 0 <= v449 && v449 < 2);
                                                                    assert("Tensor range check" && 0 <= v451 && v451 < 2);
                                                                    int v453;
                                                                    v453 = 544 * v451;
                                                                    int v454;
                                                                    v454 = v453 + v448;
                                                                    int v455;
                                                                    v455 = 4 * v449;
                                                                    int v456;
                                                                    v456 = v455 + v454;
                                                                    float v457;
                                                                    v457 = v255[v456];
                                                                    bool v458;
                                                                    v458 = 0 <= v451;
                                                                    bool v460;
                                                                    if (v458){
                                                                        bool v459;
                                                                        v459 = v451 < 2;
                                                                        v460 = v459;
                                                                    } else {
                                                                        v460 = false;
                                                                    }
                                                                    bool v461;
                                                                    v461 = v460 == false;
                                                                    if (v461){
                                                                        assert("The indices should be inside the range of the dimension." && v460);
                                                                    } else {
                                                                    }
                                                                    bool v463;
                                                                    v463 = 0 <= v449;
                                                                    bool v465;
                                                                    if (v463){
                                                                        bool v464;
                                                                        v464 = v449 < 2;
                                                                        v465 = v464;
                                                                    } else {
                                                                        v465 = false;
                                                                    }
                                                                    bool v466;
                                                                    v466 = v465 == false;
                                                                    if (v466){
                                                                        assert("The indices should be inside the range of the dimension." && v465);
                                                                    } else {
                                                                    }
                                                                    int v468;
                                                                    v468 = v449 * 2;
                                                                    int v469;
                                                                    v469 = v451 + v468;
                                                                    v445.x[v469] = wmma::__float_to_tf32(v457);
                                                                    v451 += 1 ;
                                                                }
                                                                v449 += 1 ;
                                                            }
                                                            int v470;
                                                            v470 = 0;
                                                            #pragma unroll
                                                            while (while_method_4(v470)){
                                                                assert("Tensor range check" && 0 <= v441 && v441 < 8);
                                                                assert("Tensor range check" && 0 <= v470 && v470 < 1);
                                                                int v472;
                                                                v472 = v441 + v470;
                                                                wmma::fragment<wmma::accumulator, 16, 16, 8, float> & v473 = v273[v472];
                                                                assert("Tensor range check" && 0 <= v470 && v470 < 1);
                                                                assert("Tensor range check" && 0 <= v443 && v443 < 8);
                                                                int v474;
                                                                v474 = 8 * v470;
                                                                int v475;
                                                                v475 = v474 + v443;
                                                                wmma::fragment<wmma::matrix_b, 16, 16, 8, wmma::precision::tf32, wmma::col_major> & v476 = v376[v475];
                                                                wmma::mma_sync(v473, v445, v476, v473);
                                                                v470 += 1 ;
                                                            }
                                                            v443 += 1 ;
                                                        }
                                                        v441 += 1 ;
                                                    }
                                                    // Poping the loop unrolling to: 0
                                                    __syncthreads();
                                                    v290 = v292;
                                                }
                                                // Pushing the loop unrolling to: 0
                                                int v477;
                                                v477 = 0;
                                                #pragma unroll
                                                while (while_method_5(v477)){
                                                    int v479;
                                                    v479 = 0;
                                                    #pragma unroll
                                                    while (while_method_4(v479)){
                                                        assert("Tensor range check" && 0 <= v477 && v477 < 8);
                                                        assert("Tensor range check" && 0 <= v479 && v479 < 1);
                                                        int v481;
                                                        v481 = v477 + v479;
                                                        wmma::fragment<wmma::accumulator, 16, 16, 8, float> & v482 = v273[v481];
                                                        assert("Tensor range check" && 0 <= v477 && v477 < 8);
                                                        assert("Tensor range check" && 0 <= v479 && v479 < 1);
                                                        int v483;
                                                        v483 = 16 * v479;
                                                        int v484;
                                                        v484 = 2176 * v477;
                                                        int v485;
                                                        v485 = v484 + v483;
                                                        float * v486;
                                                        v486 = v239+v485;
                                                        wmma::store_matrix_sync(v486, v482, 136, wmma::mem_row_major);
                                                        v479 += 1 ;
                                                    }
                                                    v477 += 1 ;
                                                }
                                                // Poping the loop unrolling to: 0
                                                __syncthreads();
                                                // Pushing the loop unrolling to: 0
                                                int v488;
                                                v488 = threadIdx.x;
                                                bool v489;
                                                v489 = 0 <= v488;
                                                bool v490;
                                                v490 = v489 == false;
                                                if (v490){
                                                    assert("The index needs to be zero or positive." && v489);
                                                } else {
                                                }
                                                int v492;
                                                v492 = v488 % 32;
                                                int v493;
                                                v493 = v488 / 32;
                                                bool v494;
                                                v494 = v493 < 8;
                                                bool v495;
                                                v495 = v494 == false;
                                                if (v495){
                                                    assert("The last element of the projection dimensions needs to be greater than the index remainder." && v494);
                                                } else {
                                                }
                                                assert("Tensor range check" && 0 <= v493 && v493 < 8);
                                                assert("Tensor range check" && 0 <= v492 && v492 < 32);
                                                int v497;
                                                v497 = 4 * v492;
                                                int v498;
                                                v498 = 128 * v493;
                                                int v499;
                                                v499 = v498 + v497;
                                                int v500;
                                                v500 = 136 * v493;
                                                int v501;
                                                v501 = v500 + v497;
                                                float * v502;
                                                v502 = v282+v499;
                                                float * v504;
                                                v504 = v224+v501;
                                                int v506;
                                                v506 = 0;
                                                #pragma unroll
                                                while (while_method_7(v506)){
                                                    int v508;
                                                    v508 = 0;
                                                    #pragma unroll
                                                    while (while_method_4(v508)){
                                                        assert("Tensor range check" && 0 <= v506 && v506 < 16);
                                                        assert("Tensor range check" && 0 <= v508 && v508 < 1);
                                                        int v510;
                                                        v510 = 128 * v508;
                                                        int v511;
                                                        v511 = 1024 * v506;
                                                        int v512;
                                                        v512 = v511 + v510;
                                                        int v513;
                                                        v513 = 1088 * v506;
                                                        int v514;
                                                        v514 = v513 + v510;
                                                        int4* v515;
                                                        v515 = reinterpret_cast<int4*>(v504 + v514);
                                                        int4* v516;
                                                        v516 = reinterpret_cast<int4*>(v502 + v512);
                                                        assert("Pointer alignment check" && (unsigned long long)(v515) % 4 == 0 && (unsigned long long)(v516) % 4 == 0);
                                                        *v516 = *v515;
                                                        v508 += 1 ;
                                                    }
                                                    v506 += 1 ;
                                                }
                                                // Poping the loop unrolling to: 0
                                                __syncthreads();
                                                v276 += 1 ;
                                            }
                                            v274 += 1 ;
                                        }
                                        unsigned int * v517;
                                        v517 = reinterpret_cast<unsigned int *>(&v2[6291456ull]);
                                        assert("Tensor range check" && 0 <= v206 && v206 < 4);
                                        int v519;
                                        v519 = 6144 * v206;
                                        method_23(v517, v519, v212);
                                        int * v520;
                                        v520 = reinterpret_cast<int *>(&v4[262144ull]);
                                        float * v522;
                                        v522 = reinterpret_cast<float *>(&v4[262160ull]);
                                        float * v524;
                                        v524 = reinterpret_cast<float *>(&v4[524304ull]);
                                        float * v526;
                                        v526 = reinterpret_cast<float *>(&v4[786448ull]);
                                        float * v528;
                                        v528 = reinterpret_cast<float *>(&v4[1048592ull]);
                                        float * v530;
                                        v530 = reinterpret_cast<float *>(&v4[1310736ull]);
                                        float * v532;
                                        v532 = reinterpret_cast<float *>(&v4[1572880ull]);
                                        float * v534;
                                        v534 = reinterpret_cast<float *>(&v4[1835024ull]);
                                        int * v536;
                                        v536 = reinterpret_cast<int *>(&v2[6389760ull]);
                                        float * v538;
                                        v538 = reinterpret_cast<float *>(&v2[7962624ull]);
                                        int * v540;
                                        v540 = reinterpret_cast<int *>(&v2[9535488ull]);
                                        int * v542;
                                        v542 = reinterpret_cast<int *>(&v2[11108352ull]);
                                        double * v544;
                                        v544 = reinterpret_cast<double *>(&v2[12681216ull]);
                                        double * v546;
                                        v546 = reinterpret_cast<double *>(&v2[18972672ull]);
                                        double * v548;
                                        v548 = reinterpret_cast<double *>(&v4[2097168ull]);
                                        double * v550;
                                        v550 = reinterpret_cast<double *>(&v4[2490384ull]);
                                        int * v552;
                                        v552 = reinterpret_cast<int *>(&v4[2883600ull]);
                                        __syncthreads();
                                        unsigned int * v554;
                                        v554 = reinterpret_cast<unsigned int *>(&v2[6291456ull]);
                                        int v556;
                                        v556 = blockIdx.x;
                                        int v557;
                                        v557 = threadIdx.x;
                                        assert("Tensor range check" && 0 <= v206 && v206 < 4);
                                        assert("Tensor range check" && 0 <= v556 && v556 < 24);
                                        assert("Tensor range check" && 0 <= v557 && v557 < 256);
                                        int v558;
                                        v558 = 256 * v556;
                                        int v559;
                                        v559 = v558 + v557;
                                        int v560;
                                        v560 = v519 + v559;
                                        unsigned int v561;
                                        v561 = v554[v560];
                                        int * v562;
                                        v562 = reinterpret_cast<int *>(&v4[262144ull]);
                                        float * v564;
                                        v564 = reinterpret_cast<float *>(&v4[262160ull]);
                                        float * v566;
                                        v566 = reinterpret_cast<float *>(&v4[524304ull]);
                                        float * v568;
                                        v568 = reinterpret_cast<float *>(&v4[786448ull]);
                                        float * v570;
                                        v570 = reinterpret_cast<float *>(&v4[1048592ull]);
                                        float * v572;
                                        v572 = reinterpret_cast<float *>(&v4[1310736ull]);
                                        float * v574;
                                        v574 = reinterpret_cast<float *>(&v4[1572880ull]);
                                        float * v576;
                                        v576 = reinterpret_cast<float *>(&v4[1835024ull]);
                                        int v578;
                                        v578 = (int)v561;
                                        float v579; int v580;
                                        Tuple8 tmp25 = method_24(v128, v562, v564, v566, v568, v570, v572, v574, v576, v578, v206);
                                        v579 = tmp25.v0; v580 = tmp25.v1;
                                        bool v581;
                                        v581 = 0 == v580;
                                        Union12 v590;
                                        if (v581){
                                            v590 = Union12{Union12_1{}};
                                        } else {
                                            bool v583;
                                            v583 = 1 == v580;
                                            if (v583){
                                                v590 = Union12{Union12_0{}};
                                            } else {
                                                bool v585;
                                                v585 = 2 == v580;
                                                if (v585){
                                                    v590 = Union12{Union12_2{}};
                                                } else {
                                                    printf("%s\n", "Invalid output id in the Leduc model.");
                                                    __trap();
                                                }
                                            }
                                        }
                                        Union1 v622;
                                        switch (v590.tag) {
                                            case 0: { // AA_Call
                                                v622 = Union1{Union1_0{}};
                                                break;
                                            }
                                            case 1: { // AA_Fold
                                                int v591;
                                                v591 = v110[0];
                                                int v593; int v594;
                                                Tuple7 tmp26 = Tuple7{1, v591};
                                                v593 = tmp26.v0; v594 = tmp26.v1;
                                                while (while_method_0(v593)){
                                                    bool v596;
                                                    v596 = 0 <= v593;
                                                    bool v598;
                                                    if (v596){
                                                        bool v597;
                                                        v597 = v593 < 2;
                                                        v598 = v597;
                                                    } else {
                                                        v598 = false;
                                                    }
                                                    bool v599;
                                                    v599 = v598 == false;
                                                    if (v599){
                                                        assert("Index must be in range." && v598);
                                                    } else {
                                                    }
                                                    int v601;
                                                    v601 = v110[v593];
                                                    bool v603;
                                                    v603 = v594 >= v601;
                                                    int v604;
                                                    if (v603){
                                                        v604 = v594;
                                                    } else {
                                                        v604 = v601;
                                                    }
                                                    v594 = v604;
                                                    v593 += 1 ;
                                                }
                                                bool v606;
                                                if (v113){
                                                    bool v605;
                                                    v605 = v109 < 2;
                                                    v606 = v605;
                                                } else {
                                                    v606 = false;
                                                }
                                                bool v607;
                                                v607 = v606 == false;
                                                if (v607){
                                                    assert("Index must be in range." && v606);
                                                } else {
                                                }
                                                int v609;
                                                v609 = v110[v109];
                                                bool v611;
                                                v611 = v609 == v594;
                                                if (v611){
                                                    v622 = Union1{Union1_0{}};
                                                } else {
                                                    v622 = Union1{Union1_1{}};
                                                }
                                                break;
                                            }
                                            case 2: { // AA_Raise
                                                bool v616;
                                                v616 = v111 > 0;
                                                if (v616){
                                                    v622 = Union1{Union1_2{}};
                                                } else {
                                                    v622 = Union1{Union1_0{}};
                                                }
                                                break;
                                            }
                                            default: {
                                                assert("Invalid tag." && false); __trap();
                                            }
                                        }
                                        int v623;
                                        v623 = sizeof(Union1);
                                        unsigned long long v624;
                                        v624 = (unsigned long long)v623;
                                        bool v625;
                                        v625 = v624 <= 98304ull;
                                        bool v626;
                                        v626 = v625 == false;
                                        if (v626){
                                            assert("The dynamic shared memory is insufficient to allocate the tensor." && v625);
                                        } else {
                                        }
                                        extern __shared__ unsigned char v628[];
                                        bool v629;
                                        v629 = v624 <= v624;
                                        bool v630;
                                        v630 = v629 == false;
                                        if (v630){
                                            assert("The length of the partition has to be less than or equal to the length of the base array." && v629);
                                        } else {
                                        }
                                        Union1 * v632;
                                        v632 = reinterpret_cast<Union1 *>(&v628[0ull]);
                                        int v634;
                                        v634 = threadIdx.x;
                                        bool v635;
                                        v635 = v634 == 0;
                                        if (v635){
                                            v632[0] = v622;
                                        } else {
                                        }
                                        __syncthreads();
                                        Union1 v636;
                                        v636 = v632[0];
                                        __syncthreads();
                                        Union7 v637;
                                        v637 = Union7{Union7_1{v109, v636}};
                                        v59.push(v637);
                                        Union4 v744;
                                        switch (v106.tag) {
                                            case 0: { // None
                                                switch (v636.tag) {
                                                    case 0: { // Call
                                                        if (v107){
                                                            int v700;
                                                            v700 = v109 ^ 1;
                                                            v744 = Union4{Union4_2{v106, false, v108, v700, v110, v111}};
                                                        } else {
                                                            v744 = Union4{Union4_0{v106, v107, v108, v109, v110, v111}};
                                                        }
                                                        break;
                                                    }
                                                    case 1: { // Fold
                                                        v744 = Union4{Union4_5{v106, v107, v108, v109, v110, v111}};
                                                        break;
                                                    }
                                                    case 2: { // Raise
                                                        bool v704;
                                                        v704 = v111 > 0;
                                                        if (v704){
                                                            int v705;
                                                            v705 = v109 ^ 1;
                                                            int v706;
                                                            v706 = -1 + v111;
                                                            int v707; int v708;
                                                            Tuple7 tmp27 = Tuple7{0, 0};
                                                            v707 = tmp27.v0; v708 = tmp27.v1;
                                                            while (while_method_0(v707)){
                                                                bool v710;
                                                                v710 = 0 <= v707;
                                                                bool v712;
                                                                if (v710){
                                                                    bool v711;
                                                                    v711 = v707 < 2;
                                                                    v712 = v711;
                                                                } else {
                                                                    v712 = false;
                                                                }
                                                                bool v713;
                                                                v713 = v712 == false;
                                                                if (v713){
                                                                    assert("Index must be in range." && v712);
                                                                } else {
                                                                }
                                                                int v715;
                                                                v715 = v110[v707];
                                                                bool v717;
                                                                v717 = v708 >= v715;
                                                                int v718;
                                                                if (v717){
                                                                    v718 = v708;
                                                                } else {
                                                                    v718 = v715;
                                                                }
                                                                v708 = v718;
                                                                v707 += 1 ;
                                                            }
                                                            static_array<int,2> v719;
                                                            int v721;
                                                            v721 = 0;
                                                            while (while_method_0(v721)){
                                                                v719[v721] = v708;
                                                                v721 += 1 ;
                                                            }
                                                            static_array<int,2> v723;
                                                            int v725;
                                                            v725 = 0;
                                                            while (while_method_0(v725)){
                                                                bool v727;
                                                                v727 = 0 <= v725;
                                                                bool v729;
                                                                if (v727){
                                                                    bool v728;
                                                                    v728 = v725 < 2;
                                                                    v729 = v728;
                                                                } else {
                                                                    v729 = false;
                                                                }
                                                                bool v730;
                                                                v730 = v729 == false;
                                                                if (v730){
                                                                    assert("Index must be in range." && v729);
                                                                } else {
                                                                }
                                                                int v732;
                                                                v732 = v719[v725];
                                                                bool v734;
                                                                v734 = v725 == v109;
                                                                int v736;
                                                                if (v734){
                                                                    int v735;
                                                                    v735 = v732 + 2;
                                                                    v736 = v735;
                                                                } else {
                                                                    v736 = v732;
                                                                }
                                                                v723[v725] = v736;
                                                                v725 += 1 ;
                                                            }
                                                            v744 = Union4{Union4_2{v106, false, v108, v705, v723, v706}};
                                                        } else {
                                                            printf("%s\n", "Invalid action. The number of raises left is not positive.");
                                                            __trap();
                                                        }
                                                        break;
                                                    }
                                                    default: {
                                                        assert("Invalid tag." && false); __trap();
                                                    }
                                                }
                                                break;
                                            }
                                            case 1: { // Some
                                                Union6 v638 = v106.case1.v0;
                                                switch (v636.tag) {
                                                    case 0: { // Call
                                                        if (v107){
                                                            int v640;
                                                            v640 = v109 ^ 1;
                                                            v744 = Union4{Union4_2{v106, false, v108, v640, v110, v111}};
                                                        } else {
                                                            int v642; int v643;
                                                            Tuple7 tmp28 = Tuple7{0, 0};
                                                            v642 = tmp28.v0; v643 = tmp28.v1;
                                                            while (while_method_0(v642)){
                                                                bool v645;
                                                                v645 = 0 <= v642;
                                                                bool v647;
                                                                if (v645){
                                                                    bool v646;
                                                                    v646 = v642 < 2;
                                                                    v647 = v646;
                                                                } else {
                                                                    v647 = false;
                                                                }
                                                                bool v648;
                                                                v648 = v647 == false;
                                                                if (v648){
                                                                    assert("Index must be in range." && v647);
                                                                } else {
                                                                }
                                                                int v650;
                                                                v650 = v110[v642];
                                                                bool v652;
                                                                v652 = v643 >= v650;
                                                                int v653;
                                                                if (v652){
                                                                    v653 = v643;
                                                                } else {
                                                                    v653 = v650;
                                                                }
                                                                v643 = v653;
                                                                v642 += 1 ;
                                                            }
                                                            static_array<int,2> v654;
                                                            int v656;
                                                            v656 = 0;
                                                            while (while_method_0(v656)){
                                                                v654[v656] = v643;
                                                                v656 += 1 ;
                                                            }
                                                            v744 = Union4{Union4_4{v106, v107, v108, v109, v654, v111}};
                                                        }
                                                        break;
                                                    }
                                                    case 1: { // Fold
                                                        v744 = Union4{Union4_5{v106, v107, v108, v109, v110, v111}};
                                                        break;
                                                    }
                                                    case 2: { // Raise
                                                        bool v660;
                                                        v660 = v111 > 0;
                                                        if (v660){
                                                            int v661;
                                                            v661 = v109 ^ 1;
                                                            int v662;
                                                            v662 = -1 + v111;
                                                            int v663; int v664;
                                                            Tuple7 tmp29 = Tuple7{0, 0};
                                                            v663 = tmp29.v0; v664 = tmp29.v1;
                                                            while (while_method_0(v663)){
                                                                bool v666;
                                                                v666 = 0 <= v663;
                                                                bool v668;
                                                                if (v666){
                                                                    bool v667;
                                                                    v667 = v663 < 2;
                                                                    v668 = v667;
                                                                } else {
                                                                    v668 = false;
                                                                }
                                                                bool v669;
                                                                v669 = v668 == false;
                                                                if (v669){
                                                                    assert("Index must be in range." && v668);
                                                                } else {
                                                                }
                                                                int v671;
                                                                v671 = v110[v663];
                                                                bool v673;
                                                                v673 = v664 >= v671;
                                                                int v674;
                                                                if (v673){
                                                                    v674 = v664;
                                                                } else {
                                                                    v674 = v671;
                                                                }
                                                                v664 = v674;
                                                                v663 += 1 ;
                                                            }
                                                            static_array<int,2> v675;
                                                            int v677;
                                                            v677 = 0;
                                                            while (while_method_0(v677)){
                                                                v675[v677] = v664;
                                                                v677 += 1 ;
                                                            }
                                                            static_array<int,2> v679;
                                                            int v681;
                                                            v681 = 0;
                                                            while (while_method_0(v681)){
                                                                bool v683;
                                                                v683 = 0 <= v681;
                                                                bool v685;
                                                                if (v683){
                                                                    bool v684;
                                                                    v684 = v681 < 2;
                                                                    v685 = v684;
                                                                } else {
                                                                    v685 = false;
                                                                }
                                                                bool v686;
                                                                v686 = v685 == false;
                                                                if (v686){
                                                                    assert("Index must be in range." && v685);
                                                                } else {
                                                                }
                                                                int v688;
                                                                v688 = v675[v681];
                                                                bool v690;
                                                                v690 = v681 == v109;
                                                                int v692;
                                                                if (v690){
                                                                    int v691;
                                                                    v691 = v688 + 4;
                                                                    v692 = v691;
                                                                } else {
                                                                    v692 = v688;
                                                                }
                                                                v679[v681] = v692;
                                                                v681 += 1 ;
                                                            }
                                                            v744 = Union4{Union4_2{v106, false, v108, v661, v679, v662}};
                                                        } else {
                                                            printf("%s\n", "Invalid action. The number of raises left is not positive.");
                                                            __trap();
                                                        }
                                                        break;
                                                    }
                                                    default: {
                                                        assert("Invalid tag." && false); __trap();
                                                    }
                                                }
                                                break;
                                            }
                                            default: {
                                                assert("Invalid tag." && false); __trap();
                                            }
                                        }
                                        v1075 = Union3{Union3_1{v744}};
                                        break;
                                    }
                                    case 1: { // Human
                                        Union8 v746;
                                        v746 = Union8{Union8_2{v106, v107, v108, v109, v110, v111}};
                                        v20.v5 = v746;
                                        Union3 v747;
                                        v747 = Union3{Union3_1{v63}};
                                        v20.v1 = v747;
                                        v1075 = Union3{Union3_0{}};
                                        break;
                                    }
                                    case 2: { // Random
                                        curandStatePhilox4_32_10_t & v749 = v20.v4;
                                        curandStatePhilox4_32_10_t & v750 = v749;
                                        static_array_list<Union1,3> v751;
                                        v751 = static_array_list<Union1,3>{};
                                        v751.unsafe_set_length(1);
                                        Union1 v753;
                                        v753 = Union1{Union1_0{}};
                                        v751[0] = v753;
                                        int v755;
                                        v755 = v110[0];
                                        int v757;
                                        v757 = v110[1];
                                        bool v759;
                                        v759 = v755 == v757;
                                        bool v760;
                                        v760 = v759 != true;
                                        if (v760){
                                            Union1 v761;
                                            v761 = Union1{Union1_1{}};
                                            v751.push(v761);
                                        } else {
                                        }
                                        bool v762;
                                        v762 = v111 > 0;
                                        if (v762){
                                            Union1 v763;
                                            v763 = Union1{Union1_2{}};
                                            v751.push(v763);
                                        } else {
                                        }
                                        int v764;
                                        v764 = v751.length;
                                        int v765;
                                        v765 = v764 - 1;
                                        int v766;
                                        v766 = 0;
                                        while (while_method_1(v765, v766)){
                                            int v768;
                                            v768 = v751.length;
                                            int v769;
                                            v769 = int_range_22(v768, v766, v750);
                                            Union1 v770;
                                            v770 = v751[v766];
                                            Union1 v772;
                                            v772 = v751[v769];
                                            v751[v766] = v772;
                                            v751[v769] = v770;
                                            v766 += 1 ;
                                        }
                                        Union1 v774;
                                        v774 = v751.pop();
                                        int v775;
                                        v775 = sizeof(Union1);
                                        unsigned long long v776;
                                        v776 = (unsigned long long)v775;
                                        bool v777;
                                        v777 = v776 <= 98304ull;
                                        bool v778;
                                        v778 = v777 == false;
                                        if (v778){
                                            assert("The dynamic shared memory is insufficient to allocate the tensor." && v777);
                                        } else {
                                        }
                                        extern __shared__ unsigned char v780[];
                                        bool v781;
                                        v781 = v776 <= v776;
                                        bool v782;
                                        v782 = v781 == false;
                                        if (v782){
                                            assert("The length of the partition has to be less than or equal to the length of the base array." && v781);
                                        } else {
                                        }
                                        Union1 * v784;
                                        v784 = reinterpret_cast<Union1 *>(&v780[0ull]);
                                        int v786;
                                        v786 = threadIdx.x;
                                        bool v787;
                                        v787 = v786 == 0;
                                        if (v787){
                                            v784[0] = v774;
                                        } else {
                                        }
                                        __syncthreads();
                                        Union1 v788;
                                        v788 = v784[0];
                                        __syncthreads();
                                        Union7 v789;
                                        v789 = Union7{Union7_1{v109, v788}};
                                        v59.push(v789);
                                        Union4 v894;
                                        switch (v106.tag) {
                                            case 0: { // None
                                                switch (v788.tag) {
                                                    case 0: { // Call
                                                        if (v107){
                                                            int v851;
                                                            v851 = v109 ^ 1;
                                                            v894 = Union4{Union4_2{v106, false, v108, v851, v110, v111}};
                                                        } else {
                                                            v894 = Union4{Union4_0{v106, v107, v108, v109, v110, v111}};
                                                        }
                                                        break;
                                                    }
                                                    case 1: { // Fold
                                                        v894 = Union4{Union4_5{v106, v107, v108, v109, v110, v111}};
                                                        break;
                                                    }
                                                    case 2: { // Raise
                                                        if (v762){
                                                            int v855;
                                                            v855 = v109 ^ 1;
                                                            int v856;
                                                            v856 = -1 + v111;
                                                            int v857; int v858;
                                                            Tuple7 tmp30 = Tuple7{0, 0};
                                                            v857 = tmp30.v0; v858 = tmp30.v1;
                                                            while (while_method_0(v857)){
                                                                bool v860;
                                                                v860 = 0 <= v857;
                                                                bool v862;
                                                                if (v860){
                                                                    bool v861;
                                                                    v861 = v857 < 2;
                                                                    v862 = v861;
                                                                } else {
                                                                    v862 = false;
                                                                }
                                                                bool v863;
                                                                v863 = v862 == false;
                                                                if (v863){
                                                                    assert("Index must be in range." && v862);
                                                                } else {
                                                                }
                                                                int v865;
                                                                v865 = v110[v857];
                                                                bool v867;
                                                                v867 = v858 >= v865;
                                                                int v868;
                                                                if (v867){
                                                                    v868 = v858;
                                                                } else {
                                                                    v868 = v865;
                                                                }
                                                                v858 = v868;
                                                                v857 += 1 ;
                                                            }
                                                            static_array<int,2> v869;
                                                            int v871;
                                                            v871 = 0;
                                                            while (while_method_0(v871)){
                                                                v869[v871] = v858;
                                                                v871 += 1 ;
                                                            }
                                                            static_array<int,2> v873;
                                                            int v875;
                                                            v875 = 0;
                                                            while (while_method_0(v875)){
                                                                bool v877;
                                                                v877 = 0 <= v875;
                                                                bool v879;
                                                                if (v877){
                                                                    bool v878;
                                                                    v878 = v875 < 2;
                                                                    v879 = v878;
                                                                } else {
                                                                    v879 = false;
                                                                }
                                                                bool v880;
                                                                v880 = v879 == false;
                                                                if (v880){
                                                                    assert("Index must be in range." && v879);
                                                                } else {
                                                                }
                                                                int v882;
                                                                v882 = v869[v875];
                                                                bool v884;
                                                                v884 = v875 == v109;
                                                                int v886;
                                                                if (v884){
                                                                    int v885;
                                                                    v885 = v882 + 2;
                                                                    v886 = v885;
                                                                } else {
                                                                    v886 = v882;
                                                                }
                                                                v873[v875] = v886;
                                                                v875 += 1 ;
                                                            }
                                                            v894 = Union4{Union4_2{v106, false, v108, v855, v873, v856}};
                                                        } else {
                                                            printf("%s\n", "Invalid action. The number of raises left is not positive.");
                                                            __trap();
                                                        }
                                                        break;
                                                    }
                                                    default: {
                                                        assert("Invalid tag." && false); __trap();
                                                    }
                                                }
                                                break;
                                            }
                                            case 1: { // Some
                                                Union6 v790 = v106.case1.v0;
                                                switch (v788.tag) {
                                                    case 0: { // Call
                                                        if (v107){
                                                            int v792;
                                                            v792 = v109 ^ 1;
                                                            v894 = Union4{Union4_2{v106, false, v108, v792, v110, v111}};
                                                        } else {
                                                            int v794; int v795;
                                                            Tuple7 tmp31 = Tuple7{0, 0};
                                                            v794 = tmp31.v0; v795 = tmp31.v1;
                                                            while (while_method_0(v794)){
                                                                bool v797;
                                                                v797 = 0 <= v794;
                                                                bool v799;
                                                                if (v797){
                                                                    bool v798;
                                                                    v798 = v794 < 2;
                                                                    v799 = v798;
                                                                } else {
                                                                    v799 = false;
                                                                }
                                                                bool v800;
                                                                v800 = v799 == false;
                                                                if (v800){
                                                                    assert("Index must be in range." && v799);
                                                                } else {
                                                                }
                                                                int v802;
                                                                v802 = v110[v794];
                                                                bool v804;
                                                                v804 = v795 >= v802;
                                                                int v805;
                                                                if (v804){
                                                                    v805 = v795;
                                                                } else {
                                                                    v805 = v802;
                                                                }
                                                                v795 = v805;
                                                                v794 += 1 ;
                                                            }
                                                            static_array<int,2> v806;
                                                            int v808;
                                                            v808 = 0;
                                                            while (while_method_0(v808)){
                                                                v806[v808] = v795;
                                                                v808 += 1 ;
                                                            }
                                                            v894 = Union4{Union4_4{v106, v107, v108, v109, v806, v111}};
                                                        }
                                                        break;
                                                    }
                                                    case 1: { // Fold
                                                        v894 = Union4{Union4_5{v106, v107, v108, v109, v110, v111}};
                                                        break;
                                                    }
                                                    case 2: { // Raise
                                                        if (v762){
                                                            int v812;
                                                            v812 = v109 ^ 1;
                                                            int v813;
                                                            v813 = -1 + v111;
                                                            int v814; int v815;
                                                            Tuple7 tmp32 = Tuple7{0, 0};
                                                            v814 = tmp32.v0; v815 = tmp32.v1;
                                                            while (while_method_0(v814)){
                                                                bool v817;
                                                                v817 = 0 <= v814;
                                                                bool v819;
                                                                if (v817){
                                                                    bool v818;
                                                                    v818 = v814 < 2;
                                                                    v819 = v818;
                                                                } else {
                                                                    v819 = false;
                                                                }
                                                                bool v820;
                                                                v820 = v819 == false;
                                                                if (v820){
                                                                    assert("Index must be in range." && v819);
                                                                } else {
                                                                }
                                                                int v822;
                                                                v822 = v110[v814];
                                                                bool v824;
                                                                v824 = v815 >= v822;
                                                                int v825;
                                                                if (v824){
                                                                    v825 = v815;
                                                                } else {
                                                                    v825 = v822;
                                                                }
                                                                v815 = v825;
                                                                v814 += 1 ;
                                                            }
                                                            static_array<int,2> v826;
                                                            int v828;
                                                            v828 = 0;
                                                            while (while_method_0(v828)){
                                                                v826[v828] = v815;
                                                                v828 += 1 ;
                                                            }
                                                            static_array<int,2> v830;
                                                            int v832;
                                                            v832 = 0;
                                                            while (while_method_0(v832)){
                                                                bool v834;
                                                                v834 = 0 <= v832;
                                                                bool v836;
                                                                if (v834){
                                                                    bool v835;
                                                                    v835 = v832 < 2;
                                                                    v836 = v835;
                                                                } else {
                                                                    v836 = false;
                                                                }
                                                                bool v837;
                                                                v837 = v836 == false;
                                                                if (v837){
                                                                    assert("Index must be in range." && v836);
                                                                } else {
                                                                }
                                                                int v839;
                                                                v839 = v826[v832];
                                                                bool v841;
                                                                v841 = v832 == v109;
                                                                int v843;
                                                                if (v841){
                                                                    int v842;
                                                                    v842 = v839 + 4;
                                                                    v843 = v842;
                                                                } else {
                                                                    v843 = v839;
                                                                }
                                                                v830[v832] = v843;
                                                                v832 += 1 ;
                                                            }
                                                            v894 = Union4{Union4_2{v106, false, v108, v812, v830, v813}};
                                                        } else {
                                                            printf("%s\n", "Invalid action. The number of raises left is not positive.");
                                                            __trap();
                                                        }
                                                        break;
                                                    }
                                                    default: {
                                                        assert("Invalid tag." && false); __trap();
                                                    }
                                                }
                                                break;
                                            }
                                            default: {
                                                assert("Invalid tag." && false); __trap();
                                            }
                                        }
                                        v1075 = Union3{Union3_1{v894}};
                                        break;
                                    }
                                    default: {
                                        assert("Invalid tag." && false); __trap();
                                    }
                                }
                                break;
                            }
                            case 3: { // RoundWithAction
                                Union5 v899 = v63.case3.v0; bool v900 = v63.case3.v1; static_array<Union6,2> v901 = v63.case3.v2; int v902 = v63.case3.v3; static_array<int,2> v903 = v63.case3.v4; int v904 = v63.case3.v5; Union1 v905 = v63.case3.v6;
                                Union7 v906;
                                v906 = Union7{Union7_1{v902, v905}};
                                v59.push(v906);
                                Union4 v1013;
                                switch (v899.tag) {
                                    case 0: { // None
                                        switch (v905.tag) {
                                            case 0: { // Call
                                                if (v900){
                                                    int v969;
                                                    v969 = v902 ^ 1;
                                                    v1013 = Union4{Union4_2{v899, false, v901, v969, v903, v904}};
                                                } else {
                                                    v1013 = Union4{Union4_0{v899, v900, v901, v902, v903, v904}};
                                                }
                                                break;
                                            }
                                            case 1: { // Fold
                                                v1013 = Union4{Union4_5{v899, v900, v901, v902, v903, v904}};
                                                break;
                                            }
                                            case 2: { // Raise
                                                bool v973;
                                                v973 = v904 > 0;
                                                if (v973){
                                                    int v974;
                                                    v974 = v902 ^ 1;
                                                    int v975;
                                                    v975 = -1 + v904;
                                                    int v976; int v977;
                                                    Tuple7 tmp33 = Tuple7{0, 0};
                                                    v976 = tmp33.v0; v977 = tmp33.v1;
                                                    while (while_method_0(v976)){
                                                        bool v979;
                                                        v979 = 0 <= v976;
                                                        bool v981;
                                                        if (v979){
                                                            bool v980;
                                                            v980 = v976 < 2;
                                                            v981 = v980;
                                                        } else {
                                                            v981 = false;
                                                        }
                                                        bool v982;
                                                        v982 = v981 == false;
                                                        if (v982){
                                                            assert("Index must be in range." && v981);
                                                        } else {
                                                        }
                                                        int v984;
                                                        v984 = v903[v976];
                                                        bool v986;
                                                        v986 = v977 >= v984;
                                                        int v987;
                                                        if (v986){
                                                            v987 = v977;
                                                        } else {
                                                            v987 = v984;
                                                        }
                                                        v977 = v987;
                                                        v976 += 1 ;
                                                    }
                                                    static_array<int,2> v988;
                                                    int v990;
                                                    v990 = 0;
                                                    while (while_method_0(v990)){
                                                        v988[v990] = v977;
                                                        v990 += 1 ;
                                                    }
                                                    static_array<int,2> v992;
                                                    int v994;
                                                    v994 = 0;
                                                    while (while_method_0(v994)){
                                                        bool v996;
                                                        v996 = 0 <= v994;
                                                        bool v998;
                                                        if (v996){
                                                            bool v997;
                                                            v997 = v994 < 2;
                                                            v998 = v997;
                                                        } else {
                                                            v998 = false;
                                                        }
                                                        bool v999;
                                                        v999 = v998 == false;
                                                        if (v999){
                                                            assert("Index must be in range." && v998);
                                                        } else {
                                                        }
                                                        int v1001;
                                                        v1001 = v988[v994];
                                                        bool v1003;
                                                        v1003 = v994 == v902;
                                                        int v1005;
                                                        if (v1003){
                                                            int v1004;
                                                            v1004 = v1001 + 2;
                                                            v1005 = v1004;
                                                        } else {
                                                            v1005 = v1001;
                                                        }
                                                        v992[v994] = v1005;
                                                        v994 += 1 ;
                                                    }
                                                    v1013 = Union4{Union4_2{v899, false, v901, v974, v992, v975}};
                                                } else {
                                                    printf("%s\n", "Invalid action. The number of raises left is not positive.");
                                                    __trap();
                                                }
                                                break;
                                            }
                                            default: {
                                                assert("Invalid tag." && false); __trap();
                                            }
                                        }
                                        break;
                                    }
                                    case 1: { // Some
                                        Union6 v907 = v899.case1.v0;
                                        switch (v905.tag) {
                                            case 0: { // Call
                                                if (v900){
                                                    int v909;
                                                    v909 = v902 ^ 1;
                                                    v1013 = Union4{Union4_2{v899, false, v901, v909, v903, v904}};
                                                } else {
                                                    int v911; int v912;
                                                    Tuple7 tmp34 = Tuple7{0, 0};
                                                    v911 = tmp34.v0; v912 = tmp34.v1;
                                                    while (while_method_0(v911)){
                                                        bool v914;
                                                        v914 = 0 <= v911;
                                                        bool v916;
                                                        if (v914){
                                                            bool v915;
                                                            v915 = v911 < 2;
                                                            v916 = v915;
                                                        } else {
                                                            v916 = false;
                                                        }
                                                        bool v917;
                                                        v917 = v916 == false;
                                                        if (v917){
                                                            assert("Index must be in range." && v916);
                                                        } else {
                                                        }
                                                        int v919;
                                                        v919 = v903[v911];
                                                        bool v921;
                                                        v921 = v912 >= v919;
                                                        int v922;
                                                        if (v921){
                                                            v922 = v912;
                                                        } else {
                                                            v922 = v919;
                                                        }
                                                        v912 = v922;
                                                        v911 += 1 ;
                                                    }
                                                    static_array<int,2> v923;
                                                    int v925;
                                                    v925 = 0;
                                                    while (while_method_0(v925)){
                                                        v923[v925] = v912;
                                                        v925 += 1 ;
                                                    }
                                                    v1013 = Union4{Union4_4{v899, v900, v901, v902, v923, v904}};
                                                }
                                                break;
                                            }
                                            case 1: { // Fold
                                                v1013 = Union4{Union4_5{v899, v900, v901, v902, v903, v904}};
                                                break;
                                            }
                                            case 2: { // Raise
                                                bool v929;
                                                v929 = v904 > 0;
                                                if (v929){
                                                    int v930;
                                                    v930 = v902 ^ 1;
                                                    int v931;
                                                    v931 = -1 + v904;
                                                    int v932; int v933;
                                                    Tuple7 tmp35 = Tuple7{0, 0};
                                                    v932 = tmp35.v0; v933 = tmp35.v1;
                                                    while (while_method_0(v932)){
                                                        bool v935;
                                                        v935 = 0 <= v932;
                                                        bool v937;
                                                        if (v935){
                                                            bool v936;
                                                            v936 = v932 < 2;
                                                            v937 = v936;
                                                        } else {
                                                            v937 = false;
                                                        }
                                                        bool v938;
                                                        v938 = v937 == false;
                                                        if (v938){
                                                            assert("Index must be in range." && v937);
                                                        } else {
                                                        }
                                                        int v940;
                                                        v940 = v903[v932];
                                                        bool v942;
                                                        v942 = v933 >= v940;
                                                        int v943;
                                                        if (v942){
                                                            v943 = v933;
                                                        } else {
                                                            v943 = v940;
                                                        }
                                                        v933 = v943;
                                                        v932 += 1 ;
                                                    }
                                                    static_array<int,2> v944;
                                                    int v946;
                                                    v946 = 0;
                                                    while (while_method_0(v946)){
                                                        v944[v946] = v933;
                                                        v946 += 1 ;
                                                    }
                                                    static_array<int,2> v948;
                                                    int v950;
                                                    v950 = 0;
                                                    while (while_method_0(v950)){
                                                        bool v952;
                                                        v952 = 0 <= v950;
                                                        bool v954;
                                                        if (v952){
                                                            bool v953;
                                                            v953 = v950 < 2;
                                                            v954 = v953;
                                                        } else {
                                                            v954 = false;
                                                        }
                                                        bool v955;
                                                        v955 = v954 == false;
                                                        if (v955){
                                                            assert("Index must be in range." && v954);
                                                        } else {
                                                        }
                                                        int v957;
                                                        v957 = v944[v950];
                                                        bool v959;
                                                        v959 = v950 == v902;
                                                        int v961;
                                                        if (v959){
                                                            int v960;
                                                            v960 = v957 + 4;
                                                            v961 = v960;
                                                        } else {
                                                            v961 = v957;
                                                        }
                                                        v948[v950] = v961;
                                                        v950 += 1 ;
                                                    }
                                                    v1013 = Union4{Union4_2{v899, false, v901, v930, v948, v931}};
                                                } else {
                                                    printf("%s\n", "Invalid action. The number of raises left is not positive.");
                                                    __trap();
                                                }
                                                break;
                                            }
                                            default: {
                                                assert("Invalid tag." && false); __trap();
                                            }
                                        }
                                        break;
                                    }
                                    default: {
                                        assert("Invalid tag." && false); __trap();
                                    }
                                }
                                v1075 = Union3{Union3_1{v1013}};
                                break;
                            }
                            case 4: { // TerminalCall
                                Union5 v82 = v63.case4.v0; bool v83 = v63.case4.v1; static_array<Union6,2> v84 = v63.case4.v2; int v85 = v63.case4.v3; static_array<int,2> v86 = v63.case4.v4; int v87 = v63.case4.v5;
                                bool v88;
                                v88 = 0 <= v85;
                                bool v90;
                                if (v88){
                                    bool v89;
                                    v89 = v85 < 2;
                                    v90 = v89;
                                } else {
                                    v90 = false;
                                }
                                bool v91;
                                v91 = v90 == false;
                                if (v91){
                                    assert("Index must be in range." && v90);
                                } else {
                                }
                                int v93;
                                v93 = v86[v85];
                                Union13 v95;
                                v95 = compare_hands_25(v82, v83, v84, v85, v86, v87);
                                int v100; int v101;
                                switch (v95.tag) {
                                    case 0: { // Eq
                                        v100 = 0; v101 = -1;
                                        break;
                                    }
                                    case 1: { // Gt
                                        v100 = v93; v101 = 0;
                                        break;
                                    }
                                    case 2: { // Lt
                                        v100 = v93; v101 = 1;
                                        break;
                                    }
                                    default: {
                                        assert("Invalid tag." && false); __trap();
                                    }
                                }
                                Union7 v102;
                                v102 = Union7{Union7_3{v84, v100, v101}};
                                v59.push(v102);
                                Union8 v103;
                                v103 = Union8{Union8_1{v82, v83, v84, v85, v86, v87}};
                                v20.v5 = v103;
                                Union3 v104;
                                v104 = Union3{Union3_0{}};
                                v20.v1 = v104;
                                v1075 = Union3{Union3_0{}};
                                break;
                            }
                            case 5: { // TerminalFold
                                Union5 v64 = v63.case5.v0; bool v65 = v63.case5.v1; static_array<Union6,2> v66 = v63.case5.v2; int v67 = v63.case5.v3; static_array<int,2> v68 = v63.case5.v4; int v69 = v63.case5.v5;
                                bool v70;
                                v70 = 0 <= v67;
                                bool v72;
                                if (v70){
                                    bool v71;
                                    v71 = v67 < 2;
                                    v72 = v71;
                                } else {
                                    v72 = false;
                                }
                                bool v73;
                                v73 = v72 == false;
                                if (v73){
                                    assert("Index must be in range." && v72);
                                } else {
                                }
                                int v75;
                                v75 = v68[v67];
                                int v77;
                                v77 = v67 ^ 1;
                                Union7 v78;
                                v78 = Union7{Union7_3{v66, v75, v77}};
                                v59.push(v78);
                                Union8 v79;
                                v79 = Union8{Union8_1{v64, v65, v66, v67, v68, v69}};
                                v20.v5 = v79;
                                Union3 v80;
                                v80 = Union3{Union3_0{}};
                                v20.v1 = v80;
                                v1075 = Union3{Union3_0{}};
                                break;
                            }
                            default: {
                                assert("Invalid tag." && false); __trap();
                            }
                        }
                        break;
                    }
                    default: {
                        assert("Invalid tag." && false); __trap();
                    }
                }
                v61 = v1075;
            }
            break;
        }
        default: {
            assert("Invalid tag." && false); __trap();
        }
    }
    int v1076;
    v1076 = threadIdx.x;
    int v1077;
    v1077 = blockIdx.x;
    int v1078;
    v1078 = v1077 * 256;
    int v1079;
    v1079 = v1076 + v1078;
    bool v1080;
    v1080 = v1079 == 0;
    if (v1080){
        Union8 & v1081 = v20.v5;
        static_array<Union2,2> & v1082 = v20.v3;
        static_array_list<Union7,32> & v1083 = v20.v2;
        Union3 & v1084 = v20.v1;
        unsigned int & v1085 = v20.v0;
        return f_29(v0, v1085, v1084, v1083, v1082, v1081);
    } else {
        return ;
    }
}
extern "C" __global__ void entry1(unsigned char * v0, unsigned long long v1, unsigned char * v2, unsigned long long v3, float * v4, float * v5, float * v6) {
    auto v7 = cooperative_groups::this_grid();
    unsigned long long v8;
    v8 = clock64();
    int v9;
    v9 = threadIdx.x;
    int v10;
    v10 = blockIdx.x;
    int v11;
    v11 = v10 * 256;
    int v12;
    v12 = v9 + v11;
    unsigned long long v13;
    v13 = (unsigned long long)v12;
    curandStatePhilox4_32_10_t v14;
    curand_init(v8,v13,0ull,&v14);
    static_array<Union2,2> v15;
    Union2 v17;
    v17 = Union2{Union2_2{}};
    v15[0] = v17;
    Union2 v19;
    v19 = Union2{Union2_2{}};
    v15[1] = v19;
    static_array_list<Union7,32> v21;
    v21 = static_array_list<Union7,32>{};
    static_array<float,2> v23;
    v23[0] = 0.0f;
    v23[1] = 0.0f;
    cooperative_groups::grid_group & v25 = v7;
    curandStatePhilox4_32_10_t & v26 = v14;
    StackMut1 v27{63u, v25, v21, v15, v23, v26};
    bool v28;
    v28 = 2981904ull == v3;
    bool v29;
    v29 = v28 == false;
    if (v29){
        assert("The params needs to have matching offsets." && v28);
    } else {
    }
    bool v31;
    v31 = 25264128ull == v1;
    bool v32;
    v32 = v31 == false;
    if (v32){
        assert("The outputs needs to have matching offsets." && v31);
    } else {
    }
    int v34;
    v34 = 0;
    while (while_method_8(v34)){
        int v36;
        v36 = 0;
        while (while_method_5(v36)){
            int v38;
            v38 = 0;
            while (while_method_0(v38)){
                Union4 v40;
                v40 = Union4{Union4_1{}};
                method_46(v0, v2, v27, v38, v40);
                static_array<float,2> & v41 = v27.v4;
                bool v42;
                v42 = 0 <= v38;
                bool v44;
                if (v42){
                    bool v43;
                    v43 = v38 < 2;
                    v44 = v43;
                } else {
                    v44 = false;
                }
                bool v45;
                v45 = v44 == false;
                if (v45){
                    assert("Index must be in range." && v44);
                } else {
                }
                float v47;
                v47 = v41[v38];
                double * v49;
                v49 = reinterpret_cast<double *>(&v2[2097168ull]);
                double * v51;
                v51 = reinterpret_cast<double *>(&v2[2490384ull]);
                int * v53;
                v53 = reinterpret_cast<int *>(&v2[2883600ull]);
                int v55;
                v55 = threadIdx.x;
                int v56;
                v56 = blockIdx.x;
                int v57;
                v57 = v56 * 256;
                int v58;
                v58 = v55 + v57;
                assert("Tensor range check" && 0 <= v58 && v58 < 6144);
                int v59;
                v59 = 2 * v58;
                int v60; double v61;
                Tuple12 tmp49 = Tuple12{0, 1.0};
                v60 = tmp49.v0; v61 = tmp49.v1;
                while (while_method_0(v60)){
                    assert("Tensor range check" && 0 <= v60 && v60 < 2);
                    int v63;
                    v63 = v60 + v59;
                    int v64; double v65;
                    Tuple12 tmp50 = Tuple12{0, 0.0};
                    v64 = tmp50.v0; v65 = tmp50.v1;
                    while (while_method_9(v64)){
                        assert("Tensor range check" && 0 <= v64 && v64 < 4);
                        int v67;
                        v67 = 12288 * v64;
                        int v68;
                        v68 = v67 + v63;
                        double v69;
                        v69 = v49[v68];
                        double v70;
                        v70 = v51[v68];
                        double v71;
                        v71 = v69 - v70;
                        double v72;
                        v72 = exp(v71);
                        double v73;
                        v73 = v65 + v72;
                        v65 = v73;
                        v64 += 1 ;
                    }
                    double v74;
                    v74 = v61 * v65;
                    v61 = v74;
                    v60 += 1 ;
                }
                float v75;
                v75 = (float)v61;
                int v76;
                v76 = 0;
                while (while_method_9(v76)){
                    double * v78;
                    v78 = reinterpret_cast<double *>(&v2[2097168ull]);
                    double * v80;
                    v80 = reinterpret_cast<double *>(&v2[2490384ull]);
                    int * v82;
                    v82 = reinterpret_cast<int *>(&v2[2883600ull]);
                    int v84;
                    v84 = threadIdx.x;
                    int v85;
                    v85 = blockIdx.x;
                    int v86;
                    v86 = v85 * 256;
                    int v87;
                    v87 = v84 + v86;
                    assert("Tensor range check" && 0 <= v87 && v87 < 6144);
                    int v88;
                    v88 = 2 * v87;
                    int v89; double v90;
                    Tuple12 tmp51 = Tuple12{0, 1.0};
                    v89 = tmp51.v0; v90 = tmp51.v1;
                    while (while_method_0(v89)){
                        assert("Tensor range check" && 0 <= v89 && v89 < 2);
                        int v92;
                        v92 = v89 + v88;
                        int v93; double v94;
                        Tuple12 tmp52 = Tuple12{0, 0.0};
                        v93 = tmp52.v0; v94 = tmp52.v1;
                        while (while_method_9(v93)){
                            assert("Tensor range check" && 0 <= v93 && v93 < 4);
                            int v96;
                            v96 = 12288 * v93;
                            int v97;
                            v97 = v96 + v92;
                            double v98;
                            v98 = v78[v97];
                            double v99;
                            v99 = v80[v97];
                            double v100;
                            v100 = v98 - v99;
                            double v101;
                            v101 = exp(v100);
                            bool v102;
                            v102 = v76 == v93;
                            bool v103;
                            v103 = v102 != true;
                            double v104;
                            if (v103){
                                v104 = v101;
                            } else {
                                v104 = 0.0;
                            }
                            double v105;
                            v105 = v94 + v104;
                            v94 = v105;
                            v93 += 1 ;
                        }
                        double v106;
                        v106 = v90 * v94;
                        v90 = v106;
                        v89 += 1 ;
                    }
                    float v107;
                    v107 = (float)v90;
                    float v108;
                    v108 = v75 - v107;
                    float v109;
                    v109 = v47 * v108;
                    assert("Tensor range check" && 0 <= v76 && v76 < 4);
                    assert("Tensor range check" && 0 <= v34 && v34 < 32);
                    int v110;
                    v110 = 32 * v76;
                    int v111;
                    v111 = v110 + v34;
                    float * v112;
                    v112 = v4+v111;
                    float * v114;
                    v114 = v5+v111;
                    float v116;
                    v116 = atomicAdd(v112,v109);
                    float v117;
                    v117 = atomicAdd(v114,v108);
                    v76 += 1 ;
                }
                static_array<float,2> & v118 = v27.v4;
                unsigned int * v119;
                v119 = reinterpret_cast<unsigned int *>(&v0[6291456ull]);
                int * v121;
                v121 = reinterpret_cast<int *>(&v2[262144ull]);
                float * v123;
                v123 = reinterpret_cast<float *>(&v2[262160ull]);
                float * v125;
                v125 = reinterpret_cast<float *>(&v2[524304ull]);
                float * v127;
                v127 = reinterpret_cast<float *>(&v2[786448ull]);
                float * v129;
                v129 = reinterpret_cast<float *>(&v2[1048592ull]);
                float * v131;
                v131 = reinterpret_cast<float *>(&v2[1310736ull]);
                float * v133;
                v133 = reinterpret_cast<float *>(&v2[1572880ull]);
                float * v135;
                v135 = reinterpret_cast<float *>(&v2[1835024ull]);
                int * v137;
                v137 = reinterpret_cast<int *>(&v0[6389760ull]);
                float * v139;
                v139 = reinterpret_cast<float *>(&v0[7962624ull]);
                int * v141;
                v141 = reinterpret_cast<int *>(&v0[9535488ull]);
                int * v143;
                v143 = reinterpret_cast<int *>(&v0[11108352ull]);
                double * v145;
                v145 = reinterpret_cast<double *>(&v0[12681216ull]);
                double * v147;
                v147 = reinterpret_cast<double *>(&v0[18972672ull]);
                double * v149;
                v149 = reinterpret_cast<double *>(&v2[2097168ull]);
                double * v151;
                v151 = reinterpret_cast<double *>(&v2[2490384ull]);
                int * v153;
                v153 = reinterpret_cast<int *>(&v2[2883600ull]);
                int v155;
                v155 = 0;
                while (while_method_9(v155)){
                    int v157;
                    v157 = threadIdx.x;
                    int v158;
                    v158 = blockIdx.x;
                    int v159;
                    v159 = v158 * 256;
                    int v160;
                    v160 = v157 + v159;
                    float v161[2];
                    int v162;
                    v162 = 0;
                    while (while_method_0(v162)){
                        bool v164;
                        v164 = 0 <= v162;
                        bool v166;
                        if (v164){
                            bool v165;
                            v165 = v162 < 2;
                            v166 = v165;
                        } else {
                            v166 = false;
                        }
                        bool v167;
                        v167 = v166 == false;
                        if (v167){
                            assert("Index must be in range." && v166);
                        } else {
                        }
                        float v169;
                        v169 = v118[v162];
                        v161[v162] = v169;
                        v162 += 1 ;
                    }
                    assert("Tensor range check" && 0 <= v155 && v155 < 4);
                    assert("Tensor range check" && 0 <= v160 && v160 < 6144);
                    int v171;
                    v171 = 6144 * v155;
                    int v172;
                    v172 = v171 + v160;
                    int v173;
                    v173 = v153[v172];
                    int v174;
                    v174 = v173;
                    while (while_method_11(v174)){
                        v174 -= 1 ;
                        assert("Tensor range check" && 0 <= v155 && v155 < 4);
                        assert("Tensor range check" && 0 <= v174 && v174 < 16);
                        assert("Tensor range check" && 0 <= v160 && v160 < 6144);
                        int v176;
                        v176 = 6144 * v174;
                        int v177;
                        v177 = v176 + v160;
                        int v178;
                        v178 = 98304 * v155;
                        int v179;
                        v179 = v178 + v177;
                        int v180;
                        v180 = v137[v179];
                        float v181;
                        v181 = v139[v179];
                        int v182;
                        v182 = v141[v179];
                        int v183;
                        v183 = v143[v179];
                        assert("Tensor range check" && 0 <= v182 && v182 < 2);
                        float v184;
                        v184 = v161[v182];
                        assert("Tensor range check" && 0 <= v155 && v155 < 4);
                        int v185;
                        v185 = 16384 * v155;
                        assert("Tensor range check" && 0 <= v183 && v183 < 4096);
                        int v186;
                        v186 = 4 * v183;
                        int v187;
                        v187 = v186 + v185;
                        float * v188;
                        v188 = v123+v187;
                        float * v190;
                        v190 = v125+v187;
                        float * v192;
                        v192 = v127+v187;
                        float * v194;
                        v194 = v129+v187;
                        float * v196;
                        v196 = v131+v187;
                        float * v198;
                        v198 = v133+v187;
                        float * v200;
                        v200 = v135+v187;
                        assert("Tensor range check" && 0 <= v155 && v155 < 4);
                        int v202;
                        v202 = 196608 * v155;
                        assert("Tensor range check" && 0 <= v174 && v174 < 16);
                        int v203;
                        v203 = 12288 * v174;
                        int v204;
                        v204 = v203 + v202;
                        assert("Tensor range check" && 0 <= v160 && v160 < 6144);
                        int v205;
                        v205 = 2 * v160;
                        int v206;
                        v206 = v205 + v204;
                        double v207[2];
                        int v208;
                        v208 = 0;
                        while (while_method_0(v208)){
                            assert("Tensor range check" && 0 <= v208 && v208 < 2);
                            int v210;
                            v210 = v208 + v206;
                            double v211;
                            v211 = v145[v210];
                            bool v212;
                            v212 = v182 == v208;
                            double v213;
                            if (v212){
                                v213 = 0.0;
                            } else {
                                v213 = v211;
                            }
                            assert("Tensor range check" && 0 <= v208 && v208 < 2);
                            v207[v208] = v213;
                            v208 += 1 ;
                        }
                        double v214;
                        v214 = 0.0;
                        int v215;
                        v215 = 0;
                        while (while_method_0(v215)){
                            assert("Tensor range check" && 0 <= v215 && v215 < 2);
                            double v217;
                            v217 = v207[v215];
                            double v218;
                            v218 = v214 + v217;
                            v214 = v218;
                            v215 += 1 ;
                        }
                        double v219;
                        v219 = 0.0;
                        int v220;
                        v220 = 0;
                        while (while_method_0(v220)){
                            assert("Tensor range check" && 0 <= v220 && v220 < 2);
                            int v222;
                            v222 = v220 + v206;
                            double v223;
                            v223 = v147[v222];
                            double v224;
                            v224 = v219 + v223;
                            v219 = v224;
                            v220 += 1 ;
                        }
                        double v225;
                        v225 = v214 - v219;
                        double v226;
                        v226 = exp(v225);
                        float v227;
                        v227 = (float)v226;
                        float v228;
                        v228 = v184 * v227;
                        assert("Tensor range check" && 0 <= v180 && v180 < 4);
                        float * v229;
                        v229 = v198+v180;
                        float * v231;
                        v231 = v200+v180;
                        float v233;
                        v233 = atomicAdd(v229,v228);
                        float v234;
                        v234 = atomicAdd(v231,v227);
                        float * v235;
                        v235 = v190+0;
                        float * v237;
                        v237 = v194+0;
                        float * v239;
                        v239 = v196+0;
                        int v241;
                        v241 = sizeof(float *);
                        unsigned long long v242;
                        v242 = (unsigned long long)v241;
                        unsigned long long v243;
                        v243 = 256ull * v242;
                        unsigned long long v244;
                        v244 = 4096ull + v243;
                        unsigned long long v245;
                        v245 = v244 + 16ull;
                        unsigned long long v246;
                        v246 = v245 - 1ull;
                        unsigned long long v247;
                        v247 = v246 % 16ull;
                        unsigned long long v248;
                        v248 = v246 - v247;
                        unsigned long long v249;
                        v249 = v248 + v243;
                        unsigned long long v250;
                        v250 = v249 + 16ull;
                        unsigned long long v251;
                        v251 = v250 - 1ull;
                        unsigned long long v252;
                        v252 = v251 % 16ull;
                        unsigned long long v253;
                        v253 = v251 - v252;
                        unsigned long long v254;
                        v254 = v253 + v243;
                        unsigned long long v255;
                        v255 = v254 + 16ull;
                        unsigned long long v256;
                        v256 = v255 - 1ull;
                        unsigned long long v257;
                        v257 = v256 % 16ull;
                        unsigned long long v258;
                        v258 = v256 - v257;
                        unsigned long long v259;
                        v259 = v258 + v243;
                        unsigned long long v260;
                        v260 = v259 + 16ull;
                        unsigned long long v261;
                        v261 = v260 - 1ull;
                        unsigned long long v262;
                        v262 = v261 % 16ull;
                        unsigned long long v263;
                        v263 = v261 - v262;
                        unsigned long long v264;
                        v264 = v263 + 1024ull;
                        bool v265;
                        v265 = v264 <= 98304ull;
                        bool v266;
                        v266 = v265 == false;
                        if (v266){
                            assert("The dynamic shared memory is insufficient to allocate the tensor." && v265);
                        } else {
                        }
                        extern __shared__ unsigned char v268[];
                        bool v269;
                        v269 = v264 <= v264;
                        bool v270;
                        v270 = v269 == false;
                        if (v270){
                            assert("The length of the partition has to be less than or equal to the length of the base array." && v269);
                        } else {
                        }
                        float * v272;
                        v272 = reinterpret_cast<float *>(&v268[0ull]);
                        int * v274;
                        v274 = reinterpret_cast<int *>(&v268[1024ull]);
                        float * v276;
                        v276 = reinterpret_cast<float *>(&v268[2048ull]);
                        float * v278;
                        v278 = reinterpret_cast<float *>(&v268[3072ull]);
                        float * * v280;
                        v280 = reinterpret_cast<float * *>(&v268[4096ull]);
                        float * * v282;
                        v282 = reinterpret_cast<float * *>(&v268[v248]);
                        float * * v284;
                        v284 = reinterpret_cast<float * *>(&v268[v253]);
                        float * * v286;
                        v286 = reinterpret_cast<float * *>(&v268[v258]);
                        float * v288;
                        v288 = reinterpret_cast<float *>(&v268[v263]);
                        int v290;
                        v290 = threadIdx.x;
                        assert("Tensor range check" && 0 <= v290 && v290 < 256);
                        v272[v290] = v181;
                        v274[v290] = v180;
                        v276[v290] = v184;
                        v278[v290] = v227;
                        v280[v290] = v192;
                        v282[v290] = v235;
                        v284[v290] = v237;
                        v286[v290] = v239;
                        __syncthreads();
                        bool v291;
                        v291 = 0 <= v290;
                        bool v292;
                        v292 = v291 == false;
                        if (v292){
                            assert("The index needs to be zero or positive." && v291);
                        } else {
                        }
                        int v294;
                        v294 = v290 % 1;
                        bool v295;
                        v295 = v290 < 256;
                        bool v296;
                        v296 = v295 == false;
                        if (v296){
                            assert("The last element of the projection dimensions needs to be greater than the index remainder." && v295);
                        } else {
                        }
                        assert("Tensor range check" && 0 <= v290 && v290 < 256);
                        int v298;
                        v298 = 0;
                        while (while_method_4(v298)){
                            bool v300;
                            v300 = v291 && v295;
                            bool v301;
                            v301 = v300 == false;
                            if (v301){
                                assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v300);
                            } else {
                            }
                            bool v303;
                            v303 = 0 <= v298;
                            bool v305;
                            if (v303){
                                bool v304;
                                v304 = v298 < 1;
                                v305 = v304;
                            } else {
                                v305 = false;
                            }
                            bool v306;
                            v306 = v305 == false;
                            if (v306){
                                assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v305);
                            } else {
                            }
                            int v308;
                            v308 = v298 * 256;
                            int v309;
                            v309 = v308 + v290;
                            assert("Tensor range check" && 0 <= v298 && v298 < 1);
                            int v310;
                            v310 = 256 * v298;
                            int v311;
                            v311 = v310 + v290;
                            float v312;
                            v312 = v272[v311];
                            int v313;
                            v313 = v274[v311];
                            float v314;
                            v314 = v276[v311];
                            float v315;
                            v315 = v278[v311];
                            float * v316;
                            v316 = v280[v311];
                            float * v317;
                            v317 = v282[v311];
                            float * v318;
                            v318 = v284[v311];
                            float * v319;
                            v319 = v286[v311];
                            int v320;
                            v320 = blockIdx.x;
                            int v321;
                            v321 = v320 * 256;
                            int v322;
                            v322 = v321 + v309;
                            assert("Tensor range check" && 0 <= v294 && v294 < 1);
                            int v323;
                            v323 = 4 * v294;
                            float v324[4];
                            float v325[4];
                            float v326[4];
                            int v327[4];
                            int v328;
                            v328 = 0;
                            while (while_method_4(v328)){
                                assert("Tensor range check" && 0 <= v328 && v328 < 1);
                                int v330;
                                v330 = 4 * v328;
                                assert("Tensor range check" && 0 <= v328 && v328 < 1);
                                int v331;
                                v331 = v330 + v323;
                                int4* v332;
                                v332 = reinterpret_cast<int4*>(v317 + v331);
                                int4* v333;
                                v333 = reinterpret_cast<int4*>(v324 + v330);
                                assert("Pointer alignment check" && (unsigned long long)(v332) % 4 == 0 && (unsigned long long)(v333) % 4 == 0);
                                *v333 = *v332;
                                int4* v334;
                                v334 = reinterpret_cast<int4*>(v318 + v331);
                                int4* v335;
                                v335 = reinterpret_cast<int4*>(v325 + v330);
                                assert("Pointer alignment check" && (unsigned long long)(v334) % 4 == 0 && (unsigned long long)(v335) % 4 == 0);
                                *v335 = *v334;
                                int4* v336;
                                v336 = reinterpret_cast<int4*>(v319 + v331);
                                int4* v337;
                                v337 = reinterpret_cast<int4*>(v326 + v330);
                                assert("Pointer alignment check" && (unsigned long long)(v336) % 4 == 0 && (unsigned long long)(v337) % 4 == 0);
                                *v337 = *v336;
                                v328 += 1 ;
                            }
                            int v338;
                            v338 = 0;
                            while (while_method_4(v338)){
                                int v340;
                                v340 = 0;
                                while (while_method_9(v340)){
                                    bool v342;
                                    v342 = 0 <= v340;
                                    bool v344;
                                    if (v342){
                                        bool v343;
                                        v343 = v340 < 4;
                                        v344 = v343;
                                    } else {
                                        v344 = false;
                                    }
                                    bool v345;
                                    v345 = v344 == false;
                                    if (v345){
                                        assert("The indices should be inside the range of the dimension." && v344);
                                    } else {
                                    }
                                    bool v347;
                                    v347 = 0 <= v294;
                                    bool v349;
                                    if (v347){
                                        bool v348;
                                        v348 = v294 < 1;
                                        v349 = v348;
                                    } else {
                                        v349 = false;
                                    }
                                    bool v350;
                                    v350 = v349 == false;
                                    if (v350){
                                        assert("The indices should be inside the range of the dimension." && v349);
                                    } else {
                                    }
                                    int v352;
                                    v352 = v294 * 4;
                                    int v353;
                                    v353 = v340 + v352;
                                    bool v354;
                                    v354 = 0 <= v338;
                                    bool v356;
                                    if (v354){
                                        bool v355;
                                        v355 = v338 < 1;
                                        v356 = v355;
                                    } else {
                                        v356 = false;
                                    }
                                    bool v357;
                                    v357 = v356 == false;
                                    if (v357){
                                        assert("The indices should be inside the range of the dimension." && v356);
                                    } else {
                                    }
                                    int v359;
                                    v359 = v338 * 4;
                                    int v360;
                                    v360 = v353 + v359;
                                    assert("Tensor range check" && 0 <= v338 && v338 < 1);
                                    assert("Tensor range check" && 0 <= v340 && v340 < 4);
                                    int v361;
                                    v361 = 4 * v338;
                                    int v362;
                                    v362 = v361 + v340;
                                    v327[v362] = v360;
                                    v340 += 1 ;
                                }
                                v338 += 1 ;
                            }
                            float v363[4];
                            int v364;
                            v364 = 0;
                            while (while_method_4(v364)){
                                int v366;
                                v366 = 0;
                                while (while_method_9(v366)){
                                    assert("Tensor range check" && 0 <= v364 && v364 < 1);
                                    assert("Tensor range check" && 0 <= v366 && v366 < 4);
                                    int v368;
                                    v368 = 4 * v364;
                                    int v369;
                                    v369 = v368 + v366;
                                    float v370;
                                    v370 = v325[v369];
                                    float v371;
                                    v371 = v326[v369];
                                    bool v372;
                                    v372 = v371 == 0.0f;
                                    bool v373;
                                    v373 = v372 != true;
                                    float v375;
                                    if (v373){
                                        float v374;
                                        v374 = v370 / v371;
                                        v375 = v374;
                                    } else {
                                        v375 = 0.0f;
                                    }
                                    assert("Tensor range check" && 0 <= v364 && v364 < 1);
                                    assert("Tensor range check" && 0 <= v366 && v366 < 4);
                                    v363[v369] = v375;
                                    v366 += 1 ;
                                }
                                v364 += 1 ;
                            }
                            bool v376[4];
                            int v377;
                            v377 = 0;
                            while (while_method_4(v377)){
                                int v379;
                                v379 = 0;
                                while (while_method_9(v379)){
                                    assert("Tensor range check" && 0 <= v377 && v377 < 1);
                                    assert("Tensor range check" && 0 <= v379 && v379 < 4);
                                    int v381;
                                    v381 = 4 * v377;
                                    int v382;
                                    v382 = v381 + v379;
                                    float v383;
                                    v383 = v324[v382];
                                    int v384;
                                    v384 = v327[v382];
                                    bool v385;
                                    v385 = v384 < 3;
                                    assert("Tensor range check" && 0 <= v377 && v377 < 1);
                                    assert("Tensor range check" && 0 <= v379 && v379 < 4);
                                    v376[v382] = v385;
                                    v379 += 1 ;
                                }
                                v377 += 1 ;
                            }
                            float v386[4];
                            int v387;
                            v387 = 0;
                            while (while_method_4(v387)){
                                int v389;
                                v389 = 0;
                                while (while_method_9(v389)){
                                    assert("Tensor range check" && 0 <= v387 && v387 < 1);
                                    assert("Tensor range check" && 0 <= v389 && v389 < 4);
                                    int v391;
                                    v391 = 4 * v387;
                                    int v392;
                                    v392 = v391 + v389;
                                    float v393;
                                    v393 = v324[v392];
                                    bool v394;
                                    v394 = v376[v392];
                                    float v397;
                                    if (v394){
                                        bool v395;
                                        v395 = 0.0f >= v393;
                                        if (v395){
                                            v397 = 0.0f;
                                        } else {
                                            v397 = v393;
                                        }
                                    } else {
                                        v397 = 0.0f;
                                    }
                                    assert("Tensor range check" && 0 <= v387 && v387 < 1);
                                    assert("Tensor range check" && 0 <= v389 && v389 < 4);
                                    v386[v392] = v397;
                                    v389 += 1 ;
                                }
                                v387 += 1 ;
                            }
                            float v398;
                            v398 = 0.0f;
                            int v399;
                            v399 = 0;
                            while (while_method_4(v399)){
                                int v401;
                                v401 = 0;
                                while (while_method_9(v401)){
                                    assert("Tensor range check" && 0 <= v399 && v399 < 1);
                                    assert("Tensor range check" && 0 <= v401 && v401 < 4);
                                    int v403;
                                    v403 = 4 * v399;
                                    int v404;
                                    v404 = v403 + v401;
                                    float v405;
                                    v405 = v386[v404];
                                    float v406;
                                    v406 = v398 + v405;
                                    v398 = v406;
                                    v401 += 1 ;
                                }
                                v399 += 1 ;
                            }
                            auto v407 = cooperative_groups::coalesced_threads();
                            int v408;
                            v408 = threadIdx.x;
                            auto v409 = cooperative_groups::labeled_partition(v407,v408);
                            Closure1 v410{};
                            float v411;
                            v411 = cooperative_groups::reduce(v409, v398, v410);
                            int v412[4];
                            int v413;
                            v413 = 0;
                            while (while_method_4(v413)){
                                int v415;
                                v415 = 0;
                                while (while_method_9(v415)){
                                    assert("Tensor range check" && 0 <= v413 && v413 < 1);
                                    assert("Tensor range check" && 0 <= v415 && v415 < 4);
                                    int v417;
                                    v417 = 4 * v413;
                                    int v418;
                                    v418 = v417 + v415;
                                    bool v419;
                                    v419 = v376[v418];
                                    int v420;
                                    if (v419){
                                        v420 = 1;
                                    } else {
                                        v420 = 0;
                                    }
                                    assert("Tensor range check" && 0 <= v413 && v413 < 1);
                                    assert("Tensor range check" && 0 <= v415 && v415 < 4);
                                    v412[v418] = v420;
                                    v415 += 1 ;
                                }
                                v413 += 1 ;
                            }
                            int v421;
                            v421 = 0;
                            int v422;
                            v422 = 0;
                            while (while_method_4(v422)){
                                int v424;
                                v424 = 0;
                                while (while_method_9(v424)){
                                    assert("Tensor range check" && 0 <= v422 && v422 < 1);
                                    assert("Tensor range check" && 0 <= v424 && v424 < 4);
                                    int v426;
                                    v426 = 4 * v422;
                                    int v427;
                                    v427 = v426 + v424;
                                    int v428;
                                    v428 = v412[v427];
                                    int v429;
                                    v429 = v421 + v428;
                                    v421 = v429;
                                    v424 += 1 ;
                                }
                                v422 += 1 ;
                            }
                            auto v430 = cooperative_groups::coalesced_threads();
                            int v431;
                            v431 = threadIdx.x;
                            auto v432 = cooperative_groups::labeled_partition(v430,v431);
                            Closure2 v433{};
                            int v434;
                            v434 = cooperative_groups::reduce(v432, v421, v433);
                            float v435;
                            v435 = (float)v434;
                            float v436;
                            v436 = 1.0f / v435;
                            float v437[4];
                            int v438;
                            v438 = 0;
                            while (while_method_4(v438)){
                                int v440;
                                v440 = 0;
                                while (while_method_9(v440)){
                                    assert("Tensor range check" && 0 <= v438 && v438 < 1);
                                    assert("Tensor range check" && 0 <= v440 && v440 < 4);
                                    int v442;
                                    v442 = 4 * v438;
                                    int v443;
                                    v443 = v442 + v440;
                                    float v444;
                                    v444 = v386[v443];
                                    bool v445;
                                    v445 = v376[v443];
                                    bool v446;
                                    v446 = v445 == false;
                                    float v451;
                                    if (v446){
                                        v451 = 0.0f;
                                    } else {
                                        bool v447;
                                        v447 = v411 == 0.0f;
                                        bool v448;
                                        v448 = v447 != true;
                                        if (v448){
                                            float v449;
                                            v449 = v444 / v411;
                                            v451 = v449;
                                        } else {
                                            v451 = v436;
                                        }
                                    }
                                    assert("Tensor range check" && 0 <= v438 && v438 < 1);
                                    assert("Tensor range check" && 0 <= v440 && v440 < 4);
                                    v437[v443] = v451;
                                    v440 += 1 ;
                                }
                                v438 += 1 ;
                            }
                            float v452[4];
                            int v453;
                            v453 = 0;
                            while (while_method_4(v453)){
                                int v455;
                                v455 = 0;
                                while (while_method_9(v455)){
                                    assert("Tensor range check" && 0 <= v453 && v453 < 1);
                                    assert("Tensor range check" && 0 <= v455 && v455 < 4);
                                    int v457;
                                    v457 = 4 * v453;
                                    int v458;
                                    v458 = v457 + v455;
                                    float v459;
                                    v459 = v363[v458];
                                    int v460;
                                    v460 = v327[v458];
                                    bool v461;
                                    v461 = v313 == v460;
                                    float v464;
                                    if (v461){
                                        float v462;
                                        v462 = v314 - v459;
                                        float v463;
                                        v463 = v462 / v312;
                                        v464 = v463;
                                    } else {
                                        v464 = 0.0f;
                                    }
                                    float v465;
                                    v465 = v464 + v459;
                                    assert("Tensor range check" && 0 <= v453 && v453 < 1);
                                    assert("Tensor range check" && 0 <= v455 && v455 < 4);
                                    v452[v458] = v465;
                                    v455 += 1 ;
                                }
                                v453 += 1 ;
                            }
                            float v466[4];
                            int v467;
                            v467 = 0;
                            while (while_method_4(v467)){
                                int v469;
                                v469 = 0;
                                while (while_method_9(v469)){
                                    assert("Tensor range check" && 0 <= v467 && v467 < 1);
                                    assert("Tensor range check" && 0 <= v469 && v469 < 4);
                                    int v471;
                                    v471 = 4 * v467;
                                    int v472;
                                    v472 = v471 + v469;
                                    float v473;
                                    v473 = v437[v472];
                                    float v474;
                                    v474 = v452[v472];
                                    float v475;
                                    v475 = v473 * v474;
                                    assert("Tensor range check" && 0 <= v467 && v467 < 1);
                                    assert("Tensor range check" && 0 <= v469 && v469 < 4);
                                    v466[v472] = v475;
                                    v469 += 1 ;
                                }
                                v467 += 1 ;
                            }
                            float v476;
                            v476 = 0.0f;
                            int v477;
                            v477 = 0;
                            while (while_method_4(v477)){
                                int v479;
                                v479 = 0;
                                while (while_method_9(v479)){
                                    assert("Tensor range check" && 0 <= v477 && v477 < 1);
                                    assert("Tensor range check" && 0 <= v479 && v479 < 4);
                                    int v481;
                                    v481 = 4 * v477;
                                    int v482;
                                    v482 = v481 + v479;
                                    float v483;
                                    v483 = v466[v482];
                                    float v484;
                                    v484 = v476 + v483;
                                    v476 = v484;
                                    v479 += 1 ;
                                }
                                v477 += 1 ;
                            }
                            auto v485 = cooperative_groups::coalesced_threads();
                            int v486;
                            v486 = threadIdx.x;
                            auto v487 = cooperative_groups::labeled_partition(v485,v486);
                            float v488;
                            v488 = cooperative_groups::reduce(v487, v476, v410);
                            int v489;
                            v489 = 0;
                            while (while_method_4(v489)){
                                int v491;
                                v491 = 0;
                                while (while_method_9(v491)){
                                    assert("Tensor range check" && 0 <= v489 && v489 < 1);
                                    assert("Tensor range check" && 0 <= v491 && v491 < 4);
                                    int v493;
                                    v493 = 4 * v489;
                                    int v494;
                                    v494 = v493 + v491;
                                    float v495;
                                    v495 = v452[v494];
                                    int v496;
                                    v496 = v327[v494];
                                    float v497;
                                    v497 = v495 - v488;
                                    float v498;
                                    v498 = v315 * v497;
                                    assert("Tensor range check" && 0 <= v496 && v496 < 4);
                                    float * v499;
                                    v499 = v316+v496;
                                    float v501;
                                    v501 = atomicAdd(v499,v498);
                                    v491 += 1 ;
                                }
                                v489 += 1 ;
                            }
                            int v502;
                            v502 = 0;
                            while (while_method_4(v502)){
                                assert("Tensor range check" && 0 <= v502 && v502 < 1);
                                assert("Tensor range check" && 0 <= v502 && v502 < 1);
                                v502 += 1 ;
                            }
                            assert("Tensor range check" && 0 <= v309 && v309 < 256);
                            v288[v309] = v488;
                            v298 += 1 ;
                        }
                        __syncthreads();
                        assert("Tensor range check" && 0 <= v290 && v290 < 256);
                        float v504;
                        v504 = v288[v290];
                        __syncthreads();
                        assert("Tensor range check" && 0 <= v182 && v182 < 2);
                        v161[v182] = v504;
                    }
                    int v505;
                    v505 = threadIdx.x;
                    int v506;
                    v506 = blockIdx.x;
                    int v507;
                    v507 = v506 * 256;
                    int v508;
                    v508 = v505 + v507;
                    assert("Tensor range check" && 0 <= v155 && v155 < 4);
                    int v509;
                    v509 = 12288 * v155;
                    assert("Tensor range check" && 0 <= v508 && v508 < 6144);
                    int v510;
                    v510 = 2 * v508;
                    int v511;
                    v511 = v510 + v509;
                    double * v512;
                    v512 = v149+v511;
                    double * v514;
                    v514 = v151+v511;
                    double * v516;
                    v516 = v512+0;
                    double * v518;
                    v518 = v514+0;
                    double * v520;
                    v520 = v512+0;
                    double * v522;
                    v522 = v514+0;
                    int v524;
                    v524 = sizeof(double *);
                    unsigned long long v525;
                    v525 = (unsigned long long)v524;
                    unsigned long long v526;
                    v526 = 256ull * v525;
                    unsigned long long v527;
                    v527 = v526 + 16ull;
                    unsigned long long v528;
                    v528 = v527 - 1ull;
                    unsigned long long v529;
                    v529 = v528 % 16ull;
                    unsigned long long v530;
                    v530 = v528 - v529;
                    unsigned long long v531;
                    v531 = v530 + v526;
                    unsigned long long v532;
                    v532 = v531 + 16ull;
                    unsigned long long v533;
                    v533 = v532 - 1ull;
                    unsigned long long v534;
                    v534 = v533 % 16ull;
                    unsigned long long v535;
                    v535 = v533 - v534;
                    unsigned long long v536;
                    v536 = v535 + v526;
                    unsigned long long v537;
                    v537 = v536 + 16ull;
                    unsigned long long v538;
                    v538 = v537 - 1ull;
                    unsigned long long v539;
                    v539 = v538 % 16ull;
                    unsigned long long v540;
                    v540 = v538 - v539;
                    unsigned long long v541;
                    v541 = v540 + v526;
                    bool v542;
                    v542 = v541 <= 98304ull;
                    bool v543;
                    v543 = v542 == false;
                    if (v543){
                        assert("The dynamic shared memory is insufficient to allocate the tensor." && v542);
                    } else {
                    }
                    extern __shared__ unsigned char v545[];
                    bool v546;
                    v546 = v541 <= v541;
                    bool v547;
                    v547 = v546 == false;
                    if (v547){
                        assert("The length of the partition has to be less than or equal to the length of the base array." && v546);
                    } else {
                    }
                    double * * v549;
                    v549 = reinterpret_cast<double * *>(&v545[0ull]);
                    double * * v551;
                    v551 = reinterpret_cast<double * *>(&v545[v530]);
                    double * * v553;
                    v553 = reinterpret_cast<double * *>(&v545[v535]);
                    double * * v555;
                    v555 = reinterpret_cast<double * *>(&v545[v540]);
                    int v557;
                    v557 = threadIdx.x;
                    assert("Tensor range check" && 0 <= v557 && v557 < 256);
                    v549[v557] = v516;
                    v551[v557] = v518;
                    v553[v557] = v520;
                    v555[v557] = v522;
                    __syncthreads();
                    bool v558;
                    v558 = 0 <= v557;
                    bool v559;
                    v559 = v558 == false;
                    if (v559){
                        assert("The index needs to be zero or positive." && v558);
                    } else {
                    }
                    int v561;
                    v561 = v557 % 1;
                    bool v562;
                    v562 = v557 < 256;
                    bool v563;
                    v563 = v562 == false;
                    if (v563){
                        assert("The last element of the projection dimensions needs to be greater than the index remainder." && v562);
                    } else {
                    }
                    assert("Tensor range check" && 0 <= v557 && v557 < 256);
                    int v565;
                    v565 = 0;
                    while (while_method_4(v565)){
                        bool v567;
                        v567 = v558 && v562;
                        bool v568;
                        v568 = v567 == false;
                        if (v568){
                            assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v567);
                        } else {
                        }
                        bool v570;
                        v570 = 0 <= v565;
                        bool v572;
                        if (v570){
                            bool v571;
                            v571 = v565 < 1;
                            v572 = v571;
                        } else {
                            v572 = false;
                        }
                        bool v573;
                        v573 = v572 == false;
                        if (v573){
                            assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v572);
                        } else {
                        }
                        int v575;
                        v575 = v565 * 256;
                        int v576;
                        v576 = v575 + v557;
                        assert("Tensor range check" && 0 <= v565 && v565 < 1);
                        int v577;
                        v577 = 256 * v565;
                        int v578;
                        v578 = v577 + v557;
                        double * v579;
                        v579 = v549[v578];
                        double * v580;
                        v580 = v551[v578];
                        double * v581;
                        v581 = v553[v578];
                        double * v582;
                        v582 = v555[v578];
                        int v583;
                        v583 = blockIdx.x;
                        int v584;
                        v584 = v583 * 256;
                        int v585;
                        v585 = v584 + v576;
                        assert("Tensor range check" && 0 <= v561 && v561 < 1);
                        int v586;
                        v586 = 2 * v561;
                        double v587[2];
                        double v588[2];
                        int v589[2];
                        int v590;
                        v590 = 0;
                        while (while_method_4(v590)){
                            assert("Tensor range check" && 0 <= v590 && v590 < 1);
                            int v592;
                            v592 = 2 * v590;
                            assert("Tensor range check" && 0 <= v590 && v590 < 1);
                            int v593;
                            v593 = v592 + v586;
                            int4* v594;
                            v594 = reinterpret_cast<int4*>(v579 + v593);
                            int4* v595;
                            v595 = reinterpret_cast<int4*>(v587 + v592);
                            assert("Pointer alignment check" && (unsigned long long)(v594) % 2 == 0 && (unsigned long long)(v595) % 2 == 0);
                            *v595 = *v594;
                            int4* v596;
                            v596 = reinterpret_cast<int4*>(v580 + v593);
                            int4* v597;
                            v597 = reinterpret_cast<int4*>(v588 + v592);
                            assert("Pointer alignment check" && (unsigned long long)(v596) % 2 == 0 && (unsigned long long)(v597) % 2 == 0);
                            *v597 = *v596;
                            v590 += 1 ;
                        }
                        int v598;
                        v598 = 0;
                        while (while_method_4(v598)){
                            int v600;
                            v600 = 0;
                            while (while_method_0(v600)){
                                bool v602;
                                v602 = 0 <= v600;
                                bool v604;
                                if (v602){
                                    bool v603;
                                    v603 = v600 < 2;
                                    v604 = v603;
                                } else {
                                    v604 = false;
                                }
                                bool v605;
                                v605 = v604 == false;
                                if (v605){
                                    assert("The indices should be inside the range of the dimension." && v604);
                                } else {
                                }
                                bool v607;
                                v607 = 0 <= v561;
                                bool v609;
                                if (v607){
                                    bool v608;
                                    v608 = v561 < 1;
                                    v609 = v608;
                                } else {
                                    v609 = false;
                                }
                                bool v610;
                                v610 = v609 == false;
                                if (v610){
                                    assert("The indices should be inside the range of the dimension." && v609);
                                } else {
                                }
                                int v612;
                                v612 = v561 * 2;
                                int v613;
                                v613 = v600 + v612;
                                bool v614;
                                v614 = 0 <= v598;
                                bool v616;
                                if (v614){
                                    bool v615;
                                    v615 = v598 < 1;
                                    v616 = v615;
                                } else {
                                    v616 = false;
                                }
                                bool v617;
                                v617 = v616 == false;
                                if (v617){
                                    assert("The indices should be inside the range of the dimension." && v616);
                                } else {
                                }
                                int v619;
                                v619 = v598 * 2;
                                int v620;
                                v620 = v613 + v619;
                                assert("Tensor range check" && 0 <= v598 && v598 < 1);
                                assert("Tensor range check" && 0 <= v600 && v600 < 2);
                                int v621;
                                v621 = 2 * v598;
                                int v622;
                                v622 = v621 + v600;
                                v589[v622] = v620;
                                v600 += 1 ;
                            }
                            v598 += 1 ;
                        }
                        double v623[2];
                        double v624[2];
                        int v625;
                        v625 = 0;
                        while (while_method_4(v625)){
                            int v627;
                            v627 = 0;
                            while (while_method_0(v627)){
                                assert("Tensor range check" && 0 <= v625 && v625 < 1);
                                assert("Tensor range check" && 0 <= v627 && v627 < 2);
                                int v629;
                                v629 = 2 * v625;
                                int v630;
                                v630 = v629 + v627;
                                double v631;
                                v631 = v587[v630];
                                double v632;
                                v632 = v588[v630];
                                assert("Tensor range check" && 0 <= v625 && v625 < 1);
                                assert("Tensor range check" && 0 <= v627 && v627 < 2);
                                v623[v630] = 0.0;
                                v624[v630] = 0.0;
                                v627 += 1 ;
                            }
                            v625 += 1 ;
                        }
                        int v633;
                        v633 = 0;
                        while (while_method_4(v633)){
                            assert("Tensor range check" && 0 <= v633 && v633 < 1);
                            int v635;
                            v635 = 2 * v633;
                            int v636;
                            v636 = v635 + v586;
                            assert("Tensor range check" && 0 <= v633 && v633 < 1);
                            int4* v637;
                            v637 = reinterpret_cast<int4*>(v623 + v635);
                            int4* v638;
                            v638 = reinterpret_cast<int4*>(v581 + v636);
                            assert("Pointer alignment check" && (unsigned long long)(v637) % 2 == 0 && (unsigned long long)(v638) % 2 == 0);
                            *v638 = *v637;
                            int4* v639;
                            v639 = reinterpret_cast<int4*>(v624 + v635);
                            int4* v640;
                            v640 = reinterpret_cast<int4*>(v582 + v636);
                            assert("Pointer alignment check" && (unsigned long long)(v639) % 2 == 0 && (unsigned long long)(v640) % 2 == 0);
                            *v640 = *v639;
                            v633 += 1 ;
                        }
                        assert("Tensor range check" && 0 <= v576 && v576 < 256);
                        v565 += 1 ;
                    }
                    __syncthreads();
                    assert("Tensor range check" && 0 <= v557 && v557 < 256);
                    __syncthreads();
                    assert("Tensor range check" && 0 <= v155 && v155 < 4);
                    assert("Tensor range check" && 0 <= v508 && v508 < 6144);
                    int v641;
                    v641 = v171 + v508;
                    v153[v641] = 0;
                    v155 += 1 ;
                }
                v38 += 1 ;
            }
            v36 += 1 ;
        }
        cooperative_groups::grid_group & v642 = v27.v1;
        cooperative_groups::grid_group & v643 = v642;
        curandStatePhilox4_32_10_t & v644 = v27.v5;
        curandStatePhilox4_32_10_t & v645 = v644;
        unsigned int * v646;
        v646 = reinterpret_cast<unsigned int *>(&v0[6291456ull]);
        int * v648;
        v648 = reinterpret_cast<int *>(&v2[262144ull]);
        float * v650;
        v650 = reinterpret_cast<float *>(&v2[262160ull]);
        float * v652;
        v652 = reinterpret_cast<float *>(&v2[524304ull]);
        float * v654;
        v654 = reinterpret_cast<float *>(&v2[786448ull]);
        float * v656;
        v656 = reinterpret_cast<float *>(&v2[1048592ull]);
        float * v658;
        v658 = reinterpret_cast<float *>(&v2[1310736ull]);
        float * v660;
        v660 = reinterpret_cast<float *>(&v2[1572880ull]);
        float * v662;
        v662 = reinterpret_cast<float *>(&v2[1835024ull]);
        int * v664;
        v664 = reinterpret_cast<int *>(&v0[6389760ull]);
        float * v666;
        v666 = reinterpret_cast<float *>(&v0[7962624ull]);
        int * v668;
        v668 = reinterpret_cast<int *>(&v0[9535488ull]);
        int * v670;
        v670 = reinterpret_cast<int *>(&v0[11108352ull]);
        double * v672;
        v672 = reinterpret_cast<double *>(&v0[12681216ull]);
        double * v674;
        v674 = reinterpret_cast<double *>(&v0[18972672ull]);
        double * v676;
        v676 = reinterpret_cast<double *>(&v2[2097168ull]);
        double * v678;
        v678 = reinterpret_cast<double *>(&v2[2490384ull]);
        int * v680;
        v680 = reinterpret_cast<int *>(&v2[2883600ull]);
        v643.sync() ;
        int v682;
        v682 = threadIdx.x;
        int v683;
        v683 = blockIdx.x;
        int v684;
        v684 = v683 * 256;
        int v685;
        v685 = v682 + v684;
        bool v686;
        v686 = v685 == 0;
        if (v686){
            int v687;
            v687 = 0;
            int v688;
            v688 = 4;
            int v689;
            v689 = int_range_22(v688, v687, v645);
            v648[0] = v689;
        } else {
        }
        __syncwarp();
        int v690;
        v690 = threadIdx.x;
        bool v691;
        v691 = 0 <= v690;
        bool v692;
        v692 = v691 == false;
        if (v692){
            assert("The index needs to be zero or positive." && v691);
        } else {
        }
        int v694;
        v694 = v690 % 1;
        int v695;
        v695 = v690 % 256;
        int v696;
        v696 = v690 / 256;
        bool v697;
        v697 = v696 < 1;
        bool v698;
        v698 = v697 == false;
        if (v698){
            assert("The last element of the projection dimensions needs to be greater than the index remainder." && v697);
        } else {
        }
        assert("Tensor range check" && 0 <= v696 && v696 < 1);
        assert("Tensor range check" && 0 <= v695 && v695 < 256);
        assert("Tensor range check" && 0 <= v694 && v694 < 1);
        int v700;
        v700 = 4 * v694;
        int v701;
        v701 = 4 * v695;
        int v702;
        v702 = v701 + v700;
        int v703;
        v703 = 16384 * v696;
        int v704;
        v704 = v703 + v702;
        assert("Tensor range check" && 0 <= v696 && v696 < 1);
        assert("Tensor range check" && 0 <= v695 && v695 < 256);
        assert("Tensor range check" && 0 <= v694 && v694 < 1);
        int v705;
        v705 = blockIdx.x;
        int v706;
        v706 = v705;
        while (while_method_12(v706)){
            bool v708;
            v708 = 0 <= v706;
            bool v709;
            v709 = v708 == false;
            if (v709){
                assert("The index needs to be zero or positive." && v708);
            } else {
            }
            int v711;
            v711 = v706 % 16;
            int v712;
            v712 = v706 / 16;
            bool v713;
            v713 = v712 < 4;
            bool v714;
            v714 = v713 == false;
            if (v714){
                assert("The last element of the projection dimensions needs to be greater than the index remainder." && v713);
            } else {
            }
            assert("Tensor range check" && 0 <= v712 && v712 < 4);
            assert("Tensor range check" && 0 <= v711 && v711 < 16);
            int v716;
            v716 = 1024 * v711;
            int v717;
            v717 = v716 + v704;
            int v718;
            v718 = 16384 * v712;
            int v719;
            v719 = v718 + v717;
            float v720[4];
            float v721[4];
            float v722[4];
            float v723[4];
            float v724[4];
            float v725[4];
            float v726[4];
            int v727[4];
            int v728;
            v728 = 0;
            while (while_method_4(v728)){
                assert("Tensor range check" && 0 <= v728 && v728 < 1);
                int v730;
                v730 = 4 * v728;
                assert("Tensor range check" && 0 <= v728 && v728 < 1);
                int v731;
                v731 = v730 + v719;
                int4* v732;
                v732 = reinterpret_cast<int4*>(v650 + v731);
                int4* v733;
                v733 = reinterpret_cast<int4*>(v720 + v730);
                assert("Pointer alignment check" && (unsigned long long)(v732) % 4 == 0 && (unsigned long long)(v733) % 4 == 0);
                *v733 = *v732;
                int4* v734;
                v734 = reinterpret_cast<int4*>(v652 + v731);
                int4* v735;
                v735 = reinterpret_cast<int4*>(v721 + v730);
                assert("Pointer alignment check" && (unsigned long long)(v734) % 4 == 0 && (unsigned long long)(v735) % 4 == 0);
                *v735 = *v734;
                int4* v736;
                v736 = reinterpret_cast<int4*>(v654 + v731);
                int4* v737;
                v737 = reinterpret_cast<int4*>(v722 + v730);
                assert("Pointer alignment check" && (unsigned long long)(v736) % 4 == 0 && (unsigned long long)(v737) % 4 == 0);
                *v737 = *v736;
                int4* v738;
                v738 = reinterpret_cast<int4*>(v656 + v731);
                int4* v739;
                v739 = reinterpret_cast<int4*>(v723 + v730);
                assert("Pointer alignment check" && (unsigned long long)(v738) % 4 == 0 && (unsigned long long)(v739) % 4 == 0);
                *v739 = *v738;
                int4* v740;
                v740 = reinterpret_cast<int4*>(v658 + v731);
                int4* v741;
                v741 = reinterpret_cast<int4*>(v724 + v730);
                assert("Pointer alignment check" && (unsigned long long)(v740) % 4 == 0 && (unsigned long long)(v741) % 4 == 0);
                *v741 = *v740;
                int4* v742;
                v742 = reinterpret_cast<int4*>(v660 + v731);
                int4* v743;
                v743 = reinterpret_cast<int4*>(v725 + v730);
                assert("Pointer alignment check" && (unsigned long long)(v742) % 4 == 0 && (unsigned long long)(v743) % 4 == 0);
                *v743 = *v742;
                int4* v744;
                v744 = reinterpret_cast<int4*>(v662 + v731);
                int4* v745;
                v745 = reinterpret_cast<int4*>(v726 + v730);
                assert("Pointer alignment check" && (unsigned long long)(v744) % 4 == 0 && (unsigned long long)(v745) % 4 == 0);
                *v745 = *v744;
                v728 += 1 ;
            }
            int v746;
            v746 = 0;
            while (while_method_4(v746)){
                int v748;
                v748 = 0;
                while (while_method_9(v748)){
                    bool v750;
                    v750 = 0 <= v748;
                    bool v752;
                    if (v750){
                        bool v751;
                        v751 = v748 < 4;
                        v752 = v751;
                    } else {
                        v752 = false;
                    }
                    bool v753;
                    v753 = v752 == false;
                    if (v753){
                        assert("The indices should be inside the range of the dimension." && v752);
                    } else {
                    }
                    bool v755;
                    v755 = 0 <= v694;
                    bool v757;
                    if (v755){
                        bool v756;
                        v756 = v694 < 1;
                        v757 = v756;
                    } else {
                        v757 = false;
                    }
                    bool v758;
                    v758 = v757 == false;
                    if (v758){
                        assert("The indices should be inside the range of the dimension." && v757);
                    } else {
                    }
                    int v760;
                    v760 = v694 * 4;
                    int v761;
                    v761 = v748 + v760;
                    bool v762;
                    v762 = 0 <= v746;
                    bool v764;
                    if (v762){
                        bool v763;
                        v763 = v746 < 1;
                        v764 = v763;
                    } else {
                        v764 = false;
                    }
                    bool v765;
                    v765 = v764 == false;
                    if (v765){
                        assert("The indices should be inside the range of the dimension." && v764);
                    } else {
                    }
                    int v767;
                    v767 = v746 * 4;
                    int v768;
                    v768 = v761 + v767;
                    assert("Tensor range check" && 0 <= v746 && v746 < 1);
                    assert("Tensor range check" && 0 <= v748 && v748 < 4);
                    int v769;
                    v769 = 4 * v746;
                    int v770;
                    v770 = v769 + v748;
                    v727[v770] = v768;
                    v748 += 1 ;
                }
                v746 += 1 ;
            }
            bool v771;
            v771 = 0 <= v696;
            bool v772;
            v772 = v771 && v697;
            bool v773;
            v773 = v772 == false;
            if (v773){
                assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v772);
            } else {
            }
            bool v775;
            v775 = 0 <= v695;
            bool v777;
            if (v775){
                bool v776;
                v776 = v695 < 256;
                v777 = v776;
            } else {
                v777 = false;
            }
            bool v778;
            v778 = v777 == false;
            if (v778){
                assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v777);
            } else {
            }
            bool v780;
            v780 = 0 <= v712;
            bool v781;
            v781 = v780 && v713;
            bool v782;
            v782 = v781 == false;
            if (v782){
                assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v781);
            } else {
            }
            bool v784;
            v784 = 0 <= v711;
            bool v786;
            if (v784){
                bool v785;
                v785 = v711 < 16;
                v786 = v785;
            } else {
                v786 = false;
            }
            bool v787;
            v787 = v786 == false;
            if (v787){
                assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v786);
            } else {
            }
            int v789;
            v789 = v711 * 256;
            int v790;
            v790 = v712 + v696;
            int v791;
            v791 = v789 + v695;
            bool v792[4];
            int v793;
            v793 = 0;
            while (while_method_4(v793)){
                int v795;
                v795 = 0;
                while (while_method_9(v795)){
                    assert("Tensor range check" && 0 <= v793 && v793 < 1);
                    assert("Tensor range check" && 0 <= v795 && v795 < 4);
                    int v797;
                    v797 = 4 * v793;
                    int v798;
                    v798 = v797 + v795;
                    float v799;
                    v799 = v722[v798];
                    bool v800;
                    v800 = v799 == 0.0f;
                    bool v801;
                    v801 = v800 != true;
                    assert("Tensor range check" && 0 <= v793 && v793 < 1);
                    assert("Tensor range check" && 0 <= v795 && v795 < 4);
                    v792[v798] = v801;
                    v795 += 1 ;
                }
                v793 += 1 ;
            }
            bool v802;
            v802 = false;
            int v803;
            v803 = 0;
            while (while_method_4(v803)){
                int v805;
                v805 = 0;
                while (while_method_9(v805)){
                    assert("Tensor range check" && 0 <= v803 && v803 < 1);
                    assert("Tensor range check" && 0 <= v805 && v805 < 4);
                    int v807;
                    v807 = 4 * v803;
                    int v808;
                    v808 = v807 + v805;
                    bool v809;
                    v809 = v792[v808];
                    bool v810;
                    v810 = v802 || v809;
                    v802 = v810;
                    v805 += 1 ;
                }
                v803 += 1 ;
            }
            auto v811 = cooperative_groups::coalesced_threads();
            int v812;
            v812 = threadIdx.x;
            auto v813 = cooperative_groups::labeled_partition(v811,v812);
            Closure8 v814{};
            bool v815;
            v815 = cooperative_groups::reduce(v813, v802, v814);
            if (v815){
                float v816[4];
                int v817;
                v817 = 0;
                while (while_method_4(v817)){
                    int v819;
                    v819 = 0;
                    while (while_method_9(v819)){
                        assert("Tensor range check" && 0 <= v817 && v817 < 1);
                        assert("Tensor range check" && 0 <= v819 && v819 < 4);
                        int v821;
                        v821 = 4 * v817;
                        int v822;
                        v822 = v821 + v819;
                        float v823;
                        v823 = v721[v822];
                        float v824;
                        v824 = v722[v822];
                        float v825;
                        v825 = v823 + v824;
                        bool v826;
                        v826 = 0.0f >= v825;
                        float v827;
                        if (v826){
                            v827 = 0.0f;
                        } else {
                            v827 = v825;
                        }
                        assert("Tensor range check" && 0 <= v817 && v817 < 1);
                        assert("Tensor range check" && 0 <= v819 && v819 < 4);
                        v816[v822] = v827;
                        v819 += 1 ;
                    }
                    v817 += 1 ;
                }
                float v828[4];
                int v829;
                v829 = 0;
                while (while_method_4(v829)){
                    int v831;
                    v831 = 0;
                    while (while_method_9(v831)){
                        assert("Tensor range check" && 0 <= v829 && v829 < 1);
                        assert("Tensor range check" && 0 <= v831 && v831 < 4);
                        int v833;
                        v833 = 4 * v829;
                        int v834;
                        v834 = v833 + v831;
                        float v835;
                        v835 = v816[v834];
                        bool v836;
                        v836 = 0.0f >= v835;
                        float v837;
                        if (v836){
                            v837 = 0.0f;
                        } else {
                            v837 = v835;
                        }
                        assert("Tensor range check" && 0 <= v829 && v829 < 1);
                        assert("Tensor range check" && 0 <= v831 && v831 < 4);
                        v828[v834] = v837;
                        v831 += 1 ;
                    }
                    v829 += 1 ;
                }
                float v838;
                v838 = 0.0f;
                int v839;
                v839 = 0;
                while (while_method_4(v839)){
                    int v841;
                    v841 = 0;
                    while (while_method_9(v841)){
                        assert("Tensor range check" && 0 <= v839 && v839 < 1);
                        assert("Tensor range check" && 0 <= v841 && v841 < 4);
                        int v843;
                        v843 = 4 * v839;
                        int v844;
                        v844 = v843 + v841;
                        float v845;
                        v845 = v828[v844];
                        float v846;
                        v846 = v838 + v845;
                        v838 = v846;
                        v841 += 1 ;
                    }
                    v839 += 1 ;
                }
                auto v847 = cooperative_groups::coalesced_threads();
                int v848;
                v848 = threadIdx.x;
                auto v849 = cooperative_groups::labeled_partition(v847,v848);
                Closure1 v850{};
                float v851;
                v851 = cooperative_groups::reduce(v849, v838, v850);
                float v852[4];
                int v853;
                v853 = 0;
                while (while_method_4(v853)){
                    int v855;
                    v855 = 0;
                    while (while_method_9(v855)){
                        assert("Tensor range check" && 0 <= v853 && v853 < 1);
                        assert("Tensor range check" && 0 <= v855 && v855 < 4);
                        int v857;
                        v857 = 4 * v853;
                        int v858;
                        v858 = v857 + v855;
                        float v859;
                        v859 = v828[v858];
                        bool v860;
                        v860 = v851 == 0.0f;
                        bool v861;
                        v861 = v860 != true;
                        float v863;
                        if (v861){
                            float v862;
                            v862 = v859 / v851;
                            v863 = v862;
                        } else {
                            v863 = 0.25f;
                        }
                        assert("Tensor range check" && 0 <= v853 && v853 < 1);
                        assert("Tensor range check" && 0 <= v855 && v855 < 4);
                        v852[v858] = v863;
                        v855 += 1 ;
                    }
                    v853 += 1 ;
                }
                float v864[4];
                int v865;
                v865 = 0;
                while (while_method_4(v865)){
                    int v867;
                    v867 = 0;
                    while (while_method_9(v867)){
                        assert("Tensor range check" && 0 <= v865 && v865 < 1);
                        assert("Tensor range check" && 0 <= v867 && v867 < 4);
                        int v869;
                        v869 = 4 * v865;
                        int v870;
                        v870 = v869 + v867;
                        float v871;
                        v871 = v720[v870];
                        float v872;
                        v872 = v852[v870];
                        float v873;
                        v873 = v871 + v872;
                        assert("Tensor range check" && 0 <= v865 && v865 < 1);
                        assert("Tensor range check" && 0 <= v867 && v867 < 4);
                        v864[v870] = v873;
                        v867 += 1 ;
                    }
                    v865 += 1 ;
                }
                float v874[4];
                int v875;
                v875 = 0;
                while (while_method_4(v875)){
                    int v877;
                    v877 = 0;
                    while (while_method_9(v877)){
                        assert("Tensor range check" && 0 <= v875 && v875 < 1);
                        assert("Tensor range check" && 0 <= v877 && v877 < 4);
                        int v879;
                        v879 = 4 * v875;
                        int v880;
                        v880 = v879 + v877;
                        float v881;
                        v881 = v864[v880];
                        float v882;
                        v882 = -v881;
                        bool v883;
                        v883 = v881 >= v882;
                        float v884;
                        if (v883){
                            v884 = v881;
                        } else {
                            v884 = v882;
                        }
                        assert("Tensor range check" && 0 <= v875 && v875 < 1);
                        assert("Tensor range check" && 0 <= v877 && v877 < 4);
                        v874[v880] = v884;
                        v877 += 1 ;
                    }
                    v875 += 1 ;
                }
                float v885;
                v885 = 0.0f;
                int v886;
                v886 = 0;
                while (while_method_4(v886)){
                    int v888;
                    v888 = 0;
                    while (while_method_9(v888)){
                        assert("Tensor range check" && 0 <= v886 && v886 < 1);
                        assert("Tensor range check" && 0 <= v888 && v888 < 4);
                        int v890;
                        v890 = 4 * v886;
                        int v891;
                        v891 = v890 + v888;
                        float v892;
                        v892 = v874[v891];
                        float v893;
                        v893 = v885 + v892;
                        v885 = v893;
                        v888 += 1 ;
                    }
                    v886 += 1 ;
                }
                auto v894 = cooperative_groups::coalesced_threads();
                int v895;
                v895 = threadIdx.x;
                auto v896 = cooperative_groups::labeled_partition(v894,v895);
                float v897;
                v897 = cooperative_groups::reduce(v896, v885, v850);
                bool v898;
                v898 = v897 > 100.0f;
                float v900;
                if (v898){
                    float v899;
                    v899 = 100.0f / v897;
                    v900 = v899;
                } else {
                    v900 = 1.0f;
                }
                float v901[4];
                int v902;
                v902 = 0;
                while (while_method_4(v902)){
                    int v904;
                    v904 = 0;
                    while (while_method_9(v904)){
                        assert("Tensor range check" && 0 <= v902 && v902 < 1);
                        assert("Tensor range check" && 0 <= v904 && v904 < 4);
                        int v906;
                        v906 = 4 * v902;
                        int v907;
                        v907 = v906 + v904;
                        float v908;
                        v908 = v874[v907];
                        float v909;
                        v909 = v900 * v908;
                        assert("Tensor range check" && 0 <= v902 && v902 < 1);
                        assert("Tensor range check" && 0 <= v904 && v904 < 4);
                        v901[v907] = v909;
                        v904 += 1 ;
                    }
                    v902 += 1 ;
                }
                float v910[4];
                float v911[4];
                int v912;
                v912 = 0;
                while (while_method_4(v912)){
                    int v914;
                    v914 = 0;
                    while (while_method_9(v914)){
                        assert("Tensor range check" && 0 <= v912 && v912 < 1);
                        assert("Tensor range check" && 0 <= v914 && v914 < 4);
                        int v916;
                        v916 = 4 * v912;
                        int v917;
                        v917 = v916 + v914;
                        float v918;
                        v918 = v720[v917];
                        float v919;
                        v919 = v721[v917];
                        float v920;
                        v920 = v722[v917];
                        float v921;
                        v921 = v723[v917];
                        float v922;
                        v922 = v724[v917];
                        float v923;
                        v923 = v725[v917];
                        float v924;
                        v924 = v726[v917];
                        float v925;
                        v925 = v921 + v923;
                        float v926;
                        v926 = v922 + v924;
                        assert("Tensor range check" && 0 <= v912 && v912 < 1);
                        assert("Tensor range check" && 0 <= v914 && v914 < 4);
                        v910[v917] = v925;
                        v911[v917] = v926;
                        v914 += 1 ;
                    }
                    v912 += 1 ;
                }
                int v927;
                v927 = 0;
                while (while_method_4(v927)){
                    int v929;
                    v929 = 0;
                    while (while_method_9(v929)){
                        assert("Tensor range check" && 0 <= v927 && v927 < 1);
                        assert("Tensor range check" && 0 <= v929 && v929 < 4);
                        int v931;
                        v931 = 4 * v927;
                        int v932;
                        v932 = v931 + v929;
                        float v933;
                        v933 = v901[v932];
                        float v934;
                        v934 = v816[v932];
                        float v935;
                        v935 = v910[v932];
                        float v936;
                        v936 = v911[v932];
                        assert("Tensor range check" && 0 <= v927 && v927 < 1);
                        assert("Tensor range check" && 0 <= v929 && v929 < 4);
                        v720[v932] = v933;
                        v721[v932] = v934;
                        v722[v932] = 0.0f;
                        v723[v932] = v935;
                        v724[v932] = v936;
                        v725[v932] = 0.0f;
                        v726[v932] = 0.0f;
                        v929 += 1 ;
                    }
                    v927 += 1 ;
                }
            } else {
            }
            assert("Tensor range check" && 0 <= v712 && v712 < 4);
            assert("Tensor range check" && 0 <= v711 && v711 < 16);
            int v937;
            v937 = 0;
            while (while_method_4(v937)){
                assert("Tensor range check" && 0 <= v937 && v937 < 1);
                int v939;
                v939 = 4 * v937;
                int v940;
                v940 = v939 + v719;
                assert("Tensor range check" && 0 <= v937 && v937 < 1);
                int4* v941;
                v941 = reinterpret_cast<int4*>(v720 + v939);
                int4* v942;
                v942 = reinterpret_cast<int4*>(v650 + v940);
                assert("Pointer alignment check" && (unsigned long long)(v941) % 4 == 0 && (unsigned long long)(v942) % 4 == 0);
                *v942 = *v941;
                int4* v943;
                v943 = reinterpret_cast<int4*>(v721 + v939);
                int4* v944;
                v944 = reinterpret_cast<int4*>(v652 + v940);
                assert("Pointer alignment check" && (unsigned long long)(v943) % 4 == 0 && (unsigned long long)(v944) % 4 == 0);
                *v944 = *v943;
                int4* v945;
                v945 = reinterpret_cast<int4*>(v722 + v939);
                int4* v946;
                v946 = reinterpret_cast<int4*>(v654 + v940);
                assert("Pointer alignment check" && (unsigned long long)(v945) % 4 == 0 && (unsigned long long)(v946) % 4 == 0);
                *v946 = *v945;
                int4* v947;
                v947 = reinterpret_cast<int4*>(v723 + v939);
                int4* v948;
                v948 = reinterpret_cast<int4*>(v656 + v940);
                assert("Pointer alignment check" && (unsigned long long)(v947) % 4 == 0 && (unsigned long long)(v948) % 4 == 0);
                *v948 = *v947;
                int4* v949;
                v949 = reinterpret_cast<int4*>(v724 + v939);
                int4* v950;
                v950 = reinterpret_cast<int4*>(v658 + v940);
                assert("Pointer alignment check" && (unsigned long long)(v949) % 4 == 0 && (unsigned long long)(v950) % 4 == 0);
                *v950 = *v949;
                int4* v951;
                v951 = reinterpret_cast<int4*>(v725 + v939);
                int4* v952;
                v952 = reinterpret_cast<int4*>(v660 + v940);
                assert("Pointer alignment check" && (unsigned long long)(v951) % 4 == 0 && (unsigned long long)(v952) % 4 == 0);
                *v952 = *v951;
                int4* v953;
                v953 = reinterpret_cast<int4*>(v726 + v939);
                int4* v954;
                v954 = reinterpret_cast<int4*>(v662 + v940);
                assert("Pointer alignment check" && (unsigned long long)(v953) % 4 == 0 && (unsigned long long)(v954) % 4 == 0);
                *v954 = *v953;
                v937 += 1 ;
            }
            v706 += 24 ;
        }
        v643.sync() ;
        v34 += 1 ;
    }
    cooperative_groups::grid_group & v955 = v27.v1;
    cooperative_groups::grid_group & v956 = v955;
    int v957;
    v957 = threadIdx.x;
    int v958;
    v958 = blockIdx.x;
    int v959;
    v959 = v958 * 256;
    int v960;
    v960 = v957 + v959;
    int v961;
    v961 = v960;
    while (while_method_8(v961)){
        bool v963;
        v963 = 0 <= v961;
        bool v964;
        v964 = v963 == false;
        if (v964){
            assert("The index needs to be zero or positive." && v963);
        } else {
        }
        int v966;
        v966 = v961 % 8;
        int v967;
        v967 = v961 / 8;
        bool v968;
        v968 = v967 < 4;
        bool v969;
        v969 = v968 == false;
        if (v969){
            assert("The last element of the projection dimensions needs to be greater than the index remainder." && v968);
        } else {
        }
        assert("Tensor range check" && 0 <= v967 && v967 < 4);
        assert("Tensor range check" && 0 <= v966 && v966 < 8);
        int v971;
        v971 = 4 * v966;
        int v972;
        v972 = 32 * v967;
        int v973;
        v973 = v972 + v971;
        assert("Tensor range check" && 0 <= v967 && v967 < 4);
        assert("Tensor range check" && 0 <= v966 && v966 < 8);
        float v974[4];
        float v975[4];
        float v976[4];
        int4* v977;
        v977 = reinterpret_cast<int4*>(v4 + v973);
        int4* v978;
        v978 = reinterpret_cast<int4*>(v974 + 0);
        assert("Pointer alignment check" && (unsigned long long)(v977) % 4 == 0 && (unsigned long long)(v978) % 4 == 0);
        *v978 = *v977;
        int4* v979;
        v979 = reinterpret_cast<int4*>(v5 + v973);
        int4* v980;
        v980 = reinterpret_cast<int4*>(v975 + 0);
        assert("Pointer alignment check" && (unsigned long long)(v979) % 4 == 0 && (unsigned long long)(v980) % 4 == 0);
        *v980 = *v979;
        // Pushing the loop unrolling to: 0
        int v981;
        v981 = 0;
        #pragma unroll
        while (while_method_9(v981)){
            assert("Tensor range check" && 0 <= v981 && v981 < 4);
            float v983;
            v983 = v974[v981];
            float v984;
            v984 = v975[v981];
            bool v985;
            v985 = v984 == 0.0f;
            bool v986;
            v986 = v985 != true;
            float v988;
            if (v986){
                float v987;
                v987 = v983 / v984;
                v988 = v987;
            } else {
                v988 = 0.0f;
            }
            assert("Tensor range check" && 0 <= v981 && v981 < 4);
            v976[v981] = v988;
            v981 += 1 ;
        }
        // Poping the loop unrolling to: 0
        int4* v989;
        v989 = reinterpret_cast<int4*>(v976 + 0);
        int4* v990;
        v990 = reinterpret_cast<int4*>(v6 + v973);
        assert("Pointer alignment check" && (unsigned long long)(v989) % 4 == 0 && (unsigned long long)(v990) % 4 == 0);
        *v990 = *v989;
        v961 += 6144 ;
    }
    v956.sync() ;
    return ;
}
extern "C" __global__ void entry2(unsigned char * v0, unsigned long long v1, unsigned char * v2, unsigned long long v3, float * v4, float * v5, float * v6) {
    auto v7 = cooperative_groups::this_grid();
    unsigned long long v8;
    v8 = clock64();
    int v9;
    v9 = threadIdx.x;
    int v10;
    v10 = blockIdx.x;
    int v11;
    v11 = v10 * 256;
    int v12;
    v12 = v9 + v11;
    unsigned long long v13;
    v13 = (unsigned long long)v12;
    curandStatePhilox4_32_10_t v14;
    curand_init(v8,v13,0ull,&v14);
    static_array<Union2,2> v15;
    Union2 v17;
    v17 = Union2{Union2_2{}};
    v15[0] = v17;
    Union2 v19;
    v19 = Union2{Union2_2{}};
    v15[1] = v19;
    static_array_list<Union7,32> v21;
    v21 = static_array_list<Union7,32>{};
    static_array<float,2> v23;
    v23[0] = 0.0f;
    v23[1] = 0.0f;
    cooperative_groups::grid_group & v25 = v7;
    curandStatePhilox4_32_10_t & v26 = v14;
    StackMut1 v27{63u, v25, v21, v15, v23, v26};
    bool v28;
    v28 = 2981904ull == v3;
    bool v29;
    v29 = v28 == false;
    if (v29){
        assert("The params needs to have matching offsets." && v28);
    } else {
    }
    bool v31;
    v31 = 25264128ull == v1;
    bool v32;
    v32 = v31 == false;
    if (v32){
        assert("The outputs needs to have matching offsets." && v31);
    } else {
    }
    int v34;
    v34 = 0;
    while (while_method_8(v34)){
        int v36;
        v36 = 0;
        while (while_method_5(v36)){
            Union4 v38;
            v38 = Union4{Union4_1{}};
            method_48(v0, v2, v27, v38);
            static_array<float,2> & v39 = v27.v4;
            unsigned int * v40;
            v40 = reinterpret_cast<unsigned int *>(&v0[6291456ull]);
            int * v42;
            v42 = reinterpret_cast<int *>(&v2[262144ull]);
            float * v44;
            v44 = reinterpret_cast<float *>(&v2[262160ull]);
            float * v46;
            v46 = reinterpret_cast<float *>(&v2[524304ull]);
            float * v48;
            v48 = reinterpret_cast<float *>(&v2[786448ull]);
            float * v50;
            v50 = reinterpret_cast<float *>(&v2[1048592ull]);
            float * v52;
            v52 = reinterpret_cast<float *>(&v2[1310736ull]);
            float * v54;
            v54 = reinterpret_cast<float *>(&v2[1572880ull]);
            float * v56;
            v56 = reinterpret_cast<float *>(&v2[1835024ull]);
            int * v58;
            v58 = reinterpret_cast<int *>(&v0[6389760ull]);
            float * v60;
            v60 = reinterpret_cast<float *>(&v0[7962624ull]);
            int * v62;
            v62 = reinterpret_cast<int *>(&v0[9535488ull]);
            int * v64;
            v64 = reinterpret_cast<int *>(&v0[11108352ull]);
            double * v66;
            v66 = reinterpret_cast<double *>(&v0[12681216ull]);
            double * v68;
            v68 = reinterpret_cast<double *>(&v0[18972672ull]);
            double * v70;
            v70 = reinterpret_cast<double *>(&v2[2097168ull]);
            double * v72;
            v72 = reinterpret_cast<double *>(&v2[2490384ull]);
            int * v74;
            v74 = reinterpret_cast<int *>(&v2[2883600ull]);
            int v76;
            v76 = 0;
            while (while_method_9(v76)){
                int v78;
                v78 = threadIdx.x;
                int v79;
                v79 = blockIdx.x;
                int v80;
                v80 = v79 * 256;
                int v81;
                v81 = v78 + v80;
                float v82[2];
                int v83;
                v83 = 0;
                while (while_method_0(v83)){
                    bool v85;
                    v85 = 0 <= v83;
                    bool v87;
                    if (v85){
                        bool v86;
                        v86 = v83 < 2;
                        v87 = v86;
                    } else {
                        v87 = false;
                    }
                    bool v88;
                    v88 = v87 == false;
                    if (v88){
                        assert("Index must be in range." && v87);
                    } else {
                    }
                    float v90;
                    v90 = v39[v83];
                    v82[v83] = v90;
                    v83 += 1 ;
                }
                assert("Tensor range check" && 0 <= v76 && v76 < 4);
                assert("Tensor range check" && 0 <= v81 && v81 < 6144);
                int v92;
                v92 = 6144 * v76;
                int v93;
                v93 = v92 + v81;
                int v94;
                v94 = v74[v93];
                int v95;
                v95 = v94;
                while (while_method_11(v95)){
                    v95 -= 1 ;
                    assert("Tensor range check" && 0 <= v76 && v76 < 4);
                    assert("Tensor range check" && 0 <= v95 && v95 < 16);
                    assert("Tensor range check" && 0 <= v81 && v81 < 6144);
                    int v97;
                    v97 = 6144 * v95;
                    int v98;
                    v98 = v97 + v81;
                    int v99;
                    v99 = 98304 * v76;
                    int v100;
                    v100 = v99 + v98;
                    int v101;
                    v101 = v58[v100];
                    float v102;
                    v102 = v60[v100];
                    int v103;
                    v103 = v62[v100];
                    int v104;
                    v104 = v64[v100];
                    assert("Tensor range check" && 0 <= v103 && v103 < 2);
                    float v105;
                    v105 = v82[v103];
                    assert("Tensor range check" && 0 <= v76 && v76 < 4);
                    int v106;
                    v106 = 16384 * v76;
                    assert("Tensor range check" && 0 <= v104 && v104 < 4096);
                    int v107;
                    v107 = 4 * v104;
                    int v108;
                    v108 = v107 + v106;
                    float * v109;
                    v109 = v44+v108;
                    float * v111;
                    v111 = v46+v108;
                    float * v113;
                    v113 = v48+v108;
                    float * v115;
                    v115 = v50+v108;
                    float * v117;
                    v117 = v52+v108;
                    float * v119;
                    v119 = v54+v108;
                    float * v121;
                    v121 = v56+v108;
                    assert("Tensor range check" && 0 <= v76 && v76 < 4);
                    int v123;
                    v123 = 196608 * v76;
                    assert("Tensor range check" && 0 <= v95 && v95 < 16);
                    int v124;
                    v124 = 12288 * v95;
                    int v125;
                    v125 = v124 + v123;
                    assert("Tensor range check" && 0 <= v81 && v81 < 6144);
                    int v126;
                    v126 = 2 * v81;
                    int v127;
                    v127 = v126 + v125;
                    double v128[2];
                    int v129;
                    v129 = 0;
                    while (while_method_0(v129)){
                        assert("Tensor range check" && 0 <= v129 && v129 < 2);
                        int v131;
                        v131 = v129 + v127;
                        double v132;
                        v132 = v66[v131];
                        bool v133;
                        v133 = v103 == v129;
                        double v134;
                        if (v133){
                            v134 = 0.0;
                        } else {
                            v134 = v132;
                        }
                        assert("Tensor range check" && 0 <= v129 && v129 < 2);
                        v128[v129] = v134;
                        v129 += 1 ;
                    }
                    double v135;
                    v135 = 0.0;
                    int v136;
                    v136 = 0;
                    while (while_method_0(v136)){
                        assert("Tensor range check" && 0 <= v136 && v136 < 2);
                        double v138;
                        v138 = v128[v136];
                        double v139;
                        v139 = v135 + v138;
                        v135 = v139;
                        v136 += 1 ;
                    }
                    double v140;
                    v140 = 0.0;
                    int v141;
                    v141 = 0;
                    while (while_method_0(v141)){
                        assert("Tensor range check" && 0 <= v141 && v141 < 2);
                        int v143;
                        v143 = v141 + v127;
                        double v144;
                        v144 = v68[v143];
                        double v145;
                        v145 = v140 + v144;
                        v140 = v145;
                        v141 += 1 ;
                    }
                    double v146;
                    v146 = v135 - v140;
                    double v147;
                    v147 = exp(v146);
                    float v148;
                    v148 = (float)v147;
                    float v149;
                    v149 = v105 * v148;
                    assert("Tensor range check" && 0 <= v101 && v101 < 4);
                    float * v150;
                    v150 = v119+v101;
                    float * v152;
                    v152 = v121+v101;
                    float v154;
                    v154 = atomicAdd(v150,v149);
                    float v155;
                    v155 = atomicAdd(v152,v148);
                    float * v156;
                    v156 = v111+0;
                    float * v158;
                    v158 = v115+0;
                    float * v160;
                    v160 = v117+0;
                    int v162;
                    v162 = sizeof(float *);
                    unsigned long long v163;
                    v163 = (unsigned long long)v162;
                    unsigned long long v164;
                    v164 = 256ull * v163;
                    unsigned long long v165;
                    v165 = 4096ull + v164;
                    unsigned long long v166;
                    v166 = v165 + 16ull;
                    unsigned long long v167;
                    v167 = v166 - 1ull;
                    unsigned long long v168;
                    v168 = v167 % 16ull;
                    unsigned long long v169;
                    v169 = v167 - v168;
                    unsigned long long v170;
                    v170 = v169 + v164;
                    unsigned long long v171;
                    v171 = v170 + 16ull;
                    unsigned long long v172;
                    v172 = v171 - 1ull;
                    unsigned long long v173;
                    v173 = v172 % 16ull;
                    unsigned long long v174;
                    v174 = v172 - v173;
                    unsigned long long v175;
                    v175 = v174 + v164;
                    unsigned long long v176;
                    v176 = v175 + 16ull;
                    unsigned long long v177;
                    v177 = v176 - 1ull;
                    unsigned long long v178;
                    v178 = v177 % 16ull;
                    unsigned long long v179;
                    v179 = v177 - v178;
                    unsigned long long v180;
                    v180 = v179 + v164;
                    unsigned long long v181;
                    v181 = v180 + 16ull;
                    unsigned long long v182;
                    v182 = v181 - 1ull;
                    unsigned long long v183;
                    v183 = v182 % 16ull;
                    unsigned long long v184;
                    v184 = v182 - v183;
                    unsigned long long v185;
                    v185 = v184 + 1024ull;
                    bool v186;
                    v186 = v185 <= 98304ull;
                    bool v187;
                    v187 = v186 == false;
                    if (v187){
                        assert("The dynamic shared memory is insufficient to allocate the tensor." && v186);
                    } else {
                    }
                    extern __shared__ unsigned char v189[];
                    bool v190;
                    v190 = v185 <= v185;
                    bool v191;
                    v191 = v190 == false;
                    if (v191){
                        assert("The length of the partition has to be less than or equal to the length of the base array." && v190);
                    } else {
                    }
                    float * v193;
                    v193 = reinterpret_cast<float *>(&v189[0ull]);
                    int * v195;
                    v195 = reinterpret_cast<int *>(&v189[1024ull]);
                    float * v197;
                    v197 = reinterpret_cast<float *>(&v189[2048ull]);
                    float * v199;
                    v199 = reinterpret_cast<float *>(&v189[3072ull]);
                    float * * v201;
                    v201 = reinterpret_cast<float * *>(&v189[4096ull]);
                    float * * v203;
                    v203 = reinterpret_cast<float * *>(&v189[v169]);
                    float * * v205;
                    v205 = reinterpret_cast<float * *>(&v189[v174]);
                    float * * v207;
                    v207 = reinterpret_cast<float * *>(&v189[v179]);
                    float * v209;
                    v209 = reinterpret_cast<float *>(&v189[v184]);
                    int v211;
                    v211 = threadIdx.x;
                    assert("Tensor range check" && 0 <= v211 && v211 < 256);
                    v193[v211] = v102;
                    v195[v211] = v101;
                    v197[v211] = v105;
                    v199[v211] = v148;
                    v201[v211] = v113;
                    v203[v211] = v156;
                    v205[v211] = v158;
                    v207[v211] = v160;
                    __syncthreads();
                    bool v212;
                    v212 = 0 <= v211;
                    bool v213;
                    v213 = v212 == false;
                    if (v213){
                        assert("The index needs to be zero or positive." && v212);
                    } else {
                    }
                    int v215;
                    v215 = v211 % 1;
                    bool v216;
                    v216 = v211 < 256;
                    bool v217;
                    v217 = v216 == false;
                    if (v217){
                        assert("The last element of the projection dimensions needs to be greater than the index remainder." && v216);
                    } else {
                    }
                    assert("Tensor range check" && 0 <= v211 && v211 < 256);
                    int v219;
                    v219 = 0;
                    while (while_method_4(v219)){
                        bool v221;
                        v221 = v212 && v216;
                        bool v222;
                        v222 = v221 == false;
                        if (v222){
                            assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v221);
                        } else {
                        }
                        bool v224;
                        v224 = 0 <= v219;
                        bool v226;
                        if (v224){
                            bool v225;
                            v225 = v219 < 1;
                            v226 = v225;
                        } else {
                            v226 = false;
                        }
                        bool v227;
                        v227 = v226 == false;
                        if (v227){
                            assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v226);
                        } else {
                        }
                        int v229;
                        v229 = v219 * 256;
                        int v230;
                        v230 = v229 + v211;
                        assert("Tensor range check" && 0 <= v219 && v219 < 1);
                        int v231;
                        v231 = 256 * v219;
                        int v232;
                        v232 = v231 + v211;
                        float v233;
                        v233 = v193[v232];
                        int v234;
                        v234 = v195[v232];
                        float v235;
                        v235 = v197[v232];
                        float v236;
                        v236 = v199[v232];
                        float * v237;
                        v237 = v201[v232];
                        float * v238;
                        v238 = v203[v232];
                        float * v239;
                        v239 = v205[v232];
                        float * v240;
                        v240 = v207[v232];
                        int v241;
                        v241 = blockIdx.x;
                        int v242;
                        v242 = v241 * 256;
                        int v243;
                        v243 = v242 + v230;
                        assert("Tensor range check" && 0 <= v215 && v215 < 1);
                        int v244;
                        v244 = 4 * v215;
                        float v245[4];
                        float v246[4];
                        float v247[4];
                        int v248[4];
                        int v249;
                        v249 = 0;
                        while (while_method_4(v249)){
                            assert("Tensor range check" && 0 <= v249 && v249 < 1);
                            int v251;
                            v251 = 4 * v249;
                            assert("Tensor range check" && 0 <= v249 && v249 < 1);
                            int v252;
                            v252 = v251 + v244;
                            int4* v253;
                            v253 = reinterpret_cast<int4*>(v238 + v252);
                            int4* v254;
                            v254 = reinterpret_cast<int4*>(v245 + v251);
                            assert("Pointer alignment check" && (unsigned long long)(v253) % 4 == 0 && (unsigned long long)(v254) % 4 == 0);
                            *v254 = *v253;
                            int4* v255;
                            v255 = reinterpret_cast<int4*>(v239 + v252);
                            int4* v256;
                            v256 = reinterpret_cast<int4*>(v246 + v251);
                            assert("Pointer alignment check" && (unsigned long long)(v255) % 4 == 0 && (unsigned long long)(v256) % 4 == 0);
                            *v256 = *v255;
                            int4* v257;
                            v257 = reinterpret_cast<int4*>(v240 + v252);
                            int4* v258;
                            v258 = reinterpret_cast<int4*>(v247 + v251);
                            assert("Pointer alignment check" && (unsigned long long)(v257) % 4 == 0 && (unsigned long long)(v258) % 4 == 0);
                            *v258 = *v257;
                            v249 += 1 ;
                        }
                        int v259;
                        v259 = 0;
                        while (while_method_4(v259)){
                            int v261;
                            v261 = 0;
                            while (while_method_9(v261)){
                                bool v263;
                                v263 = 0 <= v261;
                                bool v265;
                                if (v263){
                                    bool v264;
                                    v264 = v261 < 4;
                                    v265 = v264;
                                } else {
                                    v265 = false;
                                }
                                bool v266;
                                v266 = v265 == false;
                                if (v266){
                                    assert("The indices should be inside the range of the dimension." && v265);
                                } else {
                                }
                                bool v268;
                                v268 = 0 <= v215;
                                bool v270;
                                if (v268){
                                    bool v269;
                                    v269 = v215 < 1;
                                    v270 = v269;
                                } else {
                                    v270 = false;
                                }
                                bool v271;
                                v271 = v270 == false;
                                if (v271){
                                    assert("The indices should be inside the range of the dimension." && v270);
                                } else {
                                }
                                int v273;
                                v273 = v215 * 4;
                                int v274;
                                v274 = v261 + v273;
                                bool v275;
                                v275 = 0 <= v259;
                                bool v277;
                                if (v275){
                                    bool v276;
                                    v276 = v259 < 1;
                                    v277 = v276;
                                } else {
                                    v277 = false;
                                }
                                bool v278;
                                v278 = v277 == false;
                                if (v278){
                                    assert("The indices should be inside the range of the dimension." && v277);
                                } else {
                                }
                                int v280;
                                v280 = v259 * 4;
                                int v281;
                                v281 = v274 + v280;
                                assert("Tensor range check" && 0 <= v259 && v259 < 1);
                                assert("Tensor range check" && 0 <= v261 && v261 < 4);
                                int v282;
                                v282 = 4 * v259;
                                int v283;
                                v283 = v282 + v261;
                                v248[v283] = v281;
                                v261 += 1 ;
                            }
                            v259 += 1 ;
                        }
                        float v284[4];
                        int v285;
                        v285 = 0;
                        while (while_method_4(v285)){
                            int v287;
                            v287 = 0;
                            while (while_method_9(v287)){
                                assert("Tensor range check" && 0 <= v285 && v285 < 1);
                                assert("Tensor range check" && 0 <= v287 && v287 < 4);
                                int v289;
                                v289 = 4 * v285;
                                int v290;
                                v290 = v289 + v287;
                                float v291;
                                v291 = v246[v290];
                                float v292;
                                v292 = v247[v290];
                                bool v293;
                                v293 = v292 == 0.0f;
                                bool v294;
                                v294 = v293 != true;
                                float v296;
                                if (v294){
                                    float v295;
                                    v295 = v291 / v292;
                                    v296 = v295;
                                } else {
                                    v296 = 0.0f;
                                }
                                assert("Tensor range check" && 0 <= v285 && v285 < 1);
                                assert("Tensor range check" && 0 <= v287 && v287 < 4);
                                v284[v290] = v296;
                                v287 += 1 ;
                            }
                            v285 += 1 ;
                        }
                        bool v297[4];
                        int v298;
                        v298 = 0;
                        while (while_method_4(v298)){
                            int v300;
                            v300 = 0;
                            while (while_method_9(v300)){
                                assert("Tensor range check" && 0 <= v298 && v298 < 1);
                                assert("Tensor range check" && 0 <= v300 && v300 < 4);
                                int v302;
                                v302 = 4 * v298;
                                int v303;
                                v303 = v302 + v300;
                                float v304;
                                v304 = v245[v303];
                                int v305;
                                v305 = v248[v303];
                                bool v306;
                                v306 = v305 < 3;
                                assert("Tensor range check" && 0 <= v298 && v298 < 1);
                                assert("Tensor range check" && 0 <= v300 && v300 < 4);
                                v297[v303] = v306;
                                v300 += 1 ;
                            }
                            v298 += 1 ;
                        }
                        float v307[4];
                        int v308;
                        v308 = 0;
                        while (while_method_4(v308)){
                            int v310;
                            v310 = 0;
                            while (while_method_9(v310)){
                                assert("Tensor range check" && 0 <= v308 && v308 < 1);
                                assert("Tensor range check" && 0 <= v310 && v310 < 4);
                                int v312;
                                v312 = 4 * v308;
                                int v313;
                                v313 = v312 + v310;
                                float v314;
                                v314 = v245[v313];
                                bool v315;
                                v315 = v297[v313];
                                float v318;
                                if (v315){
                                    bool v316;
                                    v316 = 0.0f >= v314;
                                    if (v316){
                                        v318 = 0.0f;
                                    } else {
                                        v318 = v314;
                                    }
                                } else {
                                    v318 = 0.0f;
                                }
                                assert("Tensor range check" && 0 <= v308 && v308 < 1);
                                assert("Tensor range check" && 0 <= v310 && v310 < 4);
                                v307[v313] = v318;
                                v310 += 1 ;
                            }
                            v308 += 1 ;
                        }
                        float v319;
                        v319 = 0.0f;
                        int v320;
                        v320 = 0;
                        while (while_method_4(v320)){
                            int v322;
                            v322 = 0;
                            while (while_method_9(v322)){
                                assert("Tensor range check" && 0 <= v320 && v320 < 1);
                                assert("Tensor range check" && 0 <= v322 && v322 < 4);
                                int v324;
                                v324 = 4 * v320;
                                int v325;
                                v325 = v324 + v322;
                                float v326;
                                v326 = v307[v325];
                                float v327;
                                v327 = v319 + v326;
                                v319 = v327;
                                v322 += 1 ;
                            }
                            v320 += 1 ;
                        }
                        auto v328 = cooperative_groups::coalesced_threads();
                        int v329;
                        v329 = threadIdx.x;
                        auto v330 = cooperative_groups::labeled_partition(v328,v329);
                        Closure1 v331{};
                        float v332;
                        v332 = cooperative_groups::reduce(v330, v319, v331);
                        int v333[4];
                        int v334;
                        v334 = 0;
                        while (while_method_4(v334)){
                            int v336;
                            v336 = 0;
                            while (while_method_9(v336)){
                                assert("Tensor range check" && 0 <= v334 && v334 < 1);
                                assert("Tensor range check" && 0 <= v336 && v336 < 4);
                                int v338;
                                v338 = 4 * v334;
                                int v339;
                                v339 = v338 + v336;
                                bool v340;
                                v340 = v297[v339];
                                int v341;
                                if (v340){
                                    v341 = 1;
                                } else {
                                    v341 = 0;
                                }
                                assert("Tensor range check" && 0 <= v334 && v334 < 1);
                                assert("Tensor range check" && 0 <= v336 && v336 < 4);
                                v333[v339] = v341;
                                v336 += 1 ;
                            }
                            v334 += 1 ;
                        }
                        int v342;
                        v342 = 0;
                        int v343;
                        v343 = 0;
                        while (while_method_4(v343)){
                            int v345;
                            v345 = 0;
                            while (while_method_9(v345)){
                                assert("Tensor range check" && 0 <= v343 && v343 < 1);
                                assert("Tensor range check" && 0 <= v345 && v345 < 4);
                                int v347;
                                v347 = 4 * v343;
                                int v348;
                                v348 = v347 + v345;
                                int v349;
                                v349 = v333[v348];
                                int v350;
                                v350 = v342 + v349;
                                v342 = v350;
                                v345 += 1 ;
                            }
                            v343 += 1 ;
                        }
                        auto v351 = cooperative_groups::coalesced_threads();
                        int v352;
                        v352 = threadIdx.x;
                        auto v353 = cooperative_groups::labeled_partition(v351,v352);
                        Closure2 v354{};
                        int v355;
                        v355 = cooperative_groups::reduce(v353, v342, v354);
                        float v356;
                        v356 = (float)v355;
                        float v357;
                        v357 = 1.0f / v356;
                        float v358[4];
                        int v359;
                        v359 = 0;
                        while (while_method_4(v359)){
                            int v361;
                            v361 = 0;
                            while (while_method_9(v361)){
                                assert("Tensor range check" && 0 <= v359 && v359 < 1);
                                assert("Tensor range check" && 0 <= v361 && v361 < 4);
                                int v363;
                                v363 = 4 * v359;
                                int v364;
                                v364 = v363 + v361;
                                float v365;
                                v365 = v307[v364];
                                bool v366;
                                v366 = v297[v364];
                                bool v367;
                                v367 = v366 == false;
                                float v372;
                                if (v367){
                                    v372 = 0.0f;
                                } else {
                                    bool v368;
                                    v368 = v332 == 0.0f;
                                    bool v369;
                                    v369 = v368 != true;
                                    if (v369){
                                        float v370;
                                        v370 = v365 / v332;
                                        v372 = v370;
                                    } else {
                                        v372 = v357;
                                    }
                                }
                                assert("Tensor range check" && 0 <= v359 && v359 < 1);
                                assert("Tensor range check" && 0 <= v361 && v361 < 4);
                                v358[v364] = v372;
                                v361 += 1 ;
                            }
                            v359 += 1 ;
                        }
                        float v373[4];
                        int v374;
                        v374 = 0;
                        while (while_method_4(v374)){
                            int v376;
                            v376 = 0;
                            while (while_method_9(v376)){
                                assert("Tensor range check" && 0 <= v374 && v374 < 1);
                                assert("Tensor range check" && 0 <= v376 && v376 < 4);
                                int v378;
                                v378 = 4 * v374;
                                int v379;
                                v379 = v378 + v376;
                                float v380;
                                v380 = v284[v379];
                                int v381;
                                v381 = v248[v379];
                                bool v382;
                                v382 = v234 == v381;
                                float v385;
                                if (v382){
                                    float v383;
                                    v383 = v235 - v380;
                                    float v384;
                                    v384 = v383 / v233;
                                    v385 = v384;
                                } else {
                                    v385 = 0.0f;
                                }
                                float v386;
                                v386 = v385 + v380;
                                assert("Tensor range check" && 0 <= v374 && v374 < 1);
                                assert("Tensor range check" && 0 <= v376 && v376 < 4);
                                v373[v379] = v386;
                                v376 += 1 ;
                            }
                            v374 += 1 ;
                        }
                        float v387[4];
                        int v388;
                        v388 = 0;
                        while (while_method_4(v388)){
                            int v390;
                            v390 = 0;
                            while (while_method_9(v390)){
                                assert("Tensor range check" && 0 <= v388 && v388 < 1);
                                assert("Tensor range check" && 0 <= v390 && v390 < 4);
                                int v392;
                                v392 = 4 * v388;
                                int v393;
                                v393 = v392 + v390;
                                float v394;
                                v394 = v358[v393];
                                float v395;
                                v395 = v373[v393];
                                float v396;
                                v396 = v394 * v395;
                                assert("Tensor range check" && 0 <= v388 && v388 < 1);
                                assert("Tensor range check" && 0 <= v390 && v390 < 4);
                                v387[v393] = v396;
                                v390 += 1 ;
                            }
                            v388 += 1 ;
                        }
                        float v397;
                        v397 = 0.0f;
                        int v398;
                        v398 = 0;
                        while (while_method_4(v398)){
                            int v400;
                            v400 = 0;
                            while (while_method_9(v400)){
                                assert("Tensor range check" && 0 <= v398 && v398 < 1);
                                assert("Tensor range check" && 0 <= v400 && v400 < 4);
                                int v402;
                                v402 = 4 * v398;
                                int v403;
                                v403 = v402 + v400;
                                float v404;
                                v404 = v387[v403];
                                float v405;
                                v405 = v397 + v404;
                                v397 = v405;
                                v400 += 1 ;
                            }
                            v398 += 1 ;
                        }
                        auto v406 = cooperative_groups::coalesced_threads();
                        int v407;
                        v407 = threadIdx.x;
                        auto v408 = cooperative_groups::labeled_partition(v406,v407);
                        float v409;
                        v409 = cooperative_groups::reduce(v408, v397, v331);
                        int v410;
                        v410 = 0;
                        while (while_method_4(v410)){
                            int v412;
                            v412 = 0;
                            while (while_method_9(v412)){
                                assert("Tensor range check" && 0 <= v410 && v410 < 1);
                                assert("Tensor range check" && 0 <= v412 && v412 < 4);
                                int v414;
                                v414 = 4 * v410;
                                int v415;
                                v415 = v414 + v412;
                                float v416;
                                v416 = v373[v415];
                                int v417;
                                v417 = v248[v415];
                                float v418;
                                v418 = v416 - v409;
                                float v419;
                                v419 = v236 * v418;
                                assert("Tensor range check" && 0 <= v417 && v417 < 4);
                                float * v420;
                                v420 = v237+v417;
                                float v422;
                                v422 = atomicAdd(v420,v419);
                                v412 += 1 ;
                            }
                            v410 += 1 ;
                        }
                        int v423;
                        v423 = 0;
                        while (while_method_4(v423)){
                            assert("Tensor range check" && 0 <= v423 && v423 < 1);
                            assert("Tensor range check" && 0 <= v423 && v423 < 1);
                            v423 += 1 ;
                        }
                        assert("Tensor range check" && 0 <= v230 && v230 < 256);
                        v209[v230] = v409;
                        v219 += 1 ;
                    }
                    __syncthreads();
                    assert("Tensor range check" && 0 <= v211 && v211 < 256);
                    float v425;
                    v425 = v209[v211];
                    __syncthreads();
                    assert("Tensor range check" && 0 <= v103 && v103 < 2);
                    v82[v103] = v425;
                }
                int v426;
                v426 = threadIdx.x;
                int v427;
                v427 = blockIdx.x;
                int v428;
                v428 = v427 * 256;
                int v429;
                v429 = v426 + v428;
                assert("Tensor range check" && 0 <= v76 && v76 < 4);
                int v430;
                v430 = 12288 * v76;
                assert("Tensor range check" && 0 <= v429 && v429 < 6144);
                int v431;
                v431 = 2 * v429;
                int v432;
                v432 = v431 + v430;
                double * v433;
                v433 = v70+v432;
                double * v435;
                v435 = v72+v432;
                double * v437;
                v437 = v433+0;
                double * v439;
                v439 = v435+0;
                double * v441;
                v441 = v433+0;
                double * v443;
                v443 = v435+0;
                int v445;
                v445 = sizeof(double *);
                unsigned long long v446;
                v446 = (unsigned long long)v445;
                unsigned long long v447;
                v447 = 256ull * v446;
                unsigned long long v448;
                v448 = v447 + 16ull;
                unsigned long long v449;
                v449 = v448 - 1ull;
                unsigned long long v450;
                v450 = v449 % 16ull;
                unsigned long long v451;
                v451 = v449 - v450;
                unsigned long long v452;
                v452 = v451 + v447;
                unsigned long long v453;
                v453 = v452 + 16ull;
                unsigned long long v454;
                v454 = v453 - 1ull;
                unsigned long long v455;
                v455 = v454 % 16ull;
                unsigned long long v456;
                v456 = v454 - v455;
                unsigned long long v457;
                v457 = v456 + v447;
                unsigned long long v458;
                v458 = v457 + 16ull;
                unsigned long long v459;
                v459 = v458 - 1ull;
                unsigned long long v460;
                v460 = v459 % 16ull;
                unsigned long long v461;
                v461 = v459 - v460;
                unsigned long long v462;
                v462 = v461 + v447;
                bool v463;
                v463 = v462 <= 98304ull;
                bool v464;
                v464 = v463 == false;
                if (v464){
                    assert("The dynamic shared memory is insufficient to allocate the tensor." && v463);
                } else {
                }
                extern __shared__ unsigned char v466[];
                bool v467;
                v467 = v462 <= v462;
                bool v468;
                v468 = v467 == false;
                if (v468){
                    assert("The length of the partition has to be less than or equal to the length of the base array." && v467);
                } else {
                }
                double * * v470;
                v470 = reinterpret_cast<double * *>(&v466[0ull]);
                double * * v472;
                v472 = reinterpret_cast<double * *>(&v466[v451]);
                double * * v474;
                v474 = reinterpret_cast<double * *>(&v466[v456]);
                double * * v476;
                v476 = reinterpret_cast<double * *>(&v466[v461]);
                int v478;
                v478 = threadIdx.x;
                assert("Tensor range check" && 0 <= v478 && v478 < 256);
                v470[v478] = v437;
                v472[v478] = v439;
                v474[v478] = v441;
                v476[v478] = v443;
                __syncthreads();
                bool v479;
                v479 = 0 <= v478;
                bool v480;
                v480 = v479 == false;
                if (v480){
                    assert("The index needs to be zero or positive." && v479);
                } else {
                }
                int v482;
                v482 = v478 % 1;
                bool v483;
                v483 = v478 < 256;
                bool v484;
                v484 = v483 == false;
                if (v484){
                    assert("The last element of the projection dimensions needs to be greater than the index remainder." && v483);
                } else {
                }
                assert("Tensor range check" && 0 <= v478 && v478 < 256);
                int v486;
                v486 = 0;
                while (while_method_4(v486)){
                    bool v488;
                    v488 = v479 && v483;
                    bool v489;
                    v489 = v488 == false;
                    if (v489){
                        assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v488);
                    } else {
                    }
                    bool v491;
                    v491 = 0 <= v486;
                    bool v493;
                    if (v491){
                        bool v492;
                        v492 = v486 < 1;
                        v493 = v492;
                    } else {
                        v493 = false;
                    }
                    bool v494;
                    v494 = v493 == false;
                    if (v494){
                        assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v493);
                    } else {
                    }
                    int v496;
                    v496 = v486 * 256;
                    int v497;
                    v497 = v496 + v478;
                    assert("Tensor range check" && 0 <= v486 && v486 < 1);
                    int v498;
                    v498 = 256 * v486;
                    int v499;
                    v499 = v498 + v478;
                    double * v500;
                    v500 = v470[v499];
                    double * v501;
                    v501 = v472[v499];
                    double * v502;
                    v502 = v474[v499];
                    double * v503;
                    v503 = v476[v499];
                    int v504;
                    v504 = blockIdx.x;
                    int v505;
                    v505 = v504 * 256;
                    int v506;
                    v506 = v505 + v497;
                    assert("Tensor range check" && 0 <= v482 && v482 < 1);
                    int v507;
                    v507 = 2 * v482;
                    double v508[2];
                    double v509[2];
                    int v510[2];
                    int v511;
                    v511 = 0;
                    while (while_method_4(v511)){
                        assert("Tensor range check" && 0 <= v511 && v511 < 1);
                        int v513;
                        v513 = 2 * v511;
                        assert("Tensor range check" && 0 <= v511 && v511 < 1);
                        int v514;
                        v514 = v513 + v507;
                        int4* v515;
                        v515 = reinterpret_cast<int4*>(v500 + v514);
                        int4* v516;
                        v516 = reinterpret_cast<int4*>(v508 + v513);
                        assert("Pointer alignment check" && (unsigned long long)(v515) % 2 == 0 && (unsigned long long)(v516) % 2 == 0);
                        *v516 = *v515;
                        int4* v517;
                        v517 = reinterpret_cast<int4*>(v501 + v514);
                        int4* v518;
                        v518 = reinterpret_cast<int4*>(v509 + v513);
                        assert("Pointer alignment check" && (unsigned long long)(v517) % 2 == 0 && (unsigned long long)(v518) % 2 == 0);
                        *v518 = *v517;
                        v511 += 1 ;
                    }
                    int v519;
                    v519 = 0;
                    while (while_method_4(v519)){
                        int v521;
                        v521 = 0;
                        while (while_method_0(v521)){
                            bool v523;
                            v523 = 0 <= v521;
                            bool v525;
                            if (v523){
                                bool v524;
                                v524 = v521 < 2;
                                v525 = v524;
                            } else {
                                v525 = false;
                            }
                            bool v526;
                            v526 = v525 == false;
                            if (v526){
                                assert("The indices should be inside the range of the dimension." && v525);
                            } else {
                            }
                            bool v528;
                            v528 = 0 <= v482;
                            bool v530;
                            if (v528){
                                bool v529;
                                v529 = v482 < 1;
                                v530 = v529;
                            } else {
                                v530 = false;
                            }
                            bool v531;
                            v531 = v530 == false;
                            if (v531){
                                assert("The indices should be inside the range of the dimension." && v530);
                            } else {
                            }
                            int v533;
                            v533 = v482 * 2;
                            int v534;
                            v534 = v521 + v533;
                            bool v535;
                            v535 = 0 <= v519;
                            bool v537;
                            if (v535){
                                bool v536;
                                v536 = v519 < 1;
                                v537 = v536;
                            } else {
                                v537 = false;
                            }
                            bool v538;
                            v538 = v537 == false;
                            if (v538){
                                assert("The indices should be inside the range of the dimension." && v537);
                            } else {
                            }
                            int v540;
                            v540 = v519 * 2;
                            int v541;
                            v541 = v534 + v540;
                            assert("Tensor range check" && 0 <= v519 && v519 < 1);
                            assert("Tensor range check" && 0 <= v521 && v521 < 2);
                            int v542;
                            v542 = 2 * v519;
                            int v543;
                            v543 = v542 + v521;
                            v510[v543] = v541;
                            v521 += 1 ;
                        }
                        v519 += 1 ;
                    }
                    double v544[2];
                    double v545[2];
                    int v546;
                    v546 = 0;
                    while (while_method_4(v546)){
                        int v548;
                        v548 = 0;
                        while (while_method_0(v548)){
                            assert("Tensor range check" && 0 <= v546 && v546 < 1);
                            assert("Tensor range check" && 0 <= v548 && v548 < 2);
                            int v550;
                            v550 = 2 * v546;
                            int v551;
                            v551 = v550 + v548;
                            double v552;
                            v552 = v508[v551];
                            double v553;
                            v553 = v509[v551];
                            assert("Tensor range check" && 0 <= v546 && v546 < 1);
                            assert("Tensor range check" && 0 <= v548 && v548 < 2);
                            v544[v551] = 0.0;
                            v545[v551] = 0.0;
                            v548 += 1 ;
                        }
                        v546 += 1 ;
                    }
                    int v554;
                    v554 = 0;
                    while (while_method_4(v554)){
                        assert("Tensor range check" && 0 <= v554 && v554 < 1);
                        int v556;
                        v556 = 2 * v554;
                        int v557;
                        v557 = v556 + v507;
                        assert("Tensor range check" && 0 <= v554 && v554 < 1);
                        int4* v558;
                        v558 = reinterpret_cast<int4*>(v544 + v556);
                        int4* v559;
                        v559 = reinterpret_cast<int4*>(v502 + v557);
                        assert("Pointer alignment check" && (unsigned long long)(v558) % 2 == 0 && (unsigned long long)(v559) % 2 == 0);
                        *v559 = *v558;
                        int4* v560;
                        v560 = reinterpret_cast<int4*>(v545 + v556);
                        int4* v561;
                        v561 = reinterpret_cast<int4*>(v503 + v557);
                        assert("Pointer alignment check" && (unsigned long long)(v560) % 2 == 0 && (unsigned long long)(v561) % 2 == 0);
                        *v561 = *v560;
                        v554 += 1 ;
                    }
                    assert("Tensor range check" && 0 <= v497 && v497 < 256);
                    v486 += 1 ;
                }
                __syncthreads();
                assert("Tensor range check" && 0 <= v478 && v478 < 256);
                __syncthreads();
                assert("Tensor range check" && 0 <= v76 && v76 < 4);
                assert("Tensor range check" && 0 <= v429 && v429 < 6144);
                int v562;
                v562 = v92 + v429;
                v74[v562] = 0;
                v76 += 1 ;
            }
            Union4 v563;
            v563 = Union4{Union4_1{}};
            method_49(v0, v2, v27, v563);
            double * v564;
            v564 = reinterpret_cast<double *>(&v2[2097168ull]);
            double * v566;
            v566 = reinterpret_cast<double *>(&v2[2490384ull]);
            int * v568;
            v568 = reinterpret_cast<int *>(&v2[2883600ull]);
            int v570;
            v570 = threadIdx.x;
            int v571;
            v571 = blockIdx.x;
            int v572;
            v572 = v571 * 256;
            int v573;
            v573 = v570 + v572;
            assert("Tensor range check" && 0 <= v573 && v573 < 6144);
            int v574;
            v574 = 2 * v573;
            int v575; double v576;
            Tuple12 tmp73 = Tuple12{0, 1.0};
            v575 = tmp73.v0; v576 = tmp73.v1;
            while (while_method_0(v575)){
                assert("Tensor range check" && 0 <= v575 && v575 < 2);
                int v578;
                v578 = v575 + v574;
                int v579; double v580;
                Tuple12 tmp74 = Tuple12{0, 0.0};
                v579 = tmp74.v0; v580 = tmp74.v1;
                while (while_method_9(v579)){
                    assert("Tensor range check" && 0 <= v579 && v579 < 4);
                    int v582;
                    v582 = 12288 * v579;
                    int v583;
                    v583 = v582 + v578;
                    double v584;
                    v584 = v564[v583];
                    double v585;
                    v585 = v566[v583];
                    double v586;
                    v586 = v584 - v585;
                    double v587;
                    v587 = exp(v586);
                    double v588;
                    v588 = v580 + v587;
                    v580 = v588;
                    v579 += 1 ;
                }
                double v589;
                v589 = v576 * v580;
                v576 = v589;
                v575 += 1 ;
            }
            float v590;
            v590 = (float)v576;
            int v591;
            v591 = 0;
            while (while_method_0(v591)){
                static_array<float,2> & v593 = v27.v4;
                bool v594;
                v594 = 0 <= v591;
                bool v596;
                if (v594){
                    bool v595;
                    v595 = v591 < 2;
                    v596 = v595;
                } else {
                    v596 = false;
                }
                bool v597;
                v597 = v596 == false;
                if (v597){
                    assert("Index must be in range." && v596);
                } else {
                }
                float v599;
                v599 = v593[v591];
                float v601;
                v601 = v599 * v590;
                assert("Tensor range check" && 0 <= v591 && v591 < 2);
                assert("Tensor range check" && 0 <= v34 && v34 < 32);
                int v602;
                v602 = 32 * v591;
                int v603;
                v603 = v602 + v34;
                float * v604;
                v604 = v4+v603;
                float * v606;
                v606 = v5+v603;
                float v608;
                v608 = atomicAdd(v604,v601);
                float v609;
                v609 = atomicAdd(v606,v590);
                v591 += 1 ;
            }
            double * v610;
            v610 = reinterpret_cast<double *>(&v2[2097168ull]);
            double * v612;
            v612 = reinterpret_cast<double *>(&v2[2490384ull]);
            int * v614;
            v614 = reinterpret_cast<int *>(&v2[2883600ull]);
            int v616;
            v616 = 0;
            while (while_method_9(v616)){
                int v618;
                v618 = threadIdx.x;
                int v619;
                v619 = blockIdx.x;
                int v620;
                v620 = v619 * 256;
                int v621;
                v621 = v618 + v620;
                assert("Tensor range check" && 0 <= v616 && v616 < 4);
                int v622;
                v622 = 12288 * v616;
                assert("Tensor range check" && 0 <= v621 && v621 < 6144);
                int v623;
                v623 = 2 * v621;
                int v624;
                v624 = v623 + v622;
                double * v625;
                v625 = v610+v624;
                double * v627;
                v627 = v612+v624;
                double * v629;
                v629 = v625+0;
                double * v631;
                v631 = v627+0;
                double * v633;
                v633 = v625+0;
                double * v635;
                v635 = v627+0;
                int v637;
                v637 = sizeof(double *);
                unsigned long long v638;
                v638 = (unsigned long long)v637;
                unsigned long long v639;
                v639 = 256ull * v638;
                unsigned long long v640;
                v640 = v639 + 16ull;
                unsigned long long v641;
                v641 = v640 - 1ull;
                unsigned long long v642;
                v642 = v641 % 16ull;
                unsigned long long v643;
                v643 = v641 - v642;
                unsigned long long v644;
                v644 = v643 + v639;
                unsigned long long v645;
                v645 = v644 + 16ull;
                unsigned long long v646;
                v646 = v645 - 1ull;
                unsigned long long v647;
                v647 = v646 % 16ull;
                unsigned long long v648;
                v648 = v646 - v647;
                unsigned long long v649;
                v649 = v648 + v639;
                unsigned long long v650;
                v650 = v649 + 16ull;
                unsigned long long v651;
                v651 = v650 - 1ull;
                unsigned long long v652;
                v652 = v651 % 16ull;
                unsigned long long v653;
                v653 = v651 - v652;
                unsigned long long v654;
                v654 = v653 + v639;
                bool v655;
                v655 = v654 <= 98304ull;
                bool v656;
                v656 = v655 == false;
                if (v656){
                    assert("The dynamic shared memory is insufficient to allocate the tensor." && v655);
                } else {
                }
                extern __shared__ unsigned char v658[];
                bool v659;
                v659 = v654 <= v654;
                bool v660;
                v660 = v659 == false;
                if (v660){
                    assert("The length of the partition has to be less than or equal to the length of the base array." && v659);
                } else {
                }
                double * * v662;
                v662 = reinterpret_cast<double * *>(&v658[0ull]);
                double * * v664;
                v664 = reinterpret_cast<double * *>(&v658[v643]);
                double * * v666;
                v666 = reinterpret_cast<double * *>(&v658[v648]);
                double * * v668;
                v668 = reinterpret_cast<double * *>(&v658[v653]);
                int v670;
                v670 = threadIdx.x;
                assert("Tensor range check" && 0 <= v670 && v670 < 256);
                v662[v670] = v629;
                v664[v670] = v631;
                v666[v670] = v633;
                v668[v670] = v635;
                __syncthreads();
                bool v671;
                v671 = 0 <= v670;
                bool v672;
                v672 = v671 == false;
                if (v672){
                    assert("The index needs to be zero or positive." && v671);
                } else {
                }
                int v674;
                v674 = v670 % 1;
                bool v675;
                v675 = v670 < 256;
                bool v676;
                v676 = v675 == false;
                if (v676){
                    assert("The last element of the projection dimensions needs to be greater than the index remainder." && v675);
                } else {
                }
                assert("Tensor range check" && 0 <= v670 && v670 < 256);
                int v678;
                v678 = 0;
                while (while_method_4(v678)){
                    bool v680;
                    v680 = v671 && v675;
                    bool v681;
                    v681 = v680 == false;
                    if (v681){
                        assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v680);
                    } else {
                    }
                    bool v683;
                    v683 = 0 <= v678;
                    bool v685;
                    if (v683){
                        bool v684;
                        v684 = v678 < 1;
                        v685 = v684;
                    } else {
                        v685 = false;
                    }
                    bool v686;
                    v686 = v685 == false;
                    if (v686){
                        assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v685);
                    } else {
                    }
                    int v688;
                    v688 = v678 * 256;
                    int v689;
                    v689 = v688 + v670;
                    assert("Tensor range check" && 0 <= v678 && v678 < 1);
                    int v690;
                    v690 = 256 * v678;
                    int v691;
                    v691 = v690 + v670;
                    double * v692;
                    v692 = v662[v691];
                    double * v693;
                    v693 = v664[v691];
                    double * v694;
                    v694 = v666[v691];
                    double * v695;
                    v695 = v668[v691];
                    int v696;
                    v696 = blockIdx.x;
                    int v697;
                    v697 = v696 * 256;
                    int v698;
                    v698 = v697 + v689;
                    assert("Tensor range check" && 0 <= v674 && v674 < 1);
                    int v699;
                    v699 = 2 * v674;
                    double v700[2];
                    double v701[2];
                    int v702[2];
                    int v703;
                    v703 = 0;
                    while (while_method_4(v703)){
                        assert("Tensor range check" && 0 <= v703 && v703 < 1);
                        int v705;
                        v705 = 2 * v703;
                        assert("Tensor range check" && 0 <= v703 && v703 < 1);
                        int v706;
                        v706 = v705 + v699;
                        int4* v707;
                        v707 = reinterpret_cast<int4*>(v692 + v706);
                        int4* v708;
                        v708 = reinterpret_cast<int4*>(v700 + v705);
                        assert("Pointer alignment check" && (unsigned long long)(v707) % 2 == 0 && (unsigned long long)(v708) % 2 == 0);
                        *v708 = *v707;
                        int4* v709;
                        v709 = reinterpret_cast<int4*>(v693 + v706);
                        int4* v710;
                        v710 = reinterpret_cast<int4*>(v701 + v705);
                        assert("Pointer alignment check" && (unsigned long long)(v709) % 2 == 0 && (unsigned long long)(v710) % 2 == 0);
                        *v710 = *v709;
                        v703 += 1 ;
                    }
                    int v711;
                    v711 = 0;
                    while (while_method_4(v711)){
                        int v713;
                        v713 = 0;
                        while (while_method_0(v713)){
                            bool v715;
                            v715 = 0 <= v713;
                            bool v717;
                            if (v715){
                                bool v716;
                                v716 = v713 < 2;
                                v717 = v716;
                            } else {
                                v717 = false;
                            }
                            bool v718;
                            v718 = v717 == false;
                            if (v718){
                                assert("The indices should be inside the range of the dimension." && v717);
                            } else {
                            }
                            bool v720;
                            v720 = 0 <= v674;
                            bool v722;
                            if (v720){
                                bool v721;
                                v721 = v674 < 1;
                                v722 = v721;
                            } else {
                                v722 = false;
                            }
                            bool v723;
                            v723 = v722 == false;
                            if (v723){
                                assert("The indices should be inside the range of the dimension." && v722);
                            } else {
                            }
                            int v725;
                            v725 = v674 * 2;
                            int v726;
                            v726 = v713 + v725;
                            bool v727;
                            v727 = 0 <= v711;
                            bool v729;
                            if (v727){
                                bool v728;
                                v728 = v711 < 1;
                                v729 = v728;
                            } else {
                                v729 = false;
                            }
                            bool v730;
                            v730 = v729 == false;
                            if (v730){
                                assert("The indices should be inside the range of the dimension." && v729);
                            } else {
                            }
                            int v732;
                            v732 = v711 * 2;
                            int v733;
                            v733 = v726 + v732;
                            assert("Tensor range check" && 0 <= v711 && v711 < 1);
                            assert("Tensor range check" && 0 <= v713 && v713 < 2);
                            int v734;
                            v734 = 2 * v711;
                            int v735;
                            v735 = v734 + v713;
                            v702[v735] = v733;
                            v713 += 1 ;
                        }
                        v711 += 1 ;
                    }
                    double v736[2];
                    double v737[2];
                    int v738;
                    v738 = 0;
                    while (while_method_4(v738)){
                        int v740;
                        v740 = 0;
                        while (while_method_0(v740)){
                            assert("Tensor range check" && 0 <= v738 && v738 < 1);
                            assert("Tensor range check" && 0 <= v740 && v740 < 2);
                            int v742;
                            v742 = 2 * v738;
                            int v743;
                            v743 = v742 + v740;
                            double v744;
                            v744 = v700[v743];
                            double v745;
                            v745 = v701[v743];
                            assert("Tensor range check" && 0 <= v738 && v738 < 1);
                            assert("Tensor range check" && 0 <= v740 && v740 < 2);
                            v736[v743] = 0.0;
                            v737[v743] = 0.0;
                            v740 += 1 ;
                        }
                        v738 += 1 ;
                    }
                    int v746;
                    v746 = 0;
                    while (while_method_4(v746)){
                        assert("Tensor range check" && 0 <= v746 && v746 < 1);
                        int v748;
                        v748 = 2 * v746;
                        int v749;
                        v749 = v748 + v699;
                        assert("Tensor range check" && 0 <= v746 && v746 < 1);
                        int4* v750;
                        v750 = reinterpret_cast<int4*>(v736 + v748);
                        int4* v751;
                        v751 = reinterpret_cast<int4*>(v694 + v749);
                        assert("Pointer alignment check" && (unsigned long long)(v750) % 2 == 0 && (unsigned long long)(v751) % 2 == 0);
                        *v751 = *v750;
                        int4* v752;
                        v752 = reinterpret_cast<int4*>(v737 + v748);
                        int4* v753;
                        v753 = reinterpret_cast<int4*>(v695 + v749);
                        assert("Pointer alignment check" && (unsigned long long)(v752) % 2 == 0 && (unsigned long long)(v753) % 2 == 0);
                        *v753 = *v752;
                        v746 += 1 ;
                    }
                    assert("Tensor range check" && 0 <= v689 && v689 < 256);
                    v678 += 1 ;
                }
                __syncthreads();
                assert("Tensor range check" && 0 <= v670 && v670 < 256);
                __syncthreads();
                assert("Tensor range check" && 0 <= v616 && v616 < 4);
                assert("Tensor range check" && 0 <= v621 && v621 < 6144);
                int v754;
                v754 = 6144 * v616;
                int v755;
                v755 = v754 + v621;
                v614[v755] = 0;
                v616 += 1 ;
            }
            v36 += 1 ;
        }
        cooperative_groups::grid_group & v756 = v27.v1;
        cooperative_groups::grid_group & v757 = v756;
        curandStatePhilox4_32_10_t & v758 = v27.v5;
        curandStatePhilox4_32_10_t & v759 = v758;
        unsigned int * v760;
        v760 = reinterpret_cast<unsigned int *>(&v0[6291456ull]);
        int * v762;
        v762 = reinterpret_cast<int *>(&v2[262144ull]);
        float * v764;
        v764 = reinterpret_cast<float *>(&v2[262160ull]);
        float * v766;
        v766 = reinterpret_cast<float *>(&v2[524304ull]);
        float * v768;
        v768 = reinterpret_cast<float *>(&v2[786448ull]);
        float * v770;
        v770 = reinterpret_cast<float *>(&v2[1048592ull]);
        float * v772;
        v772 = reinterpret_cast<float *>(&v2[1310736ull]);
        float * v774;
        v774 = reinterpret_cast<float *>(&v2[1572880ull]);
        float * v776;
        v776 = reinterpret_cast<float *>(&v2[1835024ull]);
        int * v778;
        v778 = reinterpret_cast<int *>(&v0[6389760ull]);
        float * v780;
        v780 = reinterpret_cast<float *>(&v0[7962624ull]);
        int * v782;
        v782 = reinterpret_cast<int *>(&v0[9535488ull]);
        int * v784;
        v784 = reinterpret_cast<int *>(&v0[11108352ull]);
        double * v786;
        v786 = reinterpret_cast<double *>(&v0[12681216ull]);
        double * v788;
        v788 = reinterpret_cast<double *>(&v0[18972672ull]);
        double * v790;
        v790 = reinterpret_cast<double *>(&v2[2097168ull]);
        double * v792;
        v792 = reinterpret_cast<double *>(&v2[2490384ull]);
        int * v794;
        v794 = reinterpret_cast<int *>(&v2[2883600ull]);
        v757.sync() ;
        int v796;
        v796 = threadIdx.x;
        int v797;
        v797 = blockIdx.x;
        int v798;
        v798 = v797 * 256;
        int v799;
        v799 = v796 + v798;
        bool v800;
        v800 = v799 == 0;
        if (v800){
            int v801;
            v801 = 0;
            int v802;
            v802 = 4;
            int v803;
            v803 = int_range_22(v802, v801, v759);
            v762[0] = v803;
        } else {
        }
        __syncwarp();
        int v804;
        v804 = threadIdx.x;
        bool v805;
        v805 = 0 <= v804;
        bool v806;
        v806 = v805 == false;
        if (v806){
            assert("The index needs to be zero or positive." && v805);
        } else {
        }
        int v808;
        v808 = v804 % 1;
        int v809;
        v809 = v804 % 256;
        int v810;
        v810 = v804 / 256;
        bool v811;
        v811 = v810 < 1;
        bool v812;
        v812 = v811 == false;
        if (v812){
            assert("The last element of the projection dimensions needs to be greater than the index remainder." && v811);
        } else {
        }
        assert("Tensor range check" && 0 <= v810 && v810 < 1);
        assert("Tensor range check" && 0 <= v809 && v809 < 256);
        assert("Tensor range check" && 0 <= v808 && v808 < 1);
        int v814;
        v814 = 4 * v808;
        int v815;
        v815 = 4 * v809;
        int v816;
        v816 = v815 + v814;
        int v817;
        v817 = 16384 * v810;
        int v818;
        v818 = v817 + v816;
        assert("Tensor range check" && 0 <= v810 && v810 < 1);
        assert("Tensor range check" && 0 <= v809 && v809 < 256);
        assert("Tensor range check" && 0 <= v808 && v808 < 1);
        int v819;
        v819 = blockIdx.x;
        int v820;
        v820 = v819;
        while (while_method_12(v820)){
            bool v822;
            v822 = 0 <= v820;
            bool v823;
            v823 = v822 == false;
            if (v823){
                assert("The index needs to be zero or positive." && v822);
            } else {
            }
            int v825;
            v825 = v820 % 16;
            int v826;
            v826 = v820 / 16;
            bool v827;
            v827 = v826 < 4;
            bool v828;
            v828 = v827 == false;
            if (v828){
                assert("The last element of the projection dimensions needs to be greater than the index remainder." && v827);
            } else {
            }
            assert("Tensor range check" && 0 <= v826 && v826 < 4);
            assert("Tensor range check" && 0 <= v825 && v825 < 16);
            int v830;
            v830 = 1024 * v825;
            int v831;
            v831 = v830 + v818;
            int v832;
            v832 = 16384 * v826;
            int v833;
            v833 = v832 + v831;
            float v834[4];
            float v835[4];
            float v836[4];
            float v837[4];
            float v838[4];
            float v839[4];
            float v840[4];
            int v841[4];
            int v842;
            v842 = 0;
            while (while_method_4(v842)){
                assert("Tensor range check" && 0 <= v842 && v842 < 1);
                int v844;
                v844 = 4 * v842;
                assert("Tensor range check" && 0 <= v842 && v842 < 1);
                int v845;
                v845 = v844 + v833;
                int4* v846;
                v846 = reinterpret_cast<int4*>(v764 + v845);
                int4* v847;
                v847 = reinterpret_cast<int4*>(v834 + v844);
                assert("Pointer alignment check" && (unsigned long long)(v846) % 4 == 0 && (unsigned long long)(v847) % 4 == 0);
                *v847 = *v846;
                int4* v848;
                v848 = reinterpret_cast<int4*>(v766 + v845);
                int4* v849;
                v849 = reinterpret_cast<int4*>(v835 + v844);
                assert("Pointer alignment check" && (unsigned long long)(v848) % 4 == 0 && (unsigned long long)(v849) % 4 == 0);
                *v849 = *v848;
                int4* v850;
                v850 = reinterpret_cast<int4*>(v768 + v845);
                int4* v851;
                v851 = reinterpret_cast<int4*>(v836 + v844);
                assert("Pointer alignment check" && (unsigned long long)(v850) % 4 == 0 && (unsigned long long)(v851) % 4 == 0);
                *v851 = *v850;
                int4* v852;
                v852 = reinterpret_cast<int4*>(v770 + v845);
                int4* v853;
                v853 = reinterpret_cast<int4*>(v837 + v844);
                assert("Pointer alignment check" && (unsigned long long)(v852) % 4 == 0 && (unsigned long long)(v853) % 4 == 0);
                *v853 = *v852;
                int4* v854;
                v854 = reinterpret_cast<int4*>(v772 + v845);
                int4* v855;
                v855 = reinterpret_cast<int4*>(v838 + v844);
                assert("Pointer alignment check" && (unsigned long long)(v854) % 4 == 0 && (unsigned long long)(v855) % 4 == 0);
                *v855 = *v854;
                int4* v856;
                v856 = reinterpret_cast<int4*>(v774 + v845);
                int4* v857;
                v857 = reinterpret_cast<int4*>(v839 + v844);
                assert("Pointer alignment check" && (unsigned long long)(v856) % 4 == 0 && (unsigned long long)(v857) % 4 == 0);
                *v857 = *v856;
                int4* v858;
                v858 = reinterpret_cast<int4*>(v776 + v845);
                int4* v859;
                v859 = reinterpret_cast<int4*>(v840 + v844);
                assert("Pointer alignment check" && (unsigned long long)(v858) % 4 == 0 && (unsigned long long)(v859) % 4 == 0);
                *v859 = *v858;
                v842 += 1 ;
            }
            int v860;
            v860 = 0;
            while (while_method_4(v860)){
                int v862;
                v862 = 0;
                while (while_method_9(v862)){
                    bool v864;
                    v864 = 0 <= v862;
                    bool v866;
                    if (v864){
                        bool v865;
                        v865 = v862 < 4;
                        v866 = v865;
                    } else {
                        v866 = false;
                    }
                    bool v867;
                    v867 = v866 == false;
                    if (v867){
                        assert("The indices should be inside the range of the dimension." && v866);
                    } else {
                    }
                    bool v869;
                    v869 = 0 <= v808;
                    bool v871;
                    if (v869){
                        bool v870;
                        v870 = v808 < 1;
                        v871 = v870;
                    } else {
                        v871 = false;
                    }
                    bool v872;
                    v872 = v871 == false;
                    if (v872){
                        assert("The indices should be inside the range of the dimension." && v871);
                    } else {
                    }
                    int v874;
                    v874 = v808 * 4;
                    int v875;
                    v875 = v862 + v874;
                    bool v876;
                    v876 = 0 <= v860;
                    bool v878;
                    if (v876){
                        bool v877;
                        v877 = v860 < 1;
                        v878 = v877;
                    } else {
                        v878 = false;
                    }
                    bool v879;
                    v879 = v878 == false;
                    if (v879){
                        assert("The indices should be inside the range of the dimension." && v878);
                    } else {
                    }
                    int v881;
                    v881 = v860 * 4;
                    int v882;
                    v882 = v875 + v881;
                    assert("Tensor range check" && 0 <= v860 && v860 < 1);
                    assert("Tensor range check" && 0 <= v862 && v862 < 4);
                    int v883;
                    v883 = 4 * v860;
                    int v884;
                    v884 = v883 + v862;
                    v841[v884] = v882;
                    v862 += 1 ;
                }
                v860 += 1 ;
            }
            bool v885;
            v885 = 0 <= v810;
            bool v886;
            v886 = v885 && v811;
            bool v887;
            v887 = v886 == false;
            if (v887){
                assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v886);
            } else {
            }
            bool v889;
            v889 = 0 <= v809;
            bool v891;
            if (v889){
                bool v890;
                v890 = v809 < 256;
                v891 = v890;
            } else {
                v891 = false;
            }
            bool v892;
            v892 = v891 == false;
            if (v892){
                assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v891);
            } else {
            }
            bool v894;
            v894 = 0 <= v826;
            bool v895;
            v895 = v894 && v827;
            bool v896;
            v896 = v895 == false;
            if (v896){
                assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v895);
            } else {
            }
            bool v898;
            v898 = 0 <= v825;
            bool v900;
            if (v898){
                bool v899;
                v899 = v825 < 16;
                v900 = v899;
            } else {
                v900 = false;
            }
            bool v901;
            v901 = v900 == false;
            if (v901){
                assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v900);
            } else {
            }
            int v903;
            v903 = v825 * 256;
            int v904;
            v904 = v826 + v810;
            int v905;
            v905 = v903 + v809;
            bool v906[4];
            int v907;
            v907 = 0;
            while (while_method_4(v907)){
                int v909;
                v909 = 0;
                while (while_method_9(v909)){
                    assert("Tensor range check" && 0 <= v907 && v907 < 1);
                    assert("Tensor range check" && 0 <= v909 && v909 < 4);
                    int v911;
                    v911 = 4 * v907;
                    int v912;
                    v912 = v911 + v909;
                    float v913;
                    v913 = v836[v912];
                    bool v914;
                    v914 = v913 == 0.0f;
                    bool v915;
                    v915 = v914 != true;
                    assert("Tensor range check" && 0 <= v907 && v907 < 1);
                    assert("Tensor range check" && 0 <= v909 && v909 < 4);
                    v906[v912] = v915;
                    v909 += 1 ;
                }
                v907 += 1 ;
            }
            bool v916;
            v916 = false;
            int v917;
            v917 = 0;
            while (while_method_4(v917)){
                int v919;
                v919 = 0;
                while (while_method_9(v919)){
                    assert("Tensor range check" && 0 <= v917 && v917 < 1);
                    assert("Tensor range check" && 0 <= v919 && v919 < 4);
                    int v921;
                    v921 = 4 * v917;
                    int v922;
                    v922 = v921 + v919;
                    bool v923;
                    v923 = v906[v922];
                    bool v924;
                    v924 = v916 || v923;
                    v916 = v924;
                    v919 += 1 ;
                }
                v917 += 1 ;
            }
            auto v925 = cooperative_groups::coalesced_threads();
            int v926;
            v926 = threadIdx.x;
            auto v927 = cooperative_groups::labeled_partition(v925,v926);
            Closure8 v928{};
            bool v929;
            v929 = cooperative_groups::reduce(v927, v916, v928);
            if (v929){
                float v930[4];
                int v931;
                v931 = 0;
                while (while_method_4(v931)){
                    int v933;
                    v933 = 0;
                    while (while_method_9(v933)){
                        assert("Tensor range check" && 0 <= v931 && v931 < 1);
                        assert("Tensor range check" && 0 <= v933 && v933 < 4);
                        int v935;
                        v935 = 4 * v931;
                        int v936;
                        v936 = v935 + v933;
                        float v937;
                        v937 = v835[v936];
                        float v938;
                        v938 = v836[v936];
                        float v939;
                        v939 = v937 + v938;
                        bool v940;
                        v940 = 0.0f >= v939;
                        float v941;
                        if (v940){
                            v941 = 0.0f;
                        } else {
                            v941 = v939;
                        }
                        assert("Tensor range check" && 0 <= v931 && v931 < 1);
                        assert("Tensor range check" && 0 <= v933 && v933 < 4);
                        v930[v936] = v941;
                        v933 += 1 ;
                    }
                    v931 += 1 ;
                }
                float v942[4];
                int v943;
                v943 = 0;
                while (while_method_4(v943)){
                    int v945;
                    v945 = 0;
                    while (while_method_9(v945)){
                        assert("Tensor range check" && 0 <= v943 && v943 < 1);
                        assert("Tensor range check" && 0 <= v945 && v945 < 4);
                        int v947;
                        v947 = 4 * v943;
                        int v948;
                        v948 = v947 + v945;
                        float v949;
                        v949 = v930[v948];
                        bool v950;
                        v950 = 0.0f >= v949;
                        float v951;
                        if (v950){
                            v951 = 0.0f;
                        } else {
                            v951 = v949;
                        }
                        assert("Tensor range check" && 0 <= v943 && v943 < 1);
                        assert("Tensor range check" && 0 <= v945 && v945 < 4);
                        v942[v948] = v951;
                        v945 += 1 ;
                    }
                    v943 += 1 ;
                }
                float v952;
                v952 = 0.0f;
                int v953;
                v953 = 0;
                while (while_method_4(v953)){
                    int v955;
                    v955 = 0;
                    while (while_method_9(v955)){
                        assert("Tensor range check" && 0 <= v953 && v953 < 1);
                        assert("Tensor range check" && 0 <= v955 && v955 < 4);
                        int v957;
                        v957 = 4 * v953;
                        int v958;
                        v958 = v957 + v955;
                        float v959;
                        v959 = v942[v958];
                        float v960;
                        v960 = v952 + v959;
                        v952 = v960;
                        v955 += 1 ;
                    }
                    v953 += 1 ;
                }
                auto v961 = cooperative_groups::coalesced_threads();
                int v962;
                v962 = threadIdx.x;
                auto v963 = cooperative_groups::labeled_partition(v961,v962);
                Closure1 v964{};
                float v965;
                v965 = cooperative_groups::reduce(v963, v952, v964);
                float v966[4];
                int v967;
                v967 = 0;
                while (while_method_4(v967)){
                    int v969;
                    v969 = 0;
                    while (while_method_9(v969)){
                        assert("Tensor range check" && 0 <= v967 && v967 < 1);
                        assert("Tensor range check" && 0 <= v969 && v969 < 4);
                        int v971;
                        v971 = 4 * v967;
                        int v972;
                        v972 = v971 + v969;
                        float v973;
                        v973 = v942[v972];
                        bool v974;
                        v974 = v965 == 0.0f;
                        bool v975;
                        v975 = v974 != true;
                        float v977;
                        if (v975){
                            float v976;
                            v976 = v973 / v965;
                            v977 = v976;
                        } else {
                            v977 = 0.25f;
                        }
                        assert("Tensor range check" && 0 <= v967 && v967 < 1);
                        assert("Tensor range check" && 0 <= v969 && v969 < 4);
                        v966[v972] = v977;
                        v969 += 1 ;
                    }
                    v967 += 1 ;
                }
                float v978[4];
                int v979;
                v979 = 0;
                while (while_method_4(v979)){
                    int v981;
                    v981 = 0;
                    while (while_method_9(v981)){
                        assert("Tensor range check" && 0 <= v979 && v979 < 1);
                        assert("Tensor range check" && 0 <= v981 && v981 < 4);
                        int v983;
                        v983 = 4 * v979;
                        int v984;
                        v984 = v983 + v981;
                        float v985;
                        v985 = v834[v984];
                        float v986;
                        v986 = v966[v984];
                        float v987;
                        v987 = v985 + v986;
                        assert("Tensor range check" && 0 <= v979 && v979 < 1);
                        assert("Tensor range check" && 0 <= v981 && v981 < 4);
                        v978[v984] = v987;
                        v981 += 1 ;
                    }
                    v979 += 1 ;
                }
                float v988[4];
                int v989;
                v989 = 0;
                while (while_method_4(v989)){
                    int v991;
                    v991 = 0;
                    while (while_method_9(v991)){
                        assert("Tensor range check" && 0 <= v989 && v989 < 1);
                        assert("Tensor range check" && 0 <= v991 && v991 < 4);
                        int v993;
                        v993 = 4 * v989;
                        int v994;
                        v994 = v993 + v991;
                        float v995;
                        v995 = v978[v994];
                        float v996;
                        v996 = -v995;
                        bool v997;
                        v997 = v995 >= v996;
                        float v998;
                        if (v997){
                            v998 = v995;
                        } else {
                            v998 = v996;
                        }
                        assert("Tensor range check" && 0 <= v989 && v989 < 1);
                        assert("Tensor range check" && 0 <= v991 && v991 < 4);
                        v988[v994] = v998;
                        v991 += 1 ;
                    }
                    v989 += 1 ;
                }
                float v999;
                v999 = 0.0f;
                int v1000;
                v1000 = 0;
                while (while_method_4(v1000)){
                    int v1002;
                    v1002 = 0;
                    while (while_method_9(v1002)){
                        assert("Tensor range check" && 0 <= v1000 && v1000 < 1);
                        assert("Tensor range check" && 0 <= v1002 && v1002 < 4);
                        int v1004;
                        v1004 = 4 * v1000;
                        int v1005;
                        v1005 = v1004 + v1002;
                        float v1006;
                        v1006 = v988[v1005];
                        float v1007;
                        v1007 = v999 + v1006;
                        v999 = v1007;
                        v1002 += 1 ;
                    }
                    v1000 += 1 ;
                }
                auto v1008 = cooperative_groups::coalesced_threads();
                int v1009;
                v1009 = threadIdx.x;
                auto v1010 = cooperative_groups::labeled_partition(v1008,v1009);
                float v1011;
                v1011 = cooperative_groups::reduce(v1010, v999, v964);
                bool v1012;
                v1012 = v1011 > 100.0f;
                float v1014;
                if (v1012){
                    float v1013;
                    v1013 = 100.0f / v1011;
                    v1014 = v1013;
                } else {
                    v1014 = 1.0f;
                }
                float v1015[4];
                int v1016;
                v1016 = 0;
                while (while_method_4(v1016)){
                    int v1018;
                    v1018 = 0;
                    while (while_method_9(v1018)){
                        assert("Tensor range check" && 0 <= v1016 && v1016 < 1);
                        assert("Tensor range check" && 0 <= v1018 && v1018 < 4);
                        int v1020;
                        v1020 = 4 * v1016;
                        int v1021;
                        v1021 = v1020 + v1018;
                        float v1022;
                        v1022 = v988[v1021];
                        float v1023;
                        v1023 = v1014 * v1022;
                        assert("Tensor range check" && 0 <= v1016 && v1016 < 1);
                        assert("Tensor range check" && 0 <= v1018 && v1018 < 4);
                        v1015[v1021] = v1023;
                        v1018 += 1 ;
                    }
                    v1016 += 1 ;
                }
                float v1024[4];
                float v1025[4];
                int v1026;
                v1026 = 0;
                while (while_method_4(v1026)){
                    int v1028;
                    v1028 = 0;
                    while (while_method_9(v1028)){
                        assert("Tensor range check" && 0 <= v1026 && v1026 < 1);
                        assert("Tensor range check" && 0 <= v1028 && v1028 < 4);
                        int v1030;
                        v1030 = 4 * v1026;
                        int v1031;
                        v1031 = v1030 + v1028;
                        float v1032;
                        v1032 = v834[v1031];
                        float v1033;
                        v1033 = v835[v1031];
                        float v1034;
                        v1034 = v836[v1031];
                        float v1035;
                        v1035 = v837[v1031];
                        float v1036;
                        v1036 = v838[v1031];
                        float v1037;
                        v1037 = v839[v1031];
                        float v1038;
                        v1038 = v840[v1031];
                        float v1039;
                        v1039 = v1035 + v1037;
                        float v1040;
                        v1040 = v1036 + v1038;
                        assert("Tensor range check" && 0 <= v1026 && v1026 < 1);
                        assert("Tensor range check" && 0 <= v1028 && v1028 < 4);
                        v1024[v1031] = v1039;
                        v1025[v1031] = v1040;
                        v1028 += 1 ;
                    }
                    v1026 += 1 ;
                }
                int v1041;
                v1041 = 0;
                while (while_method_4(v1041)){
                    int v1043;
                    v1043 = 0;
                    while (while_method_9(v1043)){
                        assert("Tensor range check" && 0 <= v1041 && v1041 < 1);
                        assert("Tensor range check" && 0 <= v1043 && v1043 < 4);
                        int v1045;
                        v1045 = 4 * v1041;
                        int v1046;
                        v1046 = v1045 + v1043;
                        float v1047;
                        v1047 = v1015[v1046];
                        float v1048;
                        v1048 = v930[v1046];
                        float v1049;
                        v1049 = v1024[v1046];
                        float v1050;
                        v1050 = v1025[v1046];
                        assert("Tensor range check" && 0 <= v1041 && v1041 < 1);
                        assert("Tensor range check" && 0 <= v1043 && v1043 < 4);
                        v834[v1046] = v1047;
                        v835[v1046] = v1048;
                        v836[v1046] = 0.0f;
                        v837[v1046] = v1049;
                        v838[v1046] = v1050;
                        v839[v1046] = 0.0f;
                        v840[v1046] = 0.0f;
                        v1043 += 1 ;
                    }
                    v1041 += 1 ;
                }
            } else {
            }
            assert("Tensor range check" && 0 <= v826 && v826 < 4);
            assert("Tensor range check" && 0 <= v825 && v825 < 16);
            int v1051;
            v1051 = 0;
            while (while_method_4(v1051)){
                assert("Tensor range check" && 0 <= v1051 && v1051 < 1);
                int v1053;
                v1053 = 4 * v1051;
                int v1054;
                v1054 = v1053 + v833;
                assert("Tensor range check" && 0 <= v1051 && v1051 < 1);
                int4* v1055;
                v1055 = reinterpret_cast<int4*>(v834 + v1053);
                int4* v1056;
                v1056 = reinterpret_cast<int4*>(v764 + v1054);
                assert("Pointer alignment check" && (unsigned long long)(v1055) % 4 == 0 && (unsigned long long)(v1056) % 4 == 0);
                *v1056 = *v1055;
                int4* v1057;
                v1057 = reinterpret_cast<int4*>(v835 + v1053);
                int4* v1058;
                v1058 = reinterpret_cast<int4*>(v766 + v1054);
                assert("Pointer alignment check" && (unsigned long long)(v1057) % 4 == 0 && (unsigned long long)(v1058) % 4 == 0);
                *v1058 = *v1057;
                int4* v1059;
                v1059 = reinterpret_cast<int4*>(v836 + v1053);
                int4* v1060;
                v1060 = reinterpret_cast<int4*>(v768 + v1054);
                assert("Pointer alignment check" && (unsigned long long)(v1059) % 4 == 0 && (unsigned long long)(v1060) % 4 == 0);
                *v1060 = *v1059;
                int4* v1061;
                v1061 = reinterpret_cast<int4*>(v837 + v1053);
                int4* v1062;
                v1062 = reinterpret_cast<int4*>(v770 + v1054);
                assert("Pointer alignment check" && (unsigned long long)(v1061) % 4 == 0 && (unsigned long long)(v1062) % 4 == 0);
                *v1062 = *v1061;
                int4* v1063;
                v1063 = reinterpret_cast<int4*>(v838 + v1053);
                int4* v1064;
                v1064 = reinterpret_cast<int4*>(v772 + v1054);
                assert("Pointer alignment check" && (unsigned long long)(v1063) % 4 == 0 && (unsigned long long)(v1064) % 4 == 0);
                *v1064 = *v1063;
                int4* v1065;
                v1065 = reinterpret_cast<int4*>(v839 + v1053);
                int4* v1066;
                v1066 = reinterpret_cast<int4*>(v774 + v1054);
                assert("Pointer alignment check" && (unsigned long long)(v1065) % 4 == 0 && (unsigned long long)(v1066) % 4 == 0);
                *v1066 = *v1065;
                int4* v1067;
                v1067 = reinterpret_cast<int4*>(v840 + v1053);
                int4* v1068;
                v1068 = reinterpret_cast<int4*>(v776 + v1054);
                assert("Pointer alignment check" && (unsigned long long)(v1067) % 4 == 0 && (unsigned long long)(v1068) % 4 == 0);
                *v1068 = *v1067;
                v1051 += 1 ;
            }
            v820 += 24 ;
        }
        v757.sync() ;
        v34 += 1 ;
    }
    cooperative_groups::grid_group & v1069 = v27.v1;
    cooperative_groups::grid_group & v1070 = v1069;
    int v1071;
    v1071 = threadIdx.x;
    int v1072;
    v1072 = blockIdx.x;
    int v1073;
    v1073 = v1072 * 256;
    int v1074;
    v1074 = v1071 + v1073;
    int v1075;
    v1075 = v1074;
    while (while_method_7(v1075)){
        bool v1077;
        v1077 = 0 <= v1075;
        bool v1078;
        v1078 = v1077 == false;
        if (v1078){
            assert("The index needs to be zero or positive." && v1077);
        } else {
        }
        int v1080;
        v1080 = v1075 % 8;
        int v1081;
        v1081 = v1075 / 8;
        bool v1082;
        v1082 = v1081 < 2;
        bool v1083;
        v1083 = v1082 == false;
        if (v1083){
            assert("The last element of the projection dimensions needs to be greater than the index remainder." && v1082);
        } else {
        }
        assert("Tensor range check" && 0 <= v1081 && v1081 < 2);
        assert("Tensor range check" && 0 <= v1080 && v1080 < 8);
        int v1085;
        v1085 = 4 * v1080;
        int v1086;
        v1086 = 32 * v1081;
        int v1087;
        v1087 = v1086 + v1085;
        assert("Tensor range check" && 0 <= v1081 && v1081 < 2);
        assert("Tensor range check" && 0 <= v1080 && v1080 < 8);
        float v1088[4];
        float v1089[4];
        float v1090[4];
        int4* v1091;
        v1091 = reinterpret_cast<int4*>(v4 + v1087);
        int4* v1092;
        v1092 = reinterpret_cast<int4*>(v1088 + 0);
        assert("Pointer alignment check" && (unsigned long long)(v1091) % 4 == 0 && (unsigned long long)(v1092) % 4 == 0);
        *v1092 = *v1091;
        int4* v1093;
        v1093 = reinterpret_cast<int4*>(v5 + v1087);
        int4* v1094;
        v1094 = reinterpret_cast<int4*>(v1089 + 0);
        assert("Pointer alignment check" && (unsigned long long)(v1093) % 4 == 0 && (unsigned long long)(v1094) % 4 == 0);
        *v1094 = *v1093;
        // Pushing the loop unrolling to: 0
        int v1095;
        v1095 = 0;
        #pragma unroll
        while (while_method_9(v1095)){
            assert("Tensor range check" && 0 <= v1095 && v1095 < 4);
            float v1097;
            v1097 = v1088[v1095];
            float v1098;
            v1098 = v1089[v1095];
            bool v1099;
            v1099 = v1098 == 0.0f;
            bool v1100;
            v1100 = v1099 != true;
            float v1102;
            if (v1100){
                float v1101;
                v1101 = v1097 / v1098;
                v1102 = v1101;
            } else {
                v1102 = 0.0f;
            }
            assert("Tensor range check" && 0 <= v1095 && v1095 < 4);
            v1090[v1095] = v1102;
            v1095 += 1 ;
        }
        // Poping the loop unrolling to: 0
        int4* v1103;
        v1103 = reinterpret_cast<int4*>(v1090 + 0);
        int4* v1104;
        v1104 = reinterpret_cast<int4*>(v6 + v1087);
        assert("Pointer alignment check" && (unsigned long long)(v1103) % 4 == 0 && (unsigned long long)(v1104) % 4 == 0);
        *v1104 = *v1103;
        v1075 += 6144 ;
    }
    v1070.sync() ;
    return ;
}
"""
class static_array():
    def __init__(self, length):
        self.ptr = []
        for _ in range(length):
            self.ptr.append(None)

    def __getitem__(self, index):
        assert 0 <= index < len(self.ptr), "The get index needs to be in range."
        return self.ptr[index]
    
    def __setitem__(self, index, value):
        assert 0 <= index < len(self.ptr), "The set index needs to be in range."
        self.ptr[index] = value

class static_array_list(static_array):
    def __init__(self, length):
        super().__init__(length)
        self.length = 0

    def __getitem__(self, index):
        assert 0 <= index < self.length, "The get index needs to be in range."
        return self.ptr[index]
    
    def __setitem__(self, index, value):
        assert 0 <= index < self.length, "The set index needs to be in range."
        self.ptr[index] = value

    def push(self,value):
        assert (self.length < len(self.ptr)), "The length before pushing has to be less than the maximum length of the array."
        self.ptr[self.length] = value
        self.length += 1

    def pop(self):
        assert (0 < self.length), "The length before popping has to be greater than 0."
        self.length -= 1
        return self.ptr[self.length]

    def unsafe_set_length(self,i):
        assert 0 <= i <= len(self.ptr), "The new length has to be in range."
        self.length = i

class dynamic_array(static_array): 
    pass

class dynamic_array_list(static_array_list):
    def length_(self): return self.length

import cupy as cp
from dataclasses import dataclass
from typing import NamedTuple, Union, Callable, Tuple
i8 = int; i16 = int; i32 = int; i64 = int; u8 = int; u16 = int; u32 = int; u64 = int; f32 = float; f64 = float; char = str; string = str

import time
options = []
options.append('--define-macro=NDEBUG')
options.append('--dopt=on')
options.append('--diag-suppress=550,20012,68,39,177')
options.append('--restrict')
options.append('--maxrregcount=255')
options.append('--std=c++20')
options.append('-D__CUDA_NO_HALF_CONVERSIONS__')
raw_module = cp.RawModule(code=kernel, backend='nvcc', enable_cooperative_groups=True, options=tuple(options))
import collections
class US1_0(NamedTuple): # Call
    tag = 0
class US1_1(NamedTuple): # Fold
    tag = 1
class US1_2(NamedTuple): # Raise
    tag = 2
US1 = Union[US1_0, US1_1, US1_2]
class US0_0(NamedTuple): # ActionSelected
    v0 : US1
    tag = 0
class US0_1(NamedTuple): # PlayerChanged
    v0 : static_array
    tag = 1
class US0_2(NamedTuple): # StartGame
    tag = 2
class US0_3(NamedTuple): # StartTrainingVsRando
    tag = 3
class US0_4(NamedTuple): # StartTrainingVsSelf
    tag = 4
US0 = Union[US0_0, US0_1, US0_2, US0_3, US0_4]
class US2_0(NamedTuple): # Computer
    tag = 0
class US2_1(NamedTuple): # Human
    tag = 1
class US2_2(NamedTuple): # Random
    tag = 2
US2 = Union[US2_0, US2_1, US2_2]
class US6_0(NamedTuple): # Jack
    tag = 0
class US6_1(NamedTuple): # King
    tag = 1
class US6_2(NamedTuple): # Queen
    tag = 2
US6 = Union[US6_0, US6_1, US6_2]
class US5_0(NamedTuple): # None
    tag = 0
class US5_1(NamedTuple): # Some
    v0 : US6
    tag = 1
US5 = Union[US5_0, US5_1]
class US4_0(NamedTuple): # ChanceCommunityCard
    v0 : US5
    v1 : bool
    v2 : static_array
    v3 : i32
    v4 : static_array
    v5 : i32
    tag = 0
class US4_1(NamedTuple): # ChanceInit
    tag = 1
class US4_2(NamedTuple): # Round
    v0 : US5
    v1 : bool
    v2 : static_array
    v3 : i32
    v4 : static_array
    v5 : i32
    tag = 2
class US4_3(NamedTuple): # RoundWithAction
    v0 : US5
    v1 : bool
    v2 : static_array
    v3 : i32
    v4 : static_array
    v5 : i32
    v6 : US1
    tag = 3
class US4_4(NamedTuple): # TerminalCall
    v0 : US5
    v1 : bool
    v2 : static_array
    v3 : i32
    v4 : static_array
    v5 : i32
    tag = 4
class US4_5(NamedTuple): # TerminalFold
    v0 : US5
    v1 : bool
    v2 : static_array
    v3 : i32
    v4 : static_array
    v5 : i32
    tag = 5
US4 = Union[US4_0, US4_1, US4_2, US4_3, US4_4, US4_5]
class US3_0(NamedTuple): # None
    tag = 0
class US3_1(NamedTuple): # Some
    v0 : US4
    tag = 1
US3 = Union[US3_0, US3_1]
class US7_0(NamedTuple): # GameNotStarted
    tag = 0
class US7_1(NamedTuple): # GameOver
    v0 : US5
    v1 : bool
    v2 : static_array
    v3 : i32
    v4 : static_array
    v5 : i32
    tag = 1
class US7_2(NamedTuple): # WaitingForActionFromPlayerId
    v0 : US5
    v1 : bool
    v2 : static_array
    v3 : i32
    v4 : static_array
    v5 : i32
    tag = 2
US7 = Union[US7_0, US7_1, US7_2]
class US8_0(NamedTuple): # CommunityCardIs
    v0 : US6
    tag = 0
class US8_1(NamedTuple): # PlayerAction
    v0 : i32
    v1 : US1
    tag = 1
class US8_2(NamedTuple): # PlayerGotCard
    v0 : i32
    v1 : US6
    tag = 2
class US8_3(NamedTuple): # Showdown
    v0 : static_array
    v1 : i32
    v2 : i32
    tag = 3
US8 = Union[US8_0, US8_1, US8_2, US8_3]
class US9_0(NamedTuple): # AddRewardsRando
    v0 : list
    tag = 0
class US9_1(NamedTuple): # AddRewardsSelf
    v0 : list
    tag = 1
US9 = Union[US9_0, US9_1]
def Closure0():
    def inner(v0 : object, v1 : object) -> object:
        v2 = method0(v0)
        v3, v4, v5, v6, v7, v8, v9, v10, v11 = method7(v1)
        v12 = cp.empty(16,dtype=cp.uint8)
        v13 = cp.empty(1184,dtype=cp.uint8)
        method37(v13, v3, v4, v5, v6, v7)
        del v3, v4, v5, v6, v7
        v16 = "{}\n"
        v17 = "Going to run the Leduc full kernel."
        print(v16.format(v17),end="")
        del v16, v17
        v18 = time.perf_counter()
        v19 = []
        match v2:
            case US0_0(_): # ActionSelected
                method55(v12, v2)
                v78 = cp.cuda.Device().attributes['MultiProcessorCount']
                v79 = v78 == 24
                del v78
                v80 = v79 == False
                if v80:
                    v81 = "The number of SMs per GPU at runtime must much that what is declared atop of corecuda.base. Make sure to use the correct constant so it can be propagated at compile time."
                    assert v79, v81
                    del v81
                else:
                    pass
                del v79, v80
                v82 = 0
                v83 = raw_module.get_function(f"entry{v82}")
                del v82
                v83.max_dynamic_shared_size_bytes = 98304 
                print(f'Threads per block, blocks per grid: {256}, {24}')
                v83((24,),(256,),(v13, v12, v8, v9, v10, v11),shared_mem=98304)
                del v83
            case US0_1(_): # PlayerChanged
                method55(v12, v2)
                v71 = cp.cuda.Device().attributes['MultiProcessorCount']
                v72 = v71 == 24
                del v71
                v73 = v72 == False
                if v73:
                    v74 = "The number of SMs per GPU at runtime must much that what is declared atop of corecuda.base. Make sure to use the correct constant so it can be propagated at compile time."
                    assert v72, v74
                    del v74
                else:
                    pass
                del v72, v73
                v75 = 0
                v76 = raw_module.get_function(f"entry{v75}")
                del v75
                v76.max_dynamic_shared_size_bytes = 98304 
                print(f'Threads per block, blocks per grid: {256}, {24}')
                v76((24,),(256,),(v13, v12, v8, v9, v10, v11),shared_mem=98304)
                del v76
            case US0_2(): # StartGame
                method55(v12, v2)
                v64 = cp.cuda.Device().attributes['MultiProcessorCount']
                v65 = v64 == 24
                del v64
                v66 = v65 == False
                if v66:
                    v67 = "The number of SMs per GPU at runtime must much that what is declared atop of corecuda.base. Make sure to use the correct constant so it can be propagated at compile time."
                    assert v65, v67
                    del v67
                else:
                    pass
                del v65, v66
                v68 = 0
                v69 = raw_module.get_function(f"entry{v68}")
                del v68
                v69.max_dynamic_shared_size_bytes = 98304 
                print(f'Threads per block, blocks per grid: {256}, {24}')
                v69((24,),(256,),(v13, v12, v8, v9, v10, v11),shared_mem=98304)
                del v69
            case US0_3(): # StartTrainingVsRando
                v20 = cp.zeros(128,dtype=cp.float32) # type: ignore
                v21 = cp.zeros(128,dtype=cp.float32) # type: ignore
                v22 = cp.empty(128,dtype=cp.float32)
                v23 = cp.cuda.Device().attributes['MultiProcessorCount']
                v24 = v23 == 24
                del v23
                v25 = v24 == False
                if v25:
                    v26 = "The number of SMs per GPU at runtime must much that what is declared atop of corecuda.base. Make sure to use the correct constant so it can be propagated at compile time."
                    assert v24, v26
                    del v26
                else:
                    pass
                del v24, v25
                v27 = 1
                v28 = raw_module.get_function(f"entry{v27}")
                del v27
                v28.max_dynamic_shared_size_bytes = 98304 
                print(f'Threads per block, blocks per grid: {256}, {24}')
                v28((24,),(256,),(v8, v9, v10, v11, v20, v21, v22),shared_mem=98304)
                del v20, v21, v28
                v29 = []
                v31 = v22[0:]
                del v22
                v32 = v31.get()
                del v31
                v33 = 0
                while method58(v33):
                    v35 = []
                    v36 = 0
                    while method59(v36):
                        assert 0 <= v33 < 4, 'Tensor range check'
                        assert 0 <= v36 < 32, 'Tensor range check'
                        v38 = 32 * v33
                        v39 = v38 + v36
                        del v38
                        v40 = v32[v39].item()
                        del v39
                        v35.append(v40)
                        del v40
                        v36 += 1 
                    del v36
                    v29.append(v35)
                    del v35
                    v33 += 1 
                del v32, v33
                v41 = US9_0(v29)
                del v29
                v19.append(v41)
                del v41
            case US0_4(): # StartTrainingVsSelf
                v42 = cp.zeros(64,dtype=cp.float32) # type: ignore
                v43 = cp.zeros(64,dtype=cp.float32) # type: ignore
                v44 = cp.empty(64,dtype=cp.float32)
                v45 = cp.cuda.Device().attributes['MultiProcessorCount']
                v46 = v45 == 24
                del v45
                v47 = v46 == False
                if v47:
                    v48 = "The number of SMs per GPU at runtime must much that what is declared atop of corecuda.base. Make sure to use the correct constant so it can be propagated at compile time."
                    assert v46, v48
                    del v48
                else:
                    pass
                del v46, v47
                v49 = 2
                v50 = raw_module.get_function(f"entry{v49}")
                del v49
                v50.max_dynamic_shared_size_bytes = 98304 
                print(f'Threads per block, blocks per grid: {256}, {24}')
                v50((24,),(256,),(v8, v9, v10, v11, v42, v43, v44),shared_mem=98304)
                del v42, v43, v50
                v51 = []
                v53 = v44[0:]
                del v44
                v54 = v53.get()
                del v53
                v55 = 0
                while method45(v55):
                    v57 = []
                    v58 = 0
                    while method59(v58):
                        assert 0 <= v55 < 2, 'Tensor range check'
                        assert 0 <= v58 < 32, 'Tensor range check'
                        v60 = 32 * v55
                        v61 = v60 + v58
                        del v60
                        v62 = v54[v61].item()
                        del v61
                        v57.append(v62)
                        del v62
                        v58 += 1 
                    del v58
                    v51.append(v57)
                    del v57
                    v55 += 1 
                del v54, v55
                v63 = US9_1(v51)
                del v51
                v19.append(v63)
                del v63
            case t:
                raise Exception(f'Pattern matching miss. Got: {t}')
        del v2, v12
        cp.cuda.get_current_stream().synchronize()
        v84 = time.perf_counter()
        v87 = "{}"
        v88 = "The time it took to run the kernel (in seconds) is: "
        print(v87.format(v88),end="")
        del v87, v88
        v89 = v84 - v18
        del v18, v84
        v92 = "{:.6f}\n"
        print(v92.format(v89),end="")
        del v89, v92
        v93, v94, v95, v96, v97 = method60(v13)
        del v13
        return method77(v93, v94, v95, v96, v97, v8, v9, v10, v11, v19)
    return inner
def Closure1():
    def inner() -> object:
        v1 = static_array(2)
        v3 = US2_0()
        v1[0] = v3
        del v3
        v5 = US2_1()
        v1[1] = v5
        del v5
        v7 = static_array_list(32)
        v8 = cp.empty(2981904,dtype=cp.uint8)
        v9 = cp.empty(25264128,dtype=cp.uint8)
        v11 = v8[0:0+4*65536].view(cp.float32)
        v12 = cp.random.normal(0.0,0.00390625,65536,dtype=cp.float32) # type: ignore
        cp.copyto(v11[0:0+65536],v12[0:0+65536])
        del v11, v12
        v14 = v8[262144:262144+4*1].view(cp.int32)
        v16 = v8[262160:262160+4*65536].view(cp.float32)
        v18 = v8[524304:524304+4*65536].view(cp.float32)
        v20 = v8[786448:786448+4*65536].view(cp.float32)
        v22 = v8[1048592:1048592+4*65536].view(cp.float32)
        v24 = v8[1310736:1310736+4*65536].view(cp.float32)
        v26 = v8[1572880:1572880+4*65536].view(cp.float32)
        v28 = v8[1835024:1835024+4*65536].view(cp.float32)
        v14[:] = 0
        del v14
        v16[:] = 0
        v18[:] = 0
        del v18
        v20[:] = 0
        del v20
        v22[:] = 0
        del v22
        v24[:] = 0
        del v24
        v26[:] = 0
        del v26
        v28[:] = 0
        del v28
        v16[:] = 33.333332
        del v16
        v30 = v8[2097168:2097168+8*49152].view(cp.float64)
        v32 = v8[2490384:2490384+8*49152].view(cp.float64)
        v34 = v8[2883600:2883600+4*24576].view(cp.int32)
        v30[:] = 0
        del v30
        v32[:] = 0
        del v32
        v34[:] = 0
        del v34
        v35 = 63
        v36 = US3_0()
        v37 = US7_0()
        v38 = 25264128
        v39 = 2981904
        return method117(v35, v36, v7, v1, v37, v9, v38, v8, v39)
    return inner
def method3(v0 : object) -> None:
    assert v0 == [], f'Expected an unit type. Got: {v0}'
    del v0
    return 
def method2(v0 : object) -> US1:
    v1 = v0[0] # type: ignore
    v2 = v0[1] # type: ignore
    del v0
    v3 = "Call" == v1
    if v3:
        del v1, v3
        method3(v2)
        del v2
        return US1_0()
    else:
        del v3
        v5 = "Fold" == v1
        if v5:
            del v1, v5
            method3(v2)
            del v2
            return US1_1()
        else:
            del v5
            v7 = "Raise" == v1
            if v7:
                del v1, v7
                method3(v2)
                del v2
                return US1_2()
            else:
                del v2, v7
                raise TypeError(f"Cannot convert the Python object into a Spiral union type. Invalid string tag. Got: {v1}")
                del v1
                raise Exception("Error")
def method5(v0 : i32, v1 : i32) -> bool:
    v2 = v1 < v0
    del v0, v1
    return v2
def method6(v0 : object) -> US2:
    v1 = v0[0] # type: ignore
    v2 = v0[1] # type: ignore
    del v0
    v3 = "Computer" == v1
    if v3:
        del v1, v3
        method3(v2)
        del v2
        return US2_0()
    else:
        del v3
        v5 = "Human" == v1
        if v5:
            del v1, v5
            method3(v2)
            del v2
            return US2_1()
        else:
            del v5
            v7 = "Random" == v1
            if v7:
                del v1, v7
                method3(v2)
                del v2
                return US2_2()
            else:
                del v2, v7
                raise TypeError(f"Cannot convert the Python object into a Spiral union type. Invalid string tag. Got: {v1}")
                del v1
                raise Exception("Error")
def method4(v0 : object) -> static_array:
    assert isinstance(v0,list), f'The object needs to be a Python list. Got: {v0}'
    v1 = len(v0) # type: ignore
    v2 = 2 == v1
    v3 = v2 == False
    if v3:
        v4 = "The type level dimension has to equal the value passed at runtime into create."
        assert v2, v4
        del v4
    else:
        pass
    del v2, v3
    v6 = static_array(2)
    v7 = 0
    while method5(v1, v7):
        v9 = v0[v7]
        v10 = method6(v9)
        del v9
        v6[v7] = v10
        del v10
        v7 += 1 
    del v0, v1, v7
    return v6
def method1(v0 : object) -> US0:
    v1 = v0[0] # type: ignore
    v2 = v0[1] # type: ignore
    del v0
    v3 = "ActionSelected" == v1
    if v3:
        del v1, v3
        v4 = method2(v2)
        del v2
        return US0_0(v4)
    else:
        del v3
        v6 = "PlayerChanged" == v1
        if v6:
            del v1, v6
            v7 = method4(v2)
            del v2
            return US0_1(v7)
        else:
            del v6
            v9 = "StartGame" == v1
            if v9:
                del v1, v9
                method3(v2)
                del v2
                return US0_2()
            else:
                del v9
                v11 = "StartTrainingVsRando" == v1
                if v11:
                    del v1, v11
                    method3(v2)
                    del v2
                    return US0_3()
                else:
                    del v11
                    v13 = "StartTrainingVsSelf" == v1
                    if v13:
                        del v1, v13
                        method3(v2)
                        del v2
                        return US0_4()
                    else:
                        del v2, v13
                        raise TypeError(f"Cannot convert the Python object into a Spiral union type. Invalid string tag. Got: {v1}")
                        del v1
                        raise Exception("Error")
def method0(v0 : object) -> US0:
    return method1(v0)
def method12(v0 : object) -> u32:
    assert isinstance(v0,u32), f'The object needs to be the right primitive type. Got: {v0}'
    v1 = v0
    del v0
    return v1
def method11(v0 : object) -> u32:
    v1 = method12(v0)
    del v0
    return v1
def method17(v0 : object) -> US6:
    v1 = v0[0] # type: ignore
    v2 = v0[1] # type: ignore
    del v0
    v3 = "Jack" == v1
    if v3:
        del v1, v3
        method3(v2)
        del v2
        return US6_0()
    else:
        del v3
        v5 = "King" == v1
        if v5:
            del v1, v5
            method3(v2)
            del v2
            return US6_1()
        else:
            del v5
            v7 = "Queen" == v1
            if v7:
                del v1, v7
                method3(v2)
                del v2
                return US6_2()
            else:
                del v2, v7
                raise TypeError(f"Cannot convert the Python object into a Spiral union type. Invalid string tag. Got: {v1}")
                del v1
                raise Exception("Error")
def method16(v0 : object) -> US5:
    v1 = v0[0] # type: ignore
    v2 = v0[1] # type: ignore
    del v0
    v3 = "None" == v1
    if v3:
        del v1, v3
        method3(v2)
        del v2
        return US5_0()
    else:
        del v3
        v5 = "Some" == v1
        if v5:
            del v1, v5
            v6 = method17(v2)
            del v2
            return US5_1(v6)
        else:
            del v2, v5
            raise TypeError(f"Cannot convert the Python object into a Spiral union type. Invalid string tag. Got: {v1}")
            del v1
            raise Exception("Error")
def method18(v0 : object) -> bool:
    assert isinstance(v0,bool), f'The object needs to be the right primitive type. Got: {v0}'
    v1 = v0
    del v0
    return v1
def method19(v0 : object) -> static_array:
    assert isinstance(v0,list), f'The object needs to be a Python list. Got: {v0}'
    v1 = len(v0) # type: ignore
    v2 = 2 == v1
    v3 = v2 == False
    if v3:
        v4 = "The type level dimension has to equal the value passed at runtime into create."
        assert v2, v4
        del v4
    else:
        pass
    del v2, v3
    v6 = static_array(2)
    v7 = 0
    while method5(v1, v7):
        v9 = v0[v7]
        v10 = method17(v9)
        del v9
        v6[v7] = v10
        del v10
        v7 += 1 
    del v0, v1, v7
    return v6
def method20(v0 : object) -> i32:
    assert isinstance(v0,i32), f'The object needs to be the right primitive type. Got: {v0}'
    v1 = v0
    del v0
    return v1
def method21(v0 : object) -> static_array:
    assert isinstance(v0,list), f'The object needs to be a Python list. Got: {v0}'
    v1 = len(v0) # type: ignore
    v2 = 2 == v1
    v3 = v2 == False
    if v3:
        v4 = "The type level dimension has to equal the value passed at runtime into create."
        assert v2, v4
        del v4
    else:
        pass
    del v2, v3
    v6 = static_array(2)
    v7 = 0
    while method5(v1, v7):
        v9 = v0[v7]
        v10 = method20(v9)
        del v9
        v6[v7] = v10
        del v10
        v7 += 1 
    del v0, v1, v7
    return v6
def method15(v0 : object) -> Tuple[US5, bool, static_array, i32, static_array, i32]:
    v1 = v0["community_card"] # type: ignore
    v2 = method16(v1)
    del v1
    v3 = v0["is_button_s_first_move"] # type: ignore
    v4 = method18(v3)
    del v3
    v5 = v0["pl_card"] # type: ignore
    v6 = method19(v5)
    del v5
    v7 = v0["player_turn"] # type: ignore
    v8 = method20(v7)
    del v7
    v9 = v0["pot"] # type: ignore
    v10 = method21(v9)
    del v9
    v11 = v0["raises_left"] # type: ignore
    del v0
    v12 = method20(v11)
    del v11
    return v2, v4, v6, v8, v10, v12
def method22(v0 : object) -> Tuple[US5, bool, static_array, i32, static_array, i32, US1]:
    v1 = v0[0] # type: ignore
    v2, v3, v4, v5, v6, v7 = method15(v1)
    del v1
    v8 = v0[1] # type: ignore
    del v0
    v9 = method2(v8)
    del v8
    return v2, v3, v4, v5, v6, v7, v9
def method14(v0 : object) -> US4:
    v1 = v0[0] # type: ignore
    v2 = v0[1] # type: ignore
    del v0
    v3 = "ChanceCommunityCard" == v1
    if v3:
        del v1, v3
        v4, v5, v6, v7, v8, v9 = method15(v2)
        del v2
        return US4_0(v4, v5, v6, v7, v8, v9)
    else:
        del v3
        v11 = "ChanceInit" == v1
        if v11:
            del v1, v11
            method3(v2)
            del v2
            return US4_1()
        else:
            del v11
            v13 = "Round" == v1
            if v13:
                del v1, v13
                v14, v15, v16, v17, v18, v19 = method15(v2)
                del v2
                return US4_2(v14, v15, v16, v17, v18, v19)
            else:
                del v13
                v21 = "RoundWithAction" == v1
                if v21:
                    del v1, v21
                    v22, v23, v24, v25, v26, v27, v28 = method22(v2)
                    del v2
                    return US4_3(v22, v23, v24, v25, v26, v27, v28)
                else:
                    del v21
                    v30 = "TerminalCall" == v1
                    if v30:
                        del v1, v30
                        v31, v32, v33, v34, v35, v36 = method15(v2)
                        del v2
                        return US4_4(v31, v32, v33, v34, v35, v36)
                    else:
                        del v30
                        v38 = "TerminalFold" == v1
                        if v38:
                            del v1, v38
                            v39, v40, v41, v42, v43, v44 = method15(v2)
                            del v2
                            return US4_5(v39, v40, v41, v42, v43, v44)
                        else:
                            del v2, v38
                            raise TypeError(f"Cannot convert the Python object into a Spiral union type. Invalid string tag. Got: {v1}")
                            del v1
                            raise Exception("Error")
def method13(v0 : object) -> US3:
    v1 = v0[0] # type: ignore
    v2 = v0[1] # type: ignore
    del v0
    v3 = "None" == v1
    if v3:
        del v1, v3
        method3(v2)
        del v2
        return US3_0()
    else:
        del v3
        v5 = "Some" == v1
        if v5:
            del v1, v5
            v6 = method14(v2)
            del v2
            return US3_1(v6)
        else:
            del v2, v5
            raise TypeError(f"Cannot convert the Python object into a Spiral union type. Invalid string tag. Got: {v1}")
            del v1
            raise Exception("Error")
def method10(v0 : object) -> Tuple[u32, US3]:
    v1 = v0["deck"] # type: ignore
    v2 = method11(v1)
    del v1
    v3 = v0["game"] # type: ignore
    del v0
    v4 = method13(v3)
    del v3
    return v2, v4
def method26(v0 : object) -> Tuple[i32, US1]:
    v1 = v0[0] # type: ignore
    v2 = method20(v1)
    del v1
    v3 = v0[1] # type: ignore
    del v0
    v4 = method2(v3)
    del v3
    return v2, v4
def method27(v0 : object) -> Tuple[i32, US6]:
    v1 = v0[0] # type: ignore
    v2 = method20(v1)
    del v1
    v3 = v0[1] # type: ignore
    del v0
    v4 = method17(v3)
    del v3
    return v2, v4
def method28(v0 : object) -> Tuple[static_array, i32, i32]:
    v1 = v0["cards_shown"] # type: ignore
    v2 = method19(v1)
    del v1
    v3 = v0["chips_won"] # type: ignore
    v4 = method20(v3)
    del v3
    v5 = v0["winner_id"] # type: ignore
    del v0
    v6 = method20(v5)
    del v5
    return v2, v4, v6
def method25(v0 : object) -> US8:
    v1 = v0[0] # type: ignore
    v2 = v0[1] # type: ignore
    del v0
    v3 = "CommunityCardIs" == v1
    if v3:
        del v1, v3
        v4 = method17(v2)
        del v2
        return US8_0(v4)
    else:
        del v3
        v6 = "PlayerAction" == v1
        if v6:
            del v1, v6
            v7, v8 = method26(v2)
            del v2
            return US8_1(v7, v8)
        else:
            del v6
            v10 = "PlayerGotCard" == v1
            if v10:
                del v1, v10
                v11, v12 = method27(v2)
                del v2
                return US8_2(v11, v12)
            else:
                del v10
                v14 = "Showdown" == v1
                if v14:
                    del v1, v14
                    v15, v16, v17 = method28(v2)
                    del v2
                    return US8_3(v15, v16, v17)
                else:
                    del v2, v14
                    raise TypeError(f"Cannot convert the Python object into a Spiral union type. Invalid string tag. Got: {v1}")
                    del v1
                    raise Exception("Error")
def method24(v0 : object) -> static_array_list:
    v1 = len(v0) # type: ignore
    assert (32 >= v1), f'The length of the original object has to be greater than or equal to the static array dimension.\nExpected: 32\nGot: {v1} '
    del v1
    assert isinstance(v0,list), f'The object needs to be a Python list. Got: {v0}'
    v2 = len(v0) # type: ignore
    v3 = 32 >= v2
    v4 = v3 == False
    if v4:
        v5 = "The type level dimension has to equal the value passed at runtime into create."
        assert v3, v5
        del v5
    else:
        pass
    del v3, v4
    v7 = static_array_list(32)
    v7.unsafe_set_length(v2)
    v8 = 0
    while method5(v2, v8):
        v10 = v0[v8]
        v11 = method25(v10)
        del v10
        v7[v8] = v11
        del v11
        v8 += 1 
    del v0, v2, v8
    return v7
def method29(v0 : object) -> US7:
    v1 = v0[0] # type: ignore
    v2 = v0[1] # type: ignore
    del v0
    v3 = "GameNotStarted" == v1
    if v3:
        del v1, v3
        method3(v2)
        del v2
        return US7_0()
    else:
        del v3
        v5 = "GameOver" == v1
        if v5:
            del v1, v5
            v6, v7, v8, v9, v10, v11 = method15(v2)
            del v2
            return US7_1(v6, v7, v8, v9, v10, v11)
        else:
            del v5
            v13 = "WaitingForActionFromPlayerId" == v1
            if v13:
                del v1, v13
                v14, v15, v16, v17, v18, v19 = method15(v2)
                del v2
                return US7_2(v14, v15, v16, v17, v18, v19)
            else:
                del v2, v13
                raise TypeError(f"Cannot convert the Python object into a Spiral union type. Invalid string tag. Got: {v1}")
                del v1
                raise Exception("Error")
def method23(v0 : object) -> Tuple[static_array_list, static_array, US7]:
    v1 = v0["messages"] # type: ignore
    v2 = method24(v1)
    del v1
    v3 = v0["pl_type"] # type: ignore
    v4 = method4(v3)
    del v3
    v5 = v0["ui_game_state"] # type: ignore
    del v0
    v6 = method29(v5)
    del v5
    return v2, v4, v6
def method9(v0 : object) -> Tuple[u32, US3, static_array_list, static_array, US7]:
    v1 = v0["private"] # type: ignore
    v2, v3 = method10(v1)
    del v1
    v4 = v0["public"] # type: ignore
    del v0
    v5, v6, v7 = method23(v4)
    del v4
    return v2, v3, v5, v6, v7
def method35(v0 : object) -> cp.ndarray:
    assert isinstance(v0,cp.ndarray), f'The object needs to be the right primitive type. Got: {v0}'
    v1 = v0
    del v0
    return v1
def method34(v0 : object) -> cp.ndarray:
    v1 = method35(v0)
    del v0
    return v1
def method36(v0 : object) -> u64:
    assert isinstance(v0,u64), f'The object needs to be the right primitive type. Got: {v0}'
    v1 = v0
    del v0
    return v1
def method33(v0 : object) -> Tuple[cp.ndarray, u64]:
    v1 = v0[0] # type: ignore
    v2 = method34(v1)
    del v1
    v3 = v0[1] # type: ignore
    del v0
    v4 = method36(v3)
    del v3
    return v2, v4
def method32(v0 : object) -> Tuple[cp.ndarray, u64, cp.ndarray, u64]:
    v1 = v0["output"] # type: ignore
    v2, v3 = method33(v1)
    del v1
    v4 = v0["param"] # type: ignore
    del v0
    v5, v6 = method33(v4)
    del v4
    return v2, v3, v5, v6
def method31(v0 : object) -> Tuple[cp.ndarray, u64, cp.ndarray, u64]:
    v1, v2, v3, v4 = method32(v0)
    del v0
    return v1, v2, v3, v4
def method30(v0 : object) -> Tuple[cp.ndarray, u64, cp.ndarray, u64]:
    v1 = v0["model_ptrs"] # type: ignore
    del v0
    v2, v3, v4, v5 = method31(v1)
    del v1
    return v2, v3, v4, v5
def method8(v0 : object) -> Tuple[u32, US3, static_array_list, static_array, US7, cp.ndarray, u64, cp.ndarray, u64]:
    v1 = v0["game"] # type: ignore
    v2, v3, v4, v5, v6 = method9(v1)
    del v1
    v7 = v0["neural"] # type: ignore
    del v0
    v8, v9, v10, v11 = method30(v7)
    del v7
    return v2, v3, v4, v5, v6, v8, v9, v10, v11
def method7(v0 : object) -> Tuple[u32, US3, static_array_list, static_array, US7, cp.ndarray, u64, cp.ndarray, u64]:
    return method8(v0)
def method38(v0 : cp.ndarray, v1 : u32) -> None:
    v3 = v0[0:].view(cp.uint32)
    del v0
    v3[0] = v1
    del v1, v3
    return 
def method39(v0 : cp.ndarray, v1 : i32) -> None:
    v3 = v0[4:].view(cp.int32)
    del v0
    v3[0] = v1
    del v1, v3
    return 
def method40(v0 : cp.ndarray) -> None:
    del v0
    return 
def method42(v0 : cp.ndarray, v1 : i32) -> None:
    v3 = v0[0:].view(cp.int32)
    del v0
    v3[0] = v1
    del v1, v3
    return 
def method44(v0 : cp.ndarray, v1 : US6) -> None:
    v2 = v1.tag
    method42(v0, v2)
    del v2
    v4 = v0[4:].view(cp.uint8)
    del v0
    match v1:
        case US6_0(): # Jack
            del v1
            return method40(v4)
        case US6_1(): # King
            del v1
            return method40(v4)
        case US6_2(): # Queen
            del v1
            return method40(v4)
        case t:
            raise Exception(f'Pattern matching miss. Got: {t}')
def method45(v0 : i32) -> bool:
    v1 = v0 < 2
    del v0
    return v1
def method43(v0 : cp.ndarray, v1 : US5, v2 : bool, v3 : static_array, v4 : i32, v5 : static_array, v6 : i32) -> None:
    v7 = v1.tag
    method42(v0, v7)
    del v7
    v9 = v0[4:].view(cp.uint8)
    match v1:
        case US5_0(): # None
            method40(v9)
        case US5_1(v10): # Some
            method44(v9, v10)
        case t:
            raise Exception(f'Pattern matching miss. Got: {t}')
    del v1, v9
    v12 = v0[8:].view(cp.bool_)
    v12[0] = v2
    del v2, v12
    v13 = 0
    while method45(v13):
        v15 = u64(v13)
        v16 = v15 * 4
        del v15
        v17 = 12 + v16
        del v16
        v19 = v0[v17:].view(cp.uint8)
        del v17
        v20 = 0 <= v13
        if v20:
            v21 = v13 < 2
            v22 = v21
        else:
            v22 = False
        del v20
        v23 = v22 == False
        if v23:
            v24 = "Index must be in range."
            assert v22, v24
            del v24
        else:
            pass
        del v22, v23
        v26 = v3[v13]
        method44(v19, v26)
        del v19, v26
        v13 += 1 
    del v3, v13
    v28 = v0[20:].view(cp.int32)
    v28[0] = v4
    del v4, v28
    v29 = 0
    while method45(v29):
        v31 = u64(v29)
        v32 = v31 * 4
        del v31
        v33 = 24 + v32
        del v32
        v35 = v0[v33:].view(cp.uint8)
        del v33
        v36 = 0 <= v29
        if v36:
            v37 = v29 < 2
            v38 = v37
        else:
            v38 = False
        del v36
        v39 = v38 == False
        if v39:
            v40 = "Index must be in range."
            assert v38, v40
            del v40
        else:
            pass
        del v38, v39
        v42 = v5[v29]
        method42(v35, v42)
        del v35, v42
        v29 += 1 
    del v5, v29
    v44 = v0[32:].view(cp.int32)
    del v0
    v44[0] = v6
    del v6, v44
    return 
def method47(v0 : cp.ndarray, v1 : i32) -> None:
    v3 = v0[36:].view(cp.int32)
    del v0
    v3[0] = v1
    del v1, v3
    return 
def method46(v0 : cp.ndarray, v1 : US5, v2 : bool, v3 : static_array, v4 : i32, v5 : static_array, v6 : i32, v7 : US1) -> None:
    v8 = v1.tag
    method42(v0, v8)
    del v8
    v10 = v0[4:].view(cp.uint8)
    match v1:
        case US5_0(): # None
            method40(v10)
        case US5_1(v11): # Some
            method44(v10, v11)
        case t:
            raise Exception(f'Pattern matching miss. Got: {t}')
    del v1, v10
    v13 = v0[8:].view(cp.bool_)
    v13[0] = v2
    del v2, v13
    v14 = 0
    while method45(v14):
        v16 = u64(v14)
        v17 = v16 * 4
        del v16
        v18 = 12 + v17
        del v17
        v20 = v0[v18:].view(cp.uint8)
        del v18
        v21 = 0 <= v14
        if v21:
            v22 = v14 < 2
            v23 = v22
        else:
            v23 = False
        del v21
        v24 = v23 == False
        if v24:
            v25 = "Index must be in range."
            assert v23, v25
            del v25
        else:
            pass
        del v23, v24
        v27 = v3[v14]
        method44(v20, v27)
        del v20, v27
        v14 += 1 
    del v3, v14
    v29 = v0[20:].view(cp.int32)
    v29[0] = v4
    del v4, v29
    v30 = 0
    while method45(v30):
        v32 = u64(v30)
        v33 = v32 * 4
        del v32
        v34 = 24 + v33
        del v33
        v36 = v0[v34:].view(cp.uint8)
        del v34
        v37 = 0 <= v30
        if v37:
            v38 = v30 < 2
            v39 = v38
        else:
            v39 = False
        del v37
        v40 = v39 == False
        if v40:
            v41 = "Index must be in range."
            assert v39, v41
            del v41
        else:
            pass
        del v39, v40
        v43 = v5[v30]
        method42(v36, v43)
        del v36, v43
        v30 += 1 
    del v5, v30
    v45 = v0[32:].view(cp.int32)
    v45[0] = v6
    del v6, v45
    v46 = v7.tag
    method47(v0, v46)
    del v46
    v48 = v0[40:].view(cp.uint8)
    del v0
    match v7:
        case US1_0(): # Call
            del v7
            return method40(v48)
        case US1_1(): # Fold
            del v7
            return method40(v48)
        case US1_2(): # Raise
            del v7
            return method40(v48)
        case t:
            raise Exception(f'Pattern matching miss. Got: {t}')
def method41(v0 : cp.ndarray, v1 : US4) -> None:
    v2 = v1.tag
    method42(v0, v2)
    del v2
    v4 = v0[16:].view(cp.uint8)
    del v0
    match v1:
        case US4_0(v5, v6, v7, v8, v9, v10): # ChanceCommunityCard
            del v1
            return method43(v4, v5, v6, v7, v8, v9, v10)
        case US4_1(): # ChanceInit
            del v1
            return method40(v4)
        case US4_2(v11, v12, v13, v14, v15, v16): # Round
            del v1
            return method43(v4, v11, v12, v13, v14, v15, v16)
        case US4_3(v17, v18, v19, v20, v21, v22, v23): # RoundWithAction
            del v1
            return method46(v4, v17, v18, v19, v20, v21, v22, v23)
        case US4_4(v24, v25, v26, v27, v28, v29): # TerminalCall
            del v1
            return method43(v4, v24, v25, v26, v27, v28, v29)
        case US4_5(v30, v31, v32, v33, v34, v35): # TerminalFold
            del v1
            return method43(v4, v30, v31, v32, v33, v34, v35)
        case t:
            raise Exception(f'Pattern matching miss. Got: {t}')
def method48(v0 : cp.ndarray, v1 : i32) -> None:
    v3 = v0[80:].view(cp.int32)
    del v0
    v3[0] = v1
    del v1, v3
    return 
def method50(v0 : cp.ndarray, v1 : i32, v2 : US1) -> None:
    v4 = v0[0:].view(cp.int32)
    v4[0] = v1
    del v1, v4
    v5 = v2.tag
    method39(v0, v5)
    del v5
    v7 = v0[8:].view(cp.uint8)
    del v0
    match v2:
        case US1_0(): # Call
            del v2
            return method40(v7)
        case US1_1(): # Fold
            del v2
            return method40(v7)
        case US1_2(): # Raise
            del v2
            return method40(v7)
        case t:
            raise Exception(f'Pattern matching miss. Got: {t}')
def method51(v0 : cp.ndarray, v1 : i32, v2 : US6) -> None:
    v4 = v0[0:].view(cp.int32)
    v4[0] = v1
    del v1, v4
    v5 = v2.tag
    method39(v0, v5)
    del v5
    v7 = v0[8:].view(cp.uint8)
    del v0
    match v2:
        case US6_0(): # Jack
            del v2
            return method40(v7)
        case US6_1(): # King
            del v2
            return method40(v7)
        case US6_2(): # Queen
            del v2
            return method40(v7)
        case t:
            raise Exception(f'Pattern matching miss. Got: {t}')
def method52(v0 : cp.ndarray, v1 : static_array, v2 : i32, v3 : i32) -> None:
    v4 = 0
    while method45(v4):
        v6 = u64(v4)
        v7 = v6 * 4
        del v6
        v9 = v0[v7:].view(cp.uint8)
        del v7
        v10 = 0 <= v4
        if v10:
            v11 = v4 < 2
            v12 = v11
        else:
            v12 = False
        del v10
        v13 = v12 == False
        if v13:
            v14 = "Index must be in range."
            assert v12, v14
            del v14
        else:
            pass
        del v12, v13
        v16 = v1[v4]
        method44(v9, v16)
        del v9, v16
        v4 += 1 
    del v1, v4
    v18 = v0[8:].view(cp.int32)
    v18[0] = v2
    del v2, v18
    v20 = v0[12:].view(cp.int32)
    del v0
    v20[0] = v3
    del v3, v20
    return 
def method49(v0 : cp.ndarray, v1 : US8) -> None:
    v2 = v1.tag
    method42(v0, v2)
    del v2
    v4 = v0[16:].view(cp.uint8)
    del v0
    match v1:
        case US8_0(v5): # CommunityCardIs
            del v1
            return method44(v4, v5)
        case US8_1(v6, v7): # PlayerAction
            del v1
            return method50(v4, v6, v7)
        case US8_2(v8, v9): # PlayerGotCard
            del v1
            return method51(v4, v8, v9)
        case US8_3(v10, v11, v12): # Showdown
            del v1
            return method52(v4, v10, v11, v12)
        case t:
            raise Exception(f'Pattern matching miss. Got: {t}')
def method53(v0 : cp.ndarray, v1 : US2) -> None:
    v2 = v1.tag
    method42(v0, v2)
    del v2
    v4 = v0[4:].view(cp.uint8)
    del v0
    match v1:
        case US2_0(): # Computer
            del v1
            return method40(v4)
        case US2_1(): # Human
            del v1
            return method40(v4)
        case US2_2(): # Random
            del v1
            return method40(v4)
        case t:
            raise Exception(f'Pattern matching miss. Got: {t}')
def method54(v0 : cp.ndarray, v1 : i32) -> None:
    v3 = v0[1128:].view(cp.int32)
    del v0
    v3[0] = v1
    del v1, v3
    return 
def method37(v0 : cp.ndarray, v1 : u32, v2 : US3, v3 : static_array_list, v4 : static_array, v5 : US7) -> None:
    method38(v0, v1)
    del v1
    v6 = v2.tag
    method39(v0, v6)
    del v6
    v8 = v0[16:].view(cp.uint8)
    match v2:
        case US3_0(): # None
            method40(v8)
        case US3_1(v9): # Some
            method41(v8, v9)
        case t:
            raise Exception(f'Pattern matching miss. Got: {t}')
    del v2, v8
    v10 = v3.length
    method48(v0, v10)
    del v10
    v11 = v3.length
    v12 = 0
    while method5(v11, v12):
        v14 = u64(v12)
        v15 = v14 * 32
        del v14
        v16 = 96 + v15
        del v15
        v18 = v0[v16:].view(cp.uint8)
        del v16
        v20 = v3[v12]
        method49(v18, v20)
        del v18, v20
        v12 += 1 
    del v3, v11, v12
    v21 = 0
    while method45(v21):
        v23 = u64(v21)
        v24 = v23 * 4
        del v23
        v25 = 1120 + v24
        del v24
        v27 = v0[v25:].view(cp.uint8)
        del v25
        v28 = 0 <= v21
        if v28:
            v29 = v21 < 2
            v30 = v29
        else:
            v30 = False
        del v28
        v31 = v30 == False
        if v31:
            v32 = "Index must be in range."
            assert v30, v32
            del v32
        else:
            pass
        del v30, v31
        v34 = v4[v21]
        method53(v27, v34)
        del v27, v34
        v21 += 1 
    del v4, v21
    v35 = v5.tag
    method54(v0, v35)
    del v35
    v37 = v0[1136:].view(cp.uint8)
    del v0
    match v5:
        case US7_0(): # GameNotStarted
            del v5
            return method40(v37)
        case US7_1(v38, v39, v40, v41, v42, v43): # GameOver
            del v5
            return method43(v37, v38, v39, v40, v41, v42, v43)
        case US7_2(v44, v45, v46, v47, v48, v49): # WaitingForActionFromPlayerId
            del v5
            return method43(v37, v44, v45, v46, v47, v48, v49)
        case t:
            raise Exception(f'Pattern matching miss. Got: {t}')
def method56(v0 : cp.ndarray, v1 : US1) -> None:
    v2 = v1.tag
    method42(v0, v2)
    del v2
    v4 = v0[4:].view(cp.uint8)
    del v0
    match v1:
        case US1_0(): # Call
            del v1
            return method40(v4)
        case US1_1(): # Fold
            del v1
            return method40(v4)
        case US1_2(): # Raise
            del v1
            return method40(v4)
        case t:
            raise Exception(f'Pattern matching miss. Got: {t}')
def method57(v0 : cp.ndarray, v1 : static_array) -> None:
    v2 = 0
    while method45(v2):
        v4 = u64(v2)
        v5 = v4 * 4
        del v4
        v7 = v0[v5:].view(cp.uint8)
        del v5
        v8 = 0 <= v2
        if v8:
            v9 = v2 < 2
            v10 = v9
        else:
            v10 = False
        del v8
        v11 = v10 == False
        if v11:
            v12 = "Index must be in range."
            assert v10, v12
            del v12
        else:
            pass
        del v10, v11
        v14 = v1[v2]
        method53(v7, v14)
        del v7, v14
        v2 += 1 
    del v0, v1, v2
    return 
def method55(v0 : cp.ndarray, v1 : US0) -> None:
    v2 = v1.tag
    method42(v0, v2)
    del v2
    v4 = v0[8:].view(cp.uint8)
    del v0
    match v1:
        case US0_0(v5): # ActionSelected
            del v1
            return method56(v4, v5)
        case US0_1(v6): # PlayerChanged
            del v1
            return method57(v4, v6)
        case US0_2(): # StartGame
            del v1
            return method40(v4)
        case US0_3(): # StartTrainingVsRando
            del v1
            return method40(v4)
        case US0_4(): # StartTrainingVsSelf
            del v1
            return method40(v4)
        case t:
            raise Exception(f'Pattern matching miss. Got: {t}')
def method58(v0 : i32) -> bool:
    v1 = v0 < 4
    del v0
    return v1
def method59(v0 : i32) -> bool:
    v1 = v0 < 32
    del v0
    return v1
def method61(v0 : cp.ndarray) -> u32:
    v2 = v0[0:].view(cp.uint32)
    del v0
    v3 = v2[0].item()
    del v2
    return v3
def method62(v0 : cp.ndarray) -> i32:
    v2 = v0[4:].view(cp.int32)
    del v0
    v3 = v2[0].item()
    del v2
    return v3
def method63(v0 : cp.ndarray) -> None:
    del v0
    return 
def method65(v0 : cp.ndarray) -> i32:
    v2 = v0[0:].view(cp.int32)
    del v0
    v3 = v2[0].item()
    del v2
    return v3
def method67(v0 : cp.ndarray) -> US6:
    v1 = method65(v0)
    v3 = v0[4:].view(cp.uint8)
    del v0
    if v1 == 0:
        del v1
        method63(v3)
        del v3
        return US6_0()
    elif v1 == 1:
        del v1
        method63(v3)
        del v3
        return US6_1()
    elif v1 == 2:
        del v1
        method63(v3)
        del v3
        return US6_2()
    else:
        del v1, v3
        raise Exception("Invalid tag.")
def method66(v0 : cp.ndarray) -> Tuple[US5, bool, static_array, i32, static_array, i32]:
    v1 = method65(v0)
    v3 = v0[4:].view(cp.uint8)
    if v1 == 0:
        method63(v3)
        v8 = US5_0()
    elif v1 == 1:
        v6 = method67(v3)
        v8 = US5_1(v6)
    else:
        raise Exception("Invalid tag.")
    del v1, v3
    v10 = v0[8:].view(cp.bool_)
    v11 = v10[0].item()
    del v10
    v13 = static_array(2)
    v14 = 0
    while method45(v14):
        v16 = u64(v14)
        v17 = v16 * 4
        del v16
        v18 = 12 + v17
        del v17
        v20 = v0[v18:].view(cp.uint8)
        del v18
        v21 = method67(v20)
        del v20
        v13[v14] = v21
        del v21
        v14 += 1 
    del v14
    v23 = v0[20:].view(cp.int32)
    v24 = v23[0].item()
    del v23
    v26 = static_array(2)
    v27 = 0
    while method45(v27):
        v29 = u64(v27)
        v30 = v29 * 4
        del v29
        v31 = 24 + v30
        del v30
        v33 = v0[v31:].view(cp.uint8)
        del v31
        v34 = method65(v33)
        del v33
        v26[v27] = v34
        del v34
        v27 += 1 
    del v27
    v36 = v0[32:].view(cp.int32)
    del v0
    v37 = v36[0].item()
    del v36
    return v8, v11, v13, v24, v26, v37
def method69(v0 : cp.ndarray) -> i32:
    v2 = v0[36:].view(cp.int32)
    del v0
    v3 = v2[0].item()
    del v2
    return v3
def method68(v0 : cp.ndarray) -> Tuple[US5, bool, static_array, i32, static_array, i32, US1]:
    v1 = method65(v0)
    v3 = v0[4:].view(cp.uint8)
    if v1 == 0:
        method63(v3)
        v8 = US5_0()
    elif v1 == 1:
        v6 = method67(v3)
        v8 = US5_1(v6)
    else:
        raise Exception("Invalid tag.")
    del v1, v3
    v10 = v0[8:].view(cp.bool_)
    v11 = v10[0].item()
    del v10
    v13 = static_array(2)
    v14 = 0
    while method45(v14):
        v16 = u64(v14)
        v17 = v16 * 4
        del v16
        v18 = 12 + v17
        del v17
        v20 = v0[v18:].view(cp.uint8)
        del v18
        v21 = method67(v20)
        del v20
        v13[v14] = v21
        del v21
        v14 += 1 
    del v14
    v23 = v0[20:].view(cp.int32)
    v24 = v23[0].item()
    del v23
    v26 = static_array(2)
    v27 = 0
    while method45(v27):
        v29 = u64(v27)
        v30 = v29 * 4
        del v29
        v31 = 24 + v30
        del v30
        v33 = v0[v31:].view(cp.uint8)
        del v31
        v34 = method65(v33)
        del v33
        v26[v27] = v34
        del v34
        v27 += 1 
    del v27
    v36 = v0[32:].view(cp.int32)
    v37 = v36[0].item()
    del v36
    v38 = method69(v0)
    v40 = v0[40:].view(cp.uint8)
    del v0
    if v38 == 0:
        method63(v40)
        v45 = US1_0()
    elif v38 == 1:
        method63(v40)
        v45 = US1_1()
    elif v38 == 2:
        method63(v40)
        v45 = US1_2()
    else:
        raise Exception("Invalid tag.")
    del v38, v40
    return v8, v11, v13, v24, v26, v37, v45
def method64(v0 : cp.ndarray) -> US4:
    v1 = method65(v0)
    v3 = v0[16:].view(cp.uint8)
    del v0
    if v1 == 0:
        del v1
        v5, v6, v7, v8, v9, v10 = method66(v3)
        del v3
        return US4_0(v5, v6, v7, v8, v9, v10)
    elif v1 == 1:
        del v1
        method63(v3)
        del v3
        return US4_1()
    elif v1 == 2:
        del v1
        v13, v14, v15, v16, v17, v18 = method66(v3)
        del v3
        return US4_2(v13, v14, v15, v16, v17, v18)
    elif v1 == 3:
        del v1
        v20, v21, v22, v23, v24, v25, v26 = method68(v3)
        del v3
        return US4_3(v20, v21, v22, v23, v24, v25, v26)
    elif v1 == 4:
        del v1
        v28, v29, v30, v31, v32, v33 = method66(v3)
        del v3
        return US4_4(v28, v29, v30, v31, v32, v33)
    elif v1 == 5:
        del v1
        v35, v36, v37, v38, v39, v40 = method66(v3)
        del v3
        return US4_5(v35, v36, v37, v38, v39, v40)
    else:
        del v1, v3
        raise Exception("Invalid tag.")
def method70(v0 : cp.ndarray) -> i32:
    v2 = v0[80:].view(cp.int32)
    del v0
    v3 = v2[0].item()
    del v2
    return v3
def method72(v0 : cp.ndarray) -> Tuple[i32, US1]:
    v2 = v0[0:].view(cp.int32)
    v3 = v2[0].item()
    del v2
    v4 = method62(v0)
    v6 = v0[8:].view(cp.uint8)
    del v0
    if v4 == 0:
        method63(v6)
        v11 = US1_0()
    elif v4 == 1:
        method63(v6)
        v11 = US1_1()
    elif v4 == 2:
        method63(v6)
        v11 = US1_2()
    else:
        raise Exception("Invalid tag.")
    del v4, v6
    return v3, v11
def method73(v0 : cp.ndarray) -> Tuple[i32, US6]:
    v2 = v0[0:].view(cp.int32)
    v3 = v2[0].item()
    del v2
    v4 = method62(v0)
    v6 = v0[8:].view(cp.uint8)
    del v0
    if v4 == 0:
        method63(v6)
        v11 = US6_0()
    elif v4 == 1:
        method63(v6)
        v11 = US6_1()
    elif v4 == 2:
        method63(v6)
        v11 = US6_2()
    else:
        raise Exception("Invalid tag.")
    del v4, v6
    return v3, v11
def method74(v0 : cp.ndarray) -> Tuple[static_array, i32, i32]:
    v2 = static_array(2)
    v3 = 0
    while method45(v3):
        v5 = u64(v3)
        v6 = v5 * 4
        del v5
        v8 = v0[v6:].view(cp.uint8)
        del v6
        v9 = method67(v8)
        del v8
        v2[v3] = v9
        del v9
        v3 += 1 
    del v3
    v11 = v0[8:].view(cp.int32)
    v12 = v11[0].item()
    del v11
    v14 = v0[12:].view(cp.int32)
    del v0
    v15 = v14[0].item()
    del v14
    return v2, v12, v15
def method71(v0 : cp.ndarray) -> US8:
    v1 = method65(v0)
    v3 = v0[16:].view(cp.uint8)
    del v0
    if v1 == 0:
        del v1
        v5 = method67(v3)
        del v3
        return US8_0(v5)
    elif v1 == 1:
        del v1
        v7, v8 = method72(v3)
        del v3
        return US8_1(v7, v8)
    elif v1 == 2:
        del v1
        v10, v11 = method73(v3)
        del v3
        return US8_2(v10, v11)
    elif v1 == 3:
        del v1
        v13, v14, v15 = method74(v3)
        del v3
        return US8_3(v13, v14, v15)
    else:
        del v1, v3
        raise Exception("Invalid tag.")
def method75(v0 : cp.ndarray) -> US2:
    v1 = method65(v0)
    v3 = v0[4:].view(cp.uint8)
    del v0
    if v1 == 0:
        del v1
        method63(v3)
        del v3
        return US2_0()
    elif v1 == 1:
        del v1
        method63(v3)
        del v3
        return US2_1()
    elif v1 == 2:
        del v1
        method63(v3)
        del v3
        return US2_2()
    else:
        del v1, v3
        raise Exception("Invalid tag.")
def method76(v0 : cp.ndarray) -> i32:
    v2 = v0[1128:].view(cp.int32)
    del v0
    v3 = v2[0].item()
    del v2
    return v3
def method60(v0 : cp.ndarray) -> Tuple[u32, US3, static_array_list, static_array, US7]:
    v1 = method61(v0)
    v2 = method62(v0)
    v4 = v0[16:].view(cp.uint8)
    if v2 == 0:
        method63(v4)
        v9 = US3_0()
    elif v2 == 1:
        v7 = method64(v4)
        v9 = US3_1(v7)
    else:
        raise Exception("Invalid tag.")
    del v2, v4
    v11 = static_array_list(32)
    v12 = method70(v0)
    v11.unsafe_set_length(v12)
    del v12
    v13 = v11.length
    v14 = 0
    while method5(v13, v14):
        v16 = u64(v14)
        v17 = v16 * 32
        del v16
        v18 = 96 + v17
        del v17
        v20 = v0[v18:].view(cp.uint8)
        del v18
        v21 = method71(v20)
        del v20
        v11[v14] = v21
        del v21
        v14 += 1 
    del v13, v14
    v23 = static_array(2)
    v24 = 0
    while method45(v24):
        v26 = u64(v24)
        v27 = v26 * 4
        del v26
        v28 = 1120 + v27
        del v27
        v30 = v0[v28:].view(cp.uint8)
        del v28
        v31 = method75(v30)
        del v30
        v23[v24] = v31
        del v31
        v24 += 1 
    del v24
    v32 = method76(v0)
    v34 = v0[1136:].view(cp.uint8)
    del v0
    if v32 == 0:
        method63(v34)
        v51 = US7_0()
    elif v32 == 1:
        v37, v38, v39, v40, v41, v42 = method66(v34)
        v51 = US7_1(v37, v38, v39, v40, v41, v42)
    elif v32 == 2:
        v44, v45, v46, v47, v48, v49 = method66(v34)
        v51 = US7_2(v44, v45, v46, v47, v48, v49)
    else:
        raise Exception("Invalid tag.")
    del v32, v34
    return v1, v9, v11, v23, v51
def method83(v0 : u32) -> object:
    v1 = v0
    del v0
    return v1
def method82(v0 : u32) -> object:
    return method83(v0)
def method85() -> object:
    v0 = []
    return v0
def method89(v0 : US6) -> object:
    match v0:
        case US6_0(): # Jack
            del v0
            v1 = method85()
            v2 = "Jack"
            v3 = [v2,v1]
            del v1, v2
            return v3
        case US6_1(): # King
            del v0
            v4 = method85()
            v5 = "King"
            v6 = [v5,v4]
            del v4, v5
            return v6
        case US6_2(): # Queen
            del v0
            v7 = method85()
            v8 = "Queen"
            v9 = [v8,v7]
            del v7, v8
            return v9
        case t:
            raise Exception(f'Pattern matching miss. Got: {t}')
def method88(v0 : US5) -> object:
    match v0:
        case US5_0(): # None
            del v0
            v1 = method85()
            v2 = "None"
            v3 = [v2,v1]
            del v1, v2
            return v3
        case US5_1(v4): # Some
            del v0
            v5 = method89(v4)
            del v4
            v6 = "Some"
            v7 = [v6,v5]
            del v5, v6
            return v7
        case t:
            raise Exception(f'Pattern matching miss. Got: {t}')
def method90(v0 : bool) -> object:
    v1 = v0
    del v0
    return v1
def method91(v0 : static_array) -> object:
    v1 = []
    v2 = 0
    while method45(v2):
        v4 = 0 <= v2
        if v4:
            v5 = v2 < 2
            v6 = v5
        else:
            v6 = False
        del v4
        v7 = v6 == False
        if v7:
            v8 = "Index must be in range."
            assert v6, v8
            del v8
        else:
            pass
        del v6, v7
        v10 = v0[v2]
        v11 = method89(v10)
        del v10
        v1.append(v11)
        del v11
        v2 += 1 
    del v0, v2
    return v1
def method92(v0 : i32) -> object:
    v1 = v0
    del v0
    return v1
def method93(v0 : static_array) -> object:
    v1 = []
    v2 = 0
    while method45(v2):
        v4 = 0 <= v2
        if v4:
            v5 = v2 < 2
            v6 = v5
        else:
            v6 = False
        del v4
        v7 = v6 == False
        if v7:
            v8 = "Index must be in range."
            assert v6, v8
            del v8
        else:
            pass
        del v6, v7
        v10 = v0[v2]
        v11 = method92(v10)
        del v10
        v1.append(v11)
        del v11
        v2 += 1 
    del v0, v2
    return v1
def method87(v0 : US5, v1 : bool, v2 : static_array, v3 : i32, v4 : static_array, v5 : i32) -> object:
    v6 = method88(v0)
    del v0
    v7 = method90(v1)
    del v1
    v8 = method91(v2)
    del v2
    v9 = method92(v3)
    del v3
    v10 = method93(v4)
    del v4
    v11 = method92(v5)
    del v5
    v12 = {'community_card': v6, 'is_button_s_first_move': v7, 'pl_card': v8, 'player_turn': v9, 'pot': v10, 'raises_left': v11}
    del v6, v7, v8, v9, v10, v11
    return v12
def method95(v0 : US1) -> object:
    match v0:
        case US1_0(): # Call
            del v0
            v1 = method85()
            v2 = "Call"
            v3 = [v2,v1]
            del v1, v2
            return v3
        case US1_1(): # Fold
            del v0
            v4 = method85()
            v5 = "Fold"
            v6 = [v5,v4]
            del v4, v5
            return v6
        case US1_2(): # Raise
            del v0
            v7 = method85()
            v8 = "Raise"
            v9 = [v8,v7]
            del v7, v8
            return v9
        case t:
            raise Exception(f'Pattern matching miss. Got: {t}')
def method94(v0 : US5, v1 : bool, v2 : static_array, v3 : i32, v4 : static_array, v5 : i32, v6 : US1) -> object:
    v7 = []
    v8 = method87(v0, v1, v2, v3, v4, v5)
    del v0, v1, v2, v3, v4, v5
    v7.append(v8)
    del v8
    v9 = method95(v6)
    del v6
    v7.append(v9)
    del v9
    v10 = v7
    del v7
    return v10
def method86(v0 : US4) -> object:
    match v0:
        case US4_0(v1, v2, v3, v4, v5, v6): # ChanceCommunityCard
            del v0
            v7 = method87(v1, v2, v3, v4, v5, v6)
            del v1, v2, v3, v4, v5, v6
            v8 = "ChanceCommunityCard"
            v9 = [v8,v7]
            del v7, v8
            return v9
        case US4_1(): # ChanceInit
            del v0
            v10 = method85()
            v11 = "ChanceInit"
            v12 = [v11,v10]
            del v10, v11
            return v12
        case US4_2(v13, v14, v15, v16, v17, v18): # Round
            del v0
            v19 = method87(v13, v14, v15, v16, v17, v18)
            del v13, v14, v15, v16, v17, v18
            v20 = "Round"
            v21 = [v20,v19]
            del v19, v20
            return v21
        case US4_3(v22, v23, v24, v25, v26, v27, v28): # RoundWithAction
            del v0
            v29 = method94(v22, v23, v24, v25, v26, v27, v28)
            del v22, v23, v24, v25, v26, v27, v28
            v30 = "RoundWithAction"
            v31 = [v30,v29]
            del v29, v30
            return v31
        case US4_4(v32, v33, v34, v35, v36, v37): # TerminalCall
            del v0
            v38 = method87(v32, v33, v34, v35, v36, v37)
            del v32, v33, v34, v35, v36, v37
            v39 = "TerminalCall"
            v40 = [v39,v38]
            del v38, v39
            return v40
        case US4_5(v41, v42, v43, v44, v45, v46): # TerminalFold
            del v0
            v47 = method87(v41, v42, v43, v44, v45, v46)
            del v41, v42, v43, v44, v45, v46
            v48 = "TerminalFold"
            v49 = [v48,v47]
            del v47, v48
            return v49
        case t:
            raise Exception(f'Pattern matching miss. Got: {t}')
def method84(v0 : US3) -> object:
    match v0:
        case US3_0(): # None
            del v0
            v1 = method85()
            v2 = "None"
            v3 = [v2,v1]
            del v1, v2
            return v3
        case US3_1(v4): # Some
            del v0
            v5 = method86(v4)
            del v4
            v6 = "Some"
            v7 = [v6,v5]
            del v5, v6
            return v7
        case t:
            raise Exception(f'Pattern matching miss. Got: {t}')
def method81(v0 : u32, v1 : US3) -> object:
    v2 = method82(v0)
    del v0
    v3 = method84(v1)
    del v1
    v4 = {'deck': v2, 'game': v3}
    del v2, v3
    return v4
def method99(v0 : i32, v1 : US1) -> object:
    v2 = []
    v3 = method92(v0)
    del v0
    v2.append(v3)
    del v3
    v4 = method95(v1)
    del v1
    v2.append(v4)
    del v4
    v5 = v2
    del v2
    return v5
def method100(v0 : i32, v1 : US6) -> object:
    v2 = []
    v3 = method92(v0)
    del v0
    v2.append(v3)
    del v3
    v4 = method89(v1)
    del v1
    v2.append(v4)
    del v4
    v5 = v2
    del v2
    return v5
def method101(v0 : static_array, v1 : i32, v2 : i32) -> object:
    v3 = method91(v0)
    del v0
    v4 = method92(v1)
    del v1
    v5 = method92(v2)
    del v2
    v6 = {'cards_shown': v3, 'chips_won': v4, 'winner_id': v5}
    del v3, v4, v5
    return v6
def method98(v0 : US8) -> object:
    match v0:
        case US8_0(v1): # CommunityCardIs
            del v0
            v2 = method89(v1)
            del v1
            v3 = "CommunityCardIs"
            v4 = [v3,v2]
            del v2, v3
            return v4
        case US8_1(v5, v6): # PlayerAction
            del v0
            v7 = method99(v5, v6)
            del v5, v6
            v8 = "PlayerAction"
            v9 = [v8,v7]
            del v7, v8
            return v9
        case US8_2(v10, v11): # PlayerGotCard
            del v0
            v12 = method100(v10, v11)
            del v10, v11
            v13 = "PlayerGotCard"
            v14 = [v13,v12]
            del v12, v13
            return v14
        case US8_3(v15, v16, v17): # Showdown
            del v0
            v18 = method101(v15, v16, v17)
            del v15, v16, v17
            v19 = "Showdown"
            v20 = [v19,v18]
            del v18, v19
            return v20
        case t:
            raise Exception(f'Pattern matching miss. Got: {t}')
def method97(v0 : static_array_list) -> object:
    v1 = []
    v2 = v0.length
    v3 = 0
    while method5(v2, v3):
        v6 = v0[v3]
        v7 = method98(v6)
        del v6
        v1.append(v7)
        del v7
        v3 += 1 
    del v0, v2, v3
    return v1
def method103(v0 : US2) -> object:
    match v0:
        case US2_0(): # Computer
            del v0
            v1 = method85()
            v2 = "Computer"
            v3 = [v2,v1]
            del v1, v2
            return v3
        case US2_1(): # Human
            del v0
            v4 = method85()
            v5 = "Human"
            v6 = [v5,v4]
            del v4, v5
            return v6
        case US2_2(): # Random
            del v0
            v7 = method85()
            v8 = "Random"
            v9 = [v8,v7]
            del v7, v8
            return v9
        case t:
            raise Exception(f'Pattern matching miss. Got: {t}')
def method102(v0 : static_array) -> object:
    v1 = []
    v2 = 0
    while method45(v2):
        v4 = 0 <= v2
        if v4:
            v5 = v2 < 2
            v6 = v5
        else:
            v6 = False
        del v4
        v7 = v6 == False
        if v7:
            v8 = "Index must be in range."
            assert v6, v8
            del v8
        else:
            pass
        del v6, v7
        v10 = v0[v2]
        v11 = method103(v10)
        del v10
        v1.append(v11)
        del v11
        v2 += 1 
    del v0, v2
    return v1
def method104(v0 : US7) -> object:
    match v0:
        case US7_0(): # GameNotStarted
            del v0
            v1 = method85()
            v2 = "GameNotStarted"
            v3 = [v2,v1]
            del v1, v2
            return v3
        case US7_1(v4, v5, v6, v7, v8, v9): # GameOver
            del v0
            v10 = method87(v4, v5, v6, v7, v8, v9)
            del v4, v5, v6, v7, v8, v9
            v11 = "GameOver"
            v12 = [v11,v10]
            del v10, v11
            return v12
        case US7_2(v13, v14, v15, v16, v17, v18): # WaitingForActionFromPlayerId
            del v0
            v19 = method87(v13, v14, v15, v16, v17, v18)
            del v13, v14, v15, v16, v17, v18
            v20 = "WaitingForActionFromPlayerId"
            v21 = [v20,v19]
            del v19, v20
            return v21
        case t:
            raise Exception(f'Pattern matching miss. Got: {t}')
def method96(v0 : static_array_list, v1 : static_array, v2 : US7) -> object:
    v3 = method97(v0)
    del v0
    v4 = method102(v1)
    del v1
    v5 = method104(v2)
    del v2
    v6 = {'messages': v3, 'pl_type': v4, 'ui_game_state': v5}
    del v3, v4, v5
    return v6
def method80(v0 : u32, v1 : US3, v2 : static_array_list, v3 : static_array, v4 : US7) -> object:
    v5 = method81(v0, v1)
    del v0, v1
    v6 = method96(v2, v3, v4)
    del v2, v3, v4
    v7 = {'private': v5, 'public': v6}
    del v5, v6
    return v7
def method110(v0 : cp.ndarray) -> object:
    v1 = v0
    del v0
    return v1
def method109(v0 : cp.ndarray) -> object:
    return method110(v0)
def method111(v0 : u64) -> object:
    v1 = v0
    del v0
    return v1
def method108(v0 : cp.ndarray, v1 : u64) -> object:
    v2 = []
    v3 = method109(v0)
    del v0
    v2.append(v3)
    del v3
    v4 = method111(v1)
    del v1
    v2.append(v4)
    del v4
    v5 = v2
    del v2
    return v5
def method107(v0 : cp.ndarray, v1 : u64, v2 : cp.ndarray, v3 : u64) -> object:
    v4 = method108(v0, v1)
    del v0, v1
    v5 = method108(v2, v3)
    del v2, v3
    v6 = {'output': v4, 'param': v5}
    del v4, v5
    return v6
def method106(v0 : cp.ndarray, v1 : u64, v2 : cp.ndarray, v3 : u64) -> object:
    return method107(v0, v1, v2, v3)
def method105(v0 : cp.ndarray, v1 : u64, v2 : cp.ndarray, v3 : u64) -> object:
    v4 = method106(v0, v1, v2, v3)
    del v0, v1, v2, v3
    v5 = {'model_ptrs': v4}
    del v4
    return v5
def method79(v0 : u32, v1 : US3, v2 : static_array_list, v3 : static_array, v4 : US7, v5 : cp.ndarray, v6 : u64, v7 : cp.ndarray, v8 : u64) -> object:
    v9 = method80(v0, v1, v2, v3, v4)
    del v0, v1, v2, v3, v4
    v10 = method105(v5, v6, v7, v8)
    del v5, v6, v7, v8
    v11 = {'game': v9, 'neural': v10}
    del v9, v10
    return v11
def method116(v0 : f32) -> object:
    v1 = v0
    del v0
    return v1
def method115(v0 : list) -> object:
    v1 = []
    v2 = len(v0)
    v3 = 0
    while method5(v2, v3):
        v5 = v0[v3]
        v6 = method116(v5)
        del v5
        v1.append(v6)
        del v6
        v3 += 1 
    del v0, v2, v3
    return v1
def method114(v0 : list) -> object:
    v1 = []
    v2 = len(v0)
    v3 = 0
    while method5(v2, v3):
        v5 = v0[v3]
        v6 = method115(v5)
        del v5
        v1.append(v6)
        del v6
        v3 += 1 
    del v0, v2, v3
    return v1
def method113(v0 : US9) -> object:
    match v0:
        case US9_0(v1): # AddRewardsRando
            del v0
            v2 = method114(v1)
            del v1
            v3 = "AddRewardsRando"
            v4 = [v3,v2]
            del v2, v3
            return v4
        case US9_1(v5): # AddRewardsSelf
            del v0
            v6 = method114(v5)
            del v5
            v7 = "AddRewardsSelf"
            v8 = [v7,v6]
            del v6, v7
            return v8
        case t:
            raise Exception(f'Pattern matching miss. Got: {t}')
def method112(v0 : list) -> object:
    v1 = []
    v2 = len(v0)
    v3 = 0
    while method5(v2, v3):
        v5 = v0[v3]
        v6 = method113(v5)
        del v5
        v1.append(v6)
        del v6
        v3 += 1 
    del v0, v2, v3
    return v1
def method78(v0 : u32, v1 : US3, v2 : static_array_list, v3 : static_array, v4 : US7, v5 : cp.ndarray, v6 : u64, v7 : cp.ndarray, v8 : u64, v9 : list) -> object:
    v10 = []
    v11 = method79(v0, v1, v2, v3, v4, v5, v6, v7, v8)
    del v0, v1, v2, v3, v4, v5, v6, v7, v8
    v10.append(v11)
    del v11
    v12 = method112(v9)
    del v9
    v10.append(v12)
    del v12
    v13 = v10
    del v10
    return v13
def method77(v0 : u32, v1 : US3, v2 : static_array_list, v3 : static_array, v4 : US7, v5 : cp.ndarray, v6 : u64, v7 : cp.ndarray, v8 : u64, v9 : list) -> object:
    v10 = method78(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9)
    del v0, v1, v2, v3, v4, v5, v6, v7, v8, v9
    return v10
def method117(v0 : u32, v1 : US3, v2 : static_array_list, v3 : static_array, v4 : US7, v5 : cp.ndarray, v6 : u64, v7 : cp.ndarray, v8 : u64) -> object:
    v9 = method79(v0, v1, v2, v3, v4, v5, v6, v7, v8)
    del v0, v1, v2, v3, v4, v5, v6, v7, v8
    return v9
def main_body():
    v0 = Closure0()
    v1 = Closure1()
    v2 = collections.namedtuple("Leduc_Full",['event_loop_gpu', 'init'])(v0, v1)
    del v0, v1
    return v2

def main():
    r = main_body()
    cp.cuda.get_current_stream().synchronize() # This line is here so the `__trap()` calls on the kernel aren't missed.
    return r

if __name__ == '__main__': print(main())
