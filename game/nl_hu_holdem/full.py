kernel = r"""
#include <new>
#include <assert.h>
#include <stdio.h>
#include <curand_kernel.h>
#include <mma.h>
using namespace nvcuda;
#include <cuda/pipeline>
#include <cooperative_groups/memcpy_async.h>
#include <cooperative_groups.h>
#include <cooperative_groups/reduce.h>
#include <cooperative_groups/scan.h>
#include <cuda/semaphore>
__device__ cuda::binary_semaphore<cuda::thread_scope_system> console_lock(1);
using default_int = int;
using default_uint = unsigned int;
template <typename el>
struct sptr // Shared pointer for the Spiral datatypes. They have to have the refc field inside them to work.
{
    el* base;

    __device__ sptr() : base(nullptr) {}
    __device__ sptr(el* ptr) : base(ptr) { this->base->refc++; }

    __device__ ~sptr()
    {
        if (this->base != nullptr && --this->base->refc == 0)
        {
            delete this->base;
            this->base = nullptr;
        }
    }

    __device__ sptr(sptr& x)
    {
        this->base = x.base;
        this->base->refc++;
    }

    __device__ sptr(sptr&& x)
    {
        this->base = x.base;
        x.base = nullptr;
    }

    __device__ sptr& operator=(sptr& x)
    {
        if (this->base != x.base)
        {
            delete this->base;
            this->base = x.base;
            this->base->refc++;
        }
        return *this;
    }

    __device__ sptr& operator=(sptr&& x)
    {
        if (this->base != x.base)
        {
            delete this->base;
            this->base = x.base;
            x.base = nullptr;
        }
        return *this;
    }
};

template <typename el>
struct csptr : public sptr<el>
{ // Shared pointer for closures specifically.
    using sptr<el>::sptr;
    template <typename... Args>
    __device__ auto operator()(Args... args) -> decltype(this->base->operator()(args...))
    {
        return this->base->operator()(args...);
    }
};

template <typename el, default_int max_length>
struct static_array
{
    el ptr[max_length];
    __device__ el& operator[](default_int i) {
        assert("The index has to be in range." && 0 <= i && i < max_length);
        return this->ptr[i];
    }
};

template <typename el, default_int max_length>
struct static_array_list
{
    default_int length{ 0 };
    el ptr[max_length];

    __device__ el& operator[](default_int i) {
        assert("The index has to be in range." && 0 <= i && i < this->length);
        return this->ptr[i];
    }
    __device__ void push(el& x) {
        ptr[this->length++] = x;
        assert("The array after pushing should not be greater than max length." && this->length <= max_length);
    }
    __device__ void push(el&& x) {
        ptr[this->length++] = std::move(x);
        assert("The array after pushing should not be greater than max length." && this->length <= max_length);
    }
    __device__ el pop() {
        assert("The array before popping should be greater than 0." && 0 < this->length);
        auto x = ptr[--this->length];
        ptr[this->length].~el();
        new (&ptr[this->length]) el();
        return x;
    }
    // Should be used only during initialization.
    __device__ void unsafe_set_length(default_int i) {
        assert("The new length should be in range." && 0 <= i && i <= max_length);
        this->length = i;
    }
};

template <typename el, default_int max_length>
struct dynamic_array_base
{
    int refc{ 0 };
    el* ptr;

    __device__ dynamic_array_base() : ptr(new el[max_length]) {}
    __device__ ~dynamic_array_base() { delete[] this->ptr; }

    __device__ el& operator[](default_int i) {
        assert("The index has to be in range." && 0 <= i && i < this->length);
        return this->ptr[i];
    }
};

template <typename el, default_int max_length>
struct dynamic_array
{
    sptr<dynamic_array_base<el, max_length>> ptr;

    __device__ dynamic_array() = default;
    __device__ dynamic_array(bool t) : ptr(new dynamic_array_base<el, max_length>()) {}
    __device__ el& operator[](default_int i) {
        return this->ptr.base->operator[](i);
    }
};

template <typename el, default_int max_length>
struct dynamic_array_list_base
{
    int refc{ 0 };
    default_int length{ 0 };
    el* ptr;

    __device__ dynamic_array_list_base() : ptr(new el[max_length]) {}
    __device__ dynamic_array_list_base(default_int l) : ptr(new el[max_length]) { this->unsafe_set_length(l); }
    __device__ ~dynamic_array_list_base() { delete[] this->ptr; }

    __device__ el& operator[](default_int i) {
        assert("The index has to be in range." && 0 <= i && i < this->length);
        return this->ptr[i];
    }
    __device__ void push(el& x) {
        ptr[this->length++] = x;
        assert("The array after pushing should not be greater than max length." && this->length <= max_length);
    }
    __device__ void push(el&& x) {
        ptr[this->length++] = std::move(x);
        assert("The array after pushing should not be greater than max length." && this->length <= max_length);
    }
    __device__ el pop() {
        assert("The array before popping should be greater than 0." && 0 < this->length);
        auto x = ptr[--this->length];
        ptr[this->length].~el();
        new (&ptr[this->length]) el();
        return x;
    }
    // Should be used only during initialization.
    __device__ void unsafe_set_length(default_int i) {
        assert("The new length should be in range." && 0 <= i && i <= max_length);
        this->length = i;
    }
};

template <typename el, default_int max_length>
struct dynamic_array_list
{
    sptr<dynamic_array_list_base<el, max_length>> ptr;

    __device__ dynamic_array_list() = default;
    __device__ dynamic_array_list(default_int l) : ptr(new dynamic_array_list_base<el, max_length>(l)) {}

    __device__ el& operator[](default_int i) {
        return this->ptr.base->operator[](i);
    }
    __device__ void push(el& x) {
        this->ptr.base->push(x);
    }
    __device__ void push(el&& x) {
        this->ptr.base->push(std::move(x));
    }
    __device__ el pop() {
        return this->ptr.base->pop();
    }
    // Should be used only during initialization.
    __device__ void unsafe_set_length(default_int i) {
        this->ptr.base->unsafe_set_length(i);
    }
    __device__ default_int length_() {
        return this->ptr.base->length;
    }
};

struct Union1;
struct Union2;
struct Union0;
__device__ int f_1(unsigned char * v0);
__device__ void f_3(unsigned char * v0);
__device__ Union1 f_2(unsigned char * v0);
__device__ Union2 f_5(unsigned char * v0);
__device__ static_array<Union2,2> f_4(unsigned char * v0);
__device__ Union0 f_0(unsigned char * v0);
struct Union5;
struct Union4;
struct Union3;
struct Tuple0;
struct Union6;
struct Union7;
struct Tuple1;
__device__ unsigned long long f_7(unsigned char * v0);
__device__ int f_8(unsigned char * v0);
struct Tuple2;
__device__ unsigned char f_13(unsigned char * v0);
__device__ unsigned char f_12(unsigned char * v0);
__device__ static_array<unsigned char,2> f_11(unsigned char * v0);
__device__ int f_14(unsigned char * v0);
__device__ static_array<unsigned char,3> f_15(unsigned char * v0);
__device__ static_array<unsigned char,5> f_16(unsigned char * v0);
__device__ static_array<unsigned char,4> f_17(unsigned char * v0);
__device__ Tuple2 f_10(unsigned char * v0);
struct Tuple3;
__device__ int f_19(unsigned char * v0);
__device__ Tuple3 f_18(unsigned char * v0);
__device__ Union4 f_9(unsigned char * v0);
__device__ int f_20(unsigned char * v0);
__device__ static_array_list<unsigned char,5> f_22(unsigned char * v0);
struct Tuple4;
__device__ Tuple4 f_23(unsigned char * v0);
struct Tuple5;
__device__ int f_25(unsigned char * v0);
__device__ Tuple5 f_24(unsigned char * v0);
struct Tuple6;
__device__ Tuple6 f_26(unsigned char * v0);
struct Tuple7;
__device__ Tuple0 f_29(unsigned char * v0);
__device__ Tuple0 f_28(unsigned char * v0);
__device__ Tuple7 f_27(unsigned char * v0);
__device__ Union6 f_21(unsigned char * v0);
__device__ int f_30(unsigned char * v0);
__device__ Tuple1 f_6(unsigned char * v0);
struct StackMut0;
struct Tuple8;
struct Tuple9;
struct Tuple10;
__device__ unsigned int loop_34(unsigned int v0, curandStatePhilox4_32_10_t & v1);
__device__ Tuple10 draw_card_33(curandStatePhilox4_32_10_t & v0, unsigned long long v1);
__device__ Tuple8 draw_cards_32(curandStatePhilox4_32_10_t & v0, unsigned long long v1);
__device__ static_array_list<unsigned char,5> get_community_cards_35(Union5 v0, static_array<unsigned char,3> v1);
__device__ bool player_can_act_37(int v0, static_array<static_array<unsigned char,2>,2> v1, static_array<int,2> v2, int v3, static_array<int,2> v4, Union5 v5);
__device__ Union4 go_next_street_38(int v0, static_array<static_array<unsigned char,2>,2> v1, static_array<int,2> v2, int v3, static_array<int,2> v4, Union5 v5);
__device__ Union4 try_round_36(int v0, static_array<static_array<unsigned char,2>,2> v1, static_array<int,2> v2, int v3, static_array<int,2> v4, Union5 v5);
struct Tuple11;
__device__ Tuple11 draw_cards_39(curandStatePhilox4_32_10_t & v0, unsigned long long v1);
struct Tuple12;
__device__ Tuple12 draw_cards_40(curandStatePhilox4_32_10_t & v0, unsigned long long v1);
__device__ static_array_list<unsigned char,5> get_community_cards_41(Union5 v0, static_array<unsigned char,1> v1);
struct Union8;
struct Tuple13;
__device__ void method_42(unsigned int v0, float * v1, int v2);
__device__ void method_43(unsigned int v0, float * v1, int v2);
__device__ int int_range_44(int v0, int v1, curandStatePhilox4_32_10_t & v2);
struct Union9;
__device__ void block_matmul_45(float * v0, float * v1, int v2, float * v3);
__device__ void block_map_46(float * v0, float * v1);
__device__ void block_matmul_47(float * v0, float * v1, int v2, float * v3);
__device__ void block_matmul_48(float * v0, float * v1, int v2, float * v3);
__device__ void block_row_map_49(float * v0, int v1, float * v2);
struct Tuple14;
struct Tuple15;
struct Tuple16;
struct Union10;
struct Tuple17;
__device__ int loop_53(static_array<float,6> v0, float v1, int v2);
__device__ int pick_discrete__52(static_array<float,6> v0, float v1);
__device__ int sample_discrete__51(static_array<float,6> v0, curandStatePhilox4_32_10_t & v1);
__device__ Union1 sample_discrete_50(static_array<Tuple17,6> v0, curandStatePhilox4_32_10_t & v1);
struct Tuple18;
struct Tuple19;
struct Union11;
struct Tuple20;
struct Union12;
struct Tuple21;
struct Tuple22;
struct Union13;
struct Union14;
struct Union15;
struct Union16;
struct Union17;
__device__ Tuple0 score_54(static_array<unsigned char,7> v0);
__device__ void play_loop_31(unsigned char * v0, unsigned char * v1, unsigned char * v2, StackMut0 & v3, Union4 v4);
__device__ void f_56(unsigned char * v0, unsigned long long v1);
__device__ void f_57(unsigned char * v0, int v1);
__device__ void f_58(unsigned char * v0);
__device__ void f_60(unsigned char * v0, int v1);
__device__ void f_64(unsigned char * v0, unsigned char v1);
__device__ void f_63(unsigned char * v0, unsigned char v1);
__device__ void f_62(unsigned char * v0, static_array<unsigned char,2> v1);
__device__ void f_65(unsigned char * v0, int v1);
__device__ void f_66(unsigned char * v0, static_array<unsigned char,3> v1);
__device__ void f_67(unsigned char * v0, static_array<unsigned char,5> v1);
__device__ void f_68(unsigned char * v0, static_array<unsigned char,4> v1);
__device__ void f_61(unsigned char * v0, int v1, static_array<static_array<unsigned char,2>,2> v2, static_array<int,2> v3, int v4, static_array<int,2> v5, Union5 v6);
__device__ void f_70(unsigned char * v0, int v1);
__device__ void f_69(unsigned char * v0, int v1, static_array<static_array<unsigned char,2>,2> v2, static_array<int,2> v3, int v4, static_array<int,2> v5, Union5 v6, Union1 v7);
__device__ void f_59(unsigned char * v0, Union4 v1);
__device__ void f_71(unsigned char * v0, int v1);
__device__ void f_73(unsigned char * v0, static_array_list<unsigned char,5> v1);
__device__ void f_74(unsigned char * v0, int v1, int v2);
__device__ void f_76(unsigned char * v0, int v1);
__device__ void f_75(unsigned char * v0, int v1, Union1 v2);
__device__ void f_77(unsigned char * v0, int v1, static_array<unsigned char,2> v2);
__device__ void f_80(unsigned char * v0, static_array<unsigned char,5> v1, char v2);
__device__ void f_79(unsigned char * v0, static_array<unsigned char,5> v1, char v2);
__device__ void f_78(unsigned char * v0, int v1, static_array<Tuple0,2> v2, int v3);
__device__ void f_72(unsigned char * v0, Union6 v1);
__device__ void f_81(unsigned char * v0, Union2 v1);
__device__ void f_82(unsigned char * v0, int v1);
__device__ void f_55(unsigned char * v0, unsigned long long v1, Union3 v2, static_array_list<Union6,128> v3, static_array<Union2,2> v4, Union7 v5);
struct StackMut1;
struct Union18;
__device__ static_array_list<unsigned char,5> get_community_cards_84(Union5 v0, static_array<unsigned char,3> v1);
__device__ static_array_list<unsigned char,5> get_community_cards_85(Union5 v0, static_array<unsigned char,1> v1);
__device__ void method_83(unsigned char * v0, unsigned char * v1, unsigned char * v2, StackMut1 & v3, int v4, Union4 v5);
struct Tuple23;
struct Tuple24;
struct Tuple25;
__device__ void method_86(unsigned char * v0, unsigned char * v1, unsigned char * v2, StackMut1 & v3, Union4 v4);
__device__ void method_87(unsigned char * v0, unsigned char * v1, unsigned char * v2, StackMut1 & v3, Union4 v4);
struct Union1_0 { // A_All_In
};
struct Union1_1 { // A_Call
};
struct Union1_2 { // A_Fold
};
struct Union1_3 { // A_Raise
    int v0;
    __device__ Union1_3(int t0) : v0(t0) {}
    __device__ Union1_3() = delete;
};
struct Union1 {
    union {
        Union1_0 case0; // A_All_In
        Union1_1 case1; // A_Call
        Union1_2 case2; // A_Fold
        Union1_3 case3; // A_Raise
    };
    unsigned char tag{255};
    __device__ Union1() {}
    __device__ Union1(Union1_0 t) : tag(0), case0(t) {} // A_All_In
    __device__ Union1(Union1_1 t) : tag(1), case1(t) {} // A_Call
    __device__ Union1(Union1_2 t) : tag(2), case2(t) {} // A_Fold
    __device__ Union1(Union1_3 t) : tag(3), case3(t) {} // A_Raise
    __device__ Union1(Union1 & x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union1_0(x.case0); break; // A_All_In
            case 1: new (&this->case1) Union1_1(x.case1); break; // A_Call
            case 2: new (&this->case2) Union1_2(x.case2); break; // A_Fold
            case 3: new (&this->case3) Union1_3(x.case3); break; // A_Raise
        }
    }
    __device__ Union1(Union1 && x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union1_0(std::move(x.case0)); break; // A_All_In
            case 1: new (&this->case1) Union1_1(std::move(x.case1)); break; // A_Call
            case 2: new (&this->case2) Union1_2(std::move(x.case2)); break; // A_Fold
            case 3: new (&this->case3) Union1_3(std::move(x.case3)); break; // A_Raise
        }
    }
    __device__ Union1 & operator=(Union1 & x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = x.case0; break; // A_All_In
                case 1: this->case1 = x.case1; break; // A_Call
                case 2: this->case2 = x.case2; break; // A_Fold
                case 3: this->case3 = x.case3; break; // A_Raise
            }
        } else {
            this->~Union1();
            new (this) Union1{x};
        }
        return *this;
    }
    __device__ Union1 & operator=(Union1 && x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = std::move(x.case0); break; // A_All_In
                case 1: this->case1 = std::move(x.case1); break; // A_Call
                case 2: this->case2 = std::move(x.case2); break; // A_Fold
                case 3: this->case3 = std::move(x.case3); break; // A_Raise
            }
        } else {
            this->~Union1();
            new (this) Union1{std::move(x)};
        }
        return *this;
    }
    __device__ ~Union1() {
        switch(this->tag){
            case 0: this->case0.~Union1_0(); break; // A_All_In
            case 1: this->case1.~Union1_1(); break; // A_Call
            case 2: this->case2.~Union1_2(); break; // A_Fold
            case 3: this->case3.~Union1_3(); break; // A_Raise
        }
        this->tag = 255;
    }
};
struct Union2_0 { // CallingMachine
};
struct Union2_1 { // Computer
};
struct Union2_2 { // Human
};
struct Union2_3 { // Random
};
struct Union2 {
    union {
        Union2_0 case0; // CallingMachine
        Union2_1 case1; // Computer
        Union2_2 case2; // Human
        Union2_3 case3; // Random
    };
    unsigned char tag{255};
    __device__ Union2() {}
    __device__ Union2(Union2_0 t) : tag(0), case0(t) {} // CallingMachine
    __device__ Union2(Union2_1 t) : tag(1), case1(t) {} // Computer
    __device__ Union2(Union2_2 t) : tag(2), case2(t) {} // Human
    __device__ Union2(Union2_3 t) : tag(3), case3(t) {} // Random
    __device__ Union2(Union2 & x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union2_0(x.case0); break; // CallingMachine
            case 1: new (&this->case1) Union2_1(x.case1); break; // Computer
            case 2: new (&this->case2) Union2_2(x.case2); break; // Human
            case 3: new (&this->case3) Union2_3(x.case3); break; // Random
        }
    }
    __device__ Union2(Union2 && x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union2_0(std::move(x.case0)); break; // CallingMachine
            case 1: new (&this->case1) Union2_1(std::move(x.case1)); break; // Computer
            case 2: new (&this->case2) Union2_2(std::move(x.case2)); break; // Human
            case 3: new (&this->case3) Union2_3(std::move(x.case3)); break; // Random
        }
    }
    __device__ Union2 & operator=(Union2 & x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = x.case0; break; // CallingMachine
                case 1: this->case1 = x.case1; break; // Computer
                case 2: this->case2 = x.case2; break; // Human
                case 3: this->case3 = x.case3; break; // Random
            }
        } else {
            this->~Union2();
            new (this) Union2{x};
        }
        return *this;
    }
    __device__ Union2 & operator=(Union2 && x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = std::move(x.case0); break; // CallingMachine
                case 1: this->case1 = std::move(x.case1); break; // Computer
                case 2: this->case2 = std::move(x.case2); break; // Human
                case 3: this->case3 = std::move(x.case3); break; // Random
            }
        } else {
            this->~Union2();
            new (this) Union2{std::move(x)};
        }
        return *this;
    }
    __device__ ~Union2() {
        switch(this->tag){
            case 0: this->case0.~Union2_0(); break; // CallingMachine
            case 1: this->case1.~Union2_1(); break; // Computer
            case 2: this->case2.~Union2_2(); break; // Human
            case 3: this->case3.~Union2_3(); break; // Random
        }
        this->tag = 255;
    }
};
struct Union0_0 { // ActionSelected
    Union1 v0;
    __device__ Union0_0(Union1 t0) : v0(t0) {}
    __device__ Union0_0() = delete;
};
struct Union0_1 { // PlayerChanged
    static_array<Union2,2> v0;
    __device__ Union0_1(static_array<Union2,2> t0) : v0(t0) {}
    __device__ Union0_1() = delete;
};
struct Union0_2 { // StartGame
};
struct Union0_3 { // StartTrainingVsCallingMachine
};
struct Union0_4 { // StartTrainingVsSelf
};
struct Union0 {
    union {
        Union0_0 case0; // ActionSelected
        Union0_1 case1; // PlayerChanged
        Union0_2 case2; // StartGame
        Union0_3 case3; // StartTrainingVsCallingMachine
        Union0_4 case4; // StartTrainingVsSelf
    };
    unsigned char tag{255};
    __device__ Union0() {}
    __device__ Union0(Union0_0 t) : tag(0), case0(t) {} // ActionSelected
    __device__ Union0(Union0_1 t) : tag(1), case1(t) {} // PlayerChanged
    __device__ Union0(Union0_2 t) : tag(2), case2(t) {} // StartGame
    __device__ Union0(Union0_3 t) : tag(3), case3(t) {} // StartTrainingVsCallingMachine
    __device__ Union0(Union0_4 t) : tag(4), case4(t) {} // StartTrainingVsSelf
    __device__ Union0(Union0 & x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union0_0(x.case0); break; // ActionSelected
            case 1: new (&this->case1) Union0_1(x.case1); break; // PlayerChanged
            case 2: new (&this->case2) Union0_2(x.case2); break; // StartGame
            case 3: new (&this->case3) Union0_3(x.case3); break; // StartTrainingVsCallingMachine
            case 4: new (&this->case4) Union0_4(x.case4); break; // StartTrainingVsSelf
        }
    }
    __device__ Union0(Union0 && x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union0_0(std::move(x.case0)); break; // ActionSelected
            case 1: new (&this->case1) Union0_1(std::move(x.case1)); break; // PlayerChanged
            case 2: new (&this->case2) Union0_2(std::move(x.case2)); break; // StartGame
            case 3: new (&this->case3) Union0_3(std::move(x.case3)); break; // StartTrainingVsCallingMachine
            case 4: new (&this->case4) Union0_4(std::move(x.case4)); break; // StartTrainingVsSelf
        }
    }
    __device__ Union0 & operator=(Union0 & x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = x.case0; break; // ActionSelected
                case 1: this->case1 = x.case1; break; // PlayerChanged
                case 2: this->case2 = x.case2; break; // StartGame
                case 3: this->case3 = x.case3; break; // StartTrainingVsCallingMachine
                case 4: this->case4 = x.case4; break; // StartTrainingVsSelf
            }
        } else {
            this->~Union0();
            new (this) Union0{x};
        }
        return *this;
    }
    __device__ Union0 & operator=(Union0 && x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = std::move(x.case0); break; // ActionSelected
                case 1: this->case1 = std::move(x.case1); break; // PlayerChanged
                case 2: this->case2 = std::move(x.case2); break; // StartGame
                case 3: this->case3 = std::move(x.case3); break; // StartTrainingVsCallingMachine
                case 4: this->case4 = std::move(x.case4); break; // StartTrainingVsSelf
            }
        } else {
            this->~Union0();
            new (this) Union0{std::move(x)};
        }
        return *this;
    }
    __device__ ~Union0() {
        switch(this->tag){
            case 0: this->case0.~Union0_0(); break; // ActionSelected
            case 1: this->case1.~Union0_1(); break; // PlayerChanged
            case 2: this->case2.~Union0_2(); break; // StartGame
            case 3: this->case3.~Union0_3(); break; // StartTrainingVsCallingMachine
            case 4: this->case4.~Union0_4(); break; // StartTrainingVsSelf
        }
        this->tag = 255;
    }
};
struct Union5_0 { // Flop
    static_array<unsigned char,3> v0;
    __device__ Union5_0(static_array<unsigned char,3> t0) : v0(t0) {}
    __device__ Union5_0() = delete;
};
struct Union5_1 { // Preflop
};
struct Union5_2 { // River
    static_array<unsigned char,5> v0;
    __device__ Union5_2(static_array<unsigned char,5> t0) : v0(t0) {}
    __device__ Union5_2() = delete;
};
struct Union5_3 { // Turn
    static_array<unsigned char,4> v0;
    __device__ Union5_3(static_array<unsigned char,4> t0) : v0(t0) {}
    __device__ Union5_3() = delete;
};
struct Union5 {
    union {
        Union5_0 case0; // Flop
        Union5_1 case1; // Preflop
        Union5_2 case2; // River
        Union5_3 case3; // Turn
    };
    unsigned char tag{255};
    __device__ Union5() {}
    __device__ Union5(Union5_0 t) : tag(0), case0(t) {} // Flop
    __device__ Union5(Union5_1 t) : tag(1), case1(t) {} // Preflop
    __device__ Union5(Union5_2 t) : tag(2), case2(t) {} // River
    __device__ Union5(Union5_3 t) : tag(3), case3(t) {} // Turn
    __device__ Union5(Union5 & x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union5_0(x.case0); break; // Flop
            case 1: new (&this->case1) Union5_1(x.case1); break; // Preflop
            case 2: new (&this->case2) Union5_2(x.case2); break; // River
            case 3: new (&this->case3) Union5_3(x.case3); break; // Turn
        }
    }
    __device__ Union5(Union5 && x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union5_0(std::move(x.case0)); break; // Flop
            case 1: new (&this->case1) Union5_1(std::move(x.case1)); break; // Preflop
            case 2: new (&this->case2) Union5_2(std::move(x.case2)); break; // River
            case 3: new (&this->case3) Union5_3(std::move(x.case3)); break; // Turn
        }
    }
    __device__ Union5 & operator=(Union5 & x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = x.case0; break; // Flop
                case 1: this->case1 = x.case1; break; // Preflop
                case 2: this->case2 = x.case2; break; // River
                case 3: this->case3 = x.case3; break; // Turn
            }
        } else {
            this->~Union5();
            new (this) Union5{x};
        }
        return *this;
    }
    __device__ Union5 & operator=(Union5 && x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = std::move(x.case0); break; // Flop
                case 1: this->case1 = std::move(x.case1); break; // Preflop
                case 2: this->case2 = std::move(x.case2); break; // River
                case 3: this->case3 = std::move(x.case3); break; // Turn
            }
        } else {
            this->~Union5();
            new (this) Union5{std::move(x)};
        }
        return *this;
    }
    __device__ ~Union5() {
        switch(this->tag){
            case 0: this->case0.~Union5_0(); break; // Flop
            case 1: this->case1.~Union5_1(); break; // Preflop
            case 2: this->case2.~Union5_2(); break; // River
            case 3: this->case3.~Union5_3(); break; // Turn
        }
        this->tag = 255;
    }
};
struct Union4_0 { // G_Flop
    static_array<static_array<unsigned char,2>,2> v1;
    static_array<int,2> v2;
    static_array<int,2> v4;
    Union5 v5;
    int v0;
    int v3;
    __device__ Union4_0(int t0, static_array<static_array<unsigned char,2>,2> t1, static_array<int,2> t2, int t3, static_array<int,2> t4, Union5 t5) : v0(t0), v1(t1), v2(t2), v3(t3), v4(t4), v5(t5) {}
    __device__ Union4_0() = delete;
};
struct Union4_1 { // G_Fold
    static_array<static_array<unsigned char,2>,2> v1;
    static_array<int,2> v2;
    static_array<int,2> v4;
    Union5 v5;
    int v0;
    int v3;
    __device__ Union4_1(int t0, static_array<static_array<unsigned char,2>,2> t1, static_array<int,2> t2, int t3, static_array<int,2> t4, Union5 t5) : v0(t0), v1(t1), v2(t2), v3(t3), v4(t4), v5(t5) {}
    __device__ Union4_1() = delete;
};
struct Union4_2 { // G_Preflop
};
struct Union4_3 { // G_River
    static_array<static_array<unsigned char,2>,2> v1;
    static_array<int,2> v2;
    static_array<int,2> v4;
    Union5 v5;
    int v0;
    int v3;
    __device__ Union4_3(int t0, static_array<static_array<unsigned char,2>,2> t1, static_array<int,2> t2, int t3, static_array<int,2> t4, Union5 t5) : v0(t0), v1(t1), v2(t2), v3(t3), v4(t4), v5(t5) {}
    __device__ Union4_3() = delete;
};
struct Union4_4 { // G_Round
    static_array<static_array<unsigned char,2>,2> v1;
    static_array<int,2> v2;
    static_array<int,2> v4;
    Union5 v5;
    int v0;
    int v3;
    __device__ Union4_4(int t0, static_array<static_array<unsigned char,2>,2> t1, static_array<int,2> t2, int t3, static_array<int,2> t4, Union5 t5) : v0(t0), v1(t1), v2(t2), v3(t3), v4(t4), v5(t5) {}
    __device__ Union4_4() = delete;
};
struct Union4_5 { // G_Round'
    static_array<static_array<unsigned char,2>,2> v1;
    static_array<int,2> v2;
    static_array<int,2> v4;
    Union5 v5;
    Union1 v6;
    int v0;
    int v3;
    __device__ Union4_5(int t0, static_array<static_array<unsigned char,2>,2> t1, static_array<int,2> t2, int t3, static_array<int,2> t4, Union5 t5, Union1 t6) : v0(t0), v1(t1), v2(t2), v3(t3), v4(t4), v5(t5), v6(t6) {}
    __device__ Union4_5() = delete;
};
struct Union4_6 { // G_Showdown
    static_array<static_array<unsigned char,2>,2> v1;
    static_array<int,2> v2;
    static_array<int,2> v4;
    Union5 v5;
    int v0;
    int v3;
    __device__ Union4_6(int t0, static_array<static_array<unsigned char,2>,2> t1, static_array<int,2> t2, int t3, static_array<int,2> t4, Union5 t5) : v0(t0), v1(t1), v2(t2), v3(t3), v4(t4), v5(t5) {}
    __device__ Union4_6() = delete;
};
struct Union4_7 { // G_Turn
    static_array<static_array<unsigned char,2>,2> v1;
    static_array<int,2> v2;
    static_array<int,2> v4;
    Union5 v5;
    int v0;
    int v3;
    __device__ Union4_7(int t0, static_array<static_array<unsigned char,2>,2> t1, static_array<int,2> t2, int t3, static_array<int,2> t4, Union5 t5) : v0(t0), v1(t1), v2(t2), v3(t3), v4(t4), v5(t5) {}
    __device__ Union4_7() = delete;
};
struct Union4 {
    union {
        Union4_0 case0; // G_Flop
        Union4_1 case1; // G_Fold
        Union4_2 case2; // G_Preflop
        Union4_3 case3; // G_River
        Union4_4 case4; // G_Round
        Union4_5 case5; // G_Round'
        Union4_6 case6; // G_Showdown
        Union4_7 case7; // G_Turn
    };
    unsigned char tag{255};
    __device__ Union4() {}
    __device__ Union4(Union4_0 t) : tag(0), case0(t) {} // G_Flop
    __device__ Union4(Union4_1 t) : tag(1), case1(t) {} // G_Fold
    __device__ Union4(Union4_2 t) : tag(2), case2(t) {} // G_Preflop
    __device__ Union4(Union4_3 t) : tag(3), case3(t) {} // G_River
    __device__ Union4(Union4_4 t) : tag(4), case4(t) {} // G_Round
    __device__ Union4(Union4_5 t) : tag(5), case5(t) {} // G_Round'
    __device__ Union4(Union4_6 t) : tag(6), case6(t) {} // G_Showdown
    __device__ Union4(Union4_7 t) : tag(7), case7(t) {} // G_Turn
    __device__ Union4(Union4 & x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union4_0(x.case0); break; // G_Flop
            case 1: new (&this->case1) Union4_1(x.case1); break; // G_Fold
            case 2: new (&this->case2) Union4_2(x.case2); break; // G_Preflop
            case 3: new (&this->case3) Union4_3(x.case3); break; // G_River
            case 4: new (&this->case4) Union4_4(x.case4); break; // G_Round
            case 5: new (&this->case5) Union4_5(x.case5); break; // G_Round'
            case 6: new (&this->case6) Union4_6(x.case6); break; // G_Showdown
            case 7: new (&this->case7) Union4_7(x.case7); break; // G_Turn
        }
    }
    __device__ Union4(Union4 && x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union4_0(std::move(x.case0)); break; // G_Flop
            case 1: new (&this->case1) Union4_1(std::move(x.case1)); break; // G_Fold
            case 2: new (&this->case2) Union4_2(std::move(x.case2)); break; // G_Preflop
            case 3: new (&this->case3) Union4_3(std::move(x.case3)); break; // G_River
            case 4: new (&this->case4) Union4_4(std::move(x.case4)); break; // G_Round
            case 5: new (&this->case5) Union4_5(std::move(x.case5)); break; // G_Round'
            case 6: new (&this->case6) Union4_6(std::move(x.case6)); break; // G_Showdown
            case 7: new (&this->case7) Union4_7(std::move(x.case7)); break; // G_Turn
        }
    }
    __device__ Union4 & operator=(Union4 & x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = x.case0; break; // G_Flop
                case 1: this->case1 = x.case1; break; // G_Fold
                case 2: this->case2 = x.case2; break; // G_Preflop
                case 3: this->case3 = x.case3; break; // G_River
                case 4: this->case4 = x.case4; break; // G_Round
                case 5: this->case5 = x.case5; break; // G_Round'
                case 6: this->case6 = x.case6; break; // G_Showdown
                case 7: this->case7 = x.case7; break; // G_Turn
            }
        } else {
            this->~Union4();
            new (this) Union4{x};
        }
        return *this;
    }
    __device__ Union4 & operator=(Union4 && x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = std::move(x.case0); break; // G_Flop
                case 1: this->case1 = std::move(x.case1); break; // G_Fold
                case 2: this->case2 = std::move(x.case2); break; // G_Preflop
                case 3: this->case3 = std::move(x.case3); break; // G_River
                case 4: this->case4 = std::move(x.case4); break; // G_Round
                case 5: this->case5 = std::move(x.case5); break; // G_Round'
                case 6: this->case6 = std::move(x.case6); break; // G_Showdown
                case 7: this->case7 = std::move(x.case7); break; // G_Turn
            }
        } else {
            this->~Union4();
            new (this) Union4{std::move(x)};
        }
        return *this;
    }
    __device__ ~Union4() {
        switch(this->tag){
            case 0: this->case0.~Union4_0(); break; // G_Flop
            case 1: this->case1.~Union4_1(); break; // G_Fold
            case 2: this->case2.~Union4_2(); break; // G_Preflop
            case 3: this->case3.~Union4_3(); break; // G_River
            case 4: this->case4.~Union4_4(); break; // G_Round
            case 5: this->case5.~Union4_5(); break; // G_Round'
            case 6: this->case6.~Union4_6(); break; // G_Showdown
            case 7: this->case7.~Union4_7(); break; // G_Turn
        }
        this->tag = 255;
    }
};
struct Union3_0 { // None
};
struct Union3_1 { // Some
    Union4 v0;
    __device__ Union3_1(Union4 t0) : v0(t0) {}
    __device__ Union3_1() = delete;
};
struct Union3 {
    union {
        Union3_0 case0; // None
        Union3_1 case1; // Some
    };
    unsigned char tag{255};
    __device__ Union3() {}
    __device__ Union3(Union3_0 t) : tag(0), case0(t) {} // None
    __device__ Union3(Union3_1 t) : tag(1), case1(t) {} // Some
    __device__ Union3(Union3 & x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union3_0(x.case0); break; // None
            case 1: new (&this->case1) Union3_1(x.case1); break; // Some
        }
    }
    __device__ Union3(Union3 && x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union3_0(std::move(x.case0)); break; // None
            case 1: new (&this->case1) Union3_1(std::move(x.case1)); break; // Some
        }
    }
    __device__ Union3 & operator=(Union3 & x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = x.case0; break; // None
                case 1: this->case1 = x.case1; break; // Some
            }
        } else {
            this->~Union3();
            new (this) Union3{x};
        }
        return *this;
    }
    __device__ Union3 & operator=(Union3 && x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = std::move(x.case0); break; // None
                case 1: this->case1 = std::move(x.case1); break; // Some
            }
        } else {
            this->~Union3();
            new (this) Union3{std::move(x)};
        }
        return *this;
    }
    __device__ ~Union3() {
        switch(this->tag){
            case 0: this->case0.~Union3_0(); break; // None
            case 1: this->case1.~Union3_1(); break; // Some
        }
        this->tag = 255;
    }
};
struct Tuple0 {
    static_array<unsigned char,5> v0;
    char v1;
    __device__ Tuple0() = default;
    __device__ Tuple0(static_array<unsigned char,5> t0, char t1) : v0(t0), v1(t1) {}
};
struct Union6_0 { // CommunityCardsAre
    static_array_list<unsigned char,5> v0;
    __device__ Union6_0(static_array_list<unsigned char,5> t0) : v0(t0) {}
    __device__ Union6_0() = delete;
};
struct Union6_1 { // Fold
    int v0;
    int v1;
    __device__ Union6_1(int t0, int t1) : v0(t0), v1(t1) {}
    __device__ Union6_1() = delete;
};
struct Union6_2 { // PlayerAction
    Union1 v1;
    int v0;
    __device__ Union6_2(int t0, Union1 t1) : v0(t0), v1(t1) {}
    __device__ Union6_2() = delete;
};
struct Union6_3 { // PlayerGotCards
    static_array<unsigned char,2> v1;
    int v0;
    __device__ Union6_3(int t0, static_array<unsigned char,2> t1) : v0(t0), v1(t1) {}
    __device__ Union6_3() = delete;
};
struct Union6_4 { // Showdown
    static_array<Tuple0,2> v1;
    int v0;
    int v2;
    __device__ Union6_4(int t0, static_array<Tuple0,2> t1, int t2) : v0(t0), v1(t1), v2(t2) {}
    __device__ Union6_4() = delete;
};
struct Union6 {
    union {
        Union6_0 case0; // CommunityCardsAre
        Union6_1 case1; // Fold
        Union6_2 case2; // PlayerAction
        Union6_3 case3; // PlayerGotCards
        Union6_4 case4; // Showdown
    };
    unsigned char tag{255};
    __device__ Union6() {}
    __device__ Union6(Union6_0 t) : tag(0), case0(t) {} // CommunityCardsAre
    __device__ Union6(Union6_1 t) : tag(1), case1(t) {} // Fold
    __device__ Union6(Union6_2 t) : tag(2), case2(t) {} // PlayerAction
    __device__ Union6(Union6_3 t) : tag(3), case3(t) {} // PlayerGotCards
    __device__ Union6(Union6_4 t) : tag(4), case4(t) {} // Showdown
    __device__ Union6(Union6 & x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union6_0(x.case0); break; // CommunityCardsAre
            case 1: new (&this->case1) Union6_1(x.case1); break; // Fold
            case 2: new (&this->case2) Union6_2(x.case2); break; // PlayerAction
            case 3: new (&this->case3) Union6_3(x.case3); break; // PlayerGotCards
            case 4: new (&this->case4) Union6_4(x.case4); break; // Showdown
        }
    }
    __device__ Union6(Union6 && x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union6_0(std::move(x.case0)); break; // CommunityCardsAre
            case 1: new (&this->case1) Union6_1(std::move(x.case1)); break; // Fold
            case 2: new (&this->case2) Union6_2(std::move(x.case2)); break; // PlayerAction
            case 3: new (&this->case3) Union6_3(std::move(x.case3)); break; // PlayerGotCards
            case 4: new (&this->case4) Union6_4(std::move(x.case4)); break; // Showdown
        }
    }
    __device__ Union6 & operator=(Union6 & x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = x.case0; break; // CommunityCardsAre
                case 1: this->case1 = x.case1; break; // Fold
                case 2: this->case2 = x.case2; break; // PlayerAction
                case 3: this->case3 = x.case3; break; // PlayerGotCards
                case 4: this->case4 = x.case4; break; // Showdown
            }
        } else {
            this->~Union6();
            new (this) Union6{x};
        }
        return *this;
    }
    __device__ Union6 & operator=(Union6 && x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = std::move(x.case0); break; // CommunityCardsAre
                case 1: this->case1 = std::move(x.case1); break; // Fold
                case 2: this->case2 = std::move(x.case2); break; // PlayerAction
                case 3: this->case3 = std::move(x.case3); break; // PlayerGotCards
                case 4: this->case4 = std::move(x.case4); break; // Showdown
            }
        } else {
            this->~Union6();
            new (this) Union6{std::move(x)};
        }
        return *this;
    }
    __device__ ~Union6() {
        switch(this->tag){
            case 0: this->case0.~Union6_0(); break; // CommunityCardsAre
            case 1: this->case1.~Union6_1(); break; // Fold
            case 2: this->case2.~Union6_2(); break; // PlayerAction
            case 3: this->case3.~Union6_3(); break; // PlayerGotCards
            case 4: this->case4.~Union6_4(); break; // Showdown
        }
        this->tag = 255;
    }
};
struct Union7_0 { // GameNotStarted
};
struct Union7_1 { // GameOver
    static_array<static_array<unsigned char,2>,2> v1;
    static_array<int,2> v2;
    static_array<int,2> v4;
    Union5 v5;
    int v0;
    int v3;
    __device__ Union7_1(int t0, static_array<static_array<unsigned char,2>,2> t1, static_array<int,2> t2, int t3, static_array<int,2> t4, Union5 t5) : v0(t0), v1(t1), v2(t2), v3(t3), v4(t4), v5(t5) {}
    __device__ Union7_1() = delete;
};
struct Union7_2 { // WaitingForActionFromPlayerId
    static_array<static_array<unsigned char,2>,2> v1;
    static_array<int,2> v2;
    static_array<int,2> v4;
    Union5 v5;
    int v0;
    int v3;
    __device__ Union7_2(int t0, static_array<static_array<unsigned char,2>,2> t1, static_array<int,2> t2, int t3, static_array<int,2> t4, Union5 t5) : v0(t0), v1(t1), v2(t2), v3(t3), v4(t4), v5(t5) {}
    __device__ Union7_2() = delete;
};
struct Union7 {
    union {
        Union7_0 case0; // GameNotStarted
        Union7_1 case1; // GameOver
        Union7_2 case2; // WaitingForActionFromPlayerId
    };
    unsigned char tag{255};
    __device__ Union7() {}
    __device__ Union7(Union7_0 t) : tag(0), case0(t) {} // GameNotStarted
    __device__ Union7(Union7_1 t) : tag(1), case1(t) {} // GameOver
    __device__ Union7(Union7_2 t) : tag(2), case2(t) {} // WaitingForActionFromPlayerId
    __device__ Union7(Union7 & x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union7_0(x.case0); break; // GameNotStarted
            case 1: new (&this->case1) Union7_1(x.case1); break; // GameOver
            case 2: new (&this->case2) Union7_2(x.case2); break; // WaitingForActionFromPlayerId
        }
    }
    __device__ Union7(Union7 && x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union7_0(std::move(x.case0)); break; // GameNotStarted
            case 1: new (&this->case1) Union7_1(std::move(x.case1)); break; // GameOver
            case 2: new (&this->case2) Union7_2(std::move(x.case2)); break; // WaitingForActionFromPlayerId
        }
    }
    __device__ Union7 & operator=(Union7 & x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = x.case0; break; // GameNotStarted
                case 1: this->case1 = x.case1; break; // GameOver
                case 2: this->case2 = x.case2; break; // WaitingForActionFromPlayerId
            }
        } else {
            this->~Union7();
            new (this) Union7{x};
        }
        return *this;
    }
    __device__ Union7 & operator=(Union7 && x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = std::move(x.case0); break; // GameNotStarted
                case 1: this->case1 = std::move(x.case1); break; // GameOver
                case 2: this->case2 = std::move(x.case2); break; // WaitingForActionFromPlayerId
            }
        } else {
            this->~Union7();
            new (this) Union7{std::move(x)};
        }
        return *this;
    }
    __device__ ~Union7() {
        switch(this->tag){
            case 0: this->case0.~Union7_0(); break; // GameNotStarted
            case 1: this->case1.~Union7_1(); break; // GameOver
            case 2: this->case2.~Union7_2(); break; // WaitingForActionFromPlayerId
        }
        this->tag = 255;
    }
};
struct Tuple1 {
    unsigned long long v0;
    Union3 v1;
    static_array_list<Union6,128> v2;
    static_array<Union2,2> v3;
    Union7 v4;
    __device__ Tuple1() = default;
    __device__ Tuple1(unsigned long long t0, Union3 t1, static_array_list<Union6,128> t2, static_array<Union2,2> t3, Union7 t4) : v0(t0), v1(t1), v2(t2), v3(t3), v4(t4) {}
};
struct Tuple2 {
    static_array<static_array<unsigned char,2>,2> v1;
    static_array<int,2> v2;
    static_array<int,2> v4;
    Union5 v5;
    int v0;
    int v3;
    __device__ Tuple2() = default;
    __device__ Tuple2(int t0, static_array<static_array<unsigned char,2>,2> t1, static_array<int,2> t2, int t3, static_array<int,2> t4, Union5 t5) : v0(t0), v1(t1), v2(t2), v3(t3), v4(t4), v5(t5) {}
};
struct Tuple3 {
    static_array<static_array<unsigned char,2>,2> v1;
    static_array<int,2> v2;
    static_array<int,2> v4;
    Union5 v5;
    Union1 v6;
    int v0;
    int v3;
    __device__ Tuple3() = default;
    __device__ Tuple3(int t0, static_array<static_array<unsigned char,2>,2> t1, static_array<int,2> t2, int t3, static_array<int,2> t4, Union5 t5, Union1 t6) : v0(t0), v1(t1), v2(t2), v3(t3), v4(t4), v5(t5), v6(t6) {}
};
struct Tuple4 {
    int v0;
    int v1;
    __device__ Tuple4() = default;
    __device__ Tuple4(int t0, int t1) : v0(t0), v1(t1) {}
};
struct Tuple5 {
    Union1 v1;
    int v0;
    __device__ Tuple5() = default;
    __device__ Tuple5(int t0, Union1 t1) : v0(t0), v1(t1) {}
};
struct Tuple6 {
    static_array<unsigned char,2> v1;
    int v0;
    __device__ Tuple6() = default;
    __device__ Tuple6(int t0, static_array<unsigned char,2> t1) : v0(t0), v1(t1) {}
};
struct Tuple7 {
    static_array<Tuple0,2> v1;
    int v0;
    int v2;
    __device__ Tuple7() = default;
    __device__ Tuple7(int t0, static_array<Tuple0,2> t1, int t2) : v0(t0), v1(t1), v2(t2) {}
};
struct StackMut0 {
    unsigned long long v0;
    Union3 v1;
    static_array_list<Union6,128> v2;
    static_array<Union2,2> v3;
    curandStatePhilox4_32_10_t v4;
    Union7 v5;
    __device__ StackMut0() = default;
    __device__ StackMut0(unsigned long long t0, Union3 t1, static_array_list<Union6,128> t2, static_array<Union2,2> t3, curandStatePhilox4_32_10_t t4, Union7 t5) : v0(t0), v1(t1), v2(t2), v3(t3), v4(t4), v5(t5) {}
};
struct Tuple8 {
    static_array<unsigned char,3> v0;
    unsigned long long v1;
    __device__ Tuple8() = default;
    __device__ Tuple8(static_array<unsigned char,3> t0, unsigned long long t1) : v0(t0), v1(t1) {}
};
struct Tuple9 {
    unsigned long long v1;
    int v0;
    __device__ Tuple9() = default;
    __device__ Tuple9(int t0, unsigned long long t1) : v0(t0), v1(t1) {}
};
struct Tuple10 {
    unsigned long long v1;
    unsigned char v0;
    __device__ Tuple10() = default;
    __device__ Tuple10(unsigned char t0, unsigned long long t1) : v0(t0), v1(t1) {}
};
struct Tuple11 {
    static_array<unsigned char,2> v0;
    unsigned long long v1;
    __device__ Tuple11() = default;
    __device__ Tuple11(static_array<unsigned char,2> t0, unsigned long long t1) : v0(t0), v1(t1) {}
};
struct Tuple12 {
    static_array<unsigned char,1> v0;
    unsigned long long v1;
    __device__ Tuple12() = default;
    __device__ Tuple12(static_array<unsigned char,1> t0, unsigned long long t1) : v0(t0), v1(t1) {}
};
struct Union8_0 { // None
};
struct Union8_1 { // Some
    Union1 v0;
    __device__ Union8_1(Union1 t0) : v0(t0) {}
    __device__ Union8_1() = delete;
};
struct Union8 {
    union {
        Union8_0 case0; // None
        Union8_1 case1; // Some
    };
    unsigned char tag{255};
    __device__ Union8() {}
    __device__ Union8(Union8_0 t) : tag(0), case0(t) {} // None
    __device__ Union8(Union8_1 t) : tag(1), case1(t) {} // Some
    __device__ Union8(Union8 & x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union8_0(x.case0); break; // None
            case 1: new (&this->case1) Union8_1(x.case1); break; // Some
        }
    }
    __device__ Union8(Union8 && x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union8_0(std::move(x.case0)); break; // None
            case 1: new (&this->case1) Union8_1(std::move(x.case1)); break; // Some
        }
    }
    __device__ Union8 & operator=(Union8 & x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = x.case0; break; // None
                case 1: this->case1 = x.case1; break; // Some
            }
        } else {
            this->~Union8();
            new (this) Union8{x};
        }
        return *this;
    }
    __device__ Union8 & operator=(Union8 && x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = std::move(x.case0); break; // None
                case 1: this->case1 = std::move(x.case1); break; // Some
            }
        } else {
            this->~Union8();
            new (this) Union8{std::move(x)};
        }
        return *this;
    }
    __device__ ~Union8() {
        switch(this->tag){
            case 0: this->case0.~Union8_0(); break; // None
            case 1: this->case1.~Union8_1(); break; // Some
        }
        this->tag = 255;
    }
};
struct Tuple13 {
    int v0;
    unsigned int v1;
    __device__ Tuple13() = default;
    __device__ Tuple13(int t0, unsigned int t1) : v0(t0), v1(t1) {}
};
struct Union9_0 { // None
};
struct Union9_1 { // Some
    int v0;
    __device__ Union9_1(int t0) : v0(t0) {}
    __device__ Union9_1() = delete;
};
struct Union9 {
    union {
        Union9_0 case0; // None
        Union9_1 case1; // Some
    };
    unsigned char tag{255};
    __device__ Union9() {}
    __device__ Union9(Union9_0 t) : tag(0), case0(t) {} // None
    __device__ Union9(Union9_1 t) : tag(1), case1(t) {} // Some
    __device__ Union9(Union9 & x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union9_0(x.case0); break; // None
            case 1: new (&this->case1) Union9_1(x.case1); break; // Some
        }
    }
    __device__ Union9(Union9 && x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union9_0(std::move(x.case0)); break; // None
            case 1: new (&this->case1) Union9_1(std::move(x.case1)); break; // Some
        }
    }
    __device__ Union9 & operator=(Union9 & x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = x.case0; break; // None
                case 1: this->case1 = x.case1; break; // Some
            }
        } else {
            this->~Union9();
            new (this) Union9{x};
        }
        return *this;
    }
    __device__ Union9 & operator=(Union9 && x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = std::move(x.case0); break; // None
                case 1: this->case1 = std::move(x.case1); break; // Some
            }
        } else {
            this->~Union9();
            new (this) Union9{std::move(x)};
        }
        return *this;
    }
    __device__ ~Union9() {
        switch(this->tag){
            case 0: this->case0.~Union9_0(); break; // None
            case 1: this->case1.~Union9_1(); break; // Some
        }
        this->tag = 255;
    }
};
struct Closure0 {
    __device__ float operator()(float tup0, float tup1){
        float v0 = tup0; float v1 = tup1;
        float v2;
        v2 = v0 + v1;
        return v2;
    }
};
struct Closure1 {
    __device__ int operator()(int tup0, int tup1){
        int v0 = tup0; int v1 = tup1;
        int v2;
        v2 = v0 + v1;
        return v2;
    }
};
struct Closure2 {
    __device__ float operator()(float tup0, float tup1){
        float v0 = tup0; float v1 = tup1;
        float v2;
        v2 = v0 + v1;
        return v2;
    }
};
struct Tuple14 {
    float v0;
    bool v1;
    __device__ Tuple14() = default;
    __device__ Tuple14(float t0, bool t1) : v0(t0), v1(t1) {}
};
struct Closure3 {
    __device__ Tuple14 operator()(Tuple14 tup0, Tuple14 tup1){
        float v0 = tup0.v0; bool v1 = tup0.v1; float v2 = tup1.v0; bool v3 = tup1.v1;
        if (v1){
            if (v3){
                bool v4;
                v4 = v0 >= v2;
                float v5;
                if (v4){
                    v5 = v0;
                } else {
                    v5 = v2;
                }
                return Tuple14{v5, true};
            } else {
                return Tuple14{v0, v1};
            }
        } else {
            if (v3){
                return Tuple14{v2, v3};
            } else {
                return Tuple14{v0, v1};
            }
        }
    }
};
struct Tuple15 {
    float v0;
    int v1;
    __device__ Tuple15() = default;
    __device__ Tuple15(float t0, int t1) : v0(t0), v1(t1) {}
};
struct Closure4 {
    __device__ Tuple15 operator()(Tuple15 tup0, Tuple15 tup1){
        float v0 = tup0.v0; int v1 = tup0.v1; float v2 = tup1.v0; int v3 = tup1.v1;
        bool v4;
        v4 = v1 < v3;
        if (v4){
            return Tuple15{v0, v1};
        } else {
            return Tuple15{v2, v3};
        }
    }
};
struct Tuple16 {
    int v0;
    bool v1;
    __device__ Tuple16() = default;
    __device__ Tuple16(int t0, bool t1) : v0(t0), v1(t1) {}
};
struct Closure5 {
    __device__ Tuple16 operator()(Tuple16 tup0, Tuple16 tup1){
        int v0 = tup0.v0; bool v1 = tup0.v1; int v2 = tup1.v0; bool v3 = tup1.v1;
        if (v1){
            if (v3){
                bool v4;
                v4 = v0 < v2;
                int v5;
                if (v4){
                    v5 = v0;
                } else {
                    v5 = v2;
                }
                return Tuple16{v5, true};
            } else {
                return Tuple16{v0, v1};
            }
        } else {
            if (v3){
                return Tuple16{v2, v3};
            } else {
                return Tuple16{v0, v1};
            }
        }
    }
};
struct Closure6 {
    int v0;
    __device__ Tuple15 operator()(Tuple15 tup0, Tuple15 tup1){
        int & v0 = this->v0;
        float v1 = tup0.v0; int v2 = tup0.v1; float v3 = tup1.v0; int v4 = tup1.v1;
        bool v5;
        v5 = v2 == v0;
        if (v5){
            return Tuple15{v1, v2};
        } else {
            bool v6;
            v6 = v4 == v0;
            if (v6){
                return Tuple15{v3, v4};
            } else {
                return Tuple15{v1, v2};
            }
        }
    }
    __device__ Closure6(int _v0) : v0(_v0) { }
};
struct Union10_0 { // AA_Call
};
struct Union10_1 { // AA_Fold
};
struct Union10_2 { // AA_Raise
    int v0;
    int v1;
    __device__ Union10_2(int t0, int t1) : v0(t0), v1(t1) {}
    __device__ Union10_2() = delete;
};
struct Union10 {
    union {
        Union10_0 case0; // AA_Call
        Union10_1 case1; // AA_Fold
        Union10_2 case2; // AA_Raise
    };
    unsigned char tag{255};
    __device__ Union10() {}
    __device__ Union10(Union10_0 t) : tag(0), case0(t) {} // AA_Call
    __device__ Union10(Union10_1 t) : tag(1), case1(t) {} // AA_Fold
    __device__ Union10(Union10_2 t) : tag(2), case2(t) {} // AA_Raise
    __device__ Union10(Union10 & x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union10_0(x.case0); break; // AA_Call
            case 1: new (&this->case1) Union10_1(x.case1); break; // AA_Fold
            case 2: new (&this->case2) Union10_2(x.case2); break; // AA_Raise
        }
    }
    __device__ Union10(Union10 && x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union10_0(std::move(x.case0)); break; // AA_Call
            case 1: new (&this->case1) Union10_1(std::move(x.case1)); break; // AA_Fold
            case 2: new (&this->case2) Union10_2(std::move(x.case2)); break; // AA_Raise
        }
    }
    __device__ Union10 & operator=(Union10 & x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = x.case0; break; // AA_Call
                case 1: this->case1 = x.case1; break; // AA_Fold
                case 2: this->case2 = x.case2; break; // AA_Raise
            }
        } else {
            this->~Union10();
            new (this) Union10{x};
        }
        return *this;
    }
    __device__ Union10 & operator=(Union10 && x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = std::move(x.case0); break; // AA_Call
                case 1: this->case1 = std::move(x.case1); break; // AA_Fold
                case 2: this->case2 = std::move(x.case2); break; // AA_Raise
            }
        } else {
            this->~Union10();
            new (this) Union10{std::move(x)};
        }
        return *this;
    }
    __device__ ~Union10() {
        switch(this->tag){
            case 0: this->case0.~Union10_0(); break; // AA_Call
            case 1: this->case1.~Union10_1(); break; // AA_Fold
            case 2: this->case2.~Union10_2(); break; // AA_Raise
        }
        this->tag = 255;
    }
};
struct Tuple17 {
    Union1 v0;
    float v1;
    __device__ Tuple17() = default;
    __device__ Tuple17(Union1 t0, float t1) : v0(t0), v1(t1) {}
};
struct Tuple18 {
    int v1;
    bool v0;
    __device__ Tuple18() = default;
    __device__ Tuple18(bool t0, int t1) : v0(t0), v1(t1) {}
};
struct Tuple19 {
    int v0;
    int v1;
    int v2;
    __device__ Tuple19() = default;
    __device__ Tuple19(int t0, int t1, int t2) : v0(t0), v1(t1), v2(t2) {}
};
struct Union11_0 { // Eq
};
struct Union11_1 { // Gt
};
struct Union11_2 { // Lt
};
struct Union11 {
    union {
        Union11_0 case0; // Eq
        Union11_1 case1; // Gt
        Union11_2 case2; // Lt
    };
    unsigned char tag{255};
    __device__ Union11() {}
    __device__ Union11(Union11_0 t) : tag(0), case0(t) {} // Eq
    __device__ Union11(Union11_1 t) : tag(1), case1(t) {} // Gt
    __device__ Union11(Union11_2 t) : tag(2), case2(t) {} // Lt
    __device__ Union11(Union11 & x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union11_0(x.case0); break; // Eq
            case 1: new (&this->case1) Union11_1(x.case1); break; // Gt
            case 2: new (&this->case2) Union11_2(x.case2); break; // Lt
        }
    }
    __device__ Union11(Union11 && x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union11_0(std::move(x.case0)); break; // Eq
            case 1: new (&this->case1) Union11_1(std::move(x.case1)); break; // Gt
            case 2: new (&this->case2) Union11_2(std::move(x.case2)); break; // Lt
        }
    }
    __device__ Union11 & operator=(Union11 & x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = x.case0; break; // Eq
                case 1: this->case1 = x.case1; break; // Gt
                case 2: this->case2 = x.case2; break; // Lt
            }
        } else {
            this->~Union11();
            new (this) Union11{x};
        }
        return *this;
    }
    __device__ Union11 & operator=(Union11 && x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = std::move(x.case0); break; // Eq
                case 1: this->case1 = std::move(x.case1); break; // Gt
                case 2: this->case2 = std::move(x.case2); break; // Lt
            }
        } else {
            this->~Union11();
            new (this) Union11{std::move(x)};
        }
        return *this;
    }
    __device__ ~Union11() {
        switch(this->tag){
            case 0: this->case0.~Union11_0(); break; // Eq
            case 1: this->case1.~Union11_1(); break; // Gt
            case 2: this->case2.~Union11_2(); break; // Lt
        }
        this->tag = 255;
    }
};
struct Tuple20 {
    int v0;
    int v1;
    unsigned char v2;
    __device__ Tuple20() = default;
    __device__ Tuple20(int t0, int t1, unsigned char t2) : v0(t0), v1(t1), v2(t2) {}
};
struct Union12_0 { // None
};
struct Union12_1 { // Some
    static_array<unsigned char,5> v0;
    __device__ Union12_1(static_array<unsigned char,5> t0) : v0(t0) {}
    __device__ Union12_1() = delete;
};
struct Union12 {
    union {
        Union12_0 case0; // None
        Union12_1 case1; // Some
    };
    unsigned char tag{255};
    __device__ Union12() {}
    __device__ Union12(Union12_0 t) : tag(0), case0(t) {} // None
    __device__ Union12(Union12_1 t) : tag(1), case1(t) {} // Some
    __device__ Union12(Union12 & x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union12_0(x.case0); break; // None
            case 1: new (&this->case1) Union12_1(x.case1); break; // Some
        }
    }
    __device__ Union12(Union12 && x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union12_0(std::move(x.case0)); break; // None
            case 1: new (&this->case1) Union12_1(std::move(x.case1)); break; // Some
        }
    }
    __device__ Union12 & operator=(Union12 & x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = x.case0; break; // None
                case 1: this->case1 = x.case1; break; // Some
            }
        } else {
            this->~Union12();
            new (this) Union12{x};
        }
        return *this;
    }
    __device__ Union12 & operator=(Union12 && x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = std::move(x.case0); break; // None
                case 1: this->case1 = std::move(x.case1); break; // Some
            }
        } else {
            this->~Union12();
            new (this) Union12{std::move(x)};
        }
        return *this;
    }
    __device__ ~Union12() {
        switch(this->tag){
            case 0: this->case0.~Union12_0(); break; // None
            case 1: this->case1.~Union12_1(); break; // Some
        }
        this->tag = 255;
    }
};
struct Tuple21 {
    Union11 v1;
    int v0;
    __device__ Tuple21() = default;
    __device__ Tuple21(int t0, Union11 t1) : v0(t0), v1(t1) {}
};
struct Tuple22 {
    int v0;
    int v1;
    int v2;
    unsigned char v3;
    __device__ Tuple22() = default;
    __device__ Tuple22(int t0, int t1, int t2, unsigned char t3) : v0(t0), v1(t1), v2(t2), v3(t3) {}
};
struct Union13_0 { // None
};
struct Union13_1 { // Some
    static_array<unsigned char,4> v0;
    static_array<unsigned char,3> v1;
    __device__ Union13_1(static_array<unsigned char,4> t0, static_array<unsigned char,3> t1) : v0(t0), v1(t1) {}
    __device__ Union13_1() = delete;
};
struct Union13 {
    union {
        Union13_0 case0; // None
        Union13_1 case1; // Some
    };
    unsigned char tag{255};
    __device__ Union13() {}
    __device__ Union13(Union13_0 t) : tag(0), case0(t) {} // None
    __device__ Union13(Union13_1 t) : tag(1), case1(t) {} // Some
    __device__ Union13(Union13 & x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union13_0(x.case0); break; // None
            case 1: new (&this->case1) Union13_1(x.case1); break; // Some
        }
    }
    __device__ Union13(Union13 && x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union13_0(std::move(x.case0)); break; // None
            case 1: new (&this->case1) Union13_1(std::move(x.case1)); break; // Some
        }
    }
    __device__ Union13 & operator=(Union13 & x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = x.case0; break; // None
                case 1: this->case1 = x.case1; break; // Some
            }
        } else {
            this->~Union13();
            new (this) Union13{x};
        }
        return *this;
    }
    __device__ Union13 & operator=(Union13 && x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = std::move(x.case0); break; // None
                case 1: this->case1 = std::move(x.case1); break; // Some
            }
        } else {
            this->~Union13();
            new (this) Union13{std::move(x)};
        }
        return *this;
    }
    __device__ ~Union13() {
        switch(this->tag){
            case 0: this->case0.~Union13_0(); break; // None
            case 1: this->case1.~Union13_1(); break; // Some
        }
        this->tag = 255;
    }
};
struct Union14_0 { // None
};
struct Union14_1 { // Some
    static_array<unsigned char,3> v0;
    static_array<unsigned char,4> v1;
    __device__ Union14_1(static_array<unsigned char,3> t0, static_array<unsigned char,4> t1) : v0(t0), v1(t1) {}
    __device__ Union14_1() = delete;
};
struct Union14 {
    union {
        Union14_0 case0; // None
        Union14_1 case1; // Some
    };
    unsigned char tag{255};
    __device__ Union14() {}
    __device__ Union14(Union14_0 t) : tag(0), case0(t) {} // None
    __device__ Union14(Union14_1 t) : tag(1), case1(t) {} // Some
    __device__ Union14(Union14 & x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union14_0(x.case0); break; // None
            case 1: new (&this->case1) Union14_1(x.case1); break; // Some
        }
    }
    __device__ Union14(Union14 && x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union14_0(std::move(x.case0)); break; // None
            case 1: new (&this->case1) Union14_1(std::move(x.case1)); break; // Some
        }
    }
    __device__ Union14 & operator=(Union14 & x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = x.case0; break; // None
                case 1: this->case1 = x.case1; break; // Some
            }
        } else {
            this->~Union14();
            new (this) Union14{x};
        }
        return *this;
    }
    __device__ Union14 & operator=(Union14 && x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = std::move(x.case0); break; // None
                case 1: this->case1 = std::move(x.case1); break; // Some
            }
        } else {
            this->~Union14();
            new (this) Union14{std::move(x)};
        }
        return *this;
    }
    __device__ ~Union14() {
        switch(this->tag){
            case 0: this->case0.~Union14_0(); break; // None
            case 1: this->case1.~Union14_1(); break; // Some
        }
        this->tag = 255;
    }
};
struct Union15_0 { // None
};
struct Union15_1 { // Some
    static_array<unsigned char,2> v0;
    static_array<unsigned char,2> v1;
    __device__ Union15_1(static_array<unsigned char,2> t0, static_array<unsigned char,2> t1) : v0(t0), v1(t1) {}
    __device__ Union15_1() = delete;
};
struct Union15 {
    union {
        Union15_0 case0; // None
        Union15_1 case1; // Some
    };
    unsigned char tag{255};
    __device__ Union15() {}
    __device__ Union15(Union15_0 t) : tag(0), case0(t) {} // None
    __device__ Union15(Union15_1 t) : tag(1), case1(t) {} // Some
    __device__ Union15(Union15 & x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union15_0(x.case0); break; // None
            case 1: new (&this->case1) Union15_1(x.case1); break; // Some
        }
    }
    __device__ Union15(Union15 && x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union15_0(std::move(x.case0)); break; // None
            case 1: new (&this->case1) Union15_1(std::move(x.case1)); break; // Some
        }
    }
    __device__ Union15 & operator=(Union15 & x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = x.case0; break; // None
                case 1: this->case1 = x.case1; break; // Some
            }
        } else {
            this->~Union15();
            new (this) Union15{x};
        }
        return *this;
    }
    __device__ Union15 & operator=(Union15 && x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = std::move(x.case0); break; // None
                case 1: this->case1 = std::move(x.case1); break; // Some
            }
        } else {
            this->~Union15();
            new (this) Union15{std::move(x)};
        }
        return *this;
    }
    __device__ ~Union15() {
        switch(this->tag){
            case 0: this->case0.~Union15_0(); break; // None
            case 1: this->case1.~Union15_1(); break; // Some
        }
        this->tag = 255;
    }
};
struct Union16_0 { // None
};
struct Union16_1 { // Some
    static_array<unsigned char,2> v0;
    static_array<unsigned char,5> v1;
    __device__ Union16_1(static_array<unsigned char,2> t0, static_array<unsigned char,5> t1) : v0(t0), v1(t1) {}
    __device__ Union16_1() = delete;
};
struct Union16 {
    union {
        Union16_0 case0; // None
        Union16_1 case1; // Some
    };
    unsigned char tag{255};
    __device__ Union16() {}
    __device__ Union16(Union16_0 t) : tag(0), case0(t) {} // None
    __device__ Union16(Union16_1 t) : tag(1), case1(t) {} // Some
    __device__ Union16(Union16 & x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union16_0(x.case0); break; // None
            case 1: new (&this->case1) Union16_1(x.case1); break; // Some
        }
    }
    __device__ Union16(Union16 && x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union16_0(std::move(x.case0)); break; // None
            case 1: new (&this->case1) Union16_1(std::move(x.case1)); break; // Some
        }
    }
    __device__ Union16 & operator=(Union16 & x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = x.case0; break; // None
                case 1: this->case1 = x.case1; break; // Some
            }
        } else {
            this->~Union16();
            new (this) Union16{x};
        }
        return *this;
    }
    __device__ Union16 & operator=(Union16 && x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = std::move(x.case0); break; // None
                case 1: this->case1 = std::move(x.case1); break; // Some
            }
        } else {
            this->~Union16();
            new (this) Union16{std::move(x)};
        }
        return *this;
    }
    __device__ ~Union16() {
        switch(this->tag){
            case 0: this->case0.~Union16_0(); break; // None
            case 1: this->case1.~Union16_1(); break; // Some
        }
        this->tag = 255;
    }
};
struct Union17_0 { // None
};
struct Union17_1 { // Some
    static_array<unsigned char,2> v0;
    static_array<unsigned char,3> v1;
    __device__ Union17_1(static_array<unsigned char,2> t0, static_array<unsigned char,3> t1) : v0(t0), v1(t1) {}
    __device__ Union17_1() = delete;
};
struct Union17 {
    union {
        Union17_0 case0; // None
        Union17_1 case1; // Some
    };
    unsigned char tag{255};
    __device__ Union17() {}
    __device__ Union17(Union17_0 t) : tag(0), case0(t) {} // None
    __device__ Union17(Union17_1 t) : tag(1), case1(t) {} // Some
    __device__ Union17(Union17 & x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union17_0(x.case0); break; // None
            case 1: new (&this->case1) Union17_1(x.case1); break; // Some
        }
    }
    __device__ Union17(Union17 && x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union17_0(std::move(x.case0)); break; // None
            case 1: new (&this->case1) Union17_1(std::move(x.case1)); break; // Some
        }
    }
    __device__ Union17 & operator=(Union17 & x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = x.case0; break; // None
                case 1: this->case1 = x.case1; break; // Some
            }
        } else {
            this->~Union17();
            new (this) Union17{x};
        }
        return *this;
    }
    __device__ Union17 & operator=(Union17 && x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = std::move(x.case0); break; // None
                case 1: this->case1 = std::move(x.case1); break; // Some
            }
        } else {
            this->~Union17();
            new (this) Union17{std::move(x)};
        }
        return *this;
    }
    __device__ ~Union17() {
        switch(this->tag){
            case 0: this->case0.~Union17_0(); break; // None
            case 1: this->case1.~Union17_1(); break; // Some
        }
        this->tag = 255;
    }
};
struct StackMut1 {
    unsigned long long v0;
    cooperative_groups::grid_group v1;
    static_array_list<Union6,128> v2;
    static_array<Union2,2> v3;
    static_array<float,2> v4;
    curandStatePhilox4_32_10_t v5;
    __device__ StackMut1() = default;
    __device__ StackMut1(unsigned long long t0, cooperative_groups::grid_group t1, static_array_list<Union6,128> t2, static_array<Union2,2> t3, static_array<float,2> t4, curandStatePhilox4_32_10_t t5) : v0(t0), v1(t1), v2(t2), v3(t3), v4(t4), v5(t5) {}
};
struct Union18_0 { // T_none
};
struct Union18_1 { // T_round
    static_array<static_array<unsigned char,2>,2> v1;
    static_array<int,2> v2;
    static_array<int,2> v4;
    Union5 v5;
    Union1 v6;
    int v0;
    int v3;
    __device__ Union18_1(int t0, static_array<static_array<unsigned char,2>,2> t1, static_array<int,2> t2, int t3, static_array<int,2> t4, Union5 t5, Union1 t6) : v0(t0), v1(t1), v2(t2), v3(t3), v4(t4), v5(t5), v6(t6) {}
    __device__ Union18_1() = delete;
};
struct Union18_2 { // T_some
    Union4 v0;
    __device__ Union18_2(Union4 t0) : v0(t0) {}
    __device__ Union18_2() = delete;
};
struct Union18 {
    union {
        Union18_0 case0; // T_none
        Union18_1 case1; // T_round
        Union18_2 case2; // T_some
    };
    unsigned char tag{255};
    __device__ Union18() {}
    __device__ Union18(Union18_0 t) : tag(0), case0(t) {} // T_none
    __device__ Union18(Union18_1 t) : tag(1), case1(t) {} // T_round
    __device__ Union18(Union18_2 t) : tag(2), case2(t) {} // T_some
    __device__ Union18(Union18 & x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union18_0(x.case0); break; // T_none
            case 1: new (&this->case1) Union18_1(x.case1); break; // T_round
            case 2: new (&this->case2) Union18_2(x.case2); break; // T_some
        }
    }
    __device__ Union18(Union18 && x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union18_0(std::move(x.case0)); break; // T_none
            case 1: new (&this->case1) Union18_1(std::move(x.case1)); break; // T_round
            case 2: new (&this->case2) Union18_2(std::move(x.case2)); break; // T_some
        }
    }
    __device__ Union18 & operator=(Union18 & x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = x.case0; break; // T_none
                case 1: this->case1 = x.case1; break; // T_round
                case 2: this->case2 = x.case2; break; // T_some
            }
        } else {
            this->~Union18();
            new (this) Union18{x};
        }
        return *this;
    }
    __device__ Union18 & operator=(Union18 && x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = std::move(x.case0); break; // T_none
                case 1: this->case1 = std::move(x.case1); break; // T_round
                case 2: this->case2 = std::move(x.case2); break; // T_some
            }
        } else {
            this->~Union18();
            new (this) Union18{std::move(x)};
        }
        return *this;
    }
    __device__ ~Union18() {
        switch(this->tag){
            case 0: this->case0.~Union18_0(); break; // T_none
            case 1: this->case1.~Union18_1(); break; // T_round
            case 2: this->case2.~Union18_2(); break; // T_some
        }
        this->tag = 255;
    }
};
struct Tuple23 {
    double v1;
    int v0;
    __device__ Tuple23() = default;
    __device__ Tuple23(int t0, double t1) : v0(t0), v1(t1) {}
};
struct Tuple24 {
    double v2;
    float v1;
    int v0;
    __device__ Tuple24() = default;
    __device__ Tuple24(int t0, float t1, double t2) : v0(t0), v1(t1), v2(t2) {}
};
struct Tuple25 {
    int v0;
    float v1;
    __device__ Tuple25() = default;
    __device__ Tuple25(int t0, float t1) : v0(t0), v1(t1) {}
};
struct Closure7 {
    __device__ float operator()(float tup0, float tup1){
        float v0 = tup0; float v1 = tup1;
        bool v2;
        v2 = v0 >= v1;
        if (v2){
            return v0;
        } else {
            return v1;
        }
    }
};
__device__ int f_1(unsigned char * v0){
    int * v1;
    v1 = (int *)(v0+0ull);
    int v3;
    v3 = v1[0];
    return v3;
}
__device__ void f_3(unsigned char * v0){
    return ;
}
__device__ Union1 f_2(unsigned char * v0){
    int v1;
    v1 = f_1(v0);
    unsigned char * v2;
    v2 = (unsigned char *)(v0+4ull);
    switch (v1) {
        case 0: {
            f_3(v2);
            return Union1{Union1_0{}};
            break;
        }
        case 1: {
            f_3(v2);
            return Union1{Union1_1{}};
            break;
        }
        case 2: {
            f_3(v2);
            return Union1{Union1_2{}};
            break;
        }
        case 3: {
            int v8;
            v8 = f_1(v2);
            return Union1{Union1_3{v8}};
            break;
        }
        default: {
            printf("%s\n", "Invalid tag.");
            __trap();
        }
    }
}
__device__ inline bool while_method_0(int v0){
    bool v1;
    v1 = v0 < 2;
    return v1;
}
__device__ Union2 f_5(unsigned char * v0){
    int v1;
    v1 = f_1(v0);
    unsigned char * v2;
    v2 = (unsigned char *)(v0+4ull);
    switch (v1) {
        case 0: {
            f_3(v2);
            return Union2{Union2_0{}};
            break;
        }
        case 1: {
            f_3(v2);
            return Union2{Union2_1{}};
            break;
        }
        case 2: {
            f_3(v2);
            return Union2{Union2_2{}};
            break;
        }
        case 3: {
            f_3(v2);
            return Union2{Union2_3{}};
            break;
        }
        default: {
            printf("%s\n", "Invalid tag.");
            __trap();
        }
    }
}
__device__ static_array<Union2,2> f_4(unsigned char * v0){
    static_array<Union2,2> v1;
    int v3;
    v3 = 0;
    while (while_method_0(v3)){
        unsigned long long v5;
        v5 = (unsigned long long)v3;
        unsigned long long v6;
        v6 = v5 * 4ull;
        unsigned char * v7;
        v7 = (unsigned char *)(v0+v6);
        Union2 v9;
        v9 = f_5(v7);
        v1[v3] = v9;
        v3 += 1 ;
    }
    return v1;
}
__device__ Union0 f_0(unsigned char * v0){
    int v1;
    v1 = f_1(v0);
    unsigned char * v2;
    v2 = (unsigned char *)(v0+8ull);
    switch (v1) {
        case 0: {
            Union1 v5;
            v5 = f_2(v2);
            return Union0{Union0_0{v5}};
            break;
        }
        case 1: {
            static_array<Union2,2> v7;
            v7 = f_4(v2);
            return Union0{Union0_1{v7}};
            break;
        }
        case 2: {
            f_3(v2);
            return Union0{Union0_2{}};
            break;
        }
        case 3: {
            f_3(v2);
            return Union0{Union0_3{}};
            break;
        }
        case 4: {
            f_3(v2);
            return Union0{Union0_4{}};
            break;
        }
        default: {
            printf("%s\n", "Invalid tag.");
            __trap();
        }
    }
}
__device__ unsigned long long f_7(unsigned char * v0){
    unsigned long long * v1;
    v1 = (unsigned long long *)(v0+0ull);
    unsigned long long v3;
    v3 = v1[0];
    return v3;
}
__device__ int f_8(unsigned char * v0){
    int * v1;
    v1 = (int *)(v0+8ull);
    int v3;
    v3 = v1[0];
    return v3;
}
__device__ unsigned char f_13(unsigned char * v0){
    unsigned char * v1;
    v1 = (unsigned char *)(v0+0ull);
    unsigned char v3;
    v3 = v1[0];
    return v3;
}
__device__ unsigned char f_12(unsigned char * v0){
    unsigned char v1;
    v1 = f_13(v0);
    return v1;
}
__device__ static_array<unsigned char,2> f_11(unsigned char * v0){
    static_array<unsigned char,2> v1;
    int v3;
    v3 = 0;
    while (while_method_0(v3)){
        unsigned long long v5;
        v5 = (unsigned long long)v3;
        unsigned char * v6;
        v6 = (unsigned char *)(v0+v5);
        unsigned char v8;
        v8 = f_12(v6);
        v1[v3] = v8;
        v3 += 1 ;
    }
    return v1;
}
__device__ int f_14(unsigned char * v0){
    int * v1;
    v1 = (int *)(v0+28ull);
    int v3;
    v3 = v1[0];
    return v3;
}
__device__ inline bool while_method_1(int v0){
    bool v1;
    v1 = v0 < 3;
    return v1;
}
__device__ static_array<unsigned char,3> f_15(unsigned char * v0){
    static_array<unsigned char,3> v1;
    int v3;
    v3 = 0;
    while (while_method_1(v3)){
        unsigned long long v5;
        v5 = (unsigned long long)v3;
        unsigned char * v6;
        v6 = (unsigned char *)(v0+v5);
        unsigned char v8;
        v8 = f_12(v6);
        v1[v3] = v8;
        v3 += 1 ;
    }
    return v1;
}
__device__ inline bool while_method_2(int v0){
    bool v1;
    v1 = v0 < 5;
    return v1;
}
__device__ static_array<unsigned char,5> f_16(unsigned char * v0){
    static_array<unsigned char,5> v1;
    int v3;
    v3 = 0;
    while (while_method_2(v3)){
        unsigned long long v5;
        v5 = (unsigned long long)v3;
        unsigned char * v6;
        v6 = (unsigned char *)(v0+v5);
        unsigned char v8;
        v8 = f_12(v6);
        v1[v3] = v8;
        v3 += 1 ;
    }
    return v1;
}
__device__ inline bool while_method_3(int v0){
    bool v1;
    v1 = v0 < 4;
    return v1;
}
__device__ static_array<unsigned char,4> f_17(unsigned char * v0){
    static_array<unsigned char,4> v1;
    int v3;
    v3 = 0;
    while (while_method_3(v3)){
        unsigned long long v5;
        v5 = (unsigned long long)v3;
        unsigned char * v6;
        v6 = (unsigned char *)(v0+v5);
        unsigned char v8;
        v8 = f_12(v6);
        v1[v3] = v8;
        v3 += 1 ;
    }
    return v1;
}
__device__ Tuple2 f_10(unsigned char * v0){
    int * v1;
    v1 = (int *)(v0+0ull);
    int v3;
    v3 = v1[0];
    static_array<static_array<unsigned char,2>,2> v4;
    int v6;
    v6 = 0;
    while (while_method_0(v6)){
        unsigned long long v8;
        v8 = (unsigned long long)v6;
        unsigned long long v9;
        v9 = v8 * 2ull;
        unsigned long long v10;
        v10 = 4ull + v9;
        unsigned char * v11;
        v11 = (unsigned char *)(v0+v10);
        static_array<unsigned char,2> v13;
        v13 = f_11(v11);
        v4[v6] = v13;
        v6 += 1 ;
    }
    static_array<int,2> v14;
    int v16;
    v16 = 0;
    while (while_method_0(v16)){
        unsigned long long v18;
        v18 = (unsigned long long)v16;
        unsigned long long v19;
        v19 = v18 * 4ull;
        unsigned long long v20;
        v20 = 8ull + v19;
        unsigned char * v21;
        v21 = (unsigned char *)(v0+v20);
        int v23;
        v23 = f_1(v21);
        v14[v16] = v23;
        v16 += 1 ;
    }
    int * v24;
    v24 = (int *)(v0+16ull);
    int v26;
    v26 = v24[0];
    static_array<int,2> v27;
    int v29;
    v29 = 0;
    while (while_method_0(v29)){
        unsigned long long v31;
        v31 = (unsigned long long)v29;
        unsigned long long v32;
        v32 = v31 * 4ull;
        unsigned long long v33;
        v33 = 20ull + v32;
        unsigned char * v34;
        v34 = (unsigned char *)(v0+v33);
        int v36;
        v36 = f_1(v34);
        v27[v29] = v36;
        v29 += 1 ;
    }
    int v37;
    v37 = f_14(v0);
    unsigned char * v38;
    v38 = (unsigned char *)(v0+32ull);
    Union5 v48;
    switch (v37) {
        case 0: {
            static_array<unsigned char,3> v41;
            v41 = f_15(v38);
            v48 = Union5{Union5_0{v41}};
            break;
        }
        case 1: {
            f_3(v38);
            v48 = Union5{Union5_1{}};
            break;
        }
        case 2: {
            static_array<unsigned char,5> v44;
            v44 = f_16(v38);
            v48 = Union5{Union5_2{v44}};
            break;
        }
        case 3: {
            static_array<unsigned char,4> v46;
            v46 = f_17(v38);
            v48 = Union5{Union5_3{v46}};
            break;
        }
        default: {
            printf("%s\n", "Invalid tag.");
            __trap();
        }
    }
    return Tuple2{v3, v4, v14, v26, v27, v48};
}
__device__ int f_19(unsigned char * v0){
    int * v1;
    v1 = (int *)(v0+40ull);
    int v3;
    v3 = v1[0];
    return v3;
}
__device__ Tuple3 f_18(unsigned char * v0){
    int * v1;
    v1 = (int *)(v0+0ull);
    int v3;
    v3 = v1[0];
    static_array<static_array<unsigned char,2>,2> v4;
    int v6;
    v6 = 0;
    while (while_method_0(v6)){
        unsigned long long v8;
        v8 = (unsigned long long)v6;
        unsigned long long v9;
        v9 = v8 * 2ull;
        unsigned long long v10;
        v10 = 4ull + v9;
        unsigned char * v11;
        v11 = (unsigned char *)(v0+v10);
        static_array<unsigned char,2> v13;
        v13 = f_11(v11);
        v4[v6] = v13;
        v6 += 1 ;
    }
    static_array<int,2> v14;
    int v16;
    v16 = 0;
    while (while_method_0(v16)){
        unsigned long long v18;
        v18 = (unsigned long long)v16;
        unsigned long long v19;
        v19 = v18 * 4ull;
        unsigned long long v20;
        v20 = 8ull + v19;
        unsigned char * v21;
        v21 = (unsigned char *)(v0+v20);
        int v23;
        v23 = f_1(v21);
        v14[v16] = v23;
        v16 += 1 ;
    }
    int * v24;
    v24 = (int *)(v0+16ull);
    int v26;
    v26 = v24[0];
    static_array<int,2> v27;
    int v29;
    v29 = 0;
    while (while_method_0(v29)){
        unsigned long long v31;
        v31 = (unsigned long long)v29;
        unsigned long long v32;
        v32 = v31 * 4ull;
        unsigned long long v33;
        v33 = 20ull + v32;
        unsigned char * v34;
        v34 = (unsigned char *)(v0+v33);
        int v36;
        v36 = f_1(v34);
        v27[v29] = v36;
        v29 += 1 ;
    }
    int v37;
    v37 = f_14(v0);
    unsigned char * v38;
    v38 = (unsigned char *)(v0+32ull);
    Union5 v48;
    switch (v37) {
        case 0: {
            static_array<unsigned char,3> v41;
            v41 = f_15(v38);
            v48 = Union5{Union5_0{v41}};
            break;
        }
        case 1: {
            f_3(v38);
            v48 = Union5{Union5_1{}};
            break;
        }
        case 2: {
            static_array<unsigned char,5> v44;
            v44 = f_16(v38);
            v48 = Union5{Union5_2{v44}};
            break;
        }
        case 3: {
            static_array<unsigned char,4> v46;
            v46 = f_17(v38);
            v48 = Union5{Union5_3{v46}};
            break;
        }
        default: {
            printf("%s\n", "Invalid tag.");
            __trap();
        }
    }
    int v49;
    v49 = f_19(v0);
    unsigned char * v50;
    v50 = (unsigned char *)(v0+44ull);
    Union1 v58;
    switch (v49) {
        case 0: {
            f_3(v50);
            v58 = Union1{Union1_0{}};
            break;
        }
        case 1: {
            f_3(v50);
            v58 = Union1{Union1_1{}};
            break;
        }
        case 2: {
            f_3(v50);
            v58 = Union1{Union1_2{}};
            break;
        }
        case 3: {
            int v56;
            v56 = f_1(v50);
            v58 = Union1{Union1_3{v56}};
            break;
        }
        default: {
            printf("%s\n", "Invalid tag.");
            __trap();
        }
    }
    return Tuple3{v3, v4, v14, v26, v27, v48, v58};
}
__device__ Union4 f_9(unsigned char * v0){
    int v1;
    v1 = f_1(v0);
    unsigned char * v2;
    v2 = (unsigned char *)(v0+16ull);
    switch (v1) {
        case 0: {
            int v5; static_array<static_array<unsigned char,2>,2> v6; static_array<int,2> v7; int v8; static_array<int,2> v9; Union5 v10;
            Tuple2 tmp0 = f_10(v2);
            v5 = tmp0.v0; v6 = tmp0.v1; v7 = tmp0.v2; v8 = tmp0.v3; v9 = tmp0.v4; v10 = tmp0.v5;
            return Union4{Union4_0{v5, v6, v7, v8, v9, v10}};
            break;
        }
        case 1: {
            int v12; static_array<static_array<unsigned char,2>,2> v13; static_array<int,2> v14; int v15; static_array<int,2> v16; Union5 v17;
            Tuple2 tmp1 = f_10(v2);
            v12 = tmp1.v0; v13 = tmp1.v1; v14 = tmp1.v2; v15 = tmp1.v3; v16 = tmp1.v4; v17 = tmp1.v5;
            return Union4{Union4_1{v12, v13, v14, v15, v16, v17}};
            break;
        }
        case 2: {
            f_3(v2);
            return Union4{Union4_2{}};
            break;
        }
        case 3: {
            int v20; static_array<static_array<unsigned char,2>,2> v21; static_array<int,2> v22; int v23; static_array<int,2> v24; Union5 v25;
            Tuple2 tmp2 = f_10(v2);
            v20 = tmp2.v0; v21 = tmp2.v1; v22 = tmp2.v2; v23 = tmp2.v3; v24 = tmp2.v4; v25 = tmp2.v5;
            return Union4{Union4_3{v20, v21, v22, v23, v24, v25}};
            break;
        }
        case 4: {
            int v27; static_array<static_array<unsigned char,2>,2> v28; static_array<int,2> v29; int v30; static_array<int,2> v31; Union5 v32;
            Tuple2 tmp3 = f_10(v2);
            v27 = tmp3.v0; v28 = tmp3.v1; v29 = tmp3.v2; v30 = tmp3.v3; v31 = tmp3.v4; v32 = tmp3.v5;
            return Union4{Union4_4{v27, v28, v29, v30, v31, v32}};
            break;
        }
        case 5: {
            int v34; static_array<static_array<unsigned char,2>,2> v35; static_array<int,2> v36; int v37; static_array<int,2> v38; Union5 v39; Union1 v40;
            Tuple3 tmp4 = f_18(v2);
            v34 = tmp4.v0; v35 = tmp4.v1; v36 = tmp4.v2; v37 = tmp4.v3; v38 = tmp4.v4; v39 = tmp4.v5; v40 = tmp4.v6;
            return Union4{Union4_5{v34, v35, v36, v37, v38, v39, v40}};
            break;
        }
        case 6: {
            int v42; static_array<static_array<unsigned char,2>,2> v43; static_array<int,2> v44; int v45; static_array<int,2> v46; Union5 v47;
            Tuple2 tmp5 = f_10(v2);
            v42 = tmp5.v0; v43 = tmp5.v1; v44 = tmp5.v2; v45 = tmp5.v3; v46 = tmp5.v4; v47 = tmp5.v5;
            return Union4{Union4_6{v42, v43, v44, v45, v46, v47}};
            break;
        }
        case 7: {
            int v49; static_array<static_array<unsigned char,2>,2> v50; static_array<int,2> v51; int v52; static_array<int,2> v53; Union5 v54;
            Tuple2 tmp6 = f_10(v2);
            v49 = tmp6.v0; v50 = tmp6.v1; v51 = tmp6.v2; v52 = tmp6.v3; v53 = tmp6.v4; v54 = tmp6.v5;
            return Union4{Union4_7{v49, v50, v51, v52, v53, v54}};
            break;
        }
        default: {
            printf("%s\n", "Invalid tag.");
            __trap();
        }
    }
}
__device__ int f_20(unsigned char * v0){
    int * v1;
    v1 = (int *)(v0+80ull);
    int v3;
    v3 = v1[0];
    return v3;
}
__device__ inline bool while_method_4(int v0, int v1){
    bool v2;
    v2 = v1 < v0;
    return v2;
}
__device__ static_array_list<unsigned char,5> f_22(unsigned char * v0){
    static_array_list<unsigned char,5> v1;
    v1 = static_array_list<unsigned char,5>{};
    int v3;
    v3 = f_1(v0);
    v1.unsafe_set_length(v3);
    int v4;
    v4 = v1.length;
    int v5;
    v5 = 0;
    while (while_method_4(v4, v5)){
        unsigned long long v7;
        v7 = (unsigned long long)v5;
        unsigned long long v8;
        v8 = 4ull + v7;
        unsigned char * v9;
        v9 = (unsigned char *)(v0+v8);
        unsigned char v11;
        v11 = f_12(v9);
        v1[v5] = v11;
        v5 += 1 ;
    }
    return v1;
}
__device__ Tuple4 f_23(unsigned char * v0){
    int * v1;
    v1 = (int *)(v0+0ull);
    int v3;
    v3 = v1[0];
    int * v4;
    v4 = (int *)(v0+4ull);
    int v6;
    v6 = v4[0];
    return Tuple4{v3, v6};
}
__device__ int f_25(unsigned char * v0){
    int * v1;
    v1 = (int *)(v0+4ull);
    int v3;
    v3 = v1[0];
    return v3;
}
__device__ Tuple5 f_24(unsigned char * v0){
    int * v1;
    v1 = (int *)(v0+0ull);
    int v3;
    v3 = v1[0];
    int v4;
    v4 = f_25(v0);
    unsigned char * v5;
    v5 = (unsigned char *)(v0+8ull);
    Union1 v13;
    switch (v4) {
        case 0: {
            f_3(v5);
            v13 = Union1{Union1_0{}};
            break;
        }
        case 1: {
            f_3(v5);
            v13 = Union1{Union1_1{}};
            break;
        }
        case 2: {
            f_3(v5);
            v13 = Union1{Union1_2{}};
            break;
        }
        case 3: {
            int v11;
            v11 = f_1(v5);
            v13 = Union1{Union1_3{v11}};
            break;
        }
        default: {
            printf("%s\n", "Invalid tag.");
            __trap();
        }
    }
    return Tuple5{v3, v13};
}
__device__ Tuple6 f_26(unsigned char * v0){
    int * v1;
    v1 = (int *)(v0+0ull);
    int v3;
    v3 = v1[0];
    static_array<unsigned char,2> v4;
    int v6;
    v6 = 0;
    while (while_method_0(v6)){
        unsigned long long v8;
        v8 = (unsigned long long)v6;
        unsigned long long v9;
        v9 = 4ull + v8;
        unsigned char * v10;
        v10 = (unsigned char *)(v0+v9);
        unsigned char v12;
        v12 = f_12(v10);
        v4[v6] = v12;
        v6 += 1 ;
    }
    return Tuple6{v3, v4};
}
__device__ Tuple0 f_29(unsigned char * v0){
    static_array<unsigned char,5> v1;
    int v3;
    v3 = 0;
    while (while_method_2(v3)){
        unsigned long long v5;
        v5 = (unsigned long long)v3;
        unsigned char * v6;
        v6 = (unsigned char *)(v0+v5);
        unsigned char v8;
        v8 = f_12(v6);
        v1[v3] = v8;
        v3 += 1 ;
    }
    char * v9;
    v9 = (char *)(v0+5ull);
    char v11;
    v11 = v9[0];
    return Tuple0{v1, v11};
}
__device__ Tuple0 f_28(unsigned char * v0){
    static_array<unsigned char,5> v1; char v2;
    Tuple0 tmp10 = f_29(v0);
    v1 = tmp10.v0; v2 = tmp10.v1;
    return Tuple0{v1, v2};
}
__device__ Tuple7 f_27(unsigned char * v0){
    int * v1;
    v1 = (int *)(v0+0ull);
    int v3;
    v3 = v1[0];
    static_array<Tuple0,2> v4;
    int v6;
    v6 = 0;
    while (while_method_0(v6)){
        unsigned long long v8;
        v8 = (unsigned long long)v6;
        unsigned long long v9;
        v9 = v8 * 8ull;
        unsigned long long v10;
        v10 = 8ull + v9;
        unsigned char * v11;
        v11 = (unsigned char *)(v0+v10);
        static_array<unsigned char,5> v13; char v14;
        Tuple0 tmp11 = f_28(v11);
        v13 = tmp11.v0; v14 = tmp11.v1;
        v4[v6] = Tuple0{v13, v14};
        v6 += 1 ;
    }
    int * v15;
    v15 = (int *)(v0+24ull);
    int v17;
    v17 = v15[0];
    return Tuple7{v3, v4, v17};
}
__device__ Union6 f_21(unsigned char * v0){
    int v1;
    v1 = f_1(v0);
    unsigned char * v2;
    v2 = (unsigned char *)(v0+16ull);
    switch (v1) {
        case 0: {
            static_array_list<unsigned char,5> v5;
            v5 = f_22(v2);
            return Union6{Union6_0{v5}};
            break;
        }
        case 1: {
            int v7; int v8;
            Tuple4 tmp7 = f_23(v2);
            v7 = tmp7.v0; v8 = tmp7.v1;
            return Union6{Union6_1{v7, v8}};
            break;
        }
        case 2: {
            int v10; Union1 v11;
            Tuple5 tmp8 = f_24(v2);
            v10 = tmp8.v0; v11 = tmp8.v1;
            return Union6{Union6_2{v10, v11}};
            break;
        }
        case 3: {
            int v13; static_array<unsigned char,2> v14;
            Tuple6 tmp9 = f_26(v2);
            v13 = tmp9.v0; v14 = tmp9.v1;
            return Union6{Union6_3{v13, v14}};
            break;
        }
        case 4: {
            int v16; static_array<Tuple0,2> v17; int v18;
            Tuple7 tmp12 = f_27(v2);
            v16 = tmp12.v0; v17 = tmp12.v1; v18 = tmp12.v2;
            return Union6{Union6_4{v16, v17, v18}};
            break;
        }
        default: {
            printf("%s\n", "Invalid tag.");
            __trap();
        }
    }
}
__device__ int f_30(unsigned char * v0){
    int * v1;
    v1 = (int *)(v0+6248ull);
    int v3;
    v3 = v1[0];
    return v3;
}
__device__ Tuple1 f_6(unsigned char * v0){
    unsigned long long v1;
    v1 = f_7(v0);
    int v2;
    v2 = f_8(v0);
    unsigned char * v3;
    v3 = (unsigned char *)(v0+16ull);
    Union3 v9;
    switch (v2) {
        case 0: {
            f_3(v3);
            v9 = Union3{Union3_0{}};
            break;
        }
        case 1: {
            Union4 v7;
            v7 = f_9(v3);
            v9 = Union3{Union3_1{v7}};
            break;
        }
        default: {
            printf("%s\n", "Invalid tag.");
            __trap();
        }
    }
    static_array_list<Union6,128> v10;
    v10 = static_array_list<Union6,128>{};
    int v12;
    v12 = f_20(v0);
    v10.unsafe_set_length(v12);
    int v13;
    v13 = v10.length;
    int v14;
    v14 = 0;
    while (while_method_4(v13, v14)){
        unsigned long long v16;
        v16 = (unsigned long long)v14;
        unsigned long long v17;
        v17 = v16 * 48ull;
        unsigned long long v18;
        v18 = 96ull + v17;
        unsigned char * v19;
        v19 = (unsigned char *)(v0+v18);
        Union6 v21;
        v21 = f_21(v19);
        v10[v14] = v21;
        v14 += 1 ;
    }
    static_array<Union2,2> v22;
    int v24;
    v24 = 0;
    while (while_method_0(v24)){
        unsigned long long v26;
        v26 = (unsigned long long)v24;
        unsigned long long v27;
        v27 = v26 * 4ull;
        unsigned long long v28;
        v28 = 6240ull + v27;
        unsigned char * v29;
        v29 = (unsigned char *)(v0+v28);
        Union2 v31;
        v31 = f_5(v29);
        v22[v24] = v31;
        v24 += 1 ;
    }
    int v32;
    v32 = f_30(v0);
    unsigned char * v33;
    v33 = (unsigned char *)(v0+6256ull);
    Union7 v51;
    switch (v32) {
        case 0: {
            f_3(v33);
            v51 = Union7{Union7_0{}};
            break;
        }
        case 1: {
            int v37; static_array<static_array<unsigned char,2>,2> v38; static_array<int,2> v39; int v40; static_array<int,2> v41; Union5 v42;
            Tuple2 tmp13 = f_10(v33);
            v37 = tmp13.v0; v38 = tmp13.v1; v39 = tmp13.v2; v40 = tmp13.v3; v41 = tmp13.v4; v42 = tmp13.v5;
            v51 = Union7{Union7_1{v37, v38, v39, v40, v41, v42}};
            break;
        }
        case 2: {
            int v44; static_array<static_array<unsigned char,2>,2> v45; static_array<int,2> v46; int v47; static_array<int,2> v48; Union5 v49;
            Tuple2 tmp14 = f_10(v33);
            v44 = tmp14.v0; v45 = tmp14.v1; v46 = tmp14.v2; v47 = tmp14.v3; v48 = tmp14.v4; v49 = tmp14.v5;
            v51 = Union7{Union7_2{v44, v45, v46, v47, v48, v49}};
            break;
        }
        default: {
            printf("%s\n", "Invalid tag.");
            __trap();
        }
    }
    return Tuple1{v1, v9, v10, v22, v51};
}
__device__ inline bool while_method_5(Union3 v0){
    switch (v0.tag) {
        case 0: { // None
            return false;
            break;
        }
        case 1: { // Some
            Union4 v1 = v0.case1.v0;
            return true;
            break;
        }
        default: {
            assert("Invalid tag." && false); __trap();
        }
    }
}
__device__ unsigned int loop_34(unsigned int v0, curandStatePhilox4_32_10_t & v1){
    unsigned int v2;
    v2 = curand(&v1);
    unsigned int v3;
    v3 = v2 % v0;
    unsigned int v4;
    v4 = v2 - v3;
    unsigned int v5;
    v5 = 0u - v0;
    bool v6;
    v6 = v4 <= v5;
    if (v6){
        return v3;
    } else {
        return loop_34(v0, v1);
    }
}
__device__ Tuple10 draw_card_33(curandStatePhilox4_32_10_t & v0, unsigned long long v1){
    int v2;
    v2 = __popcll(v1);
    unsigned int v3;
    v3 = (unsigned int)v2;
    unsigned int v4;
    v4 = loop_34(v3, v0);
    int v5;
    v5 = (int)v4;
    unsigned int v6;
    v6 = (unsigned int)v1;
    unsigned long long v7;
    v7 = v1 >> 32;
    unsigned int v8;
    v8 = (unsigned int)v7;
    int v9;
    v9 = __popc(v6);
    bool v10;
    v10 = v5 < v9;
    unsigned int v22;
    if (v10){
        int v11;
        v11 = v5 + 1;
        unsigned int v12;
        v12 = __fns(v6,0u,v11);
        v22 = v12;
    } else {
        int v13;
        v13 = v5 - v9;
        int v14;
        v14 = __popc(v8);
        bool v15;
        v15 = v13 < v14;
        if (v15){
            int v16;
            v16 = v13 + 1;
            unsigned int v17;
            v17 = __fns(v8,0u,v16);
            unsigned int v18;
            v18 = v17 + 32u;
            v22 = v18;
        } else {
            int v19;
            v19 = v13 - v14;
            printf("%s\n", "Cannot find the n-th set bit.");
            __trap();
        }
    }
    unsigned char v23;
    v23 = (unsigned char)v22;
    int v24;
    v24 = (int)v22;
    unsigned long long v25;
    v25 = 1ull << v24;
    unsigned long long v26;
    v26 = v1 ^ v25;
    return Tuple10{v23, v26};
}
__device__ Tuple8 draw_cards_32(curandStatePhilox4_32_10_t & v0, unsigned long long v1){
    static_array<unsigned char,3> v2;
    int v4; unsigned long long v5;
    Tuple9 tmp16 = Tuple9{0, v1};
    v4 = tmp16.v0; v5 = tmp16.v1;
    while (while_method_1(v4)){
        unsigned char v7; unsigned long long v8;
        Tuple10 tmp17 = draw_card_33(v0, v5);
        v7 = tmp17.v0; v8 = tmp17.v1;
        v2[v4] = v7;
        v5 = v8;
        v4 += 1 ;
    }
    return Tuple8{v2, v5};
}
__device__ static_array_list<unsigned char,5> get_community_cards_35(Union5 v0, static_array<unsigned char,3> v1){
    static_array_list<unsigned char,5> v2;
    v2 = static_array_list<unsigned char,5>{};
    switch (v0.tag) {
        case 0: { // Flop
            static_array<unsigned char,3> v4 = v0.case0.v0;
            int v5;
            v5 = 0;
            while (while_method_1(v5)){
                bool v7;
                v7 = 0 <= v5;
                bool v9;
                if (v7){
                    bool v8;
                    v8 = v5 < 3;
                    v9 = v8;
                } else {
                    v9 = false;
                }
                bool v10;
                v10 = v9 == false;
                if (v10){
                    assert("Index must be in range." && v9);
                } else {
                }
                unsigned char v12;
                v12 = v4[v5];
                v2.push(v12);
                v5 += 1 ;
            }
            break;
        }
        case 1: { // Preflop
            break;
        }
        case 2: { // River
            static_array<unsigned char,5> v24 = v0.case2.v0;
            int v25;
            v25 = 0;
            while (while_method_2(v25)){
                bool v27;
                v27 = 0 <= v25;
                bool v29;
                if (v27){
                    bool v28;
                    v28 = v25 < 5;
                    v29 = v28;
                } else {
                    v29 = false;
                }
                bool v30;
                v30 = v29 == false;
                if (v30){
                    assert("Index must be in range." && v29);
                } else {
                }
                unsigned char v32;
                v32 = v24[v25];
                v2.push(v32);
                v25 += 1 ;
            }
            break;
        }
        case 3: { // Turn
            static_array<unsigned char,4> v14 = v0.case3.v0;
            int v15;
            v15 = 0;
            while (while_method_3(v15)){
                bool v17;
                v17 = 0 <= v15;
                bool v19;
                if (v17){
                    bool v18;
                    v18 = v15 < 4;
                    v19 = v18;
                } else {
                    v19 = false;
                }
                bool v20;
                v20 = v19 == false;
                if (v20){
                    assert("Index must be in range." && v19);
                } else {
                }
                unsigned char v22;
                v22 = v14[v15];
                v2.push(v22);
                v15 += 1 ;
            }
            break;
        }
        default: {
            assert("Invalid tag." && false); __trap();
        }
    }
    int v34;
    v34 = 0;
    while (while_method_1(v34)){
        bool v36;
        v36 = 0 <= v34;
        bool v38;
        if (v36){
            bool v37;
            v37 = v34 < 3;
            v38 = v37;
        } else {
            v38 = false;
        }
        bool v39;
        v39 = v38 == false;
        if (v39){
            assert("Index must be in range." && v38);
        } else {
        }
        unsigned char v41;
        v41 = v1[v34];
        v2.push(v41);
        v34 += 1 ;
    }
    return v2;
}
__device__ bool player_can_act_37(int v0, static_array<static_array<unsigned char,2>,2> v1, static_array<int,2> v2, int v3, static_array<int,2> v4, Union5 v5){
    int v6;
    v6 = v3 % 2;
    bool v7;
    v7 = 0 <= v6;
    bool v9;
    if (v7){
        bool v8;
        v8 = v6 < 2;
        v9 = v8;
    } else {
        v9 = false;
    }
    bool v10;
    v10 = v9 == false;
    if (v10){
        assert("Index must be in range." && v9);
    } else {
    }
    int v12;
    v12 = v4[v6];
    bool v14;
    v14 = v12 > 0;
    bool v16;
    if (v7){
        bool v15;
        v15 = v6 < 2;
        v16 = v15;
    } else {
        v16 = false;
    }
    bool v17;
    v17 = v16 == false;
    if (v17){
        assert("Index must be in range." && v16);
    } else {
    }
    int v19;
    v19 = v2[v6];
    int v21;
    v21 = v2[0];
    int v23; int v24;
    Tuple4 tmp19 = Tuple4{1, v21};
    v23 = tmp19.v0; v24 = tmp19.v1;
    while (while_method_0(v23)){
        bool v26;
        v26 = 0 <= v23;
        bool v28;
        if (v26){
            bool v27;
            v27 = v23 < 2;
            v28 = v27;
        } else {
            v28 = false;
        }
        bool v29;
        v29 = v28 == false;
        if (v29){
            assert("Index must be in range." && v28);
        } else {
        }
        int v31;
        v31 = v2[v23];
        bool v33;
        v33 = v24 >= v31;
        int v34;
        if (v33){
            v34 = v24;
        } else {
            v34 = v31;
        }
        v24 = v34;
        v23 += 1 ;
    }
    bool v35;
    v35 = v19 < v24;
    int v36; int v37;
    Tuple4 tmp20 = Tuple4{0, 0};
    v36 = tmp20.v0; v37 = tmp20.v1;
    while (while_method_0(v36)){
        bool v39;
        v39 = 0 <= v36;
        bool v41;
        if (v39){
            bool v40;
            v40 = v36 < 2;
            v41 = v40;
        } else {
            v41 = false;
        }
        bool v42;
        v42 = v41 == false;
        if (v42){
            assert("Index must be in range." && v41);
        } else {
        }
        int v44;
        v44 = v4[v36];
        bool v46;
        v46 = 0 < v44;
        int v47;
        if (v46){
            v47 = 1;
        } else {
            v47 = 0;
        }
        int v48;
        v48 = v37 + v47;
        v37 = v48;
        v36 += 1 ;
    }
    if (v14){
        if (v35){
            return true;
        } else {
            bool v49;
            v49 = v3 < 2;
            if (v49){
                bool v50;
                v50 = 0 < v37;
                return v50;
            } else {
                return false;
            }
        }
    } else {
        return false;
    }
}
__device__ Union4 go_next_street_38(int v0, static_array<static_array<unsigned char,2>,2> v1, static_array<int,2> v2, int v3, static_array<int,2> v4, Union5 v5){
    switch (v5.tag) {
        case 0: { // Flop
            static_array<unsigned char,3> v7 = v5.case0.v0;
            return Union4{Union4_7{v0, v1, v2, v3, v4, v5}};
            break;
        }
        case 1: { // Preflop
            return Union4{Union4_0{v0, v1, v2, v3, v4, v5}};
            break;
        }
        case 2: { // River
            static_array<unsigned char,5> v11 = v5.case2.v0;
            return Union4{Union4_6{v0, v1, v2, v3, v4, v5}};
            break;
        }
        case 3: { // Turn
            static_array<unsigned char,4> v9 = v5.case3.v0;
            return Union4{Union4_3{v0, v1, v2, v3, v4, v5}};
            break;
        }
        default: {
            assert("Invalid tag." && false); __trap();
        }
    }
}
__device__ Union4 try_round_36(int v0, static_array<static_array<unsigned char,2>,2> v1, static_array<int,2> v2, int v3, static_array<int,2> v4, Union5 v5){
    int v6;
    v6 = v3 + 1;
    bool v7;
    v7 = player_can_act_37(v0, v1, v2, v3, v4, v5);
    if (v7){
        return Union4{Union4_4{v0, v1, v2, v3, v4, v5}};
    } else {
        bool v9;
        v9 = player_can_act_37(v0, v1, v2, v6, v4, v5);
        if (v9){
            return Union4{Union4_4{v0, v1, v2, v6, v4, v5}};
        } else {
            return go_next_street_38(v0, v1, v2, v3, v4, v5);
        }
    }
}
__device__ Tuple11 draw_cards_39(curandStatePhilox4_32_10_t & v0, unsigned long long v1){
    static_array<unsigned char,2> v2;
    int v4; unsigned long long v5;
    Tuple9 tmp21 = Tuple9{0, v1};
    v4 = tmp21.v0; v5 = tmp21.v1;
    while (while_method_0(v4)){
        unsigned char v7; unsigned long long v8;
        Tuple10 tmp22 = draw_card_33(v0, v5);
        v7 = tmp22.v0; v8 = tmp22.v1;
        v2[v4] = v7;
        v5 = v8;
        v4 += 1 ;
    }
    return Tuple11{v2, v5};
}
__device__ inline bool while_method_6(int v0){
    bool v1;
    v1 = v0 < 1;
    return v1;
}
__device__ Tuple12 draw_cards_40(curandStatePhilox4_32_10_t & v0, unsigned long long v1){
    static_array<unsigned char,1> v2;
    int v4; unsigned long long v5;
    Tuple9 tmp25 = Tuple9{0, v1};
    v4 = tmp25.v0; v5 = tmp25.v1;
    while (while_method_6(v4)){
        unsigned char v7; unsigned long long v8;
        Tuple10 tmp26 = draw_card_33(v0, v5);
        v7 = tmp26.v0; v8 = tmp26.v1;
        v2[v4] = v7;
        v5 = v8;
        v4 += 1 ;
    }
    return Tuple12{v2, v5};
}
__device__ static_array_list<unsigned char,5> get_community_cards_41(Union5 v0, static_array<unsigned char,1> v1){
    static_array_list<unsigned char,5> v2;
    v2 = static_array_list<unsigned char,5>{};
    switch (v0.tag) {
        case 0: { // Flop
            static_array<unsigned char,3> v4 = v0.case0.v0;
            int v5;
            v5 = 0;
            while (while_method_1(v5)){
                bool v7;
                v7 = 0 <= v5;
                bool v9;
                if (v7){
                    bool v8;
                    v8 = v5 < 3;
                    v9 = v8;
                } else {
                    v9 = false;
                }
                bool v10;
                v10 = v9 == false;
                if (v10){
                    assert("Index must be in range." && v9);
                } else {
                }
                unsigned char v12;
                v12 = v4[v5];
                v2.push(v12);
                v5 += 1 ;
            }
            break;
        }
        case 1: { // Preflop
            break;
        }
        case 2: { // River
            static_array<unsigned char,5> v24 = v0.case2.v0;
            int v25;
            v25 = 0;
            while (while_method_2(v25)){
                bool v27;
                v27 = 0 <= v25;
                bool v29;
                if (v27){
                    bool v28;
                    v28 = v25 < 5;
                    v29 = v28;
                } else {
                    v29 = false;
                }
                bool v30;
                v30 = v29 == false;
                if (v30){
                    assert("Index must be in range." && v29);
                } else {
                }
                unsigned char v32;
                v32 = v24[v25];
                v2.push(v32);
                v25 += 1 ;
            }
            break;
        }
        case 3: { // Turn
            static_array<unsigned char,4> v14 = v0.case3.v0;
            int v15;
            v15 = 0;
            while (while_method_3(v15)){
                bool v17;
                v17 = 0 <= v15;
                bool v19;
                if (v17){
                    bool v18;
                    v18 = v15 < 4;
                    v19 = v18;
                } else {
                    v19 = false;
                }
                bool v20;
                v20 = v19 == false;
                if (v20){
                    assert("Index must be in range." && v19);
                } else {
                }
                unsigned char v22;
                v22 = v14[v15];
                v2.push(v22);
                v15 += 1 ;
            }
            break;
        }
        default: {
            assert("Invalid tag." && false); __trap();
        }
    }
    int v34;
    v34 = 0;
    while (while_method_6(v34)){
        bool v36;
        v36 = 0 <= v34;
        bool v38;
        if (v36){
            bool v37;
            v37 = v34 < 1;
            v38 = v37;
        } else {
            v38 = false;
        }
        bool v39;
        v39 = v38 == false;
        if (v39){
            assert("Index must be in range." && v38);
        } else {
        }
        unsigned char v41;
        v41 = v1[v34];
        v2.push(v41);
        v34 += 1 ;
    }
    return v2;
}
__device__ inline bool while_method_7(int v0){
    bool v1;
    v1 = v0 < 524288;
    return v1;
}
__device__ inline bool while_method_8(int v0){
    bool v1;
    v1 = v0 < 10;
    return v1;
}
__device__ void method_42(unsigned int v0, float * v1, int v2){
    unsigned int v3;
    v3 = v0 + 1u;
    bool v4;
    v4 = v3 == 0u;
    bool v5;
    v5 = v4 != true;
    bool v6;
    v6 = v5 == false;
    if (v6){
        assert("Pickle failure. The input is too large in the binary serializer." && v5);
    } else {
    }
    int v8; unsigned int v9;
    Tuple13 tmp29 = Tuple13{0, v3};
    v8 = tmp29.v0; v9 = tmp29.v1;
    while (while_method_8(v8)){
        unsigned int v11;
        v11 = v9 & 1u;
        int v12;
        v12 = v2 + v8;
        float v13;
        v13 = (float)v11;
        v1[v12] = v13;
        unsigned int v14;
        v14 = v9 >> 1;
        v9 = v14;
        v8 += 1 ;
    }
    bool v15;
    v15 = v9 == 0u;
    bool v16;
    v16 = v15 == false;
    if (v16){
        assert("Picke failure. The remains of the input has to equal zero in the binary pickler." && v15);
        return ;
    } else {
        return ;
    }
}
__device__ inline bool while_method_9(int v0){
    bool v1;
    v1 = v0 < 11;
    return v1;
}
__device__ void method_43(unsigned int v0, float * v1, int v2){
    unsigned int v3;
    v3 = v0 + 1u;
    bool v4;
    v4 = v3 == 0u;
    bool v5;
    v5 = v4 != true;
    bool v6;
    v6 = v5 == false;
    if (v6){
        assert("Pickle failure. The input is too large in the binary serializer." && v5);
    } else {
    }
    int v8; unsigned int v9;
    Tuple13 tmp30 = Tuple13{0, v3};
    v8 = tmp30.v0; v9 = tmp30.v1;
    while (while_method_9(v8)){
        unsigned int v11;
        v11 = v9 & 1u;
        int v12;
        v12 = v2 + v8;
        float v13;
        v13 = (float)v11;
        v1[v12] = v13;
        unsigned int v14;
        v14 = v9 >> 1;
        v9 = v14;
        v8 += 1 ;
    }
    bool v15;
    v15 = v9 == 0u;
    bool v16;
    v16 = v15 == false;
    if (v16){
        assert("Picke failure. The remains of the input has to equal zero in the binary pickler." && v15);
        return ;
    } else {
        return ;
    }
}
__device__ int int_range_44(int v0, int v1, curandStatePhilox4_32_10_t & v2){
    int v3;
    v3 = v0 - v1;
    unsigned int v4;
    v4 = (unsigned int)v3;
    unsigned int v5;
    v5 = loop_34(v4, v2);
    unsigned int v6;
    v6 = (unsigned int)v1;
    unsigned int v7;
    v7 = v5 + v6;
    int v8;
    v8 = (int)v7;
    return v8;
}
__device__ inline bool while_method_10(int v0){
    bool v1;
    v1 = v0 < 8;
    return v1;
}
__device__ inline bool while_method_11(int v0){
    bool v1;
    v1 = v0 < 32;
    return v1;
}
__device__ inline bool while_method_12(int v0){
    bool v1;
    v1 = v0 < 16;
    return v1;
}
__device__ void block_matmul_45(float * v0, float * v1, int v2, float * v3){
    int v4;
    v4 = blockIdx.x;
    assert("Tensor range check" && 0 <= v4 && v4 < 24);
    int v5;
    v5 = 524288 * v4;
    int v6;
    v6 = blockIdx.x;
    assert("Tensor range check" && 0 <= v6 && v6 < 24);
    int v7;
    v7 = 65536 * v6;
    cuda::pipeline<cuda::thread_scope_thread> v8 = cuda::make_pipeline();
    extern __shared__ unsigned char v9[];
    float * v10;
    v10 = reinterpret_cast<float *>(&v9[0ull]);
    float * v12;
    v12 = reinterpret_cast<float *>(&v9[34816ull]);
    float * v14;
    v14 = reinterpret_cast<float *>(&v9[0ull]);
    int v16;
    v16 = threadIdx.x;
    int v17;
    v17 = v16 / 32;
    bool v18;
    v18 = 0 <= v17;
    bool v19;
    v19 = v18 == false;
    if (v19){
        assert("The index needs to be zero or positive." && v18);
    } else {
    }
    int v21;
    v21 = v17 % 8;
    int v22;
    v22 = v17 / 8;
    bool v23;
    v23 = v22 < 1;
    bool v24;
    v24 = v23 == false;
    if (v24){
        assert("The last element of the projection dimensions needs to be greater than the index remainder." && v23);
    } else {
    }
    assert("Tensor range check" && 0 <= v22 && v22 < 1);
    assert("Tensor range check" && 0 <= v21 && v21 < 8);
    int v26;
    v26 = 16 * v21;
    int v27;
    v27 = 17408 * v22;
    int v28;
    v28 = v27 + v26;
    float * v29;
    v29 = v14+v28;
    assert("Tensor range check" && 0 <= v22 && v22 < 1);
    int v31;
    v31 = 8704 * v22;
    int v32;
    v32 = threadIdx.x;
    int v33;
    v33 = v32 % 32;
    bool v34;
    v34 = 0 <= v33;
    bool v35;
    v35 = v34 == false;
    if (v35){
        assert("The index needs to be zero or positive." && v34);
    } else {
    }
    int v37;
    v37 = v33 % 4;
    int v38;
    v38 = v33 / 4;
    bool v39;
    v39 = v38 < 8;
    bool v40;
    v40 = v39 == false;
    if (v40){
        assert("The last element of the projection dimensions needs to be greater than the index remainder." && v39);
    } else {
    }
    assert("Tensor range check" && 0 <= v38 && v38 < 8);
    assert("Tensor range check" && 0 <= v37 && v37 < 4);
    int v42;
    v42 = v37 + v31;
    int v43;
    v43 = 68 * v38;
    int v44;
    v44 = v43 + v42;
    float * v45;
    v45 = v10+v44;
    assert("Tensor range check" && 0 <= v21 && v21 < 8);
    int v47;
    v47 = 1088 * v21;
    int v48;
    v48 = threadIdx.x;
    int v49;
    v49 = v48 % 32;
    bool v50;
    v50 = 0 <= v49;
    bool v51;
    v51 = v50 == false;
    if (v51){
        assert("The index needs to be zero or positive." && v50);
    } else {
    }
    int v53;
    v53 = v49 % 4;
    int v54;
    v54 = v49 / 4;
    bool v55;
    v55 = v54 < 8;
    bool v56;
    v56 = v55 == false;
    if (v56){
        assert("The last element of the projection dimensions needs to be greater than the index remainder." && v55);
    } else {
    }
    assert("Tensor range check" && 0 <= v54 && v54 < 8);
    assert("Tensor range check" && 0 <= v53 && v53 < 4);
    int v58;
    v58 = v53 + v47;
    int v59;
    v59 = 68 * v54;
    int v60;
    v60 = v59 + v58;
    float * v61;
    v61 = v12+v60;
    wmma::fragment<wmma::accumulator, 16, 16, 8, float> v63[8];
    int v64;
    v64 = 0;
    while (while_method_0(v64)){
        int v66;
        v66 = 0;
        while (while_method_0(v66)){
            assert("Tensor range check" && 0 <= v64 && v64 < 2);
            assert("Tensor range check" && 0 <= v66 && v66 < 2);
            int v68;
            v68 = 128 * v66;
            int v69;
            v69 = v68 + v7;
            int v70;
            v70 = 32768 * v64;
            int v71;
            v71 = v70 + v69;
            float * v72;
            v72 = v0+v71;
            // Pushing the loop unrolling to: 0
            int v74;
            v74 = 0;
            #pragma unroll
            while (while_method_10(v74)){
                int v76;
                v76 = 0;
                #pragma unroll
                while (while_method_6(v76)){
                    assert("Tensor range check" && 0 <= v74 && v74 < 8);
                    assert("Tensor range check" && 0 <= v76 && v76 < 1);
                    int v78;
                    v78 = v74 + v76;
                    wmma::fragment<wmma::accumulator, 16, 16, 8, float> & v79 = v63[v78];
                    wmma::fill_fragment(v79, 0.0f);
                    v76 += 1 ;
                }
                v74 += 1 ;
            }
            // Poping the loop unrolling to: 0
            int v80;
            v80 = 0;
            while (while_method_11(v80)){
                int v82;
                v82 = v80 + 1;
                bool v83;
                v83 = v80 == 0;
                int v84;
                v84 = v80 % 2;
                bool v85;
                v85 = 0 <= v80;
                bool v86;
                v86 = v85 == false;
                if (v86){
                    assert("The index needs to be zero or positive." && v85);
                } else {
                }
                bool v88;
                v88 = v80 < 32;
                bool v89;
                v89 = v88 == false;
                if (v89){
                    assert("The last element of the projection dimensions needs to be greater than the index remainder." && v88);
                } else {
                }
                bool v91;
                v91 = v82 < 32;
                Union9 v97;
                if (v91){
                    bool v92;
                    v92 = 0 <= v82;
                    bool v93;
                    v93 = v92 == false;
                    if (v93){
                        assert("The index needs to be zero or positive." && v92);
                    } else {
                    }
                    v97 = Union9{Union9_1{v82}};
                } else {
                    v97 = Union9{Union9_0{}};
                }
                assert("Tensor range check" && 0 <= v64 && v64 < 2);
                int v98;
                v98 = 262144 * v64;
                int v99;
                v99 = v98 + v5;
                assert("Tensor range check" && 0 <= v80 && v80 < 32);
                int v100;
                v100 = 64 * v80;
                int v101;
                v101 = v100 + v99;
                float * v102;
                v102 = v3+v101;
                assert("Tensor range check" && 0 <= v66 && v66 < 2);
                int v104;
                v104 = 262144 * v66;
                int v105;
                v105 = v104 + v2;
                if (v83){
                    assert("Tensor range check" && 0 <= v80 && v80 < 32);
                    int v106;
                    v106 = v100 + v105;
                    float * v107;
                    v107 = v1+v106;
                    // Pushing the loop unrolling to: 0
                    v8.producer_acquire();
                    int v109;
                    v109 = threadIdx.x;
                    bool v110;
                    v110 = 0 <= v109;
                    bool v111;
                    v111 = v110 == false;
                    if (v111){
                        assert("The index needs to be zero or positive." && v110);
                    } else {
                    }
                    int v113;
                    v113 = v109 % 16;
                    int v114;
                    v114 = v109 / 16;
                    bool v115;
                    v115 = v114 < 16;
                    bool v116;
                    v116 = v115 == false;
                    if (v116){
                        assert("The last element of the projection dimensions needs to be greater than the index remainder." && v115);
                    } else {
                    }
                    assert("Tensor range check" && 0 <= v114 && v114 < 16);
                    assert("Tensor range check" && 0 <= v113 && v113 < 16);
                    int v118;
                    v118 = 4 * v113;
                    int v119;
                    v119 = 68 * v114;
                    int v120;
                    v120 = v119 + v118;
                    int v121;
                    v121 = 2048 * v114;
                    int v122;
                    v122 = v121 + v118;
                    float * v123;
                    v123 = v12+v120;
                    float * v125;
                    v125 = v107+v122;
                    int v127;
                    v127 = 0;
                    #pragma unroll
                    while (while_method_10(v127)){
                        int v129;
                        v129 = 0;
                        #pragma unroll
                        while (while_method_6(v129)){
                            assert("Tensor range check" && 0 <= v127 && v127 < 8);
                            assert("Tensor range check" && 0 <= v129 && v129 < 1);
                            int v131;
                            v131 = 64 * v129;
                            int v132;
                            v132 = 1088 * v127;
                            int v133;
                            v133 = v132 + v131;
                            int v134;
                            v134 = 32768 * v127;
                            int v135;
                            v135 = v134 + v131;
                            constexpr int v136 = sizeof(float) * 4;
                            assert("Pointer alignment check" && (unsigned long long)(v125 + v135) % v136 == 0 && (unsigned long long)(v123 + v133) % v136 == 0);
                            cuda::memcpy_async(v123 + v133, v125 + v135, cuda::aligned_size_t<v136>(v136), v8);
                            v129 += 1 ;
                        }
                        v127 += 1 ;
                    }
                    v8.producer_commit();
                    // Poping the loop unrolling to: 0
                } else {
                }
                // Pushing the loop unrolling to: 0
                int v137;
                v137 = threadIdx.x;
                bool v138;
                v138 = 0 <= v137;
                bool v139;
                v139 = v138 == false;
                if (v139){
                    assert("The index needs to be zero or positive." && v138);
                } else {
                }
                int v141;
                v141 = v137 % 16;
                int v142;
                v142 = v137 / 16;
                bool v143;
                v143 = v142 < 16;
                bool v144;
                v144 = v143 == false;
                if (v144){
                    assert("The last element of the projection dimensions needs to be greater than the index remainder." && v143);
                } else {
                }
                assert("Tensor range check" && 0 <= v142 && v142 < 16);
                assert("Tensor range check" && 0 <= v141 && v141 < 16);
                int v146;
                v146 = 4 * v141;
                int v147;
                v147 = 68 * v142;
                int v148;
                v148 = v147 + v146;
                int v149;
                v149 = 2048 * v142;
                int v150;
                v150 = v149 + v146;
                float * v151;
                v151 = v10+v148;
                float * v153;
                v153 = v102+v150;
                int v155;
                v155 = 0;
                #pragma unroll
                while (while_method_10(v155)){
                    int v157;
                    v157 = 0;
                    #pragma unroll
                    while (while_method_6(v157)){
                        assert("Tensor range check" && 0 <= v155 && v155 < 8);
                        assert("Tensor range check" && 0 <= v157 && v157 < 1);
                        int v159;
                        v159 = 64 * v157;
                        int v160;
                        v160 = 1088 * v155;
                        int v161;
                        v161 = v160 + v159;
                        int v162;
                        v162 = 32768 * v155;
                        int v163;
                        v163 = v162 + v159;
                        int4* v164;
                        v164 = reinterpret_cast<int4*>(v153 + v163);
                        int4* v165;
                        v165 = reinterpret_cast<int4*>(v151 + v161);
                        assert("Pointer alignment check" && reinterpret_cast<unsigned long long>(v164) % 16 == 0 && reinterpret_cast<unsigned long long>(v165) % 16 == 0);
                        *v165 = *v164;
                        v157 += 1 ;
                    }
                    v155 += 1 ;
                }
                // Poping the loop unrolling to: 0
                wmma::fragment<wmma::matrix_a, 16, 16, 8, wmma::precision::tf32, wmma::row_major> v166[1];
                wmma::fragment<wmma::matrix_b, 16, 16, 8, wmma::precision::tf32, wmma::col_major> v167[8];
                cuda::pipeline_consumer_wait_prior<0>(v8);;
                __syncthreads();
                // Pushing the loop unrolling to: 0
                int v168;
                v168 = 0;
                #pragma unroll
                while (while_method_6(v168)){
                    int v170;
                    v170 = 0;
                    #pragma unroll
                    while (while_method_10(v170)){
                        assert("Tensor range check" && 0 <= v168 && v168 < 1);
                        assert("Tensor range check" && 0 <= v170 && v170 < 8);
                        int v172;
                        v172 = 8 * v168;
                        int v173;
                        v173 = v172 + v170;
                        wmma::fragment<wmma::matrix_b, 16, 16, 8, wmma::precision::tf32, wmma::col_major> & v174 = v167[v173];
                        assert("Tensor range check" && 0 <= v168 && v168 < 1);
                        int v175;
                        v175 = 1088 * v168;
                        assert("Tensor range check" && 0 <= v170 && v170 < 8);
                        int v176;
                        v176 = 8 * v170;
                        int v177;
                        v177 = v176 + v175;
                        int v178;
                        v178 = 0;
                        #pragma unroll
                        while (while_method_0(v178)){
                            int v180;
                            v180 = 0;
                            #pragma unroll
                            while (while_method_0(v180)){
                                assert("Tensor range check" && 0 <= v178 && v178 < 2);
                                assert("Tensor range check" && 0 <= v180 && v180 < 2);
                                int v182;
                                v182 = 4 * v180;
                                int v183;
                                v183 = v182 + v177;
                                int v184;
                                v184 = 544 * v178;
                                int v185;
                                v185 = v184 + v183;
                                float v186;
                                v186 = v61[v185];
                                bool v187;
                                v187 = 0 <= v180;
                                bool v189;
                                if (v187){
                                    bool v188;
                                    v188 = v180 < 2;
                                    v189 = v188;
                                } else {
                                    v189 = false;
                                }
                                bool v190;
                                v190 = v189 == false;
                                if (v190){
                                    assert("The indices should be inside the range of the dimension." && v189);
                                } else {
                                }
                                bool v192;
                                v192 = 0 <= v178;
                                bool v194;
                                if (v192){
                                    bool v193;
                                    v193 = v178 < 2;
                                    v194 = v193;
                                } else {
                                    v194 = false;
                                }
                                bool v195;
                                v195 = v194 == false;
                                if (v195){
                                    assert("The indices should be inside the range of the dimension." && v194);
                                } else {
                                }
                                int v197;
                                v197 = v178 * 2;
                                int v198;
                                v198 = v180 + v197;
                                v174.x[v198] = wmma::__float_to_tf32(v186);
                                v180 += 1 ;
                            }
                            v178 += 1 ;
                        }
                        v170 += 1 ;
                    }
                    v168 += 1 ;
                }
                // Poping the loop unrolling to: 0
                v8.consumer_release();
                switch (v97.tag) {
                    case 0: { // None
                        break;
                    }
                    case 1: { // Some
                        int v199 = v97.case1.v0;
                        assert("Tensor range check" && 0 <= v199 && v199 < 32);
                        int v200;
                        v200 = 64 * v199;
                        int v201;
                        v201 = v200 + v105;
                        float * v202;
                        v202 = v1+v201;
                        __syncthreads();
                        // Pushing the loop unrolling to: 0
                        v8.producer_acquire();
                        int v204;
                        v204 = threadIdx.x;
                        bool v205;
                        v205 = 0 <= v204;
                        bool v206;
                        v206 = v205 == false;
                        if (v206){
                            assert("The index needs to be zero or positive." && v205);
                        } else {
                        }
                        int v208;
                        v208 = v204 % 16;
                        int v209;
                        v209 = v204 / 16;
                        bool v210;
                        v210 = v209 < 16;
                        bool v211;
                        v211 = v210 == false;
                        if (v211){
                            assert("The last element of the projection dimensions needs to be greater than the index remainder." && v210);
                        } else {
                        }
                        assert("Tensor range check" && 0 <= v209 && v209 < 16);
                        assert("Tensor range check" && 0 <= v208 && v208 < 16);
                        int v213;
                        v213 = 4 * v208;
                        int v214;
                        v214 = 68 * v209;
                        int v215;
                        v215 = v214 + v213;
                        int v216;
                        v216 = 2048 * v209;
                        int v217;
                        v217 = v216 + v213;
                        float * v218;
                        v218 = v12+v215;
                        float * v220;
                        v220 = v202+v217;
                        int v222;
                        v222 = 0;
                        #pragma unroll
                        while (while_method_10(v222)){
                            int v224;
                            v224 = 0;
                            #pragma unroll
                            while (while_method_6(v224)){
                                assert("Tensor range check" && 0 <= v222 && v222 < 8);
                                assert("Tensor range check" && 0 <= v224 && v224 < 1);
                                int v226;
                                v226 = 64 * v224;
                                int v227;
                                v227 = 1088 * v222;
                                int v228;
                                v228 = v227 + v226;
                                int v229;
                                v229 = 32768 * v222;
                                int v230;
                                v230 = v229 + v226;
                                constexpr int v231 = sizeof(float) * 4;
                                assert("Pointer alignment check" && (unsigned long long)(v220 + v230) % v231 == 0 && (unsigned long long)(v218 + v228) % v231 == 0);
                                cuda::memcpy_async(v218 + v228, v220 + v230, cuda::aligned_size_t<v231>(v231), v8);
                                v224 += 1 ;
                            }
                            v222 += 1 ;
                        }
                        v8.producer_commit();
                        // Poping the loop unrolling to: 0
                        break;
                    }
                    default: {
                        assert("Invalid tag." && false); __trap();
                    }
                }
                // Pushing the loop unrolling to: 0
                int v232;
                v232 = 0;
                #pragma unroll
                while (while_method_10(v232)){
                    int v234;
                    v234 = 0;
                    #pragma unroll
                    while (while_method_10(v234)){
                        wmma::fragment<wmma::matrix_a, 16, 16, 8, wmma::precision::tf32, wmma::row_major> & v236 = v166[0];
                        assert("Tensor range check" && 0 <= v232 && v232 < 8);
                        int v237;
                        v237 = 1088 * v232;
                        assert("Tensor range check" && 0 <= v234 && v234 < 8);
                        int v238;
                        v238 = 8 * v234;
                        int v239;
                        v239 = v238 + v237;
                        int v240;
                        v240 = 0;
                        #pragma unroll
                        while (while_method_0(v240)){
                            int v242;
                            v242 = 0;
                            #pragma unroll
                            while (while_method_0(v242)){
                                assert("Tensor range check" && 0 <= v240 && v240 < 2);
                                assert("Tensor range check" && 0 <= v242 && v242 < 2);
                                int v244;
                                v244 = 544 * v242;
                                int v245;
                                v245 = v244 + v239;
                                int v246;
                                v246 = 4 * v240;
                                int v247;
                                v247 = v246 + v245;
                                float v248;
                                v248 = v45[v247];
                                bool v249;
                                v249 = 0 <= v242;
                                bool v251;
                                if (v249){
                                    bool v250;
                                    v250 = v242 < 2;
                                    v251 = v250;
                                } else {
                                    v251 = false;
                                }
                                bool v252;
                                v252 = v251 == false;
                                if (v252){
                                    assert("The indices should be inside the range of the dimension." && v251);
                                } else {
                                }
                                bool v254;
                                v254 = 0 <= v240;
                                bool v256;
                                if (v254){
                                    bool v255;
                                    v255 = v240 < 2;
                                    v256 = v255;
                                } else {
                                    v256 = false;
                                }
                                bool v257;
                                v257 = v256 == false;
                                if (v257){
                                    assert("The indices should be inside the range of the dimension." && v256);
                                } else {
                                }
                                int v259;
                                v259 = v240 * 2;
                                int v260;
                                v260 = v242 + v259;
                                v236.x[v260] = wmma::__float_to_tf32(v248);
                                v242 += 1 ;
                            }
                            v240 += 1 ;
                        }
                        int v261;
                        v261 = 0;
                        #pragma unroll
                        while (while_method_6(v261)){
                            assert("Tensor range check" && 0 <= v232 && v232 < 8);
                            assert("Tensor range check" && 0 <= v261 && v261 < 1);
                            int v263;
                            v263 = v232 + v261;
                            wmma::fragment<wmma::accumulator, 16, 16, 8, float> & v264 = v63[v263];
                            assert("Tensor range check" && 0 <= v261 && v261 < 1);
                            assert("Tensor range check" && 0 <= v234 && v234 < 8);
                            int v265;
                            v265 = 8 * v261;
                            int v266;
                            v266 = v265 + v234;
                            wmma::fragment<wmma::matrix_b, 16, 16, 8, wmma::precision::tf32, wmma::col_major> & v267 = v167[v266];
                            wmma::mma_sync(v264, v236, v267, v264);
                            v261 += 1 ;
                        }
                        v234 += 1 ;
                    }
                    v232 += 1 ;
                }
                // Poping the loop unrolling to: 0
                __syncthreads();
                v80 = v82;
            }
            // Pushing the loop unrolling to: 0
            int v268;
            v268 = 0;
            #pragma unroll
            while (while_method_10(v268)){
                int v270;
                v270 = 0;
                #pragma unroll
                while (while_method_6(v270)){
                    assert("Tensor range check" && 0 <= v268 && v268 < 8);
                    assert("Tensor range check" && 0 <= v270 && v270 < 1);
                    int v272;
                    v272 = v268 + v270;
                    wmma::fragment<wmma::accumulator, 16, 16, 8, float> & v273 = v63[v272];
                    assert("Tensor range check" && 0 <= v268 && v268 < 8);
                    assert("Tensor range check" && 0 <= v270 && v270 < 1);
                    int v274;
                    v274 = 16 * v270;
                    int v275;
                    v275 = 2176 * v268;
                    int v276;
                    v276 = v275 + v274;
                    float * v277;
                    v277 = v29+v276;
                    wmma::store_matrix_sync(v277, v273, 136, wmma::mem_row_major);
                    v270 += 1 ;
                }
                v268 += 1 ;
            }
            // Poping the loop unrolling to: 0
            __syncthreads();
            // Pushing the loop unrolling to: 0
            int v279;
            v279 = threadIdx.x;
            bool v280;
            v280 = 0 <= v279;
            bool v281;
            v281 = v280 == false;
            if (v281){
                assert("The index needs to be zero or positive." && v280);
            } else {
            }
            int v283;
            v283 = v279 % 32;
            int v284;
            v284 = v279 / 32;
            bool v285;
            v285 = v284 < 8;
            bool v286;
            v286 = v285 == false;
            if (v286){
                assert("The last element of the projection dimensions needs to be greater than the index remainder." && v285);
            } else {
            }
            assert("Tensor range check" && 0 <= v284 && v284 < 8);
            assert("Tensor range check" && 0 <= v283 && v283 < 32);
            int v288;
            v288 = 4 * v283;
            int v289;
            v289 = 256 * v284;
            int v290;
            v290 = v289 + v288;
            int v291;
            v291 = 136 * v284;
            int v292;
            v292 = v291 + v288;
            float * v293;
            v293 = v72+v290;
            float * v295;
            v295 = v14+v292;
            int v297;
            v297 = 0;
            #pragma unroll
            while (while_method_12(v297)){
                int v299;
                v299 = 0;
                #pragma unroll
                while (while_method_6(v299)){
                    assert("Tensor range check" && 0 <= v297 && v297 < 16);
                    assert("Tensor range check" && 0 <= v299 && v299 < 1);
                    int v301;
                    v301 = 128 * v299;
                    int v302;
                    v302 = 2048 * v297;
                    int v303;
                    v303 = v302 + v301;
                    int v304;
                    v304 = 1088 * v297;
                    int v305;
                    v305 = v304 + v301;
                    int4* v306;
                    v306 = reinterpret_cast<int4*>(v295 + v305);
                    int4* v307;
                    v307 = reinterpret_cast<int4*>(v293 + v303);
                    assert("Pointer alignment check" && reinterpret_cast<unsigned long long>(v306) % 16 == 0 && reinterpret_cast<unsigned long long>(v307) % 16 == 0);
                    *v307 = *v306;
                    v299 += 1 ;
                }
                v297 += 1 ;
            }
            // Poping the loop unrolling to: 0
            __syncthreads();
            v66 += 1 ;
        }
        v64 += 1 ;
    }
    return ;
}
__device__ inline bool while_method_13(int v0){
    bool v1;
    v1 = v0 < 16384;
    return v1;
}
__device__ void block_map_46(float * v0, float * v1){
    int v2;
    v2 = blockIdx.x;
    assert("Tensor range check" && 0 <= v2 && v2 < 24);
    int v3;
    v3 = 65536 * v2;
    int v4;
    v4 = blockIdx.x;
    assert("Tensor range check" && 0 <= v4 && v4 < 24);
    int v5;
    v5 = 65536 * v4;
    int v6;
    v6 = threadIdx.x;
    int v7;
    v7 = v6;
    while (while_method_13(v7)){
        bool v9;
        v9 = 0 <= v7;
        bool v10;
        v10 = v9 == false;
        if (v10){
            assert("The index needs to be zero or positive." && v9);
        } else {
        }
        int v12;
        v12 = v7 % 64;
        int v13;
        v13 = v7 / 64;
        bool v14;
        v14 = v13 < 256;
        bool v15;
        v15 = v14 == false;
        if (v15){
            assert("The last element of the projection dimensions needs to be greater than the index remainder." && v14);
        } else {
        }
        assert("Tensor range check" && 0 <= v13 && v13 < 256);
        assert("Tensor range check" && 0 <= v12 && v12 < 64);
        int v17;
        v17 = 4 * v12;
        int v18;
        v18 = v17 + v3;
        int v19;
        v19 = 256 * v13;
        int v20;
        v20 = v19 + v18;
        assert("Tensor range check" && 0 <= v13 && v13 < 256);
        assert("Tensor range check" && 0 <= v12 && v12 < 64);
        int v21;
        v21 = v17 + v5;
        int v22;
        v22 = v19 + v21;
        float v23[4];
        float v24[4];
        int4* v25;
        v25 = reinterpret_cast<int4*>(v1 + v20);
        int4* v26;
        v26 = reinterpret_cast<int4*>(v23 + 0);
        assert("Pointer alignment check" && reinterpret_cast<unsigned long long>(v25) % 16 == 0 && reinterpret_cast<unsigned long long>(v26) % 16 == 0);
        *v26 = *v25;
        // Pushing the loop unrolling to: 0
        int v27;
        v27 = 0;
        #pragma unroll
        while (while_method_3(v27)){
            assert("Tensor range check" && 0 <= v27 && v27 < 4);
            float v29;
            v29 = v23[v27];
            bool v30;
            v30 = 0.0f >= v29;
            float v31;
            if (v30){
                v31 = 0.0f;
            } else {
                v31 = v29;
            }
            assert("Tensor range check" && 0 <= v27 && v27 < 4);
            v24[v27] = v31;
            v27 += 1 ;
        }
        // Poping the loop unrolling to: 0
        int4* v32;
        v32 = reinterpret_cast<int4*>(v24 + 0);
        int4* v33;
        v33 = reinterpret_cast<int4*>(v0 + v22);
        assert("Pointer alignment check" && reinterpret_cast<unsigned long long>(v32) % 16 == 0 && reinterpret_cast<unsigned long long>(v33) % 16 == 0);
        *v33 = *v32;
        v7 += 256 ;
    }
    __syncthreads();
    return ;
}
__device__ inline bool while_method_14(int v0){
    bool v1;
    v1 = v0 < 4;
    return v1;
}
__device__ void block_matmul_47(float * v0, float * v1, int v2, float * v3){
    int v4;
    v4 = blockIdx.x;
    assert("Tensor range check" && 0 <= v4 && v4 < 24);
    int v5;
    v5 = 65536 * v4;
    int v6;
    v6 = blockIdx.x;
    assert("Tensor range check" && 0 <= v6 && v6 < 24);
    int v7;
    v7 = 65536 * v6;
    cuda::pipeline<cuda::thread_scope_thread> v8 = cuda::make_pipeline();
    extern __shared__ unsigned char v9[];
    float * v10;
    v10 = reinterpret_cast<float *>(&v9[0ull]);
    float * v12;
    v12 = reinterpret_cast<float *>(&v9[34816ull]);
    float * v14;
    v14 = reinterpret_cast<float *>(&v9[0ull]);
    int v16;
    v16 = threadIdx.x;
    int v17;
    v17 = v16 / 32;
    bool v18;
    v18 = 0 <= v17;
    bool v19;
    v19 = v18 == false;
    if (v19){
        assert("The index needs to be zero or positive." && v18);
    } else {
    }
    int v21;
    v21 = v17 % 8;
    int v22;
    v22 = v17 / 8;
    bool v23;
    v23 = v22 < 1;
    bool v24;
    v24 = v23 == false;
    if (v24){
        assert("The last element of the projection dimensions needs to be greater than the index remainder." && v23);
    } else {
    }
    assert("Tensor range check" && 0 <= v22 && v22 < 1);
    assert("Tensor range check" && 0 <= v21 && v21 < 8);
    int v26;
    v26 = 16 * v21;
    int v27;
    v27 = 17408 * v22;
    int v28;
    v28 = v27 + v26;
    float * v29;
    v29 = v14+v28;
    assert("Tensor range check" && 0 <= v22 && v22 < 1);
    int v31;
    v31 = 8704 * v22;
    int v32;
    v32 = threadIdx.x;
    int v33;
    v33 = v32 % 32;
    bool v34;
    v34 = 0 <= v33;
    bool v35;
    v35 = v34 == false;
    if (v35){
        assert("The index needs to be zero or positive." && v34);
    } else {
    }
    int v37;
    v37 = v33 % 4;
    int v38;
    v38 = v33 / 4;
    bool v39;
    v39 = v38 < 8;
    bool v40;
    v40 = v39 == false;
    if (v40){
        assert("The last element of the projection dimensions needs to be greater than the index remainder." && v39);
    } else {
    }
    assert("Tensor range check" && 0 <= v38 && v38 < 8);
    assert("Tensor range check" && 0 <= v37 && v37 < 4);
    int v42;
    v42 = v37 + v31;
    int v43;
    v43 = 68 * v38;
    int v44;
    v44 = v43 + v42;
    float * v45;
    v45 = v10+v44;
    assert("Tensor range check" && 0 <= v21 && v21 < 8);
    int v47;
    v47 = 1088 * v21;
    int v48;
    v48 = threadIdx.x;
    int v49;
    v49 = v48 % 32;
    bool v50;
    v50 = 0 <= v49;
    bool v51;
    v51 = v50 == false;
    if (v51){
        assert("The index needs to be zero or positive." && v50);
    } else {
    }
    int v53;
    v53 = v49 % 4;
    int v54;
    v54 = v49 / 4;
    bool v55;
    v55 = v54 < 8;
    bool v56;
    v56 = v55 == false;
    if (v56){
        assert("The last element of the projection dimensions needs to be greater than the index remainder." && v55);
    } else {
    }
    assert("Tensor range check" && 0 <= v54 && v54 < 8);
    assert("Tensor range check" && 0 <= v53 && v53 < 4);
    int v58;
    v58 = v53 + v47;
    int v59;
    v59 = 68 * v54;
    int v60;
    v60 = v59 + v58;
    float * v61;
    v61 = v12+v60;
    wmma::fragment<wmma::accumulator, 16, 16, 8, float> v63[8];
    int v64;
    v64 = 0;
    while (while_method_0(v64)){
        int v66;
        v66 = 0;
        while (while_method_0(v66)){
            assert("Tensor range check" && 0 <= v64 && v64 < 2);
            assert("Tensor range check" && 0 <= v66 && v66 < 2);
            int v68;
            v68 = 128 * v66;
            int v69;
            v69 = v68 + v7;
            int v70;
            v70 = 32768 * v64;
            int v71;
            v71 = v70 + v69;
            float * v72;
            v72 = v0+v71;
            // Pushing the loop unrolling to: 0
            int v74;
            v74 = 0;
            #pragma unroll
            while (while_method_10(v74)){
                int v76;
                v76 = 0;
                #pragma unroll
                while (while_method_6(v76)){
                    assert("Tensor range check" && 0 <= v74 && v74 < 8);
                    assert("Tensor range check" && 0 <= v76 && v76 < 1);
                    int v78;
                    v78 = v74 + v76;
                    wmma::fragment<wmma::accumulator, 16, 16, 8, float> & v79 = v63[v78];
                    wmma::fill_fragment(v79, 0.0f);
                    v76 += 1 ;
                }
                v74 += 1 ;
            }
            // Poping the loop unrolling to: 0
            int v80;
            v80 = 0;
            while (while_method_14(v80)){
                int v82;
                v82 = v80 + 1;
                bool v83;
                v83 = v80 == 0;
                int v84;
                v84 = v80 % 2;
                bool v85;
                v85 = 0 <= v80;
                bool v86;
                v86 = v85 == false;
                if (v86){
                    assert("The index needs to be zero or positive." && v85);
                } else {
                }
                bool v88;
                v88 = v80 < 4;
                bool v89;
                v89 = v88 == false;
                if (v89){
                    assert("The last element of the projection dimensions needs to be greater than the index remainder." && v88);
                } else {
                }
                bool v91;
                v91 = v82 < 4;
                Union9 v97;
                if (v91){
                    bool v92;
                    v92 = 0 <= v82;
                    bool v93;
                    v93 = v92 == false;
                    if (v93){
                        assert("The index needs to be zero or positive." && v92);
                    } else {
                    }
                    v97 = Union9{Union9_1{v82}};
                } else {
                    v97 = Union9{Union9_0{}};
                }
                assert("Tensor range check" && 0 <= v64 && v64 < 2);
                int v98;
                v98 = v70 + v5;
                assert("Tensor range check" && 0 <= v80 && v80 < 4);
                int v99;
                v99 = 64 * v80;
                int v100;
                v100 = v99 + v98;
                float * v101;
                v101 = v3+v100;
                assert("Tensor range check" && 0 <= v66 && v66 < 2);
                int v103;
                v103 = 32768 * v66;
                int v104;
                v104 = v103 + v2;
                if (v83){
                    assert("Tensor range check" && 0 <= v80 && v80 < 4);
                    int v105;
                    v105 = v99 + v104;
                    float * v106;
                    v106 = v1+v105;
                    // Pushing the loop unrolling to: 0
                    v8.producer_acquire();
                    int v108;
                    v108 = threadIdx.x;
                    bool v109;
                    v109 = 0 <= v108;
                    bool v110;
                    v110 = v109 == false;
                    if (v110){
                        assert("The index needs to be zero or positive." && v109);
                    } else {
                    }
                    int v112;
                    v112 = v108 % 16;
                    int v113;
                    v113 = v108 / 16;
                    bool v114;
                    v114 = v113 < 16;
                    bool v115;
                    v115 = v114 == false;
                    if (v115){
                        assert("The last element of the projection dimensions needs to be greater than the index remainder." && v114);
                    } else {
                    }
                    assert("Tensor range check" && 0 <= v113 && v113 < 16);
                    assert("Tensor range check" && 0 <= v112 && v112 < 16);
                    int v117;
                    v117 = 4 * v112;
                    int v118;
                    v118 = 68 * v113;
                    int v119;
                    v119 = v118 + v117;
                    int v120;
                    v120 = 256 * v113;
                    int v121;
                    v121 = v120 + v117;
                    float * v122;
                    v122 = v12+v119;
                    float * v124;
                    v124 = v106+v121;
                    int v126;
                    v126 = 0;
                    #pragma unroll
                    while (while_method_10(v126)){
                        int v128;
                        v128 = 0;
                        #pragma unroll
                        while (while_method_6(v128)){
                            assert("Tensor range check" && 0 <= v126 && v126 < 8);
                            assert("Tensor range check" && 0 <= v128 && v128 < 1);
                            int v130;
                            v130 = 64 * v128;
                            int v131;
                            v131 = 1088 * v126;
                            int v132;
                            v132 = v131 + v130;
                            int v133;
                            v133 = 4096 * v126;
                            int v134;
                            v134 = v133 + v130;
                            constexpr int v135 = sizeof(float) * 4;
                            assert("Pointer alignment check" && (unsigned long long)(v124 + v134) % v135 == 0 && (unsigned long long)(v122 + v132) % v135 == 0);
                            cuda::memcpy_async(v122 + v132, v124 + v134, cuda::aligned_size_t<v135>(v135), v8);
                            v128 += 1 ;
                        }
                        v126 += 1 ;
                    }
                    v8.producer_commit();
                    // Poping the loop unrolling to: 0
                } else {
                }
                // Pushing the loop unrolling to: 0
                int v136;
                v136 = threadIdx.x;
                bool v137;
                v137 = 0 <= v136;
                bool v138;
                v138 = v137 == false;
                if (v138){
                    assert("The index needs to be zero or positive." && v137);
                } else {
                }
                int v140;
                v140 = v136 % 16;
                int v141;
                v141 = v136 / 16;
                bool v142;
                v142 = v141 < 16;
                bool v143;
                v143 = v142 == false;
                if (v143){
                    assert("The last element of the projection dimensions needs to be greater than the index remainder." && v142);
                } else {
                }
                assert("Tensor range check" && 0 <= v141 && v141 < 16);
                assert("Tensor range check" && 0 <= v140 && v140 < 16);
                int v145;
                v145 = 4 * v140;
                int v146;
                v146 = 68 * v141;
                int v147;
                v147 = v146 + v145;
                int v148;
                v148 = 256 * v141;
                int v149;
                v149 = v148 + v145;
                float * v150;
                v150 = v10+v147;
                float * v152;
                v152 = v101+v149;
                int v154;
                v154 = 0;
                #pragma unroll
                while (while_method_10(v154)){
                    int v156;
                    v156 = 0;
                    #pragma unroll
                    while (while_method_6(v156)){
                        assert("Tensor range check" && 0 <= v154 && v154 < 8);
                        assert("Tensor range check" && 0 <= v156 && v156 < 1);
                        int v158;
                        v158 = 64 * v156;
                        int v159;
                        v159 = 1088 * v154;
                        int v160;
                        v160 = v159 + v158;
                        int v161;
                        v161 = 4096 * v154;
                        int v162;
                        v162 = v161 + v158;
                        int4* v163;
                        v163 = reinterpret_cast<int4*>(v152 + v162);
                        int4* v164;
                        v164 = reinterpret_cast<int4*>(v150 + v160);
                        assert("Pointer alignment check" && reinterpret_cast<unsigned long long>(v163) % 16 == 0 && reinterpret_cast<unsigned long long>(v164) % 16 == 0);
                        *v164 = *v163;
                        v156 += 1 ;
                    }
                    v154 += 1 ;
                }
                // Poping the loop unrolling to: 0
                wmma::fragment<wmma::matrix_a, 16, 16, 8, wmma::precision::tf32, wmma::row_major> v165[1];
                wmma::fragment<wmma::matrix_b, 16, 16, 8, wmma::precision::tf32, wmma::col_major> v166[8];
                cuda::pipeline_consumer_wait_prior<0>(v8);;
                __syncthreads();
                // Pushing the loop unrolling to: 0
                int v167;
                v167 = 0;
                #pragma unroll
                while (while_method_6(v167)){
                    int v169;
                    v169 = 0;
                    #pragma unroll
                    while (while_method_10(v169)){
                        assert("Tensor range check" && 0 <= v167 && v167 < 1);
                        assert("Tensor range check" && 0 <= v169 && v169 < 8);
                        int v171;
                        v171 = 8 * v167;
                        int v172;
                        v172 = v171 + v169;
                        wmma::fragment<wmma::matrix_b, 16, 16, 8, wmma::precision::tf32, wmma::col_major> & v173 = v166[v172];
                        assert("Tensor range check" && 0 <= v167 && v167 < 1);
                        int v174;
                        v174 = 1088 * v167;
                        assert("Tensor range check" && 0 <= v169 && v169 < 8);
                        int v175;
                        v175 = 8 * v169;
                        int v176;
                        v176 = v175 + v174;
                        int v177;
                        v177 = 0;
                        #pragma unroll
                        while (while_method_0(v177)){
                            int v179;
                            v179 = 0;
                            #pragma unroll
                            while (while_method_0(v179)){
                                assert("Tensor range check" && 0 <= v177 && v177 < 2);
                                assert("Tensor range check" && 0 <= v179 && v179 < 2);
                                int v181;
                                v181 = 4 * v179;
                                int v182;
                                v182 = v181 + v176;
                                int v183;
                                v183 = 544 * v177;
                                int v184;
                                v184 = v183 + v182;
                                float v185;
                                v185 = v61[v184];
                                bool v186;
                                v186 = 0 <= v179;
                                bool v188;
                                if (v186){
                                    bool v187;
                                    v187 = v179 < 2;
                                    v188 = v187;
                                } else {
                                    v188 = false;
                                }
                                bool v189;
                                v189 = v188 == false;
                                if (v189){
                                    assert("The indices should be inside the range of the dimension." && v188);
                                } else {
                                }
                                bool v191;
                                v191 = 0 <= v177;
                                bool v193;
                                if (v191){
                                    bool v192;
                                    v192 = v177 < 2;
                                    v193 = v192;
                                } else {
                                    v193 = false;
                                }
                                bool v194;
                                v194 = v193 == false;
                                if (v194){
                                    assert("The indices should be inside the range of the dimension." && v193);
                                } else {
                                }
                                int v196;
                                v196 = v177 * 2;
                                int v197;
                                v197 = v179 + v196;
                                v173.x[v197] = wmma::__float_to_tf32(v185);
                                v179 += 1 ;
                            }
                            v177 += 1 ;
                        }
                        v169 += 1 ;
                    }
                    v167 += 1 ;
                }
                // Poping the loop unrolling to: 0
                v8.consumer_release();
                switch (v97.tag) {
                    case 0: { // None
                        break;
                    }
                    case 1: { // Some
                        int v198 = v97.case1.v0;
                        assert("Tensor range check" && 0 <= v198 && v198 < 4);
                        int v199;
                        v199 = 64 * v198;
                        int v200;
                        v200 = v199 + v104;
                        float * v201;
                        v201 = v1+v200;
                        __syncthreads();
                        // Pushing the loop unrolling to: 0
                        v8.producer_acquire();
                        int v203;
                        v203 = threadIdx.x;
                        bool v204;
                        v204 = 0 <= v203;
                        bool v205;
                        v205 = v204 == false;
                        if (v205){
                            assert("The index needs to be zero or positive." && v204);
                        } else {
                        }
                        int v207;
                        v207 = v203 % 16;
                        int v208;
                        v208 = v203 / 16;
                        bool v209;
                        v209 = v208 < 16;
                        bool v210;
                        v210 = v209 == false;
                        if (v210){
                            assert("The last element of the projection dimensions needs to be greater than the index remainder." && v209);
                        } else {
                        }
                        assert("Tensor range check" && 0 <= v208 && v208 < 16);
                        assert("Tensor range check" && 0 <= v207 && v207 < 16);
                        int v212;
                        v212 = 4 * v207;
                        int v213;
                        v213 = 68 * v208;
                        int v214;
                        v214 = v213 + v212;
                        int v215;
                        v215 = 256 * v208;
                        int v216;
                        v216 = v215 + v212;
                        float * v217;
                        v217 = v12+v214;
                        float * v219;
                        v219 = v201+v216;
                        int v221;
                        v221 = 0;
                        #pragma unroll
                        while (while_method_10(v221)){
                            int v223;
                            v223 = 0;
                            #pragma unroll
                            while (while_method_6(v223)){
                                assert("Tensor range check" && 0 <= v221 && v221 < 8);
                                assert("Tensor range check" && 0 <= v223 && v223 < 1);
                                int v225;
                                v225 = 64 * v223;
                                int v226;
                                v226 = 1088 * v221;
                                int v227;
                                v227 = v226 + v225;
                                int v228;
                                v228 = 4096 * v221;
                                int v229;
                                v229 = v228 + v225;
                                constexpr int v230 = sizeof(float) * 4;
                                assert("Pointer alignment check" && (unsigned long long)(v219 + v229) % v230 == 0 && (unsigned long long)(v217 + v227) % v230 == 0);
                                cuda::memcpy_async(v217 + v227, v219 + v229, cuda::aligned_size_t<v230>(v230), v8);
                                v223 += 1 ;
                            }
                            v221 += 1 ;
                        }
                        v8.producer_commit();
                        // Poping the loop unrolling to: 0
                        break;
                    }
                    default: {
                        assert("Invalid tag." && false); __trap();
                    }
                }
                // Pushing the loop unrolling to: 0
                int v231;
                v231 = 0;
                #pragma unroll
                while (while_method_10(v231)){
                    int v233;
                    v233 = 0;
                    #pragma unroll
                    while (while_method_10(v233)){
                        wmma::fragment<wmma::matrix_a, 16, 16, 8, wmma::precision::tf32, wmma::row_major> & v235 = v165[0];
                        assert("Tensor range check" && 0 <= v231 && v231 < 8);
                        int v236;
                        v236 = 1088 * v231;
                        assert("Tensor range check" && 0 <= v233 && v233 < 8);
                        int v237;
                        v237 = 8 * v233;
                        int v238;
                        v238 = v237 + v236;
                        int v239;
                        v239 = 0;
                        #pragma unroll
                        while (while_method_0(v239)){
                            int v241;
                            v241 = 0;
                            #pragma unroll
                            while (while_method_0(v241)){
                                assert("Tensor range check" && 0 <= v239 && v239 < 2);
                                assert("Tensor range check" && 0 <= v241 && v241 < 2);
                                int v243;
                                v243 = 544 * v241;
                                int v244;
                                v244 = v243 + v238;
                                int v245;
                                v245 = 4 * v239;
                                int v246;
                                v246 = v245 + v244;
                                float v247;
                                v247 = v45[v246];
                                bool v248;
                                v248 = 0 <= v241;
                                bool v250;
                                if (v248){
                                    bool v249;
                                    v249 = v241 < 2;
                                    v250 = v249;
                                } else {
                                    v250 = false;
                                }
                                bool v251;
                                v251 = v250 == false;
                                if (v251){
                                    assert("The indices should be inside the range of the dimension." && v250);
                                } else {
                                }
                                bool v253;
                                v253 = 0 <= v239;
                                bool v255;
                                if (v253){
                                    bool v254;
                                    v254 = v239 < 2;
                                    v255 = v254;
                                } else {
                                    v255 = false;
                                }
                                bool v256;
                                v256 = v255 == false;
                                if (v256){
                                    assert("The indices should be inside the range of the dimension." && v255);
                                } else {
                                }
                                int v258;
                                v258 = v239 * 2;
                                int v259;
                                v259 = v241 + v258;
                                v235.x[v259] = wmma::__float_to_tf32(v247);
                                v241 += 1 ;
                            }
                            v239 += 1 ;
                        }
                        int v260;
                        v260 = 0;
                        #pragma unroll
                        while (while_method_6(v260)){
                            assert("Tensor range check" && 0 <= v231 && v231 < 8);
                            assert("Tensor range check" && 0 <= v260 && v260 < 1);
                            int v262;
                            v262 = v231 + v260;
                            wmma::fragment<wmma::accumulator, 16, 16, 8, float> & v263 = v63[v262];
                            assert("Tensor range check" && 0 <= v260 && v260 < 1);
                            assert("Tensor range check" && 0 <= v233 && v233 < 8);
                            int v264;
                            v264 = 8 * v260;
                            int v265;
                            v265 = v264 + v233;
                            wmma::fragment<wmma::matrix_b, 16, 16, 8, wmma::precision::tf32, wmma::col_major> & v266 = v166[v265];
                            wmma::mma_sync(v263, v235, v266, v263);
                            v260 += 1 ;
                        }
                        v233 += 1 ;
                    }
                    v231 += 1 ;
                }
                // Poping the loop unrolling to: 0
                __syncthreads();
                v80 = v82;
            }
            // Pushing the loop unrolling to: 0
            int v267;
            v267 = 0;
            #pragma unroll
            while (while_method_10(v267)){
                int v269;
                v269 = 0;
                #pragma unroll
                while (while_method_6(v269)){
                    assert("Tensor range check" && 0 <= v267 && v267 < 8);
                    assert("Tensor range check" && 0 <= v269 && v269 < 1);
                    int v271;
                    v271 = v267 + v269;
                    wmma::fragment<wmma::accumulator, 16, 16, 8, float> & v272 = v63[v271];
                    assert("Tensor range check" && 0 <= v267 && v267 < 8);
                    assert("Tensor range check" && 0 <= v269 && v269 < 1);
                    int v273;
                    v273 = 16 * v269;
                    int v274;
                    v274 = 2176 * v267;
                    int v275;
                    v275 = v274 + v273;
                    float * v276;
                    v276 = v29+v275;
                    wmma::store_matrix_sync(v276, v272, 136, wmma::mem_row_major);
                    v269 += 1 ;
                }
                v267 += 1 ;
            }
            // Poping the loop unrolling to: 0
            __syncthreads();
            // Pushing the loop unrolling to: 0
            int v278;
            v278 = threadIdx.x;
            bool v279;
            v279 = 0 <= v278;
            bool v280;
            v280 = v279 == false;
            if (v280){
                assert("The index needs to be zero or positive." && v279);
            } else {
            }
            int v282;
            v282 = v278 % 32;
            int v283;
            v283 = v278 / 32;
            bool v284;
            v284 = v283 < 8;
            bool v285;
            v285 = v284 == false;
            if (v285){
                assert("The last element of the projection dimensions needs to be greater than the index remainder." && v284);
            } else {
            }
            assert("Tensor range check" && 0 <= v283 && v283 < 8);
            assert("Tensor range check" && 0 <= v282 && v282 < 32);
            int v287;
            v287 = 4 * v282;
            int v288;
            v288 = 256 * v283;
            int v289;
            v289 = v288 + v287;
            int v290;
            v290 = 136 * v283;
            int v291;
            v291 = v290 + v287;
            float * v292;
            v292 = v72+v289;
            float * v294;
            v294 = v14+v291;
            int v296;
            v296 = 0;
            #pragma unroll
            while (while_method_12(v296)){
                int v298;
                v298 = 0;
                #pragma unroll
                while (while_method_6(v298)){
                    assert("Tensor range check" && 0 <= v296 && v296 < 16);
                    assert("Tensor range check" && 0 <= v298 && v298 < 1);
                    int v300;
                    v300 = 128 * v298;
                    int v301;
                    v301 = 2048 * v296;
                    int v302;
                    v302 = v301 + v300;
                    int v303;
                    v303 = 1088 * v296;
                    int v304;
                    v304 = v303 + v300;
                    int4* v305;
                    v305 = reinterpret_cast<int4*>(v294 + v304);
                    int4* v306;
                    v306 = reinterpret_cast<int4*>(v292 + v302);
                    assert("Pointer alignment check" && reinterpret_cast<unsigned long long>(v305) % 16 == 0 && reinterpret_cast<unsigned long long>(v306) % 16 == 0);
                    *v306 = *v305;
                    v298 += 1 ;
                }
                v296 += 1 ;
            }
            // Poping the loop unrolling to: 0
            __syncthreads();
            v66 += 1 ;
        }
        v64 += 1 ;
    }
    return ;
}
__device__ inline bool while_method_15(int v0){
    bool v1;
    v1 = v0 < 8;
    return v1;
}
__device__ void block_matmul_48(float * v0, float * v1, int v2, float * v3){
    int v4;
    v4 = blockIdx.x;
    assert("Tensor range check" && 0 <= v4 && v4 < 24);
    int v5;
    v5 = 65536 * v4;
    int v6;
    v6 = blockIdx.x;
    assert("Tensor range check" && 0 <= v6 && v6 < 24);
    int v7;
    v7 = 16384 * v6;
    cuda::pipeline<cuda::thread_scope_thread> v8 = cuda::make_pipeline();
    extern __shared__ unsigned char v9[];
    float * v10;
    v10 = reinterpret_cast<float *>(&v9[0ull]);
    float * v12;
    v12 = reinterpret_cast<float *>(&v9[36864ull]);
    float * v14;
    v14 = reinterpret_cast<float *>(&v9[0ull]);
    int v16;
    v16 = threadIdx.x;
    int v17;
    v17 = v16 / 32;
    bool v18;
    v18 = 0 <= v17;
    bool v19;
    v19 = v18 == false;
    if (v19){
        assert("The index needs to be zero or positive." && v18);
    } else {
    }
    int v21;
    v21 = v17 % 4;
    int v22;
    v22 = v17 / 4;
    bool v23;
    v23 = v22 < 2;
    bool v24;
    v24 = v23 == false;
    if (v24){
        assert("The last element of the projection dimensions needs to be greater than the index remainder." && v23);
    } else {
    }
    assert("Tensor range check" && 0 <= v22 && v22 < 2);
    assert("Tensor range check" && 0 <= v21 && v21 < 4);
    int v26;
    v26 = 16 * v21;
    int v27;
    v27 = 9216 * v22;
    int v28;
    v28 = v27 + v26;
    float * v29;
    v29 = v14+v28;
    assert("Tensor range check" && 0 <= v22 && v22 < 2);
    int v31;
    v31 = 4608 * v22;
    int v32;
    v32 = threadIdx.x;
    int v33;
    v33 = v32 % 32;
    bool v34;
    v34 = 0 <= v33;
    bool v35;
    v35 = v34 == false;
    if (v35){
        assert("The index needs to be zero or positive." && v34);
    } else {
    }
    int v37;
    v37 = v33 % 4;
    int v38;
    v38 = v33 / 4;
    bool v39;
    v39 = v38 < 8;
    bool v40;
    v40 = v39 == false;
    if (v40){
        assert("The last element of the projection dimensions needs to be greater than the index remainder." && v39);
    } else {
    }
    assert("Tensor range check" && 0 <= v38 && v38 < 8);
    assert("Tensor range check" && 0 <= v37 && v37 < 4);
    int v42;
    v42 = v37 + v31;
    int v43;
    v43 = 36 * v38;
    int v44;
    v44 = v43 + v42;
    float * v45;
    v45 = v10+v44;
    assert("Tensor range check" && 0 <= v21 && v21 < 4);
    int v47;
    v47 = 576 * v21;
    int v48;
    v48 = threadIdx.x;
    int v49;
    v49 = v48 % 32;
    bool v50;
    v50 = 0 <= v49;
    bool v51;
    v51 = v50 == false;
    if (v51){
        assert("The index needs to be zero or positive." && v50);
    } else {
    }
    int v53;
    v53 = v49 % 4;
    int v54;
    v54 = v49 / 4;
    bool v55;
    v55 = v54 < 8;
    bool v56;
    v56 = v55 == false;
    if (v56){
        assert("The last element of the projection dimensions needs to be greater than the index remainder." && v55);
    } else {
    }
    assert("Tensor range check" && 0 <= v54 && v54 < 8);
    assert("Tensor range check" && 0 <= v53 && v53 < 4);
    int v58;
    v58 = v53 + v47;
    int v59;
    v59 = 36 * v54;
    int v60;
    v60 = v59 + v58;
    float * v61;
    v61 = v12+v60;
    wmma::fragment<wmma::accumulator, 16, 16, 8, float> v63[8];
    int v64;
    v64 = 0;
    while (while_method_6(v64)){
        int v66;
        v66 = 0;
        while (while_method_6(v66)){
            assert("Tensor range check" && 0 <= v64 && v64 < 1);
            assert("Tensor range check" && 0 <= v66 && v66 < 1);
            int v68;
            v68 = 64 * v66;
            int v69;
            v69 = v68 + v7;
            int v70;
            v70 = 16384 * v64;
            int v71;
            v71 = v70 + v69;
            float * v72;
            v72 = v0+v71;
            // Pushing the loop unrolling to: 0
            int v74;
            v74 = 0;
            #pragma unroll
            while (while_method_10(v74)){
                int v76;
                v76 = 0;
                #pragma unroll
                while (while_method_6(v76)){
                    assert("Tensor range check" && 0 <= v74 && v74 < 8);
                    assert("Tensor range check" && 0 <= v76 && v76 < 1);
                    int v78;
                    v78 = v74 + v76;
                    wmma::fragment<wmma::accumulator, 16, 16, 8, float> & v79 = v63[v78];
                    wmma::fill_fragment(v79, 0.0f);
                    v76 += 1 ;
                }
                v74 += 1 ;
            }
            // Poping the loop unrolling to: 0
            int v80;
            v80 = 0;
            while (while_method_15(v80)){
                int v82;
                v82 = v80 + 1;
                bool v83;
                v83 = v80 == 0;
                int v84;
                v84 = v80 % 2;
                bool v85;
                v85 = 0 <= v80;
                bool v86;
                v86 = v85 == false;
                if (v86){
                    assert("The index needs to be zero or positive." && v85);
                } else {
                }
                bool v88;
                v88 = v80 < 8;
                bool v89;
                v89 = v88 == false;
                if (v89){
                    assert("The last element of the projection dimensions needs to be greater than the index remainder." && v88);
                } else {
                }
                bool v91;
                v91 = v82 < 8;
                Union9 v97;
                if (v91){
                    bool v92;
                    v92 = 0 <= v82;
                    bool v93;
                    v93 = v92 == false;
                    if (v93){
                        assert("The index needs to be zero or positive." && v92);
                    } else {
                    }
                    v97 = Union9{Union9_1{v82}};
                } else {
                    v97 = Union9{Union9_0{}};
                }
                assert("Tensor range check" && 0 <= v64 && v64 < 1);
                int v98;
                v98 = 65536 * v64;
                int v99;
                v99 = v98 + v5;
                assert("Tensor range check" && 0 <= v80 && v80 < 8);
                int v100;
                v100 = 32 * v80;
                int v101;
                v101 = v100 + v99;
                float * v102;
                v102 = v3+v101;
                assert("Tensor range check" && 0 <= v66 && v66 < 1);
                int v104;
                v104 = 16384 * v66;
                int v105;
                v105 = v104 + v2;
                if (v83){
                    assert("Tensor range check" && 0 <= v80 && v80 < 8);
                    int v106;
                    v106 = v100 + v105;
                    float * v107;
                    v107 = v1+v106;
                    // Pushing the loop unrolling to: 0
                    v8.producer_acquire();
                    int v109;
                    v109 = threadIdx.x;
                    bool v110;
                    v110 = 0 <= v109;
                    bool v111;
                    v111 = v110 == false;
                    if (v111){
                        assert("The index needs to be zero or positive." && v110);
                    } else {
                    }
                    int v113;
                    v113 = v109 % 8;
                    int v114;
                    v114 = v109 / 8;
                    bool v115;
                    v115 = v114 < 32;
                    bool v116;
                    v116 = v115 == false;
                    if (v116){
                        assert("The last element of the projection dimensions needs to be greater than the index remainder." && v115);
                    } else {
                    }
                    assert("Tensor range check" && 0 <= v114 && v114 < 32);
                    assert("Tensor range check" && 0 <= v113 && v113 < 8);
                    int v118;
                    v118 = 4 * v113;
                    int v119;
                    v119 = 36 * v114;
                    int v120;
                    v120 = v119 + v118;
                    int v121;
                    v121 = 256 * v114;
                    int v122;
                    v122 = v121 + v118;
                    float * v123;
                    v123 = v12+v120;
                    float * v125;
                    v125 = v107+v122;
                    int v127;
                    v127 = 0;
                    #pragma unroll
                    while (while_method_0(v127)){
                        int v129;
                        v129 = 0;
                        #pragma unroll
                        while (while_method_6(v129)){
                            assert("Tensor range check" && 0 <= v127 && v127 < 2);
                            assert("Tensor range check" && 0 <= v129 && v129 < 1);
                            int v131;
                            v131 = 32 * v129;
                            int v132;
                            v132 = 1152 * v127;
                            int v133;
                            v133 = v132 + v131;
                            int v134;
                            v134 = 8192 * v127;
                            int v135;
                            v135 = v134 + v131;
                            constexpr int v136 = sizeof(float) * 4;
                            assert("Pointer alignment check" && (unsigned long long)(v125 + v135) % v136 == 0 && (unsigned long long)(v123 + v133) % v136 == 0);
                            cuda::memcpy_async(v123 + v133, v125 + v135, cuda::aligned_size_t<v136>(v136), v8);
                            v129 += 1 ;
                        }
                        v127 += 1 ;
                    }
                    v8.producer_commit();
                    // Poping the loop unrolling to: 0
                } else {
                }
                // Pushing the loop unrolling to: 0
                int v137;
                v137 = threadIdx.x;
                bool v138;
                v138 = 0 <= v137;
                bool v139;
                v139 = v138 == false;
                if (v139){
                    assert("The index needs to be zero or positive." && v138);
                } else {
                }
                int v141;
                v141 = v137 % 8;
                int v142;
                v142 = v137 / 8;
                bool v143;
                v143 = v142 < 32;
                bool v144;
                v144 = v143 == false;
                if (v144){
                    assert("The last element of the projection dimensions needs to be greater than the index remainder." && v143);
                } else {
                }
                assert("Tensor range check" && 0 <= v142 && v142 < 32);
                assert("Tensor range check" && 0 <= v141 && v141 < 8);
                int v146;
                v146 = 4 * v141;
                int v147;
                v147 = 36 * v142;
                int v148;
                v148 = v147 + v146;
                int v149;
                v149 = 256 * v142;
                int v150;
                v150 = v149 + v146;
                float * v151;
                v151 = v10+v148;
                float * v153;
                v153 = v102+v150;
                int v155;
                v155 = 0;
                #pragma unroll
                while (while_method_10(v155)){
                    int v157;
                    v157 = 0;
                    #pragma unroll
                    while (while_method_6(v157)){
                        assert("Tensor range check" && 0 <= v155 && v155 < 8);
                        assert("Tensor range check" && 0 <= v157 && v157 < 1);
                        int v159;
                        v159 = 32 * v157;
                        int v160;
                        v160 = 1152 * v155;
                        int v161;
                        v161 = v160 + v159;
                        int v162;
                        v162 = 8192 * v155;
                        int v163;
                        v163 = v162 + v159;
                        int4* v164;
                        v164 = reinterpret_cast<int4*>(v153 + v163);
                        int4* v165;
                        v165 = reinterpret_cast<int4*>(v151 + v161);
                        assert("Pointer alignment check" && reinterpret_cast<unsigned long long>(v164) % 16 == 0 && reinterpret_cast<unsigned long long>(v165) % 16 == 0);
                        *v165 = *v164;
                        v157 += 1 ;
                    }
                    v155 += 1 ;
                }
                // Poping the loop unrolling to: 0
                wmma::fragment<wmma::matrix_a, 16, 16, 8, wmma::precision::tf32, wmma::row_major> v166[1];
                wmma::fragment<wmma::matrix_b, 16, 16, 8, wmma::precision::tf32, wmma::col_major> v167[4];
                cuda::pipeline_consumer_wait_prior<0>(v8);;
                __syncthreads();
                // Pushing the loop unrolling to: 0
                int v168;
                v168 = 0;
                #pragma unroll
                while (while_method_6(v168)){
                    int v170;
                    v170 = 0;
                    #pragma unroll
                    while (while_method_3(v170)){
                        assert("Tensor range check" && 0 <= v168 && v168 < 1);
                        assert("Tensor range check" && 0 <= v170 && v170 < 4);
                        int v172;
                        v172 = 4 * v168;
                        int v173;
                        v173 = v172 + v170;
                        wmma::fragment<wmma::matrix_b, 16, 16, 8, wmma::precision::tf32, wmma::col_major> & v174 = v167[v173];
                        assert("Tensor range check" && 0 <= v168 && v168 < 1);
                        int v175;
                        v175 = 576 * v168;
                        assert("Tensor range check" && 0 <= v170 && v170 < 4);
                        int v176;
                        v176 = 8 * v170;
                        int v177;
                        v177 = v176 + v175;
                        int v178;
                        v178 = 0;
                        #pragma unroll
                        while (while_method_0(v178)){
                            int v180;
                            v180 = 0;
                            #pragma unroll
                            while (while_method_0(v180)){
                                assert("Tensor range check" && 0 <= v178 && v178 < 2);
                                assert("Tensor range check" && 0 <= v180 && v180 < 2);
                                int v182;
                                v182 = 4 * v180;
                                int v183;
                                v183 = v182 + v177;
                                int v184;
                                v184 = 288 * v178;
                                int v185;
                                v185 = v184 + v183;
                                float v186;
                                v186 = v61[v185];
                                bool v187;
                                v187 = 0 <= v180;
                                bool v189;
                                if (v187){
                                    bool v188;
                                    v188 = v180 < 2;
                                    v189 = v188;
                                } else {
                                    v189 = false;
                                }
                                bool v190;
                                v190 = v189 == false;
                                if (v190){
                                    assert("The indices should be inside the range of the dimension." && v189);
                                } else {
                                }
                                bool v192;
                                v192 = 0 <= v178;
                                bool v194;
                                if (v192){
                                    bool v193;
                                    v193 = v178 < 2;
                                    v194 = v193;
                                } else {
                                    v194 = false;
                                }
                                bool v195;
                                v195 = v194 == false;
                                if (v195){
                                    assert("The indices should be inside the range of the dimension." && v194);
                                } else {
                                }
                                int v197;
                                v197 = v178 * 2;
                                int v198;
                                v198 = v180 + v197;
                                v174.x[v198] = wmma::__float_to_tf32(v186);
                                v180 += 1 ;
                            }
                            v178 += 1 ;
                        }
                        v170 += 1 ;
                    }
                    v168 += 1 ;
                }
                // Poping the loop unrolling to: 0
                v8.consumer_release();
                switch (v97.tag) {
                    case 0: { // None
                        break;
                    }
                    case 1: { // Some
                        int v199 = v97.case1.v0;
                        assert("Tensor range check" && 0 <= v199 && v199 < 8);
                        int v200;
                        v200 = 32 * v199;
                        int v201;
                        v201 = v200 + v105;
                        float * v202;
                        v202 = v1+v201;
                        __syncthreads();
                        // Pushing the loop unrolling to: 0
                        v8.producer_acquire();
                        int v204;
                        v204 = threadIdx.x;
                        bool v205;
                        v205 = 0 <= v204;
                        bool v206;
                        v206 = v205 == false;
                        if (v206){
                            assert("The index needs to be zero or positive." && v205);
                        } else {
                        }
                        int v208;
                        v208 = v204 % 8;
                        int v209;
                        v209 = v204 / 8;
                        bool v210;
                        v210 = v209 < 32;
                        bool v211;
                        v211 = v210 == false;
                        if (v211){
                            assert("The last element of the projection dimensions needs to be greater than the index remainder." && v210);
                        } else {
                        }
                        assert("Tensor range check" && 0 <= v209 && v209 < 32);
                        assert("Tensor range check" && 0 <= v208 && v208 < 8);
                        int v213;
                        v213 = 4 * v208;
                        int v214;
                        v214 = 36 * v209;
                        int v215;
                        v215 = v214 + v213;
                        int v216;
                        v216 = 256 * v209;
                        int v217;
                        v217 = v216 + v213;
                        float * v218;
                        v218 = v12+v215;
                        float * v220;
                        v220 = v202+v217;
                        int v222;
                        v222 = 0;
                        #pragma unroll
                        while (while_method_0(v222)){
                            int v224;
                            v224 = 0;
                            #pragma unroll
                            while (while_method_6(v224)){
                                assert("Tensor range check" && 0 <= v222 && v222 < 2);
                                assert("Tensor range check" && 0 <= v224 && v224 < 1);
                                int v226;
                                v226 = 32 * v224;
                                int v227;
                                v227 = 1152 * v222;
                                int v228;
                                v228 = v227 + v226;
                                int v229;
                                v229 = 8192 * v222;
                                int v230;
                                v230 = v229 + v226;
                                constexpr int v231 = sizeof(float) * 4;
                                assert("Pointer alignment check" && (unsigned long long)(v220 + v230) % v231 == 0 && (unsigned long long)(v218 + v228) % v231 == 0);
                                cuda::memcpy_async(v218 + v228, v220 + v230, cuda::aligned_size_t<v231>(v231), v8);
                                v224 += 1 ;
                            }
                            v222 += 1 ;
                        }
                        v8.producer_commit();
                        // Poping the loop unrolling to: 0
                        break;
                    }
                    default: {
                        assert("Invalid tag." && false); __trap();
                    }
                }
                // Pushing the loop unrolling to: 0
                int v232;
                v232 = 0;
                #pragma unroll
                while (while_method_10(v232)){
                    int v234;
                    v234 = 0;
                    #pragma unroll
                    while (while_method_3(v234)){
                        wmma::fragment<wmma::matrix_a, 16, 16, 8, wmma::precision::tf32, wmma::row_major> & v236 = v166[0];
                        assert("Tensor range check" && 0 <= v232 && v232 < 8);
                        int v237;
                        v237 = 576 * v232;
                        assert("Tensor range check" && 0 <= v234 && v234 < 4);
                        int v238;
                        v238 = 8 * v234;
                        int v239;
                        v239 = v238 + v237;
                        int v240;
                        v240 = 0;
                        #pragma unroll
                        while (while_method_0(v240)){
                            int v242;
                            v242 = 0;
                            #pragma unroll
                            while (while_method_0(v242)){
                                assert("Tensor range check" && 0 <= v240 && v240 < 2);
                                assert("Tensor range check" && 0 <= v242 && v242 < 2);
                                int v244;
                                v244 = 288 * v242;
                                int v245;
                                v245 = v244 + v239;
                                int v246;
                                v246 = 4 * v240;
                                int v247;
                                v247 = v246 + v245;
                                float v248;
                                v248 = v45[v247];
                                bool v249;
                                v249 = 0 <= v242;
                                bool v251;
                                if (v249){
                                    bool v250;
                                    v250 = v242 < 2;
                                    v251 = v250;
                                } else {
                                    v251 = false;
                                }
                                bool v252;
                                v252 = v251 == false;
                                if (v252){
                                    assert("The indices should be inside the range of the dimension." && v251);
                                } else {
                                }
                                bool v254;
                                v254 = 0 <= v240;
                                bool v256;
                                if (v254){
                                    bool v255;
                                    v255 = v240 < 2;
                                    v256 = v255;
                                } else {
                                    v256 = false;
                                }
                                bool v257;
                                v257 = v256 == false;
                                if (v257){
                                    assert("The indices should be inside the range of the dimension." && v256);
                                } else {
                                }
                                int v259;
                                v259 = v240 * 2;
                                int v260;
                                v260 = v242 + v259;
                                v236.x[v260] = wmma::__float_to_tf32(v248);
                                v242 += 1 ;
                            }
                            v240 += 1 ;
                        }
                        int v261;
                        v261 = 0;
                        #pragma unroll
                        while (while_method_6(v261)){
                            assert("Tensor range check" && 0 <= v232 && v232 < 8);
                            assert("Tensor range check" && 0 <= v261 && v261 < 1);
                            int v263;
                            v263 = v232 + v261;
                            wmma::fragment<wmma::accumulator, 16, 16, 8, float> & v264 = v63[v263];
                            assert("Tensor range check" && 0 <= v261 && v261 < 1);
                            assert("Tensor range check" && 0 <= v234 && v234 < 4);
                            int v265;
                            v265 = 4 * v261;
                            int v266;
                            v266 = v265 + v234;
                            wmma::fragment<wmma::matrix_b, 16, 16, 8, wmma::precision::tf32, wmma::col_major> & v267 = v167[v266];
                            wmma::mma_sync(v264, v236, v267, v264);
                            v261 += 1 ;
                        }
                        v234 += 1 ;
                    }
                    v232 += 1 ;
                }
                // Poping the loop unrolling to: 0
                __syncthreads();
                v80 = v82;
            }
            // Pushing the loop unrolling to: 0
            int v268;
            v268 = 0;
            #pragma unroll
            while (while_method_10(v268)){
                int v270;
                v270 = 0;
                #pragma unroll
                while (while_method_6(v270)){
                    assert("Tensor range check" && 0 <= v268 && v268 < 8);
                    assert("Tensor range check" && 0 <= v270 && v270 < 1);
                    int v272;
                    v272 = v268 + v270;
                    wmma::fragment<wmma::accumulator, 16, 16, 8, float> & v273 = v63[v272];
                    assert("Tensor range check" && 0 <= v268 && v268 < 8);
                    assert("Tensor range check" && 0 <= v270 && v270 < 1);
                    int v274;
                    v274 = 16 * v270;
                    int v275;
                    v275 = 1152 * v268;
                    int v276;
                    v276 = v275 + v274;
                    float * v277;
                    v277 = v29+v276;
                    wmma::store_matrix_sync(v277, v273, 72, wmma::mem_row_major);
                    v270 += 1 ;
                }
                v268 += 1 ;
            }
            // Poping the loop unrolling to: 0
            __syncthreads();
            // Pushing the loop unrolling to: 0
            int v279;
            v279 = threadIdx.x;
            bool v280;
            v280 = 0 <= v279;
            bool v281;
            v281 = v280 == false;
            if (v281){
                assert("The index needs to be zero or positive." && v280);
            } else {
            }
            int v283;
            v283 = v279 % 16;
            int v284;
            v284 = v279 / 16;
            bool v285;
            v285 = v284 < 16;
            bool v286;
            v286 = v285 == false;
            if (v286){
                assert("The last element of the projection dimensions needs to be greater than the index remainder." && v285);
            } else {
            }
            assert("Tensor range check" && 0 <= v284 && v284 < 16);
            assert("Tensor range check" && 0 <= v283 && v283 < 16);
            int v288;
            v288 = 4 * v283;
            int v289;
            v289 = 64 * v284;
            int v290;
            v290 = v289 + v288;
            int v291;
            v291 = 72 * v284;
            int v292;
            v292 = v291 + v288;
            float * v293;
            v293 = v72+v290;
            float * v295;
            v295 = v14+v292;
            int v297;
            v297 = 0;
            #pragma unroll
            while (while_method_12(v297)){
                int v299;
                v299 = 0;
                #pragma unroll
                while (while_method_6(v299)){
                    assert("Tensor range check" && 0 <= v297 && v297 < 16);
                    assert("Tensor range check" && 0 <= v299 && v299 < 1);
                    int v301;
                    v301 = 64 * v299;
                    int v302;
                    v302 = 1024 * v297;
                    int v303;
                    v303 = v302 + v301;
                    int v304;
                    v304 = 1152 * v297;
                    int v305;
                    v305 = v304 + v301;
                    int4* v306;
                    v306 = reinterpret_cast<int4*>(v295 + v305);
                    int4* v307;
                    v307 = reinterpret_cast<int4*>(v293 + v303);
                    assert("Pointer alignment check" && reinterpret_cast<unsigned long long>(v306) % 16 == 0 && reinterpret_cast<unsigned long long>(v307) % 16 == 0);
                    *v307 = *v306;
                    v299 += 1 ;
                }
                v297 += 1 ;
            }
            // Poping the loop unrolling to: 0
            __syncthreads();
            v66 += 1 ;
        }
        v64 += 1 ;
    }
    return ;
}
__device__ void block_row_map_49(float * v0, int v1, float * v2){
    int v3;
    v3 = blockIdx.x;
    assert("Tensor range check" && 0 <= v3 && v3 < 24);
    int v4;
    v4 = 16384 * v3;
    int v5;
    v5 = blockIdx.x;
    assert("Tensor range check" && 0 <= v5 && v5 < 24);
    int v6;
    v6 = 16384 * v5;
    int v7;
    v7 = v6 + v1;
    int v8;
    v8 = threadIdx.x;
    bool v9;
    v9 = 0 <= v8;
    bool v10;
    v10 = v9 == false;
    if (v10){
        assert("The index needs to be zero or positive." && v9);
    } else {
    }
    int v12;
    v12 = v8 % 16;
    int v13;
    v13 = v8 / 16;
    bool v14;
    v14 = v13 < 16;
    bool v15;
    v15 = v14 == false;
    if (v15){
        assert("The last element of the projection dimensions needs to be greater than the index remainder." && v14);
    } else {
    }
    assert("Tensor range check" && 0 <= v13 && v13 < 16);
    assert("Tensor range check" && 0 <= v12 && v12 < 16);
    int v17;
    v17 = 4 * v12;
    int v18;
    v18 = v17 + v4;
    int v19;
    v19 = 64 * v13;
    int v20;
    v20 = v19 + v18;
    assert("Tensor range check" && 0 <= v13 && v13 < 16);
    assert("Tensor range check" && 0 <= v12 && v12 < 16);
    int v21;
    v21 = v17 + v7;
    int v22;
    v22 = v19 + v21;
    int v23;
    v23 = 0;
    while (while_method_12(v23)){
        assert("Tensor range check" && 0 <= v23 && v23 < 16);
        int v25;
        v25 = 1024 * v23;
        int v26;
        v26 = v25 + v20;
        float v27[4];
        int v28[4];
        int v29;
        v29 = 0;
        while (while_method_6(v29)){
            assert("Tensor range check" && 0 <= v29 && v29 < 1);
            int v31;
            v31 = 4 * v29;
            assert("Tensor range check" && 0 <= v29 && v29 < 1);
            int v32;
            v32 = 64 * v29;
            int v33;
            v33 = v32 + v26;
            int4* v34;
            v34 = reinterpret_cast<int4*>(v2 + v33);
            int4* v35;
            v35 = reinterpret_cast<int4*>(v27 + v31);
            assert("Pointer alignment check" && reinterpret_cast<unsigned long long>(v34) % 16 == 0 && reinterpret_cast<unsigned long long>(v35) % 16 == 0);
            *v35 = *v34;
            v29 += 1 ;
        }
        int v36;
        v36 = 0;
        while (while_method_6(v36)){
            int v38;
            v38 = 0;
            while (while_method_3(v38)){
                bool v40;
                v40 = 0 <= v38;
                bool v42;
                if (v40){
                    bool v41;
                    v41 = v38 < 4;
                    v42 = v41;
                } else {
                    v42 = false;
                }
                bool v43;
                v43 = v42 == false;
                if (v43){
                    assert("The indices should be inside the range of the dimension." && v42);
                } else {
                }
                bool v45;
                v45 = 0 <= v12;
                bool v47;
                if (v45){
                    bool v46;
                    v46 = v12 < 16;
                    v47 = v46;
                } else {
                    v47 = false;
                }
                bool v48;
                v48 = v47 == false;
                if (v48){
                    assert("The indices should be inside the range of the dimension." && v47);
                } else {
                }
                int v50;
                v50 = v12 * 4;
                int v51;
                v51 = v38 + v50;
                bool v52;
                v52 = 0 <= v36;
                bool v54;
                if (v52){
                    bool v53;
                    v53 = v36 < 1;
                    v54 = v53;
                } else {
                    v54 = false;
                }
                bool v55;
                v55 = v54 == false;
                if (v55){
                    assert("The indices should be inside the range of the dimension." && v54);
                } else {
                }
                int v57;
                v57 = v36 * 64;
                int v58;
                v58 = v51 + v57;
                assert("Tensor range check" && 0 <= v36 && v36 < 1);
                assert("Tensor range check" && 0 <= v38 && v38 < 4);
                int v59;
                v59 = 4 * v36;
                int v60;
                v60 = v59 + v38;
                v28[v60] = v58;
                v38 += 1 ;
            }
            v36 += 1 ;
        }
        bool v61;
        v61 = 0 <= v13;
        bool v62;
        v62 = v61 && v14;
        bool v63;
        v63 = v62 == false;
        if (v63){
            assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v62);
        } else {
        }
        bool v65;
        v65 = 0 <= v23;
        bool v67;
        if (v65){
            bool v66;
            v66 = v23 < 16;
            v67 = v66;
        } else {
            v67 = false;
        }
        bool v68;
        v68 = v67 == false;
        if (v68){
            assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v67);
        } else {
        }
        int v70;
        v70 = v23 * 16;
        int v71;
        v71 = v70 + v13;
        bool v72[4];
        int v73;
        v73 = 0;
        while (while_method_6(v73)){
            int v75;
            v75 = 0;
            while (while_method_3(v75)){
                assert("Tensor range check" && 0 <= v73 && v73 < 1);
                assert("Tensor range check" && 0 <= v75 && v75 < 4);
                int v77;
                v77 = 4 * v73;
                int v78;
                v78 = v77 + v75;
                float v79;
                v79 = v27[v78];
                int v80;
                v80 = v28[v78];
                bool v81;
                v81 = v80 < 3;
                assert("Tensor range check" && 0 <= v73 && v73 < 1);
                assert("Tensor range check" && 0 <= v75 && v75 < 4);
                v72[v78] = v81;
                v75 += 1 ;
            }
            v73 += 1 ;
        }
        float v82[4];
        int v83;
        v83 = 0;
        while (while_method_6(v83)){
            int v85;
            v85 = 0;
            while (while_method_3(v85)){
                assert("Tensor range check" && 0 <= v83 && v83 < 1);
                assert("Tensor range check" && 0 <= v85 && v85 < 4);
                int v87;
                v87 = 4 * v83;
                int v88;
                v88 = v87 + v85;
                float v89;
                v89 = v27[v88];
                bool v90;
                v90 = v72[v88];
                bool v91;
                v91 = isnan(v89);
                bool v92;
                v92 = v91 == false;
                bool v93;
                v93 = v92 == false;
                if (v93){
                    assert("What comes into regret matching must not be a nan." && v92);
                } else {
                }
                float v97;
                if (v90){
                    bool v95;
                    v95 = 0.0f >= v89;
                    if (v95){
                        v97 = 0.0f;
                    } else {
                        v97 = v89;
                    }
                } else {
                    v97 = 0.0f;
                }
                assert("Tensor range check" && 0 <= v83 && v83 < 1);
                assert("Tensor range check" && 0 <= v85 && v85 < 4);
                v82[v88] = v97;
                v85 += 1 ;
            }
            v83 += 1 ;
        }
        float v98;
        v98 = 0.0f;
        int v99;
        v99 = 0;
        while (while_method_6(v99)){
            int v101;
            v101 = 0;
            while (while_method_3(v101)){
                assert("Tensor range check" && 0 <= v99 && v99 < 1);
                assert("Tensor range check" && 0 <= v101 && v101 < 4);
                int v103;
                v103 = 4 * v99;
                int v104;
                v104 = v103 + v101;
                float v105;
                v105 = v82[v104];
                float v106;
                v106 = v98 + v105;
                v98 = v106;
                v101 += 1 ;
            }
            v99 += 1 ;
        }
        auto v107 = cooperative_groups::coalesced_threads();
        int v108;
        v108 = threadIdx.x;
        int v109;
        v109 = v108 / 16;
        auto v110 = cooperative_groups::labeled_partition(v107,v109);
        Closure0 v111{};
        float v112;
        v112 = cooperative_groups::reduce(v110, v98, v111);
        int v113[4];
        int v114;
        v114 = 0;
        while (while_method_6(v114)){
            int v116;
            v116 = 0;
            while (while_method_3(v116)){
                assert("Tensor range check" && 0 <= v114 && v114 < 1);
                assert("Tensor range check" && 0 <= v116 && v116 < 4);
                int v118;
                v118 = 4 * v114;
                int v119;
                v119 = v118 + v116;
                bool v120;
                v120 = v72[v119];
                int v121;
                if (v120){
                    v121 = 1;
                } else {
                    v121 = 0;
                }
                assert("Tensor range check" && 0 <= v114 && v114 < 1);
                assert("Tensor range check" && 0 <= v116 && v116 < 4);
                v113[v119] = v121;
                v116 += 1 ;
            }
            v114 += 1 ;
        }
        int v122;
        v122 = 0;
        int v123;
        v123 = 0;
        while (while_method_6(v123)){
            int v125;
            v125 = 0;
            while (while_method_3(v125)){
                assert("Tensor range check" && 0 <= v123 && v123 < 1);
                assert("Tensor range check" && 0 <= v125 && v125 < 4);
                int v127;
                v127 = 4 * v123;
                int v128;
                v128 = v127 + v125;
                int v129;
                v129 = v113[v128];
                int v130;
                v130 = v122 + v129;
                v122 = v130;
                v125 += 1 ;
            }
            v123 += 1 ;
        }
        auto v131 = cooperative_groups::coalesced_threads();
        int v132;
        v132 = threadIdx.x;
        int v133;
        v133 = v132 / 16;
        auto v134 = cooperative_groups::labeled_partition(v131,v133);
        Closure1 v135{};
        int v136;
        v136 = cooperative_groups::reduce(v134, v122, v135);
        float v137;
        v137 = (float)v136;
        float v138;
        v138 = 1.0f / v137;
        bool v139;
        v139 = isnan(v138);
        bool v140;
        v140 = v139 == false;
        bool v141;
        v141 = v140 == false;
        if (v141){
            assert("Inverse length in regret matching must not be nan." && v140);
        } else {
        }
        float v143[4];
        int v144;
        v144 = 0;
        while (while_method_6(v144)){
            int v146;
            v146 = 0;
            while (while_method_3(v146)){
                assert("Tensor range check" && 0 <= v144 && v144 < 1);
                assert("Tensor range check" && 0 <= v146 && v146 < 4);
                int v148;
                v148 = 4 * v144;
                int v149;
                v149 = v148 + v146;
                float v150;
                v150 = v82[v149];
                bool v151;
                v151 = v72[v149];
                bool v152;
                v152 = v151 == false;
                float v157;
                if (v152){
                    v157 = 0.0f;
                } else {
                    bool v153;
                    v153 = v112 == 0.0f;
                    bool v154;
                    v154 = v153 != true;
                    if (v154){
                        float v155;
                        v155 = v150 / v112;
                        v157 = v155;
                    } else {
                        v157 = v138;
                    }
                }
                bool v158;
                v158 = isnan(v157);
                bool v159;
                v159 = v158 == false;
                bool v160;
                v160 = v159 == false;
                if (v160){
                    assert("What comes out of regret matching must not be a nan." && v159);
                } else {
                }
                bool v162;
                v162 = v157 >= 0.0f;
                bool v163;
                v163 = v162 == false;
                if (v163){
                    assert("What comes out of regret matching must be >= 0." && v162);
                } else {
                }
                bool v165;
                v165 = v157 <= 1.0f;
                bool v166;
                v166 = v165 == false;
                if (v166){
                    assert("What comes out of regret matching must be <= 1." && v165);
                } else {
                }
                assert("Tensor range check" && 0 <= v144 && v144 < 1);
                assert("Tensor range check" && 0 <= v146 && v146 < 4);
                v143[v149] = v157;
                v146 += 1 ;
            }
            v144 += 1 ;
        }
        assert("Tensor range check" && 0 <= v23 && v23 < 16);
        int v168;
        v168 = v25 + v22;
        int v169;
        v169 = 0;
        while (while_method_6(v169)){
            assert("Tensor range check" && 0 <= v169 && v169 < 1);
            int v171;
            v171 = 64 * v169;
            int v172;
            v172 = v171 + v168;
            assert("Tensor range check" && 0 <= v169 && v169 < 1);
            int v173;
            v173 = 4 * v169;
            int4* v174;
            v174 = reinterpret_cast<int4*>(v143 + v173);
            int4* v175;
            v175 = reinterpret_cast<int4*>(v0 + v172);
            assert("Pointer alignment check" && reinterpret_cast<unsigned long long>(v174) % 16 == 0 && reinterpret_cast<unsigned long long>(v175) % 16 == 0);
            *v175 = *v174;
            v169 += 1 ;
        }
        v23 += 1 ;
    }
    __syncthreads();
    return ;
}
__device__ inline bool while_method_16(int v0){
    bool v1;
    v1 = v0 < 6;
    return v1;
}
__device__ inline bool while_method_17(static_array<float,6> v0, int v1){
    bool v2;
    v2 = v1 < 6;
    return v2;
}
__device__ inline bool while_method_18(int v0, int v1){
    bool v2;
    v2 = v1 > v0;
    return v2;
}
__device__ int loop_53(static_array<float,6> v0, float v1, int v2){
    bool v3;
    v3 = v2 < 6;
    if (v3){
        bool v4;
        v4 = 0 <= v2;
        bool v5;
        v5 = v4 && v3;
        bool v6;
        v6 = v5 == false;
        if (v6){
            assert("Index must be in range." && v5);
        } else {
        }
        float v8;
        v8 = v0[v2];
        bool v10;
        v10 = v1 <= v8;
        if (v10){
            return v2;
        } else {
            int v11;
            v11 = v2 + 1;
            return loop_53(v0, v1, v11);
        }
    } else {
        return 5;
    }
}
__device__ int pick_discrete__52(static_array<float,6> v0, float v1){
    static_array<float,6> v2;
    int v4;
    v4 = 0;
    while (while_method_16(v4)){
        bool v6;
        v6 = 0 <= v4;
        bool v8;
        if (v6){
            bool v7;
            v7 = v4 < 6;
            v8 = v7;
        } else {
            v8 = false;
        }
        bool v9;
        v9 = v8 == false;
        if (v9){
            assert("Index must be in range." && v8);
        } else {
        }
        float v11;
        v11 = v0[v4];
        v2[v4] = v11;
        v4 += 1 ;
    }
    int v13;
    v13 = 1;
    while (while_method_17(v2, v13)){
        int v15;
        v15 = 6;
        while (while_method_18(v13, v15)){
            v15 -= 1 ;
            int v17;
            v17 = v15 - v13;
            bool v18;
            v18 = 0 <= v17;
            bool v20;
            if (v18){
                bool v19;
                v19 = v17 < 6;
                v20 = v19;
            } else {
                v20 = false;
            }
            bool v21;
            v21 = v20 == false;
            if (v21){
                assert("Index must be in range." && v20);
            } else {
            }
            float v23;
            v23 = v2[v17];
            bool v25;
            v25 = 0 <= v15;
            bool v27;
            if (v25){
                bool v26;
                v26 = v15 < 6;
                v27 = v26;
            } else {
                v27 = false;
            }
            bool v28;
            v28 = v27 == false;
            if (v28){
                assert("Index must be in range." && v27);
            } else {
            }
            float v30;
            v30 = v2[v15];
            float v32;
            v32 = v23 + v30;
            v2[v15] = v32;
        }
        int v33;
        v33 = v13 * 2;
        v13 = v33;
    }
    float v34;
    v34 = v2[5];
    float v36;
    v36 = v1 * v34;
    int v37;
    v37 = 0;
    return loop_53(v2, v36, v37);
}
__device__ int sample_discrete__51(static_array<float,6> v0, curandStatePhilox4_32_10_t & v1){
    float v2;
    v2 = curand_uniform(&v1);
    return pick_discrete__52(v0, v2);
}
__device__ Union1 sample_discrete_50(static_array<Tuple17,6> v0, curandStatePhilox4_32_10_t & v1){
    static_array<float,6> v2;
    int v4;
    v4 = 0;
    while (while_method_16(v4)){
        bool v6;
        v6 = 0 <= v4;
        bool v8;
        if (v6){
            bool v7;
            v7 = v4 < 6;
            v8 = v7;
        } else {
            v8 = false;
        }
        bool v9;
        v9 = v8 == false;
        if (v9){
            assert("Index must be in range." && v8);
        } else {
        }
        Union1 v11; float v12;
        Tuple17 tmp47 = v0[v4];
        v11 = tmp47.v0; v12 = tmp47.v1;
        v2[v4] = v12;
        v4 += 1 ;
    }
    int v15;
    v15 = sample_discrete__51(v2, v1);
    bool v16;
    v16 = 0 <= v15;
    bool v18;
    if (v16){
        bool v17;
        v17 = v15 < 6;
        v18 = v17;
    } else {
        v18 = false;
    }
    bool v19;
    v19 = v18 == false;
    if (v19){
        assert("Index must be in range." && v18);
    } else {
    }
    Union1 v21; float v22;
    Tuple17 tmp48 = v0[v15];
    v21 = tmp48.v0; v22 = tmp48.v1;
    return v21;
}
__device__ inline bool while_method_19(int v0){
    bool v1;
    v1 = v0 < 7;
    return v1;
}
__device__ inline bool while_method_20(static_array<unsigned char,7> v0, bool v1, int v2){
    bool v3;
    v3 = v2 < 7;
    return v3;
}
__device__ inline bool while_method_21(static_array<unsigned char,7> v0, int v1){
    bool v2;
    v2 = v1 < 7;
    return v2;
}
__device__ inline bool while_method_22(int v0, int v1, int v2, int v3){
    bool v4;
    v4 = v3 < v0;
    return v4;
}
__device__ Tuple0 score_54(static_array<unsigned char,7> v0){
    static_array<unsigned char,7> v1;
    int v3;
    v3 = 0;
    while (while_method_19(v3)){
        bool v5;
        v5 = 0 <= v3;
        bool v7;
        if (v5){
            bool v6;
            v6 = v3 < 7;
            v7 = v6;
        } else {
            v7 = false;
        }
        bool v8;
        v8 = v7 == false;
        if (v8){
            assert("Index must be in range." && v7);
        } else {
        }
        unsigned char v10;
        v10 = v0[v3];
        v1[v3] = v10;
        v3 += 1 ;
    }
    static_array<unsigned char,7> v12;
    bool v14; int v15;
    Tuple18 tmp55 = Tuple18{true, 1};
    v14 = tmp55.v0; v15 = tmp55.v1;
    while (while_method_20(v1, v14, v15)){
        int v17;
        v17 = 0;
        while (while_method_21(v1, v17)){
            int v19;
            v19 = v17 + v15;
            bool v20;
            v20 = v19 < 7;
            int v21;
            if (v20){
                v21 = v19;
            } else {
                v21 = 7;
            }
            int v22;
            v22 = v15 * 2;
            int v23;
            v23 = v17 + v22;
            bool v24;
            v24 = v23 < 7;
            int v25;
            if (v24){
                v25 = v23;
            } else {
                v25 = 7;
            }
            int v26; int v27; int v28;
            Tuple19 tmp56 = Tuple19{v17, v21, v17};
            v26 = tmp56.v0; v27 = tmp56.v1; v28 = tmp56.v2;
            while (while_method_22(v25, v26, v27, v28)){
                bool v30;
                v30 = v26 < v21;
                bool v32;
                if (v30){
                    bool v31;
                    v31 = v27 < v25;
                    v32 = v31;
                } else {
                    v32 = false;
                }
                unsigned char v122; int v123; int v124;
                if (v32){
                    unsigned char v47;
                    if (v14){
                        bool v33;
                        v33 = 0 <= v26;
                        bool v35;
                        if (v33){
                            bool v34;
                            v34 = v26 < 7;
                            v35 = v34;
                        } else {
                            v35 = false;
                        }
                        bool v36;
                        v36 = v35 == false;
                        if (v36){
                            assert("Index must be in range." && v35);
                        } else {
                        }
                        unsigned char v38;
                        v38 = v1[v26];
                        v47 = v38;
                    } else {
                        bool v40;
                        v40 = 0 <= v26;
                        bool v42;
                        if (v40){
                            bool v41;
                            v41 = v26 < 7;
                            v42 = v41;
                        } else {
                            v42 = false;
                        }
                        bool v43;
                        v43 = v42 == false;
                        if (v43){
                            assert("Index must be in range." && v42);
                        } else {
                        }
                        unsigned char v45;
                        v45 = v12[v26];
                        v47 = v45;
                    }
                    unsigned char v62;
                    if (v14){
                        bool v48;
                        v48 = 0 <= v27;
                        bool v50;
                        if (v48){
                            bool v49;
                            v49 = v27 < 7;
                            v50 = v49;
                        } else {
                            v50 = false;
                        }
                        bool v51;
                        v51 = v50 == false;
                        if (v51){
                            assert("Index must be in range." && v50);
                        } else {
                        }
                        unsigned char v53;
                        v53 = v1[v27];
                        v62 = v53;
                    } else {
                        bool v55;
                        v55 = 0 <= v27;
                        bool v57;
                        if (v55){
                            bool v56;
                            v56 = v27 < 7;
                            v57 = v56;
                        } else {
                            v57 = false;
                        }
                        bool v58;
                        v58 = v57 == false;
                        if (v58){
                            assert("Index must be in range." && v57);
                        } else {
                        }
                        unsigned char v60;
                        v60 = v12[v27];
                        v62 = v60;
                    }
                    unsigned char v63;
                    v63 = v62 / 4u;
                    unsigned char v64;
                    v64 = v47 / 4u;
                    bool v65;
                    v65 = v63 < v64;
                    Union11 v71;
                    if (v65){
                        v71 = Union11{Union11_2{}};
                    } else {
                        bool v67;
                        v67 = v63 > v64;
                        if (v67){
                            v71 = Union11{Union11_1{}};
                        } else {
                            v71 = Union11{Union11_0{}};
                        }
                    }
                    Union11 v81;
                    switch (v71.tag) {
                        case 0: { // Eq
                            unsigned char v72;
                            v72 = v47 % 4u;
                            unsigned char v73;
                            v73 = v62 % 4u;
                            bool v74;
                            v74 = v72 < v73;
                            if (v74){
                                v81 = Union11{Union11_2{}};
                            } else {
                                bool v76;
                                v76 = v72 > v73;
                                if (v76){
                                    v81 = Union11{Union11_1{}};
                                } else {
                                    v81 = Union11{Union11_0{}};
                                }
                            }
                            break;
                        }
                        default: {
                            v81 = v71;
                        }
                    }
                    switch (v81.tag) {
                        case 1: { // Gt
                            int v82;
                            v82 = v27 + 1;
                            v122 = v62; v123 = v26; v124 = v82;
                            break;
                        }
                        default: {
                            int v83;
                            v83 = v26 + 1;
                            v122 = v47; v123 = v83; v124 = v27;
                        }
                    }
                } else {
                    if (v30){
                        unsigned char v101;
                        if (v14){
                            bool v87;
                            v87 = 0 <= v26;
                            bool v89;
                            if (v87){
                                bool v88;
                                v88 = v26 < 7;
                                v89 = v88;
                            } else {
                                v89 = false;
                            }
                            bool v90;
                            v90 = v89 == false;
                            if (v90){
                                assert("Index must be in range." && v89);
                            } else {
                            }
                            unsigned char v92;
                            v92 = v1[v26];
                            v101 = v92;
                        } else {
                            bool v94;
                            v94 = 0 <= v26;
                            bool v96;
                            if (v94){
                                bool v95;
                                v95 = v26 < 7;
                                v96 = v95;
                            } else {
                                v96 = false;
                            }
                            bool v97;
                            v97 = v96 == false;
                            if (v97){
                                assert("Index must be in range." && v96);
                            } else {
                            }
                            unsigned char v99;
                            v99 = v12[v26];
                            v101 = v99;
                        }
                        int v102;
                        v102 = v26 + 1;
                        v122 = v101; v123 = v102; v124 = v27;
                    } else {
                        unsigned char v117;
                        if (v14){
                            bool v103;
                            v103 = 0 <= v27;
                            bool v105;
                            if (v103){
                                bool v104;
                                v104 = v27 < 7;
                                v105 = v104;
                            } else {
                                v105 = false;
                            }
                            bool v106;
                            v106 = v105 == false;
                            if (v106){
                                assert("Index must be in range." && v105);
                            } else {
                            }
                            unsigned char v108;
                            v108 = v1[v27];
                            v117 = v108;
                        } else {
                            bool v110;
                            v110 = 0 <= v27;
                            bool v112;
                            if (v110){
                                bool v111;
                                v111 = v27 < 7;
                                v112 = v111;
                            } else {
                                v112 = false;
                            }
                            bool v113;
                            v113 = v112 == false;
                            if (v113){
                                assert("Index must be in range." && v112);
                            } else {
                            }
                            unsigned char v115;
                            v115 = v12[v27];
                            v117 = v115;
                        }
                        int v118;
                        v118 = v27 + 1;
                        v122 = v117; v123 = v26; v124 = v118;
                    }
                }
                if (v14){
                    v12[v28] = v122;
                } else {
                    v1[v28] = v122;
                }
                int v125;
                v125 = v28 + 1;
                v26 = v123;
                v27 = v124;
                v28 = v125;
            }
            v17 = v23;
        }
        bool v126;
        v126 = v14 == false;
        int v127;
        v127 = v15 * 2;
        v14 = v126;
        v15 = v127;
    }
    bool v128;
    v128 = v14 == false;
    static_array<unsigned char,7> v129;
    if (v128){
        v129 = v12;
    } else {
        v129 = v1;
    }
    static_array<unsigned char,5> v130;
    int v132; int v133; unsigned char v134;
    Tuple20 tmp57 = Tuple20{0, 0, 12u};
    v132 = tmp57.v0; v133 = tmp57.v1; v134 = tmp57.v2;
    while (while_method_19(v132)){
        bool v136;
        v136 = 0 <= v132;
        bool v138;
        if (v136){
            bool v137;
            v137 = v132 < 7;
            v138 = v137;
        } else {
            v138 = false;
        }
        bool v139;
        v139 = v138 == false;
        if (v139){
            assert("Index must be in range." && v138);
        } else {
        }
        unsigned char v141;
        v141 = v129[v132];
        bool v143;
        v143 = v133 < 5;
        int v155; unsigned char v156;
        if (v143){
            unsigned char v144;
            v144 = v141 % 4u;
            bool v145;
            v145 = 0u == v144;
            if (v145){
                unsigned char v146;
                v146 = v141 / 4u;
                bool v147;
                v147 = v134 == v146;
                int v148;
                if (v147){
                    v148 = v133;
                } else {
                    v148 = 0;
                }
                v130[v148] = v141;
                int v149;
                v149 = v148 + 1;
                unsigned char v150;
                v150 = v146 - 1u;
                v155 = v149; v156 = v150;
            } else {
                v155 = v133; v156 = v134;
            }
        } else {
            break;
        }
        v133 = v155;
        v134 = v156;
        v132 += 1 ;
    }
    bool v157;
    v157 = v133 == 4;
    bool v196;
    if (v157){
        unsigned char v158;
        v158 = v134 + 1u;
        bool v159;
        v159 = v158 == 0u;
        if (v159){
            unsigned char v160;
            v160 = v129[0];
            unsigned char v162;
            v162 = v160 % 4u;
            bool v163;
            v163 = 0u == v162;
            bool v167;
            if (v163){
                unsigned char v164;
                v164 = v160 / 4u;
                bool v165;
                v165 = v164 == 12u;
                if (v165){
                    v130[4] = v160;
                    v167 = true;
                } else {
                    v167 = false;
                }
            } else {
                v167 = false;
            }
            if (v167){
                v196 = true;
            } else {
                unsigned char v168;
                v168 = v129[1];
                unsigned char v170;
                v170 = v168 % 4u;
                bool v171;
                v171 = 0u == v170;
                bool v175;
                if (v171){
                    unsigned char v172;
                    v172 = v168 / 4u;
                    bool v173;
                    v173 = v172 == 12u;
                    if (v173){
                        v130[4] = v168;
                        v175 = true;
                    } else {
                        v175 = false;
                    }
                } else {
                    v175 = false;
                }
                if (v175){
                    v196 = true;
                } else {
                    unsigned char v176;
                    v176 = v129[2];
                    unsigned char v178;
                    v178 = v176 % 4u;
                    bool v179;
                    v179 = 0u == v178;
                    bool v183;
                    if (v179){
                        unsigned char v180;
                        v180 = v176 / 4u;
                        bool v181;
                        v181 = v180 == 12u;
                        if (v181){
                            v130[4] = v176;
                            v183 = true;
                        } else {
                            v183 = false;
                        }
                    } else {
                        v183 = false;
                    }
                    if (v183){
                        v196 = true;
                    } else {
                        unsigned char v184;
                        v184 = v129[3];
                        unsigned char v186;
                        v186 = v184 % 4u;
                        bool v187;
                        v187 = 0u == v186;
                        if (v187){
                            unsigned char v188;
                            v188 = v184 / 4u;
                            bool v189;
                            v189 = v188 == 12u;
                            if (v189){
                                v130[4] = v184;
                                v196 = true;
                            } else {
                                v196 = false;
                            }
                        } else {
                            v196 = false;
                        }
                    }
                }
            }
        } else {
            v196 = false;
        }
    } else {
        v196 = false;
    }
    Union12 v202;
    if (v196){
        v202 = Union12{Union12_1{v130}};
    } else {
        bool v198;
        v198 = v133 == 5;
        if (v198){
            v202 = Union12{Union12_1{v130}};
        } else {
            v202 = Union12{Union12_0{}};
        }
    }
    static_array<unsigned char,5> v203;
    int v205; int v206; unsigned char v207;
    Tuple20 tmp58 = Tuple20{0, 0, 12u};
    v205 = tmp58.v0; v206 = tmp58.v1; v207 = tmp58.v2;
    while (while_method_19(v205)){
        bool v209;
        v209 = 0 <= v205;
        bool v211;
        if (v209){
            bool v210;
            v210 = v205 < 7;
            v211 = v210;
        } else {
            v211 = false;
        }
        bool v212;
        v212 = v211 == false;
        if (v212){
            assert("Index must be in range." && v211);
        } else {
        }
        unsigned char v214;
        v214 = v129[v205];
        bool v216;
        v216 = v206 < 5;
        int v228; unsigned char v229;
        if (v216){
            unsigned char v217;
            v217 = v214 % 4u;
            bool v218;
            v218 = 1u == v217;
            if (v218){
                unsigned char v219;
                v219 = v214 / 4u;
                bool v220;
                v220 = v207 == v219;
                int v221;
                if (v220){
                    v221 = v206;
                } else {
                    v221 = 0;
                }
                v203[v221] = v214;
                int v222;
                v222 = v221 + 1;
                unsigned char v223;
                v223 = v219 - 1u;
                v228 = v222; v229 = v223;
            } else {
                v228 = v206; v229 = v207;
            }
        } else {
            break;
        }
        v206 = v228;
        v207 = v229;
        v205 += 1 ;
    }
    bool v230;
    v230 = v206 == 4;
    bool v269;
    if (v230){
        unsigned char v231;
        v231 = v207 + 1u;
        bool v232;
        v232 = v231 == 0u;
        if (v232){
            unsigned char v233;
            v233 = v129[0];
            unsigned char v235;
            v235 = v233 % 4u;
            bool v236;
            v236 = 1u == v235;
            bool v240;
            if (v236){
                unsigned char v237;
                v237 = v233 / 4u;
                bool v238;
                v238 = v237 == 12u;
                if (v238){
                    v203[4] = v233;
                    v240 = true;
                } else {
                    v240 = false;
                }
            } else {
                v240 = false;
            }
            if (v240){
                v269 = true;
            } else {
                unsigned char v241;
                v241 = v129[1];
                unsigned char v243;
                v243 = v241 % 4u;
                bool v244;
                v244 = 1u == v243;
                bool v248;
                if (v244){
                    unsigned char v245;
                    v245 = v241 / 4u;
                    bool v246;
                    v246 = v245 == 12u;
                    if (v246){
                        v203[4] = v241;
                        v248 = true;
                    } else {
                        v248 = false;
                    }
                } else {
                    v248 = false;
                }
                if (v248){
                    v269 = true;
                } else {
                    unsigned char v249;
                    v249 = v129[2];
                    unsigned char v251;
                    v251 = v249 % 4u;
                    bool v252;
                    v252 = 1u == v251;
                    bool v256;
                    if (v252){
                        unsigned char v253;
                        v253 = v249 / 4u;
                        bool v254;
                        v254 = v253 == 12u;
                        if (v254){
                            v203[4] = v249;
                            v256 = true;
                        } else {
                            v256 = false;
                        }
                    } else {
                        v256 = false;
                    }
                    if (v256){
                        v269 = true;
                    } else {
                        unsigned char v257;
                        v257 = v129[3];
                        unsigned char v259;
                        v259 = v257 % 4u;
                        bool v260;
                        v260 = 1u == v259;
                        if (v260){
                            unsigned char v261;
                            v261 = v257 / 4u;
                            bool v262;
                            v262 = v261 == 12u;
                            if (v262){
                                v203[4] = v257;
                                v269 = true;
                            } else {
                                v269 = false;
                            }
                        } else {
                            v269 = false;
                        }
                    }
                }
            }
        } else {
            v269 = false;
        }
    } else {
        v269 = false;
    }
    Union12 v275;
    if (v269){
        v275 = Union12{Union12_1{v203}};
    } else {
        bool v271;
        v271 = v206 == 5;
        if (v271){
            v275 = Union12{Union12_1{v203}};
        } else {
            v275 = Union12{Union12_0{}};
        }
    }
    Union12 v312;
    switch (v202.tag) {
        case 0: { // None
            v312 = v275;
            break;
        }
        case 1: { // Some
            static_array<unsigned char,5> v276 = v202.case1.v0;
            switch (v275.tag) {
                case 0: { // None
                    v312 = v202;
                    break;
                }
                case 1: { // Some
                    static_array<unsigned char,5> v277 = v275.case1.v0;
                    Union11 v278;
                    v278 = Union11{Union11_0{}};
                    int v279; Union11 v280;
                    Tuple21 tmp59 = Tuple21{0, v278};
                    v279 = tmp59.v0; v280 = tmp59.v1;
                    while (while_method_2(v279)){
                        bool v282;
                        v282 = 0 <= v279;
                        bool v284;
                        if (v282){
                            bool v283;
                            v283 = v279 < 5;
                            v284 = v283;
                        } else {
                            v284 = false;
                        }
                        bool v285;
                        v285 = v284 == false;
                        if (v285){
                            assert("Index must be in range." && v284);
                        } else {
                        }
                        unsigned char v287;
                        v287 = v276[v279];
                        bool v290;
                        if (v282){
                            bool v289;
                            v289 = v279 < 5;
                            v290 = v289;
                        } else {
                            v290 = false;
                        }
                        bool v291;
                        v291 = v290 == false;
                        if (v291){
                            assert("Index must be in range." && v290);
                        } else {
                        }
                        unsigned char v293;
                        v293 = v277[v279];
                        Union11 v305;
                        switch (v280.tag) {
                            case 0: { // Eq
                                unsigned char v295;
                                v295 = v287 / 4u;
                                unsigned char v296;
                                v296 = v293 / 4u;
                                bool v297;
                                v297 = v295 < v296;
                                if (v297){
                                    v305 = Union11{Union11_2{}};
                                } else {
                                    bool v299;
                                    v299 = v295 > v296;
                                    if (v299){
                                        v305 = Union11{Union11_1{}};
                                    } else {
                                        v305 = Union11{Union11_0{}};
                                    }
                                }
                                break;
                            }
                            default: {
                                break;
                            }
                        }
                        v280 = v305;
                        v279 += 1 ;
                    }
                    bool v306;
                    switch (v280.tag) {
                        case 1: { // Gt
                            v306 = true;
                            break;
                        }
                        default: {
                            v306 = false;
                        }
                    }
                    static_array<unsigned char,5> v307;
                    if (v306){
                        v307 = v276;
                    } else {
                        v307 = v277;
                    }
                    v312 = Union12{Union12_1{v307}};
                    break;
                }
                default: {
                    assert("Invalid tag." && false); __trap();
                }
            }
            break;
        }
        default: {
            assert("Invalid tag." && false); __trap();
        }
    }
    static_array<unsigned char,5> v313;
    int v315; int v316; unsigned char v317;
    Tuple20 tmp60 = Tuple20{0, 0, 12u};
    v315 = tmp60.v0; v316 = tmp60.v1; v317 = tmp60.v2;
    while (while_method_19(v315)){
        bool v319;
        v319 = 0 <= v315;
        bool v321;
        if (v319){
            bool v320;
            v320 = v315 < 7;
            v321 = v320;
        } else {
            v321 = false;
        }
        bool v322;
        v322 = v321 == false;
        if (v322){
            assert("Index must be in range." && v321);
        } else {
        }
        unsigned char v324;
        v324 = v129[v315];
        bool v326;
        v326 = v316 < 5;
        int v338; unsigned char v339;
        if (v326){
            unsigned char v327;
            v327 = v324 % 4u;
            bool v328;
            v328 = 2u == v327;
            if (v328){
                unsigned char v329;
                v329 = v324 / 4u;
                bool v330;
                v330 = v317 == v329;
                int v331;
                if (v330){
                    v331 = v316;
                } else {
                    v331 = 0;
                }
                v313[v331] = v324;
                int v332;
                v332 = v331 + 1;
                unsigned char v333;
                v333 = v329 - 1u;
                v338 = v332; v339 = v333;
            } else {
                v338 = v316; v339 = v317;
            }
        } else {
            break;
        }
        v316 = v338;
        v317 = v339;
        v315 += 1 ;
    }
    bool v340;
    v340 = v316 == 4;
    bool v379;
    if (v340){
        unsigned char v341;
        v341 = v317 + 1u;
        bool v342;
        v342 = v341 == 0u;
        if (v342){
            unsigned char v343;
            v343 = v129[0];
            unsigned char v345;
            v345 = v343 % 4u;
            bool v346;
            v346 = 2u == v345;
            bool v350;
            if (v346){
                unsigned char v347;
                v347 = v343 / 4u;
                bool v348;
                v348 = v347 == 12u;
                if (v348){
                    v313[4] = v343;
                    v350 = true;
                } else {
                    v350 = false;
                }
            } else {
                v350 = false;
            }
            if (v350){
                v379 = true;
            } else {
                unsigned char v351;
                v351 = v129[1];
                unsigned char v353;
                v353 = v351 % 4u;
                bool v354;
                v354 = 2u == v353;
                bool v358;
                if (v354){
                    unsigned char v355;
                    v355 = v351 / 4u;
                    bool v356;
                    v356 = v355 == 12u;
                    if (v356){
                        v313[4] = v351;
                        v358 = true;
                    } else {
                        v358 = false;
                    }
                } else {
                    v358 = false;
                }
                if (v358){
                    v379 = true;
                } else {
                    unsigned char v359;
                    v359 = v129[2];
                    unsigned char v361;
                    v361 = v359 % 4u;
                    bool v362;
                    v362 = 2u == v361;
                    bool v366;
                    if (v362){
                        unsigned char v363;
                        v363 = v359 / 4u;
                        bool v364;
                        v364 = v363 == 12u;
                        if (v364){
                            v313[4] = v359;
                            v366 = true;
                        } else {
                            v366 = false;
                        }
                    } else {
                        v366 = false;
                    }
                    if (v366){
                        v379 = true;
                    } else {
                        unsigned char v367;
                        v367 = v129[3];
                        unsigned char v369;
                        v369 = v367 % 4u;
                        bool v370;
                        v370 = 2u == v369;
                        if (v370){
                            unsigned char v371;
                            v371 = v367 / 4u;
                            bool v372;
                            v372 = v371 == 12u;
                            if (v372){
                                v313[4] = v367;
                                v379 = true;
                            } else {
                                v379 = false;
                            }
                        } else {
                            v379 = false;
                        }
                    }
                }
            }
        } else {
            v379 = false;
        }
    } else {
        v379 = false;
    }
    Union12 v385;
    if (v379){
        v385 = Union12{Union12_1{v313}};
    } else {
        bool v381;
        v381 = v316 == 5;
        if (v381){
            v385 = Union12{Union12_1{v313}};
        } else {
            v385 = Union12{Union12_0{}};
        }
    }
    Union12 v422;
    switch (v312.tag) {
        case 0: { // None
            v422 = v385;
            break;
        }
        case 1: { // Some
            static_array<unsigned char,5> v386 = v312.case1.v0;
            switch (v385.tag) {
                case 0: { // None
                    v422 = v312;
                    break;
                }
                case 1: { // Some
                    static_array<unsigned char,5> v387 = v385.case1.v0;
                    Union11 v388;
                    v388 = Union11{Union11_0{}};
                    int v389; Union11 v390;
                    Tuple21 tmp61 = Tuple21{0, v388};
                    v389 = tmp61.v0; v390 = tmp61.v1;
                    while (while_method_2(v389)){
                        bool v392;
                        v392 = 0 <= v389;
                        bool v394;
                        if (v392){
                            bool v393;
                            v393 = v389 < 5;
                            v394 = v393;
                        } else {
                            v394 = false;
                        }
                        bool v395;
                        v395 = v394 == false;
                        if (v395){
                            assert("Index must be in range." && v394);
                        } else {
                        }
                        unsigned char v397;
                        v397 = v386[v389];
                        bool v400;
                        if (v392){
                            bool v399;
                            v399 = v389 < 5;
                            v400 = v399;
                        } else {
                            v400 = false;
                        }
                        bool v401;
                        v401 = v400 == false;
                        if (v401){
                            assert("Index must be in range." && v400);
                        } else {
                        }
                        unsigned char v403;
                        v403 = v387[v389];
                        Union11 v415;
                        switch (v390.tag) {
                            case 0: { // Eq
                                unsigned char v405;
                                v405 = v397 / 4u;
                                unsigned char v406;
                                v406 = v403 / 4u;
                                bool v407;
                                v407 = v405 < v406;
                                if (v407){
                                    v415 = Union11{Union11_2{}};
                                } else {
                                    bool v409;
                                    v409 = v405 > v406;
                                    if (v409){
                                        v415 = Union11{Union11_1{}};
                                    } else {
                                        v415 = Union11{Union11_0{}};
                                    }
                                }
                                break;
                            }
                            default: {
                                break;
                            }
                        }
                        v390 = v415;
                        v389 += 1 ;
                    }
                    bool v416;
                    switch (v390.tag) {
                        case 1: { // Gt
                            v416 = true;
                            break;
                        }
                        default: {
                            v416 = false;
                        }
                    }
                    static_array<unsigned char,5> v417;
                    if (v416){
                        v417 = v386;
                    } else {
                        v417 = v387;
                    }
                    v422 = Union12{Union12_1{v417}};
                    break;
                }
                default: {
                    assert("Invalid tag." && false); __trap();
                }
            }
            break;
        }
        default: {
            assert("Invalid tag." && false); __trap();
        }
    }
    static_array<unsigned char,5> v423;
    int v425; int v426; unsigned char v427;
    Tuple20 tmp62 = Tuple20{0, 0, 12u};
    v425 = tmp62.v0; v426 = tmp62.v1; v427 = tmp62.v2;
    while (while_method_19(v425)){
        bool v429;
        v429 = 0 <= v425;
        bool v431;
        if (v429){
            bool v430;
            v430 = v425 < 7;
            v431 = v430;
        } else {
            v431 = false;
        }
        bool v432;
        v432 = v431 == false;
        if (v432){
            assert("Index must be in range." && v431);
        } else {
        }
        unsigned char v434;
        v434 = v129[v425];
        bool v436;
        v436 = v426 < 5;
        int v448; unsigned char v449;
        if (v436){
            unsigned char v437;
            v437 = v434 % 4u;
            bool v438;
            v438 = 3u == v437;
            if (v438){
                unsigned char v439;
                v439 = v434 / 4u;
                bool v440;
                v440 = v427 == v439;
                int v441;
                if (v440){
                    v441 = v426;
                } else {
                    v441 = 0;
                }
                v423[v441] = v434;
                int v442;
                v442 = v441 + 1;
                unsigned char v443;
                v443 = v439 - 1u;
                v448 = v442; v449 = v443;
            } else {
                v448 = v426; v449 = v427;
            }
        } else {
            break;
        }
        v426 = v448;
        v427 = v449;
        v425 += 1 ;
    }
    bool v450;
    v450 = v426 == 4;
    bool v489;
    if (v450){
        unsigned char v451;
        v451 = v427 + 1u;
        bool v452;
        v452 = v451 == 0u;
        if (v452){
            unsigned char v453;
            v453 = v129[0];
            unsigned char v455;
            v455 = v453 % 4u;
            bool v456;
            v456 = 3u == v455;
            bool v460;
            if (v456){
                unsigned char v457;
                v457 = v453 / 4u;
                bool v458;
                v458 = v457 == 12u;
                if (v458){
                    v423[4] = v453;
                    v460 = true;
                } else {
                    v460 = false;
                }
            } else {
                v460 = false;
            }
            if (v460){
                v489 = true;
            } else {
                unsigned char v461;
                v461 = v129[1];
                unsigned char v463;
                v463 = v461 % 4u;
                bool v464;
                v464 = 3u == v463;
                bool v468;
                if (v464){
                    unsigned char v465;
                    v465 = v461 / 4u;
                    bool v466;
                    v466 = v465 == 12u;
                    if (v466){
                        v423[4] = v461;
                        v468 = true;
                    } else {
                        v468 = false;
                    }
                } else {
                    v468 = false;
                }
                if (v468){
                    v489 = true;
                } else {
                    unsigned char v469;
                    v469 = v129[2];
                    unsigned char v471;
                    v471 = v469 % 4u;
                    bool v472;
                    v472 = 3u == v471;
                    bool v476;
                    if (v472){
                        unsigned char v473;
                        v473 = v469 / 4u;
                        bool v474;
                        v474 = v473 == 12u;
                        if (v474){
                            v423[4] = v469;
                            v476 = true;
                        } else {
                            v476 = false;
                        }
                    } else {
                        v476 = false;
                    }
                    if (v476){
                        v489 = true;
                    } else {
                        unsigned char v477;
                        v477 = v129[3];
                        unsigned char v479;
                        v479 = v477 % 4u;
                        bool v480;
                        v480 = 3u == v479;
                        if (v480){
                            unsigned char v481;
                            v481 = v477 / 4u;
                            bool v482;
                            v482 = v481 == 12u;
                            if (v482){
                                v423[4] = v477;
                                v489 = true;
                            } else {
                                v489 = false;
                            }
                        } else {
                            v489 = false;
                        }
                    }
                }
            }
        } else {
            v489 = false;
        }
    } else {
        v489 = false;
    }
    Union12 v495;
    if (v489){
        v495 = Union12{Union12_1{v423}};
    } else {
        bool v491;
        v491 = v426 == 5;
        if (v491){
            v495 = Union12{Union12_1{v423}};
        } else {
            v495 = Union12{Union12_0{}};
        }
    }
    Union12 v532;
    switch (v422.tag) {
        case 0: { // None
            v532 = v495;
            break;
        }
        case 1: { // Some
            static_array<unsigned char,5> v496 = v422.case1.v0;
            switch (v495.tag) {
                case 0: { // None
                    v532 = v422;
                    break;
                }
                case 1: { // Some
                    static_array<unsigned char,5> v497 = v495.case1.v0;
                    Union11 v498;
                    v498 = Union11{Union11_0{}};
                    int v499; Union11 v500;
                    Tuple21 tmp63 = Tuple21{0, v498};
                    v499 = tmp63.v0; v500 = tmp63.v1;
                    while (while_method_2(v499)){
                        bool v502;
                        v502 = 0 <= v499;
                        bool v504;
                        if (v502){
                            bool v503;
                            v503 = v499 < 5;
                            v504 = v503;
                        } else {
                            v504 = false;
                        }
                        bool v505;
                        v505 = v504 == false;
                        if (v505){
                            assert("Index must be in range." && v504);
                        } else {
                        }
                        unsigned char v507;
                        v507 = v496[v499];
                        bool v510;
                        if (v502){
                            bool v509;
                            v509 = v499 < 5;
                            v510 = v509;
                        } else {
                            v510 = false;
                        }
                        bool v511;
                        v511 = v510 == false;
                        if (v511){
                            assert("Index must be in range." && v510);
                        } else {
                        }
                        unsigned char v513;
                        v513 = v497[v499];
                        Union11 v525;
                        switch (v500.tag) {
                            case 0: { // Eq
                                unsigned char v515;
                                v515 = v507 / 4u;
                                unsigned char v516;
                                v516 = v513 / 4u;
                                bool v517;
                                v517 = v515 < v516;
                                if (v517){
                                    v525 = Union11{Union11_2{}};
                                } else {
                                    bool v519;
                                    v519 = v515 > v516;
                                    if (v519){
                                        v525 = Union11{Union11_1{}};
                                    } else {
                                        v525 = Union11{Union11_0{}};
                                    }
                                }
                                break;
                            }
                            default: {
                                break;
                            }
                        }
                        v500 = v525;
                        v499 += 1 ;
                    }
                    bool v526;
                    switch (v500.tag) {
                        case 1: { // Gt
                            v526 = true;
                            break;
                        }
                        default: {
                            v526 = false;
                        }
                    }
                    static_array<unsigned char,5> v527;
                    if (v526){
                        v527 = v496;
                    } else {
                        v527 = v497;
                    }
                    v532 = Union12{Union12_1{v527}};
                    break;
                }
                default: {
                    assert("Invalid tag." && false); __trap();
                }
            }
            break;
        }
        default: {
            assert("Invalid tag." && false); __trap();
        }
    }
    static_array<unsigned char,5> v1331; char v1332;
    switch (v532.tag) {
        case 0: { // None
            static_array<unsigned char,4> v534;
            static_array<unsigned char,3> v536;
            int v538; int v539; int v540; unsigned char v541;
            Tuple22 tmp64 = Tuple22{0, 0, 0, 12u};
            v538 = tmp64.v0; v539 = tmp64.v1; v540 = tmp64.v2; v541 = tmp64.v3;
            while (while_method_19(v538)){
                bool v543;
                v543 = 0 <= v538;
                bool v545;
                if (v543){
                    bool v544;
                    v544 = v538 < 7;
                    v545 = v544;
                } else {
                    v545 = false;
                }
                bool v546;
                v546 = v545 == false;
                if (v546){
                    assert("Index must be in range." && v545);
                } else {
                }
                unsigned char v548;
                v548 = v129[v538];
                bool v550;
                v550 = v540 < 4;
                int v558; int v559; unsigned char v560;
                if (v550){
                    unsigned char v551;
                    v551 = v548 / 4u;
                    bool v552;
                    v552 = v541 == v551;
                    int v553;
                    if (v552){
                        v553 = v540;
                    } else {
                        v553 = 0;
                    }
                    v534[v553] = v548;
                    int v554;
                    v554 = v553 + 1;
                    v558 = v538; v559 = v554; v560 = v551;
                } else {
                    break;
                }
                v539 = v558;
                v540 = v559;
                v541 = v560;
                v538 += 1 ;
            }
            bool v561;
            v561 = v540 == 4;
            Union13 v577;
            if (v561){
                int v562;
                v562 = 0;
                while (while_method_1(v562)){
                    int v564;
                    v564 = v539 + -3;
                    bool v565;
                    v565 = v562 < v564;
                    int v566;
                    if (v565){
                        v566 = 0;
                    } else {
                        v566 = 4;
                    }
                    int v567;
                    v567 = v566 + v562;
                    bool v568;
                    v568 = 0 <= v567;
                    bool v570;
                    if (v568){
                        bool v569;
                        v569 = v567 < 7;
                        v570 = v569;
                    } else {
                        v570 = false;
                    }
                    bool v571;
                    v571 = v570 == false;
                    if (v571){
                        assert("Index must be in range." && v570);
                    } else {
                    }
                    unsigned char v573;
                    v573 = v129[v567];
                    v536[v562] = v573;
                    v562 += 1 ;
                }
                v577 = Union13{Union13_1{v534, v536}};
            } else {
                v577 = Union13{Union13_0{}};
            }
            Union12 v615;
            switch (v577.tag) {
                case 0: { // None
                    v615 = Union12{Union12_0{}};
                    break;
                }
                case 1: { // Some
                    static_array<unsigned char,4> v578 = v577.case1.v0; static_array<unsigned char,3> v579 = v577.case1.v1;
                    static_array<unsigned char,1> v580;
                    int v582;
                    v582 = 0;
                    while (while_method_6(v582)){
                        bool v584;
                        v584 = 0 <= v582;
                        bool v586;
                        if (v584){
                            bool v585;
                            v585 = v582 < 3;
                            v586 = v585;
                        } else {
                            v586 = false;
                        }
                        bool v587;
                        v587 = v586 == false;
                        if (v587){
                            assert("Index must be in range." && v586);
                        } else {
                        }
                        unsigned char v589;
                        v589 = v579[v582];
                        v580[v582] = v589;
                        v582 += 1 ;
                    }
                    static_array<unsigned char,5> v591;
                    int v593;
                    v593 = 0;
                    while (while_method_3(v593)){
                        bool v595;
                        v595 = 0 <= v593;
                        bool v597;
                        if (v595){
                            bool v596;
                            v596 = v593 < 4;
                            v597 = v596;
                        } else {
                            v597 = false;
                        }
                        bool v598;
                        v598 = v597 == false;
                        if (v598){
                            assert("Index must be in range." && v597);
                        } else {
                        }
                        unsigned char v600;
                        v600 = v578[v593];
                        v591[v593] = v600;
                        v593 += 1 ;
                    }
                    int v602;
                    v602 = 0;
                    while (while_method_6(v602)){
                        bool v604;
                        v604 = 0 <= v602;
                        bool v606;
                        if (v604){
                            bool v605;
                            v605 = v602 < 1;
                            v606 = v605;
                        } else {
                            v606 = false;
                        }
                        bool v607;
                        v607 = v606 == false;
                        if (v607){
                            assert("Index must be in range." && v606);
                        } else {
                        }
                        unsigned char v609;
                        v609 = v580[v602];
                        int v611;
                        v611 = 4 + v602;
                        v591[v611] = v609;
                        v602 += 1 ;
                    }
                    v615 = Union12{Union12_1{v591}};
                    break;
                }
                default: {
                    assert("Invalid tag." && false); __trap();
                }
            }
            switch (v615.tag) {
                case 0: { // None
                    static_array<unsigned char,3> v617;
                    static_array<unsigned char,4> v619;
                    int v621; int v622; int v623; unsigned char v624;
                    Tuple22 tmp65 = Tuple22{0, 0, 0, 12u};
                    v621 = tmp65.v0; v622 = tmp65.v1; v623 = tmp65.v2; v624 = tmp65.v3;
                    while (while_method_19(v621)){
                        bool v626;
                        v626 = 0 <= v621;
                        bool v628;
                        if (v626){
                            bool v627;
                            v627 = v621 < 7;
                            v628 = v627;
                        } else {
                            v628 = false;
                        }
                        bool v629;
                        v629 = v628 == false;
                        if (v629){
                            assert("Index must be in range." && v628);
                        } else {
                        }
                        unsigned char v631;
                        v631 = v129[v621];
                        bool v633;
                        v633 = v623 < 3;
                        int v641; int v642; unsigned char v643;
                        if (v633){
                            unsigned char v634;
                            v634 = v631 / 4u;
                            bool v635;
                            v635 = v624 == v634;
                            int v636;
                            if (v635){
                                v636 = v623;
                            } else {
                                v636 = 0;
                            }
                            v617[v636] = v631;
                            int v637;
                            v637 = v636 + 1;
                            v641 = v621; v642 = v637; v643 = v634;
                        } else {
                            break;
                        }
                        v622 = v641;
                        v623 = v642;
                        v624 = v643;
                        v621 += 1 ;
                    }
                    bool v644;
                    v644 = v623 == 3;
                    Union14 v660;
                    if (v644){
                        int v645;
                        v645 = 0;
                        while (while_method_3(v645)){
                            int v647;
                            v647 = v622 + -2;
                            bool v648;
                            v648 = v645 < v647;
                            int v649;
                            if (v648){
                                v649 = 0;
                            } else {
                                v649 = 3;
                            }
                            int v650;
                            v650 = v649 + v645;
                            bool v651;
                            v651 = 0 <= v650;
                            bool v653;
                            if (v651){
                                bool v652;
                                v652 = v650 < 7;
                                v653 = v652;
                            } else {
                                v653 = false;
                            }
                            bool v654;
                            v654 = v653 == false;
                            if (v654){
                                assert("Index must be in range." && v653);
                            } else {
                            }
                            unsigned char v656;
                            v656 = v129[v650];
                            v619[v645] = v656;
                            v645 += 1 ;
                        }
                        v660 = Union14{Union14_1{v617, v619}};
                    } else {
                        v660 = Union14{Union14_0{}};
                    }
                    Union12 v736;
                    switch (v660.tag) {
                        case 0: { // None
                            v736 = Union12{Union12_0{}};
                            break;
                        }
                        case 1: { // Some
                            static_array<unsigned char,3> v661 = v660.case1.v0; static_array<unsigned char,4> v662 = v660.case1.v1;
                            static_array<unsigned char,2> v663;
                            static_array<unsigned char,2> v665;
                            int v667; int v668; int v669; unsigned char v670;
                            Tuple22 tmp66 = Tuple22{0, 0, 0, 12u};
                            v667 = tmp66.v0; v668 = tmp66.v1; v669 = tmp66.v2; v670 = tmp66.v3;
                            while (while_method_3(v667)){
                                bool v672;
                                v672 = 0 <= v667;
                                bool v674;
                                if (v672){
                                    bool v673;
                                    v673 = v667 < 4;
                                    v674 = v673;
                                } else {
                                    v674 = false;
                                }
                                bool v675;
                                v675 = v674 == false;
                                if (v675){
                                    assert("Index must be in range." && v674);
                                } else {
                                }
                                unsigned char v677;
                                v677 = v662[v667];
                                bool v679;
                                v679 = v669 < 2;
                                int v687; int v688; unsigned char v689;
                                if (v679){
                                    unsigned char v680;
                                    v680 = v677 / 4u;
                                    bool v681;
                                    v681 = v670 == v680;
                                    int v682;
                                    if (v681){
                                        v682 = v669;
                                    } else {
                                        v682 = 0;
                                    }
                                    v663[v682] = v677;
                                    int v683;
                                    v683 = v682 + 1;
                                    v687 = v667; v688 = v683; v689 = v680;
                                } else {
                                    break;
                                }
                                v668 = v687;
                                v669 = v688;
                                v670 = v689;
                                v667 += 1 ;
                            }
                            bool v690;
                            v690 = v669 == 2;
                            Union15 v706;
                            if (v690){
                                int v691;
                                v691 = 0;
                                while (while_method_0(v691)){
                                    int v693;
                                    v693 = v668 + -1;
                                    bool v694;
                                    v694 = v691 < v693;
                                    int v695;
                                    if (v694){
                                        v695 = 0;
                                    } else {
                                        v695 = 2;
                                    }
                                    int v696;
                                    v696 = v695 + v691;
                                    bool v697;
                                    v697 = 0 <= v696;
                                    bool v699;
                                    if (v697){
                                        bool v698;
                                        v698 = v696 < 4;
                                        v699 = v698;
                                    } else {
                                        v699 = false;
                                    }
                                    bool v700;
                                    v700 = v699 == false;
                                    if (v700){
                                        assert("Index must be in range." && v699);
                                    } else {
                                    }
                                    unsigned char v702;
                                    v702 = v662[v696];
                                    v665[v691] = v702;
                                    v691 += 1 ;
                                }
                                v706 = Union15{Union15_1{v663, v665}};
                            } else {
                                v706 = Union15{Union15_0{}};
                            }
                            switch (v706.tag) {
                                case 0: { // None
                                    v736 = Union12{Union12_0{}};
                                    break;
                                }
                                case 1: { // Some
                                    static_array<unsigned char,2> v707 = v706.case1.v0; static_array<unsigned char,2> v708 = v706.case1.v1;
                                    static_array<unsigned char,5> v709;
                                    int v711;
                                    v711 = 0;
                                    while (while_method_1(v711)){
                                        bool v713;
                                        v713 = 0 <= v711;
                                        bool v715;
                                        if (v713){
                                            bool v714;
                                            v714 = v711 < 3;
                                            v715 = v714;
                                        } else {
                                            v715 = false;
                                        }
                                        bool v716;
                                        v716 = v715 == false;
                                        if (v716){
                                            assert("Index must be in range." && v715);
                                        } else {
                                        }
                                        unsigned char v718;
                                        v718 = v661[v711];
                                        v709[v711] = v718;
                                        v711 += 1 ;
                                    }
                                    int v720;
                                    v720 = 0;
                                    while (while_method_0(v720)){
                                        bool v722;
                                        v722 = 0 <= v720;
                                        bool v724;
                                        if (v722){
                                            bool v723;
                                            v723 = v720 < 2;
                                            v724 = v723;
                                        } else {
                                            v724 = false;
                                        }
                                        bool v725;
                                        v725 = v724 == false;
                                        if (v725){
                                            assert("Index must be in range." && v724);
                                        } else {
                                        }
                                        unsigned char v727;
                                        v727 = v707[v720];
                                        int v729;
                                        v729 = 3 + v720;
                                        v709[v729] = v727;
                                        v720 += 1 ;
                                    }
                                    v736 = Union12{Union12_1{v709}};
                                    break;
                                }
                                default: {
                                    assert("Invalid tag." && false); __trap();
                                }
                            }
                            break;
                        }
                        default: {
                            assert("Invalid tag." && false); __trap();
                        }
                    }
                    switch (v736.tag) {
                        case 0: { // None
                            static_array<unsigned char,5> v738;
                            int v740; int v741;
                            Tuple4 tmp67 = Tuple4{0, 0};
                            v740 = tmp67.v0; v741 = tmp67.v1;
                            while (while_method_19(v740)){
                                bool v743;
                                v743 = 0 <= v740;
                                bool v745;
                                if (v743){
                                    bool v744;
                                    v744 = v740 < 7;
                                    v745 = v744;
                                } else {
                                    v745 = false;
                                }
                                bool v746;
                                v746 = v745 == false;
                                if (v746){
                                    assert("Index must be in range." && v745);
                                } else {
                                }
                                unsigned char v748;
                                v748 = v129[v740];
                                unsigned char v750;
                                v750 = v748 % 4u;
                                bool v751;
                                v751 = v750 == 0u;
                                bool v753;
                                if (v751){
                                    bool v752;
                                    v752 = v741 < 5;
                                    v753 = v752;
                                } else {
                                    v753 = false;
                                }
                                int v755;
                                if (v753){
                                    v738[v741] = v748;
                                    int v754;
                                    v754 = v741 + 1;
                                    v755 = v754;
                                } else {
                                    v755 = v741;
                                }
                                v741 = v755;
                                v740 += 1 ;
                            }
                            bool v756;
                            v756 = v741 == 5;
                            Union12 v759;
                            if (v756){
                                v759 = Union12{Union12_1{v738}};
                            } else {
                                v759 = Union12{Union12_0{}};
                            }
                            static_array<unsigned char,5> v760;
                            int v762; int v763;
                            Tuple4 tmp68 = Tuple4{0, 0};
                            v762 = tmp68.v0; v763 = tmp68.v1;
                            while (while_method_19(v762)){
                                bool v765;
                                v765 = 0 <= v762;
                                bool v767;
                                if (v765){
                                    bool v766;
                                    v766 = v762 < 7;
                                    v767 = v766;
                                } else {
                                    v767 = false;
                                }
                                bool v768;
                                v768 = v767 == false;
                                if (v768){
                                    assert("Index must be in range." && v767);
                                } else {
                                }
                                unsigned char v770;
                                v770 = v129[v762];
                                unsigned char v772;
                                v772 = v770 % 4u;
                                bool v773;
                                v773 = v772 == 1u;
                                bool v775;
                                if (v773){
                                    bool v774;
                                    v774 = v763 < 5;
                                    v775 = v774;
                                } else {
                                    v775 = false;
                                }
                                int v777;
                                if (v775){
                                    v760[v763] = v770;
                                    int v776;
                                    v776 = v763 + 1;
                                    v777 = v776;
                                } else {
                                    v777 = v763;
                                }
                                v763 = v777;
                                v762 += 1 ;
                            }
                            bool v778;
                            v778 = v763 == 5;
                            Union12 v781;
                            if (v778){
                                v781 = Union12{Union12_1{v760}};
                            } else {
                                v781 = Union12{Union12_0{}};
                            }
                            Union12 v818;
                            switch (v759.tag) {
                                case 0: { // None
                                    v818 = v781;
                                    break;
                                }
                                case 1: { // Some
                                    static_array<unsigned char,5> v782 = v759.case1.v0;
                                    switch (v781.tag) {
                                        case 0: { // None
                                            v818 = v759;
                                            break;
                                        }
                                        case 1: { // Some
                                            static_array<unsigned char,5> v783 = v781.case1.v0;
                                            Union11 v784;
                                            v784 = Union11{Union11_0{}};
                                            int v785; Union11 v786;
                                            Tuple21 tmp69 = Tuple21{0, v784};
                                            v785 = tmp69.v0; v786 = tmp69.v1;
                                            while (while_method_2(v785)){
                                                bool v788;
                                                v788 = 0 <= v785;
                                                bool v790;
                                                if (v788){
                                                    bool v789;
                                                    v789 = v785 < 5;
                                                    v790 = v789;
                                                } else {
                                                    v790 = false;
                                                }
                                                bool v791;
                                                v791 = v790 == false;
                                                if (v791){
                                                    assert("Index must be in range." && v790);
                                                } else {
                                                }
                                                unsigned char v793;
                                                v793 = v782[v785];
                                                bool v796;
                                                if (v788){
                                                    bool v795;
                                                    v795 = v785 < 5;
                                                    v796 = v795;
                                                } else {
                                                    v796 = false;
                                                }
                                                bool v797;
                                                v797 = v796 == false;
                                                if (v797){
                                                    assert("Index must be in range." && v796);
                                                } else {
                                                }
                                                unsigned char v799;
                                                v799 = v783[v785];
                                                Union11 v811;
                                                switch (v786.tag) {
                                                    case 0: { // Eq
                                                        unsigned char v801;
                                                        v801 = v793 / 4u;
                                                        unsigned char v802;
                                                        v802 = v799 / 4u;
                                                        bool v803;
                                                        v803 = v801 < v802;
                                                        if (v803){
                                                            v811 = Union11{Union11_2{}};
                                                        } else {
                                                            bool v805;
                                                            v805 = v801 > v802;
                                                            if (v805){
                                                                v811 = Union11{Union11_1{}};
                                                            } else {
                                                                v811 = Union11{Union11_0{}};
                                                            }
                                                        }
                                                        break;
                                                    }
                                                    default: {
                                                        break;
                                                    }
                                                }
                                                v786 = v811;
                                                v785 += 1 ;
                                            }
                                            bool v812;
                                            switch (v786.tag) {
                                                case 1: { // Gt
                                                    v812 = true;
                                                    break;
                                                }
                                                default: {
                                                    v812 = false;
                                                }
                                            }
                                            static_array<unsigned char,5> v813;
                                            if (v812){
                                                v813 = v782;
                                            } else {
                                                v813 = v783;
                                            }
                                            v818 = Union12{Union12_1{v813}};
                                            break;
                                        }
                                        default: {
                                            assert("Invalid tag." && false); __trap();
                                        }
                                    }
                                    break;
                                }
                                default: {
                                    assert("Invalid tag." && false); __trap();
                                }
                            }
                            static_array<unsigned char,5> v819;
                            int v821; int v822;
                            Tuple4 tmp70 = Tuple4{0, 0};
                            v821 = tmp70.v0; v822 = tmp70.v1;
                            while (while_method_19(v821)){
                                bool v824;
                                v824 = 0 <= v821;
                                bool v826;
                                if (v824){
                                    bool v825;
                                    v825 = v821 < 7;
                                    v826 = v825;
                                } else {
                                    v826 = false;
                                }
                                bool v827;
                                v827 = v826 == false;
                                if (v827){
                                    assert("Index must be in range." && v826);
                                } else {
                                }
                                unsigned char v829;
                                v829 = v129[v821];
                                unsigned char v831;
                                v831 = v829 % 4u;
                                bool v832;
                                v832 = v831 == 2u;
                                bool v834;
                                if (v832){
                                    bool v833;
                                    v833 = v822 < 5;
                                    v834 = v833;
                                } else {
                                    v834 = false;
                                }
                                int v836;
                                if (v834){
                                    v819[v822] = v829;
                                    int v835;
                                    v835 = v822 + 1;
                                    v836 = v835;
                                } else {
                                    v836 = v822;
                                }
                                v822 = v836;
                                v821 += 1 ;
                            }
                            bool v837;
                            v837 = v822 == 5;
                            Union12 v840;
                            if (v837){
                                v840 = Union12{Union12_1{v819}};
                            } else {
                                v840 = Union12{Union12_0{}};
                            }
                            Union12 v877;
                            switch (v818.tag) {
                                case 0: { // None
                                    v877 = v840;
                                    break;
                                }
                                case 1: { // Some
                                    static_array<unsigned char,5> v841 = v818.case1.v0;
                                    switch (v840.tag) {
                                        case 0: { // None
                                            v877 = v818;
                                            break;
                                        }
                                        case 1: { // Some
                                            static_array<unsigned char,5> v842 = v840.case1.v0;
                                            Union11 v843;
                                            v843 = Union11{Union11_0{}};
                                            int v844; Union11 v845;
                                            Tuple21 tmp71 = Tuple21{0, v843};
                                            v844 = tmp71.v0; v845 = tmp71.v1;
                                            while (while_method_2(v844)){
                                                bool v847;
                                                v847 = 0 <= v844;
                                                bool v849;
                                                if (v847){
                                                    bool v848;
                                                    v848 = v844 < 5;
                                                    v849 = v848;
                                                } else {
                                                    v849 = false;
                                                }
                                                bool v850;
                                                v850 = v849 == false;
                                                if (v850){
                                                    assert("Index must be in range." && v849);
                                                } else {
                                                }
                                                unsigned char v852;
                                                v852 = v841[v844];
                                                bool v855;
                                                if (v847){
                                                    bool v854;
                                                    v854 = v844 < 5;
                                                    v855 = v854;
                                                } else {
                                                    v855 = false;
                                                }
                                                bool v856;
                                                v856 = v855 == false;
                                                if (v856){
                                                    assert("Index must be in range." && v855);
                                                } else {
                                                }
                                                unsigned char v858;
                                                v858 = v842[v844];
                                                Union11 v870;
                                                switch (v845.tag) {
                                                    case 0: { // Eq
                                                        unsigned char v860;
                                                        v860 = v852 / 4u;
                                                        unsigned char v861;
                                                        v861 = v858 / 4u;
                                                        bool v862;
                                                        v862 = v860 < v861;
                                                        if (v862){
                                                            v870 = Union11{Union11_2{}};
                                                        } else {
                                                            bool v864;
                                                            v864 = v860 > v861;
                                                            if (v864){
                                                                v870 = Union11{Union11_1{}};
                                                            } else {
                                                                v870 = Union11{Union11_0{}};
                                                            }
                                                        }
                                                        break;
                                                    }
                                                    default: {
                                                        break;
                                                    }
                                                }
                                                v845 = v870;
                                                v844 += 1 ;
                                            }
                                            bool v871;
                                            switch (v845.tag) {
                                                case 1: { // Gt
                                                    v871 = true;
                                                    break;
                                                }
                                                default: {
                                                    v871 = false;
                                                }
                                            }
                                            static_array<unsigned char,5> v872;
                                            if (v871){
                                                v872 = v841;
                                            } else {
                                                v872 = v842;
                                            }
                                            v877 = Union12{Union12_1{v872}};
                                            break;
                                        }
                                        default: {
                                            assert("Invalid tag." && false); __trap();
                                        }
                                    }
                                    break;
                                }
                                default: {
                                    assert("Invalid tag." && false); __trap();
                                }
                            }
                            static_array<unsigned char,5> v878;
                            int v880; int v881;
                            Tuple4 tmp72 = Tuple4{0, 0};
                            v880 = tmp72.v0; v881 = tmp72.v1;
                            while (while_method_19(v880)){
                                bool v883;
                                v883 = 0 <= v880;
                                bool v885;
                                if (v883){
                                    bool v884;
                                    v884 = v880 < 7;
                                    v885 = v884;
                                } else {
                                    v885 = false;
                                }
                                bool v886;
                                v886 = v885 == false;
                                if (v886){
                                    assert("Index must be in range." && v885);
                                } else {
                                }
                                unsigned char v888;
                                v888 = v129[v880];
                                unsigned char v890;
                                v890 = v888 % 4u;
                                bool v891;
                                v891 = v890 == 3u;
                                bool v893;
                                if (v891){
                                    bool v892;
                                    v892 = v881 < 5;
                                    v893 = v892;
                                } else {
                                    v893 = false;
                                }
                                int v895;
                                if (v893){
                                    v878[v881] = v888;
                                    int v894;
                                    v894 = v881 + 1;
                                    v895 = v894;
                                } else {
                                    v895 = v881;
                                }
                                v881 = v895;
                                v880 += 1 ;
                            }
                            bool v896;
                            v896 = v881 == 5;
                            Union12 v899;
                            if (v896){
                                v899 = Union12{Union12_1{v878}};
                            } else {
                                v899 = Union12{Union12_0{}};
                            }
                            Union12 v936;
                            switch (v877.tag) {
                                case 0: { // None
                                    v936 = v899;
                                    break;
                                }
                                case 1: { // Some
                                    static_array<unsigned char,5> v900 = v877.case1.v0;
                                    switch (v899.tag) {
                                        case 0: { // None
                                            v936 = v877;
                                            break;
                                        }
                                        case 1: { // Some
                                            static_array<unsigned char,5> v901 = v899.case1.v0;
                                            Union11 v902;
                                            v902 = Union11{Union11_0{}};
                                            int v903; Union11 v904;
                                            Tuple21 tmp73 = Tuple21{0, v902};
                                            v903 = tmp73.v0; v904 = tmp73.v1;
                                            while (while_method_2(v903)){
                                                bool v906;
                                                v906 = 0 <= v903;
                                                bool v908;
                                                if (v906){
                                                    bool v907;
                                                    v907 = v903 < 5;
                                                    v908 = v907;
                                                } else {
                                                    v908 = false;
                                                }
                                                bool v909;
                                                v909 = v908 == false;
                                                if (v909){
                                                    assert("Index must be in range." && v908);
                                                } else {
                                                }
                                                unsigned char v911;
                                                v911 = v900[v903];
                                                bool v914;
                                                if (v906){
                                                    bool v913;
                                                    v913 = v903 < 5;
                                                    v914 = v913;
                                                } else {
                                                    v914 = false;
                                                }
                                                bool v915;
                                                v915 = v914 == false;
                                                if (v915){
                                                    assert("Index must be in range." && v914);
                                                } else {
                                                }
                                                unsigned char v917;
                                                v917 = v901[v903];
                                                Union11 v929;
                                                switch (v904.tag) {
                                                    case 0: { // Eq
                                                        unsigned char v919;
                                                        v919 = v911 / 4u;
                                                        unsigned char v920;
                                                        v920 = v917 / 4u;
                                                        bool v921;
                                                        v921 = v919 < v920;
                                                        if (v921){
                                                            v929 = Union11{Union11_2{}};
                                                        } else {
                                                            bool v923;
                                                            v923 = v919 > v920;
                                                            if (v923){
                                                                v929 = Union11{Union11_1{}};
                                                            } else {
                                                                v929 = Union11{Union11_0{}};
                                                            }
                                                        }
                                                        break;
                                                    }
                                                    default: {
                                                        break;
                                                    }
                                                }
                                                v904 = v929;
                                                v903 += 1 ;
                                            }
                                            bool v930;
                                            switch (v904.tag) {
                                                case 1: { // Gt
                                                    v930 = true;
                                                    break;
                                                }
                                                default: {
                                                    v930 = false;
                                                }
                                            }
                                            static_array<unsigned char,5> v931;
                                            if (v930){
                                                v931 = v900;
                                            } else {
                                                v931 = v901;
                                            }
                                            v936 = Union12{Union12_1{v931}};
                                            break;
                                        }
                                        default: {
                                            assert("Invalid tag." && false); __trap();
                                        }
                                    }
                                    break;
                                }
                                default: {
                                    assert("Invalid tag." && false); __trap();
                                }
                            }
                            switch (v936.tag) {
                                case 0: { // None
                                    static_array<unsigned char,5> v938;
                                    int v940; int v941; unsigned char v942;
                                    Tuple20 tmp74 = Tuple20{0, 0, 12u};
                                    v940 = tmp74.v0; v941 = tmp74.v1; v942 = tmp74.v2;
                                    while (while_method_19(v940)){
                                        bool v944;
                                        v944 = 0 <= v940;
                                        bool v946;
                                        if (v944){
                                            bool v945;
                                            v945 = v940 < 7;
                                            v946 = v945;
                                        } else {
                                            v946 = false;
                                        }
                                        bool v947;
                                        v947 = v946 == false;
                                        if (v947){
                                            assert("Index must be in range." && v946);
                                        } else {
                                        }
                                        unsigned char v949;
                                        v949 = v129[v940];
                                        bool v951;
                                        v951 = v941 < 5;
                                        int v963; unsigned char v964;
                                        if (v951){
                                            unsigned char v952;
                                            v952 = v949 / 4u;
                                            unsigned char v953;
                                            v953 = v952 - 1u;
                                            bool v954;
                                            v954 = v942 == v953;
                                            bool v955;
                                            v955 = v954 != true;
                                            if (v955){
                                                bool v956;
                                                v956 = v942 == v952;
                                                int v957;
                                                if (v956){
                                                    v957 = v941;
                                                } else {
                                                    v957 = 0;
                                                }
                                                v938[v957] = v949;
                                                int v958;
                                                v958 = v957 + 1;
                                                v963 = v958; v964 = v953;
                                            } else {
                                                v963 = v941; v964 = v942;
                                            }
                                        } else {
                                            break;
                                        }
                                        v941 = v963;
                                        v942 = v964;
                                        v940 += 1 ;
                                    }
                                    bool v965;
                                    v965 = v941 == 4;
                                    bool v974;
                                    if (v965){
                                        unsigned char v966;
                                        v966 = v942 + 1u;
                                        bool v967;
                                        v967 = v966 == 0u;
                                        if (v967){
                                            unsigned char v968;
                                            v968 = v129[0];
                                            unsigned char v970;
                                            v970 = v968 / 4u;
                                            bool v971;
                                            v971 = v970 == 12u;
                                            if (v971){
                                                v938[4] = v968;
                                                v974 = true;
                                            } else {
                                                v974 = false;
                                            }
                                        } else {
                                            v974 = false;
                                        }
                                    } else {
                                        v974 = false;
                                    }
                                    Union12 v980;
                                    if (v974){
                                        v980 = Union12{Union12_1{v938}};
                                    } else {
                                        bool v976;
                                        v976 = v941 == 5;
                                        if (v976){
                                            v980 = Union12{Union12_1{v938}};
                                        } else {
                                            v980 = Union12{Union12_0{}};
                                        }
                                    }
                                    switch (v980.tag) {
                                        case 0: { // None
                                            static_array<unsigned char,3> v982;
                                            static_array<unsigned char,4> v984;
                                            int v986; int v987; int v988; unsigned char v989;
                                            Tuple22 tmp75 = Tuple22{0, 0, 0, 12u};
                                            v986 = tmp75.v0; v987 = tmp75.v1; v988 = tmp75.v2; v989 = tmp75.v3;
                                            while (while_method_19(v986)){
                                                bool v991;
                                                v991 = 0 <= v986;
                                                bool v993;
                                                if (v991){
                                                    bool v992;
                                                    v992 = v986 < 7;
                                                    v993 = v992;
                                                } else {
                                                    v993 = false;
                                                }
                                                bool v994;
                                                v994 = v993 == false;
                                                if (v994){
                                                    assert("Index must be in range." && v993);
                                                } else {
                                                }
                                                unsigned char v996;
                                                v996 = v129[v986];
                                                bool v998;
                                                v998 = v988 < 3;
                                                int v1006; int v1007; unsigned char v1008;
                                                if (v998){
                                                    unsigned char v999;
                                                    v999 = v996 / 4u;
                                                    bool v1000;
                                                    v1000 = v989 == v999;
                                                    int v1001;
                                                    if (v1000){
                                                        v1001 = v988;
                                                    } else {
                                                        v1001 = 0;
                                                    }
                                                    v982[v1001] = v996;
                                                    int v1002;
                                                    v1002 = v1001 + 1;
                                                    v1006 = v986; v1007 = v1002; v1008 = v999;
                                                } else {
                                                    break;
                                                }
                                                v987 = v1006;
                                                v988 = v1007;
                                                v989 = v1008;
                                                v986 += 1 ;
                                            }
                                            bool v1009;
                                            v1009 = v988 == 3;
                                            Union14 v1025;
                                            if (v1009){
                                                int v1010;
                                                v1010 = 0;
                                                while (while_method_3(v1010)){
                                                    int v1012;
                                                    v1012 = v987 + -2;
                                                    bool v1013;
                                                    v1013 = v1010 < v1012;
                                                    int v1014;
                                                    if (v1013){
                                                        v1014 = 0;
                                                    } else {
                                                        v1014 = 3;
                                                    }
                                                    int v1015;
                                                    v1015 = v1014 + v1010;
                                                    bool v1016;
                                                    v1016 = 0 <= v1015;
                                                    bool v1018;
                                                    if (v1016){
                                                        bool v1017;
                                                        v1017 = v1015 < 7;
                                                        v1018 = v1017;
                                                    } else {
                                                        v1018 = false;
                                                    }
                                                    bool v1019;
                                                    v1019 = v1018 == false;
                                                    if (v1019){
                                                        assert("Index must be in range." && v1018);
                                                    } else {
                                                    }
                                                    unsigned char v1021;
                                                    v1021 = v129[v1015];
                                                    v984[v1010] = v1021;
                                                    v1010 += 1 ;
                                                }
                                                v1025 = Union14{Union14_1{v982, v984}};
                                            } else {
                                                v1025 = Union14{Union14_0{}};
                                            }
                                            Union12 v1063;
                                            switch (v1025.tag) {
                                                case 0: { // None
                                                    v1063 = Union12{Union12_0{}};
                                                    break;
                                                }
                                                case 1: { // Some
                                                    static_array<unsigned char,3> v1026 = v1025.case1.v0; static_array<unsigned char,4> v1027 = v1025.case1.v1;
                                                    static_array<unsigned char,2> v1028;
                                                    int v1030;
                                                    v1030 = 0;
                                                    while (while_method_0(v1030)){
                                                        bool v1032;
                                                        v1032 = 0 <= v1030;
                                                        bool v1034;
                                                        if (v1032){
                                                            bool v1033;
                                                            v1033 = v1030 < 4;
                                                            v1034 = v1033;
                                                        } else {
                                                            v1034 = false;
                                                        }
                                                        bool v1035;
                                                        v1035 = v1034 == false;
                                                        if (v1035){
                                                            assert("Index must be in range." && v1034);
                                                        } else {
                                                        }
                                                        unsigned char v1037;
                                                        v1037 = v1027[v1030];
                                                        v1028[v1030] = v1037;
                                                        v1030 += 1 ;
                                                    }
                                                    static_array<unsigned char,5> v1039;
                                                    int v1041;
                                                    v1041 = 0;
                                                    while (while_method_1(v1041)){
                                                        bool v1043;
                                                        v1043 = 0 <= v1041;
                                                        bool v1045;
                                                        if (v1043){
                                                            bool v1044;
                                                            v1044 = v1041 < 3;
                                                            v1045 = v1044;
                                                        } else {
                                                            v1045 = false;
                                                        }
                                                        bool v1046;
                                                        v1046 = v1045 == false;
                                                        if (v1046){
                                                            assert("Index must be in range." && v1045);
                                                        } else {
                                                        }
                                                        unsigned char v1048;
                                                        v1048 = v1026[v1041];
                                                        v1039[v1041] = v1048;
                                                        v1041 += 1 ;
                                                    }
                                                    int v1050;
                                                    v1050 = 0;
                                                    while (while_method_0(v1050)){
                                                        bool v1052;
                                                        v1052 = 0 <= v1050;
                                                        bool v1054;
                                                        if (v1052){
                                                            bool v1053;
                                                            v1053 = v1050 < 2;
                                                            v1054 = v1053;
                                                        } else {
                                                            v1054 = false;
                                                        }
                                                        bool v1055;
                                                        v1055 = v1054 == false;
                                                        if (v1055){
                                                            assert("Index must be in range." && v1054);
                                                        } else {
                                                        }
                                                        unsigned char v1057;
                                                        v1057 = v1028[v1050];
                                                        int v1059;
                                                        v1059 = 3 + v1050;
                                                        v1039[v1059] = v1057;
                                                        v1050 += 1 ;
                                                    }
                                                    v1063 = Union12{Union12_1{v1039}};
                                                    break;
                                                }
                                                default: {
                                                    assert("Invalid tag." && false); __trap();
                                                }
                                            }
                                            switch (v1063.tag) {
                                                case 0: { // None
                                                    static_array<unsigned char,2> v1065;
                                                    static_array<unsigned char,5> v1067;
                                                    int v1069; int v1070; int v1071; unsigned char v1072;
                                                    Tuple22 tmp76 = Tuple22{0, 0, 0, 12u};
                                                    v1069 = tmp76.v0; v1070 = tmp76.v1; v1071 = tmp76.v2; v1072 = tmp76.v3;
                                                    while (while_method_19(v1069)){
                                                        bool v1074;
                                                        v1074 = 0 <= v1069;
                                                        bool v1076;
                                                        if (v1074){
                                                            bool v1075;
                                                            v1075 = v1069 < 7;
                                                            v1076 = v1075;
                                                        } else {
                                                            v1076 = false;
                                                        }
                                                        bool v1077;
                                                        v1077 = v1076 == false;
                                                        if (v1077){
                                                            assert("Index must be in range." && v1076);
                                                        } else {
                                                        }
                                                        unsigned char v1079;
                                                        v1079 = v129[v1069];
                                                        bool v1081;
                                                        v1081 = v1071 < 2;
                                                        int v1089; int v1090; unsigned char v1091;
                                                        if (v1081){
                                                            unsigned char v1082;
                                                            v1082 = v1079 / 4u;
                                                            bool v1083;
                                                            v1083 = v1072 == v1082;
                                                            int v1084;
                                                            if (v1083){
                                                                v1084 = v1071;
                                                            } else {
                                                                v1084 = 0;
                                                            }
                                                            v1065[v1084] = v1079;
                                                            int v1085;
                                                            v1085 = v1084 + 1;
                                                            v1089 = v1069; v1090 = v1085; v1091 = v1082;
                                                        } else {
                                                            break;
                                                        }
                                                        v1070 = v1089;
                                                        v1071 = v1090;
                                                        v1072 = v1091;
                                                        v1069 += 1 ;
                                                    }
                                                    bool v1092;
                                                    v1092 = v1071 == 2;
                                                    Union16 v1108;
                                                    if (v1092){
                                                        int v1093;
                                                        v1093 = 0;
                                                        while (while_method_2(v1093)){
                                                            int v1095;
                                                            v1095 = v1070 + -1;
                                                            bool v1096;
                                                            v1096 = v1093 < v1095;
                                                            int v1097;
                                                            if (v1096){
                                                                v1097 = 0;
                                                            } else {
                                                                v1097 = 2;
                                                            }
                                                            int v1098;
                                                            v1098 = v1097 + v1093;
                                                            bool v1099;
                                                            v1099 = 0 <= v1098;
                                                            bool v1101;
                                                            if (v1099){
                                                                bool v1100;
                                                                v1100 = v1098 < 7;
                                                                v1101 = v1100;
                                                            } else {
                                                                v1101 = false;
                                                            }
                                                            bool v1102;
                                                            v1102 = v1101 == false;
                                                            if (v1102){
                                                                assert("Index must be in range." && v1101);
                                                            } else {
                                                            }
                                                            unsigned char v1104;
                                                            v1104 = v129[v1098];
                                                            v1067[v1093] = v1104;
                                                            v1093 += 1 ;
                                                        }
                                                        v1108 = Union16{Union16_1{v1065, v1067}};
                                                    } else {
                                                        v1108 = Union16{Union16_0{}};
                                                    }
                                                    Union12 v1205;
                                                    switch (v1108.tag) {
                                                        case 0: { // None
                                                            v1205 = Union12{Union12_0{}};
                                                            break;
                                                        }
                                                        case 1: { // Some
                                                            static_array<unsigned char,2> v1109 = v1108.case1.v0; static_array<unsigned char,5> v1110 = v1108.case1.v1;
                                                            static_array<unsigned char,2> v1111;
                                                            static_array<unsigned char,3> v1113;
                                                            int v1115; int v1116; int v1117; unsigned char v1118;
                                                            Tuple22 tmp77 = Tuple22{0, 0, 0, 12u};
                                                            v1115 = tmp77.v0; v1116 = tmp77.v1; v1117 = tmp77.v2; v1118 = tmp77.v3;
                                                            while (while_method_2(v1115)){
                                                                bool v1120;
                                                                v1120 = 0 <= v1115;
                                                                bool v1122;
                                                                if (v1120){
                                                                    bool v1121;
                                                                    v1121 = v1115 < 5;
                                                                    v1122 = v1121;
                                                                } else {
                                                                    v1122 = false;
                                                                }
                                                                bool v1123;
                                                                v1123 = v1122 == false;
                                                                if (v1123){
                                                                    assert("Index must be in range." && v1122);
                                                                } else {
                                                                }
                                                                unsigned char v1125;
                                                                v1125 = v1110[v1115];
                                                                bool v1127;
                                                                v1127 = v1117 < 2;
                                                                int v1135; int v1136; unsigned char v1137;
                                                                if (v1127){
                                                                    unsigned char v1128;
                                                                    v1128 = v1125 / 4u;
                                                                    bool v1129;
                                                                    v1129 = v1118 == v1128;
                                                                    int v1130;
                                                                    if (v1129){
                                                                        v1130 = v1117;
                                                                    } else {
                                                                        v1130 = 0;
                                                                    }
                                                                    v1111[v1130] = v1125;
                                                                    int v1131;
                                                                    v1131 = v1130 + 1;
                                                                    v1135 = v1115; v1136 = v1131; v1137 = v1128;
                                                                } else {
                                                                    break;
                                                                }
                                                                v1116 = v1135;
                                                                v1117 = v1136;
                                                                v1118 = v1137;
                                                                v1115 += 1 ;
                                                            }
                                                            bool v1138;
                                                            v1138 = v1117 == 2;
                                                            Union17 v1154;
                                                            if (v1138){
                                                                int v1139;
                                                                v1139 = 0;
                                                                while (while_method_1(v1139)){
                                                                    int v1141;
                                                                    v1141 = v1116 + -1;
                                                                    bool v1142;
                                                                    v1142 = v1139 < v1141;
                                                                    int v1143;
                                                                    if (v1142){
                                                                        v1143 = 0;
                                                                    } else {
                                                                        v1143 = 2;
                                                                    }
                                                                    int v1144;
                                                                    v1144 = v1143 + v1139;
                                                                    bool v1145;
                                                                    v1145 = 0 <= v1144;
                                                                    bool v1147;
                                                                    if (v1145){
                                                                        bool v1146;
                                                                        v1146 = v1144 < 5;
                                                                        v1147 = v1146;
                                                                    } else {
                                                                        v1147 = false;
                                                                    }
                                                                    bool v1148;
                                                                    v1148 = v1147 == false;
                                                                    if (v1148){
                                                                        assert("Index must be in range." && v1147);
                                                                    } else {
                                                                    }
                                                                    unsigned char v1150;
                                                                    v1150 = v1110[v1144];
                                                                    v1113[v1139] = v1150;
                                                                    v1139 += 1 ;
                                                                }
                                                                v1154 = Union17{Union17_1{v1111, v1113}};
                                                            } else {
                                                                v1154 = Union17{Union17_0{}};
                                                            }
                                                            switch (v1154.tag) {
                                                                case 0: { // None
                                                                    v1205 = Union12{Union12_0{}};
                                                                    break;
                                                                }
                                                                case 1: { // Some
                                                                    static_array<unsigned char,2> v1155 = v1154.case1.v0; static_array<unsigned char,3> v1156 = v1154.case1.v1;
                                                                    static_array<unsigned char,1> v1157;
                                                                    int v1159;
                                                                    v1159 = 0;
                                                                    while (while_method_6(v1159)){
                                                                        bool v1161;
                                                                        v1161 = 0 <= v1159;
                                                                        bool v1163;
                                                                        if (v1161){
                                                                            bool v1162;
                                                                            v1162 = v1159 < 3;
                                                                            v1163 = v1162;
                                                                        } else {
                                                                            v1163 = false;
                                                                        }
                                                                        bool v1164;
                                                                        v1164 = v1163 == false;
                                                                        if (v1164){
                                                                            assert("Index must be in range." && v1163);
                                                                        } else {
                                                                        }
                                                                        unsigned char v1166;
                                                                        v1166 = v1156[v1159];
                                                                        v1157[v1159] = v1166;
                                                                        v1159 += 1 ;
                                                                    }
                                                                    static_array<unsigned char,5> v1168;
                                                                    int v1170;
                                                                    v1170 = 0;
                                                                    while (while_method_0(v1170)){
                                                                        bool v1172;
                                                                        v1172 = 0 <= v1170;
                                                                        bool v1174;
                                                                        if (v1172){
                                                                            bool v1173;
                                                                            v1173 = v1170 < 2;
                                                                            v1174 = v1173;
                                                                        } else {
                                                                            v1174 = false;
                                                                        }
                                                                        bool v1175;
                                                                        v1175 = v1174 == false;
                                                                        if (v1175){
                                                                            assert("Index must be in range." && v1174);
                                                                        } else {
                                                                        }
                                                                        unsigned char v1177;
                                                                        v1177 = v1109[v1170];
                                                                        v1168[v1170] = v1177;
                                                                        v1170 += 1 ;
                                                                    }
                                                                    int v1179;
                                                                    v1179 = 0;
                                                                    while (while_method_0(v1179)){
                                                                        bool v1181;
                                                                        v1181 = 0 <= v1179;
                                                                        bool v1183;
                                                                        if (v1181){
                                                                            bool v1182;
                                                                            v1182 = v1179 < 2;
                                                                            v1183 = v1182;
                                                                        } else {
                                                                            v1183 = false;
                                                                        }
                                                                        bool v1184;
                                                                        v1184 = v1183 == false;
                                                                        if (v1184){
                                                                            assert("Index must be in range." && v1183);
                                                                        } else {
                                                                        }
                                                                        unsigned char v1186;
                                                                        v1186 = v1155[v1179];
                                                                        int v1188;
                                                                        v1188 = 2 + v1179;
                                                                        v1168[v1188] = v1186;
                                                                        v1179 += 1 ;
                                                                    }
                                                                    int v1189;
                                                                    v1189 = 0;
                                                                    while (while_method_6(v1189)){
                                                                        bool v1191;
                                                                        v1191 = 0 <= v1189;
                                                                        bool v1193;
                                                                        if (v1191){
                                                                            bool v1192;
                                                                            v1192 = v1189 < 1;
                                                                            v1193 = v1192;
                                                                        } else {
                                                                            v1193 = false;
                                                                        }
                                                                        bool v1194;
                                                                        v1194 = v1193 == false;
                                                                        if (v1194){
                                                                            assert("Index must be in range." && v1193);
                                                                        } else {
                                                                        }
                                                                        unsigned char v1196;
                                                                        v1196 = v1157[v1189];
                                                                        int v1198;
                                                                        v1198 = 4 + v1189;
                                                                        v1168[v1198] = v1196;
                                                                        v1189 += 1 ;
                                                                    }
                                                                    v1205 = Union12{Union12_1{v1168}};
                                                                    break;
                                                                }
                                                                default: {
                                                                    assert("Invalid tag." && false); __trap();
                                                                }
                                                            }
                                                            break;
                                                        }
                                                        default: {
                                                            assert("Invalid tag." && false); __trap();
                                                        }
                                                    }
                                                    switch (v1205.tag) {
                                                        case 0: { // None
                                                            static_array<unsigned char,2> v1207;
                                                            static_array<unsigned char,5> v1209;
                                                            int v1211; int v1212; int v1213; unsigned char v1214;
                                                            Tuple22 tmp78 = Tuple22{0, 0, 0, 12u};
                                                            v1211 = tmp78.v0; v1212 = tmp78.v1; v1213 = tmp78.v2; v1214 = tmp78.v3;
                                                            while (while_method_19(v1211)){
                                                                bool v1216;
                                                                v1216 = 0 <= v1211;
                                                                bool v1218;
                                                                if (v1216){
                                                                    bool v1217;
                                                                    v1217 = v1211 < 7;
                                                                    v1218 = v1217;
                                                                } else {
                                                                    v1218 = false;
                                                                }
                                                                bool v1219;
                                                                v1219 = v1218 == false;
                                                                if (v1219){
                                                                    assert("Index must be in range." && v1218);
                                                                } else {
                                                                }
                                                                unsigned char v1221;
                                                                v1221 = v129[v1211];
                                                                bool v1223;
                                                                v1223 = v1213 < 2;
                                                                int v1231; int v1232; unsigned char v1233;
                                                                if (v1223){
                                                                    unsigned char v1224;
                                                                    v1224 = v1221 / 4u;
                                                                    bool v1225;
                                                                    v1225 = v1214 == v1224;
                                                                    int v1226;
                                                                    if (v1225){
                                                                        v1226 = v1213;
                                                                    } else {
                                                                        v1226 = 0;
                                                                    }
                                                                    v1207[v1226] = v1221;
                                                                    int v1227;
                                                                    v1227 = v1226 + 1;
                                                                    v1231 = v1211; v1232 = v1227; v1233 = v1224;
                                                                } else {
                                                                    break;
                                                                }
                                                                v1212 = v1231;
                                                                v1213 = v1232;
                                                                v1214 = v1233;
                                                                v1211 += 1 ;
                                                            }
                                                            bool v1234;
                                                            v1234 = v1213 == 2;
                                                            Union16 v1250;
                                                            if (v1234){
                                                                int v1235;
                                                                v1235 = 0;
                                                                while (while_method_2(v1235)){
                                                                    int v1237;
                                                                    v1237 = v1212 + -1;
                                                                    bool v1238;
                                                                    v1238 = v1235 < v1237;
                                                                    int v1239;
                                                                    if (v1238){
                                                                        v1239 = 0;
                                                                    } else {
                                                                        v1239 = 2;
                                                                    }
                                                                    int v1240;
                                                                    v1240 = v1239 + v1235;
                                                                    bool v1241;
                                                                    v1241 = 0 <= v1240;
                                                                    bool v1243;
                                                                    if (v1241){
                                                                        bool v1242;
                                                                        v1242 = v1240 < 7;
                                                                        v1243 = v1242;
                                                                    } else {
                                                                        v1243 = false;
                                                                    }
                                                                    bool v1244;
                                                                    v1244 = v1243 == false;
                                                                    if (v1244){
                                                                        assert("Index must be in range." && v1243);
                                                                    } else {
                                                                    }
                                                                    unsigned char v1246;
                                                                    v1246 = v129[v1240];
                                                                    v1209[v1235] = v1246;
                                                                    v1235 += 1 ;
                                                                }
                                                                v1250 = Union16{Union16_1{v1207, v1209}};
                                                            } else {
                                                                v1250 = Union16{Union16_0{}};
                                                            }
                                                            Union12 v1288;
                                                            switch (v1250.tag) {
                                                                case 0: { // None
                                                                    v1288 = Union12{Union12_0{}};
                                                                    break;
                                                                }
                                                                case 1: { // Some
                                                                    static_array<unsigned char,2> v1251 = v1250.case1.v0; static_array<unsigned char,5> v1252 = v1250.case1.v1;
                                                                    static_array<unsigned char,3> v1253;
                                                                    int v1255;
                                                                    v1255 = 0;
                                                                    while (while_method_1(v1255)){
                                                                        bool v1257;
                                                                        v1257 = 0 <= v1255;
                                                                        bool v1259;
                                                                        if (v1257){
                                                                            bool v1258;
                                                                            v1258 = v1255 < 5;
                                                                            v1259 = v1258;
                                                                        } else {
                                                                            v1259 = false;
                                                                        }
                                                                        bool v1260;
                                                                        v1260 = v1259 == false;
                                                                        if (v1260){
                                                                            assert("Index must be in range." && v1259);
                                                                        } else {
                                                                        }
                                                                        unsigned char v1262;
                                                                        v1262 = v1252[v1255];
                                                                        v1253[v1255] = v1262;
                                                                        v1255 += 1 ;
                                                                    }
                                                                    static_array<unsigned char,5> v1264;
                                                                    int v1266;
                                                                    v1266 = 0;
                                                                    while (while_method_0(v1266)){
                                                                        bool v1268;
                                                                        v1268 = 0 <= v1266;
                                                                        bool v1270;
                                                                        if (v1268){
                                                                            bool v1269;
                                                                            v1269 = v1266 < 2;
                                                                            v1270 = v1269;
                                                                        } else {
                                                                            v1270 = false;
                                                                        }
                                                                        bool v1271;
                                                                        v1271 = v1270 == false;
                                                                        if (v1271){
                                                                            assert("Index must be in range." && v1270);
                                                                        } else {
                                                                        }
                                                                        unsigned char v1273;
                                                                        v1273 = v1251[v1266];
                                                                        v1264[v1266] = v1273;
                                                                        v1266 += 1 ;
                                                                    }
                                                                    int v1275;
                                                                    v1275 = 0;
                                                                    while (while_method_1(v1275)){
                                                                        bool v1277;
                                                                        v1277 = 0 <= v1275;
                                                                        bool v1279;
                                                                        if (v1277){
                                                                            bool v1278;
                                                                            v1278 = v1275 < 3;
                                                                            v1279 = v1278;
                                                                        } else {
                                                                            v1279 = false;
                                                                        }
                                                                        bool v1280;
                                                                        v1280 = v1279 == false;
                                                                        if (v1280){
                                                                            assert("Index must be in range." && v1279);
                                                                        } else {
                                                                        }
                                                                        unsigned char v1282;
                                                                        v1282 = v1253[v1275];
                                                                        int v1284;
                                                                        v1284 = 2 + v1275;
                                                                        v1264[v1284] = v1282;
                                                                        v1275 += 1 ;
                                                                    }
                                                                    v1288 = Union12{Union12_1{v1264}};
                                                                    break;
                                                                }
                                                                default: {
                                                                    assert("Invalid tag." && false); __trap();
                                                                }
                                                            }
                                                            switch (v1288.tag) {
                                                                case 0: { // None
                                                                    static_array<unsigned char,5> v1290;
                                                                    int v1292;
                                                                    v1292 = 0;
                                                                    while (while_method_2(v1292)){
                                                                        bool v1294;
                                                                        v1294 = 0 <= v1292;
                                                                        bool v1296;
                                                                        if (v1294){
                                                                            bool v1295;
                                                                            v1295 = v1292 < 7;
                                                                            v1296 = v1295;
                                                                        } else {
                                                                            v1296 = false;
                                                                        }
                                                                        bool v1297;
                                                                        v1297 = v1296 == false;
                                                                        if (v1297){
                                                                            assert("Index must be in range." && v1296);
                                                                        } else {
                                                                        }
                                                                        unsigned char v1299;
                                                                        v1299 = v129[v1292];
                                                                        v1290[v1292] = v1299;
                                                                        v1292 += 1 ;
                                                                    }
                                                                    v1331 = v1290; v1332 = 0;
                                                                    break;
                                                                }
                                                                case 1: { // Some
                                                                    static_array<unsigned char,5> v1289 = v1288.case1.v0;
                                                                    v1331 = v1289; v1332 = 1;
                                                                    break;
                                                                }
                                                                default: {
                                                                    assert("Invalid tag." && false); __trap();
                                                                }
                                                            }
                                                            break;
                                                        }
                                                        case 1: { // Some
                                                            static_array<unsigned char,5> v1206 = v1205.case1.v0;
                                                            v1331 = v1206; v1332 = 2;
                                                            break;
                                                        }
                                                        default: {
                                                            assert("Invalid tag." && false); __trap();
                                                        }
                                                    }
                                                    break;
                                                }
                                                case 1: { // Some
                                                    static_array<unsigned char,5> v1064 = v1063.case1.v0;
                                                    v1331 = v1064; v1332 = 3;
                                                    break;
                                                }
                                                default: {
                                                    assert("Invalid tag." && false); __trap();
                                                }
                                            }
                                            break;
                                        }
                                        case 1: { // Some
                                            static_array<unsigned char,5> v981 = v980.case1.v0;
                                            v1331 = v981; v1332 = 4;
                                            break;
                                        }
                                        default: {
                                            assert("Invalid tag." && false); __trap();
                                        }
                                    }
                                    break;
                                }
                                case 1: { // Some
                                    static_array<unsigned char,5> v937 = v936.case1.v0;
                                    v1331 = v937; v1332 = 5;
                                    break;
                                }
                                default: {
                                    assert("Invalid tag." && false); __trap();
                                }
                            }
                            break;
                        }
                        case 1: { // Some
                            static_array<unsigned char,5> v737 = v736.case1.v0;
                            v1331 = v737; v1332 = 6;
                            break;
                        }
                        default: {
                            assert("Invalid tag." && false); __trap();
                        }
                    }
                    break;
                }
                case 1: { // Some
                    static_array<unsigned char,5> v616 = v615.case1.v0;
                    v1331 = v616; v1332 = 7;
                    break;
                }
                default: {
                    assert("Invalid tag." && false); __trap();
                }
            }
            break;
        }
        case 1: { // Some
            static_array<unsigned char,5> v533 = v532.case1.v0;
            v1331 = v533; v1332 = 8;
            break;
        }
        default: {
            assert("Invalid tag." && false); __trap();
        }
    }
    return Tuple0{v1331, v1332};
}
__device__ void play_loop_31(unsigned char * v0, unsigned char * v1, unsigned char * v2, StackMut0 & v3, Union4 v4){
    static_array_list<Union6,128> & v5 = v3.v2;
    unsigned long long & v6 = v3.v0;
    Union3 v7;
    v7 = Union3{Union3_1{v4}};
    Union3 v8;
    v8 = v7;
    while (while_method_5(v8)){
        Union3 v2401;
        switch (v8.tag) {
            case 0: { // None
                v2401 = Union3{Union3_0{}};
                break;
            }
            case 1: { // Some
                Union4 v10 = v8.case1.v0;
                switch (v10.tag) {
                    case 0: { // G_Flop
                        int v2259 = v10.case0.v0; static_array<static_array<unsigned char,2>,2> v2260 = v10.case0.v1; static_array<int,2> v2261 = v10.case0.v2; int v2262 = v10.case0.v3; static_array<int,2> v2263 = v10.case0.v4; Union5 v2264 = v10.case0.v5;
                        curandStatePhilox4_32_10_t & v2265 = v3.v4;
                        curandStatePhilox4_32_10_t & v2266 = v2265;
                        static_array<unsigned char,3> v2267; unsigned long long v2268;
                        Tuple8 tmp18 = draw_cards_32(v2266, v6);
                        v2267 = tmp18.v0; v2268 = tmp18.v1;
                        v3.v0 = v2268;
                        static_array_list<unsigned char,5> v2269;
                        v2269 = get_community_cards_35(v2264, v2267);
                        Union6 v2270;
                        v2270 = Union6{Union6_0{v2269}};
                        v5.push(v2270);
                        Union5 v2273;
                        switch (v2264.tag) {
                            case 1: { // Preflop
                                v2273 = Union5{Union5_0{v2267}};
                                break;
                            }
                            default: {
                                printf("%s\n", "Invalid street in flop.");
                                __trap();
                            }
                        }
                        int v2274;
                        v2274 = 2;
                        int v2275;
                        v2275 = 0;
                        Union4 v2276;
                        v2276 = try_round_36(v2274, v2260, v2261, v2275, v2263, v2273);
                        v2401 = Union3{Union3_1{v2276}};
                        break;
                    }
                    case 1: { // G_Fold
                        int v11 = v10.case1.v0; static_array<static_array<unsigned char,2>,2> v12 = v10.case1.v1; static_array<int,2> v13 = v10.case1.v2; int v14 = v10.case1.v3; static_array<int,2> v15 = v10.case1.v4; Union5 v16 = v10.case1.v5;
                        int v17;
                        v17 = v14 % 2;
                        bool v18;
                        v18 = 0 <= v17;
                        bool v20;
                        if (v18){
                            bool v19;
                            v19 = v17 < 2;
                            v20 = v19;
                        } else {
                            v20 = false;
                        }
                        bool v21;
                        v21 = v20 == false;
                        if (v21){
                            assert("Index must be in range." && v20);
                        } else {
                        }
                        int v23;
                        v23 = v13[v17];
                        int v25;
                        v25 = v14 + 1;
                        int v26;
                        v26 = v25 % 2;
                        Union6 v27;
                        v27 = Union6{Union6_1{v23, v26}};
                        v5.push(v27);
                        Union7 v28;
                        v28 = Union7{Union7_1{v11, v12, v13, v14, v15, v16}};
                        v3.v5 = v28;
                        Union3 v29;
                        v29 = Union3{Union3_0{}};
                        v3.v1 = v29;
                        v2401 = Union3{Union3_0{}};
                        break;
                    }
                    case 2: { // G_Preflop
                        curandStatePhilox4_32_10_t & v2360 = v3.v4;
                        curandStatePhilox4_32_10_t & v2361 = v2360;
                        static_array<unsigned char,2> v2362; unsigned long long v2363;
                        Tuple11 tmp23 = draw_cards_39(v2361, v6);
                        v2362 = tmp23.v0; v2363 = tmp23.v1;
                        v3.v0 = v2363;
                        curandStatePhilox4_32_10_t & v2364 = v3.v4;
                        curandStatePhilox4_32_10_t & v2365 = v2364;
                        static_array<unsigned char,2> v2366; unsigned long long v2367;
                        Tuple11 tmp24 = draw_cards_39(v2365, v6);
                        v2366 = tmp24.v0; v2367 = tmp24.v1;
                        v3.v0 = v2367;
                        Union6 v2368;
                        v2368 = Union6{Union6_3{0, v2362}};
                        v5.push(v2368);
                        Union6 v2369;
                        v2369 = Union6{Union6_3{1, v2366}};
                        v5.push(v2369);
                        static_array<static_array<unsigned char,2>,2> v2370;
                        v2370[0] = v2362;
                        v2370[1] = v2366;
                        static_array<int,2> v2372;
                        v2372[0] = 2;
                        v2372[1] = 1;
                        static_array<int,2> v2374;
                        int v2376;
                        v2376 = 0;
                        while (while_method_0(v2376)){
                            bool v2378;
                            v2378 = 0 <= v2376;
                            bool v2380;
                            if (v2378){
                                bool v2379;
                                v2379 = v2376 < 2;
                                v2380 = v2379;
                            } else {
                                v2380 = false;
                            }
                            bool v2381;
                            v2381 = v2380 == false;
                            if (v2381){
                                assert("Index must be in range." && v2380);
                            } else {
                            }
                            int v2383;
                            v2383 = v2372[v2376];
                            int v2385;
                            v2385 = 100 - v2383;
                            v2374[v2376] = v2385;
                            v2376 += 1 ;
                        }
                        int v2386;
                        v2386 = 2;
                        int v2387;
                        v2387 = 0;
                        Union5 v2388;
                        v2388 = Union5{Union5_1{}};
                        Union4 v2389;
                        v2389 = try_round_36(v2386, v2370, v2372, v2387, v2374, v2388);
                        v2401 = Union3{Union3_1{v2389}};
                        break;
                    }
                    case 3: { // G_River
                        int v2319 = v10.case3.v0; static_array<static_array<unsigned char,2>,2> v2320 = v10.case3.v1; static_array<int,2> v2321 = v10.case3.v2; int v2322 = v10.case3.v3; static_array<int,2> v2323 = v10.case3.v4; Union5 v2324 = v10.case3.v5;
                        curandStatePhilox4_32_10_t & v2325 = v3.v4;
                        curandStatePhilox4_32_10_t & v2326 = v2325;
                        static_array<unsigned char,1> v2327; unsigned long long v2328;
                        Tuple12 tmp27 = draw_cards_40(v2326, v6);
                        v2327 = tmp27.v0; v2328 = tmp27.v1;
                        v3.v0 = v2328;
                        static_array_list<unsigned char,5> v2329;
                        v2329 = get_community_cards_41(v2324, v2327);
                        Union6 v2330;
                        v2330 = Union6{Union6_0{v2329}};
                        v5.push(v2330);
                        Union5 v2355;
                        switch (v2324.tag) {
                            case 3: { // Turn
                                static_array<unsigned char,4> v2331 = v2324.case3.v0;
                                static_array<unsigned char,5> v2332;
                                int v2334;
                                v2334 = 0;
                                while (while_method_3(v2334)){
                                    bool v2336;
                                    v2336 = 0 <= v2334;
                                    bool v2338;
                                    if (v2336){
                                        bool v2337;
                                        v2337 = v2334 < 4;
                                        v2338 = v2337;
                                    } else {
                                        v2338 = false;
                                    }
                                    bool v2339;
                                    v2339 = v2338 == false;
                                    if (v2339){
                                        assert("Index must be in range." && v2338);
                                    } else {
                                    }
                                    unsigned char v2341;
                                    v2341 = v2331[v2334];
                                    v2332[v2334] = v2341;
                                    v2334 += 1 ;
                                }
                                int v2343;
                                v2343 = 0;
                                while (while_method_6(v2343)){
                                    bool v2345;
                                    v2345 = 0 <= v2343;
                                    bool v2347;
                                    if (v2345){
                                        bool v2346;
                                        v2346 = v2343 < 1;
                                        v2347 = v2346;
                                    } else {
                                        v2347 = false;
                                    }
                                    bool v2348;
                                    v2348 = v2347 == false;
                                    if (v2348){
                                        assert("Index must be in range." && v2347);
                                    } else {
                                    }
                                    unsigned char v2350;
                                    v2350 = v2327[v2343];
                                    int v2352;
                                    v2352 = 4 + v2343;
                                    v2332[v2352] = v2350;
                                    v2343 += 1 ;
                                }
                                v2355 = Union5{Union5_2{v2332}};
                                break;
                            }
                            default: {
                                printf("%s\n", "Invalid street in river.");
                                __trap();
                            }
                        }
                        int v2356;
                        v2356 = 2;
                        int v2357;
                        v2357 = 0;
                        Union4 v2358;
                        v2358 = try_round_36(v2356, v2320, v2321, v2357, v2323, v2355);
                        v2401 = Union3{Union3_1{v2358}};
                        break;
                    }
                    case 4: { // G_Round
                        int v145 = v10.case4.v0; static_array<static_array<unsigned char,2>,2> v146 = v10.case4.v1; static_array<int,2> v147 = v10.case4.v2; int v148 = v10.case4.v3; static_array<int,2> v149 = v10.case4.v4; Union5 v150 = v10.case4.v5;
                        int v151;
                        v151 = v148 % 2;
                        static_array<Union2,2> & v152 = v3.v3;
                        bool v153;
                        v153 = 0 <= v151;
                        bool v155;
                        if (v153){
                            bool v154;
                            v154 = v151 < 2;
                            v155 = v154;
                        } else {
                            v155 = false;
                        }
                        bool v156;
                        v156 = v155 == false;
                        if (v156){
                            assert("Index must be in range." && v155);
                        } else {
                        }
                        Union2 v158;
                        v158 = v152[v151];
                        switch (v158.tag) {
                            case 0: { // CallingMachine
                                Union1 v1835;
                                v1835 = Union1{Union1_1{}};
                                Union6 v1836;
                                v1836 = Union6{Union6_2{v151, v1835}};
                                v5.push(v1836);
                                static_array<int,2> v1837;
                                int v1839;
                                v1839 = 0;
                                while (while_method_0(v1839)){
                                    bool v1841;
                                    v1841 = 0 <= v1839;
                                    bool v1843;
                                    if (v1841){
                                        bool v1842;
                                        v1842 = v1839 < 2;
                                        v1843 = v1842;
                                    } else {
                                        v1843 = false;
                                    }
                                    bool v1844;
                                    v1844 = v1843 == false;
                                    if (v1844){
                                        assert("Index must be in range." && v1843);
                                    } else {
                                    }
                                    int v1846;
                                    v1846 = v149[v1839];
                                    bool v1849;
                                    if (v1841){
                                        bool v1848;
                                        v1848 = v1839 < 2;
                                        v1849 = v1848;
                                    } else {
                                        v1849 = false;
                                    }
                                    bool v1850;
                                    v1850 = v1849 == false;
                                    if (v1850){
                                        assert("Index must be in range." && v1849);
                                    } else {
                                    }
                                    int v1852;
                                    v1852 = v147[v1839];
                                    int v1854;
                                    v1854 = v1846 + v1852;
                                    v1837[v1839] = v1854;
                                    v1839 += 1 ;
                                }
                                int v1855;
                                v1855 = v147[0];
                                int v1857; int v1858;
                                Tuple4 tmp28 = Tuple4{1, v1855};
                                v1857 = tmp28.v0; v1858 = tmp28.v1;
                                while (while_method_0(v1857)){
                                    bool v1860;
                                    v1860 = 0 <= v1857;
                                    bool v1862;
                                    if (v1860){
                                        bool v1861;
                                        v1861 = v1857 < 2;
                                        v1862 = v1861;
                                    } else {
                                        v1862 = false;
                                    }
                                    bool v1863;
                                    v1863 = v1862 == false;
                                    if (v1863){
                                        assert("Index must be in range." && v1862);
                                    } else {
                                    }
                                    int v1865;
                                    v1865 = v147[v1857];
                                    bool v1867;
                                    v1867 = v1858 >= v1865;
                                    int v1868;
                                    if (v1867){
                                        v1868 = v1858;
                                    } else {
                                        v1868 = v1865;
                                    }
                                    v1858 = v1868;
                                    v1857 += 1 ;
                                }
                                bool v1870;
                                if (v153){
                                    bool v1869;
                                    v1869 = v151 < 2;
                                    v1870 = v1869;
                                } else {
                                    v1870 = false;
                                }
                                bool v1871;
                                v1871 = v1870 == false;
                                if (v1871){
                                    assert("Index must be in range." && v1870);
                                } else {
                                }
                                int v1873;
                                v1873 = v1837[v151];
                                bool v1875;
                                v1875 = v1858 < v1873;
                                int v1876;
                                if (v1875){
                                    v1876 = v1858;
                                } else {
                                    v1876 = v1873;
                                }
                                static_array<int,2> v1877;
                                int v1879;
                                v1879 = 0;
                                while (while_method_0(v1879)){
                                    bool v1881;
                                    v1881 = 0 <= v1879;
                                    bool v1883;
                                    if (v1881){
                                        bool v1882;
                                        v1882 = v1879 < 2;
                                        v1883 = v1882;
                                    } else {
                                        v1883 = false;
                                    }
                                    bool v1884;
                                    v1884 = v1883 == false;
                                    if (v1884){
                                        assert("Index must be in range." && v1883);
                                    } else {
                                    }
                                    int v1886;
                                    v1886 = v147[v1879];
                                    bool v1888;
                                    v1888 = v151 == v1879;
                                    int v1889;
                                    if (v1888){
                                        v1889 = v1876;
                                    } else {
                                        v1889 = v1886;
                                    }
                                    v1877[v1879] = v1889;
                                    v1879 += 1 ;
                                }
                                static_array<int,2> v1890;
                                int v1892;
                                v1892 = 0;
                                while (while_method_0(v1892)){
                                    bool v1894;
                                    v1894 = 0 <= v1892;
                                    bool v1896;
                                    if (v1894){
                                        bool v1895;
                                        v1895 = v1892 < 2;
                                        v1896 = v1895;
                                    } else {
                                        v1896 = false;
                                    }
                                    bool v1897;
                                    v1897 = v1896 == false;
                                    if (v1897){
                                        assert("Index must be in range." && v1896);
                                    } else {
                                    }
                                    int v1899;
                                    v1899 = v1837[v1892];
                                    bool v1902;
                                    if (v1894){
                                        bool v1901;
                                        v1901 = v1892 < 2;
                                        v1902 = v1901;
                                    } else {
                                        v1902 = false;
                                    }
                                    bool v1903;
                                    v1903 = v1902 == false;
                                    if (v1903){
                                        assert("Index must be in range." && v1902);
                                    } else {
                                    }
                                    int v1905;
                                    v1905 = v1877[v1892];
                                    int v1907;
                                    v1907 = v1899 - v1905;
                                    v1890[v1892] = v1907;
                                    v1892 += 1 ;
                                }
                                bool v1908;
                                v1908 = v151 < 2;
                                Union4 v1912;
                                if (v1908){
                                    int v1909;
                                    v1909 = v148 + 1;
                                    v1912 = try_round_36(v145, v146, v1877, v1909, v1890, v150);
                                } else {
                                    v1912 = go_next_street_38(v145, v146, v1877, v148, v1890, v150);
                                }
                                v2401 = Union3{Union3_1{v1912}};
                                break;
                            }
                            case 1: { // Computer
                                static_array_list<Union6,128> & v160 = v3.v2;
                                curandStatePhilox4_32_10_t & v161 = v3.v4;
                                curandStatePhilox4_32_10_t & v162 = v161;
                                float * v163;
                                v163 = reinterpret_cast<float *>(&v1[114819072ull]);
                                float * v165;
                                v165 = reinterpret_cast<float *>(&v1[0ull]);
                                float * v167;
                                v167 = reinterpret_cast<float *>(&v1[0ull]);
                                int v169;
                                v169 = blockIdx.x;
                                assert("Tensor range check" && 0 <= v169 && v169 < 24);
                                int v170;
                                v170 = 524288 * v169;
                                int v171;
                                v171 = threadIdx.x;
                                int v172;
                                v172 = v171;
                                while (while_method_7(v172)){
                                    bool v174;
                                    v174 = 0 <= v172;
                                    bool v175;
                                    v175 = v174 == false;
                                    if (v175){
                                        assert("The index needs to be zero or positive." && v174);
                                    } else {
                                    }
                                    int v177;
                                    v177 = v172 % 2048;
                                    int v178;
                                    v178 = v172 / 2048;
                                    bool v179;
                                    v179 = v178 < 256;
                                    bool v180;
                                    v180 = v179 == false;
                                    if (v180){
                                        assert("The last element of the projection dimensions needs to be greater than the index remainder." && v179);
                                    } else {
                                    }
                                    assert("Tensor range check" && 0 <= v178 && v178 < 256);
                                    assert("Tensor range check" && 0 <= v177 && v177 < 2048);
                                    int v182;
                                    v182 = v177 + v170;
                                    int v183;
                                    v183 = 2048 * v178;
                                    int v184;
                                    v184 = v183 + v182;
                                    v167[v184] = 0.0f;
                                    v172 += 256 ;
                                }
                                __syncthreads();
                                int v185;
                                v185 = threadIdx.x;
                                assert("Tensor range check" && 0 <= v185 && v185 < 256);
                                int v186;
                                v186 = 2048 * v185;
                                int v187;
                                v187 = v186 + v170;
                                int v188;
                                v188 = v160.length;
                                bool v189;
                                v189 = 128 >= v188;
                                bool v190;
                                v190 = v189 == false;
                                if (v190){
                                    assert("The type level dimension has to equal the value passed at runtime into create." && v189);
                                } else {
                                }
                                static_array_list<Union8,128> v192;
                                v192 = static_array_list<Union8,128>{};
                                v192.unsafe_set_length(v188);
                                int v194;
                                v194 = 0;
                                while (while_method_4(v188, v194)){
                                    Union6 v196;
                                    v196 = v160[v194];
                                    Union8 v202;
                                    switch (v196.tag) {
                                        case 2: { // PlayerAction
                                            int v198 = v196.case2.v0; Union1 v199 = v196.case2.v1;
                                            v202 = Union8{Union8_1{v199}};
                                            break;
                                        }
                                        default: {
                                            v202 = Union8{Union8_0{}};
                                        }
                                    }
                                    v192[v194] = v202;
                                    v194 += 1 ;
                                }
                                static_array<int,2> v203;
                                int v205;
                                v205 = 0;
                                while (while_method_0(v205)){
                                    int v207;
                                    v207 = v205 + v148;
                                    int v208;
                                    v208 = v207 % 2;
                                    bool v209;
                                    v209 = 0 <= v208;
                                    bool v211;
                                    if (v209){
                                        bool v210;
                                        v210 = v208 < 2;
                                        v211 = v210;
                                    } else {
                                        v211 = false;
                                    }
                                    bool v212;
                                    v212 = v211 == false;
                                    if (v212){
                                        assert("Index must be in range." && v211);
                                    } else {
                                    }
                                    int v214;
                                    v214 = v147[v208];
                                    v203[v205] = v214;
                                    v205 += 1 ;
                                }
                                static_array<int,2> v216;
                                int v218;
                                v218 = 0;
                                while (while_method_0(v218)){
                                    int v220;
                                    v220 = v218 + v148;
                                    int v221;
                                    v221 = v220 % 2;
                                    bool v222;
                                    v222 = 0 <= v221;
                                    bool v224;
                                    if (v222){
                                        bool v223;
                                        v223 = v221 < 2;
                                        v224 = v223;
                                    } else {
                                        v224 = false;
                                    }
                                    bool v225;
                                    v225 = v224 == false;
                                    if (v225){
                                        assert("Index must be in range." && v224);
                                    } else {
                                    }
                                    int v227;
                                    v227 = v149[v221];
                                    v216[v218] = v227;
                                    v218 += 1 ;
                                }
                                bool v230;
                                if (v153){
                                    bool v229;
                                    v229 = v151 < 2;
                                    v230 = v229;
                                } else {
                                    v230 = false;
                                }
                                bool v231;
                                v231 = v230 == false;
                                if (v231){
                                    assert("Index must be in range." && v230);
                                } else {
                                }
                                static_array<unsigned char,2> v233;
                                v233 = v146[v151];
                                static_array_list<unsigned char,5> v235;
                                v235 = static_array_list<unsigned char,5>{};
                                switch (v150.tag) {
                                    case 0: { // Flop
                                        static_array<unsigned char,3> v237 = v150.case0.v0;
                                        int v238;
                                        v238 = 0;
                                        while (while_method_1(v238)){
                                            bool v240;
                                            v240 = 0 <= v238;
                                            bool v242;
                                            if (v240){
                                                bool v241;
                                                v241 = v238 < 3;
                                                v242 = v241;
                                            } else {
                                                v242 = false;
                                            }
                                            bool v243;
                                            v243 = v242 == false;
                                            if (v243){
                                                assert("Index must be in range." && v242);
                                            } else {
                                            }
                                            unsigned char v245;
                                            v245 = v237[v238];
                                            v235.push(v245);
                                            v238 += 1 ;
                                        }
                                        break;
                                    }
                                    case 1: { // Preflop
                                        break;
                                    }
                                    case 2: { // River
                                        static_array<unsigned char,5> v257 = v150.case2.v0;
                                        int v258;
                                        v258 = 0;
                                        while (while_method_2(v258)){
                                            bool v260;
                                            v260 = 0 <= v258;
                                            bool v262;
                                            if (v260){
                                                bool v261;
                                                v261 = v258 < 5;
                                                v262 = v261;
                                            } else {
                                                v262 = false;
                                            }
                                            bool v263;
                                            v263 = v262 == false;
                                            if (v263){
                                                assert("Index must be in range." && v262);
                                            } else {
                                            }
                                            unsigned char v265;
                                            v265 = v257[v258];
                                            v235.push(v265);
                                            v258 += 1 ;
                                        }
                                        break;
                                    }
                                    case 3: { // Turn
                                        static_array<unsigned char,4> v247 = v150.case3.v0;
                                        int v248;
                                        v248 = 0;
                                        while (while_method_3(v248)){
                                            bool v250;
                                            v250 = 0 <= v248;
                                            bool v252;
                                            if (v250){
                                                bool v251;
                                                v251 = v248 < 4;
                                                v252 = v251;
                                            } else {
                                                v252 = false;
                                            }
                                            bool v253;
                                            v253 = v252 == false;
                                            if (v253){
                                                assert("Index must be in range." && v252);
                                            } else {
                                            }
                                            unsigned char v255;
                                            v255 = v247[v248];
                                            v235.push(v255);
                                            v248 += 1 ;
                                        }
                                        break;
                                    }
                                    default: {
                                        assert("Invalid tag." && false); __trap();
                                    }
                                }
                                float * v267;
                                v267 = v167+v187;
                                int v269;
                                v269 = v192.length;
                                bool v270;
                                v270 = v269 == 0;
                                if (v270){
                                    v267[0] = 1.0f;
                                } else {
                                }
                                int v271;
                                v271 = v192.length;
                                int v272;
                                v272 = 0;
                                while (while_method_4(v271, v272)){
                                    Union8 v274;
                                    v274 = v192[v272];
                                    int v276;
                                    v276 = v272 * 14;
                                    int v277;
                                    v277 = 1 + v276;
                                    switch (v274.tag) {
                                        case 0: { // None
                                            v267[v277] = 1.0f;
                                            break;
                                        }
                                        case 1: { // Some
                                            Union1 v278 = v274.case1.v0;
                                            int v279;
                                            v279 = v277 + 1;
                                            switch (v278.tag) {
                                                case 0: { // A_All_In
                                                    v267[v279] = 1.0f;
                                                    break;
                                                }
                                                case 1: { // A_Call
                                                    int v280;
                                                    v280 = v279 + 1;
                                                    v267[v280] = 1.0f;
                                                    break;
                                                }
                                                case 2: { // A_Fold
                                                    int v281;
                                                    v281 = v279 + 2;
                                                    v267[v281] = 1.0f;
                                                    break;
                                                }
                                                case 3: { // A_Raise
                                                    int v282 = v278.case3.v0;
                                                    int v283;
                                                    v283 = v279 + 3;
                                                    bool v284;
                                                    v284 = 1 <= v282;
                                                    bool v286;
                                                    if (v284){
                                                        bool v285;
                                                        v285 = v282 < 1023;
                                                        v286 = v285;
                                                    } else {
                                                        v286 = false;
                                                    }
                                                    bool v287;
                                                    v287 = v286 == false;
                                                    if (v287){
                                                        assert("Pickle failure. The input is out of the bounds of the given range." && v286);
                                                    } else {
                                                    }
                                                    int v289;
                                                    v289 = v282 - 1;
                                                    unsigned int v290;
                                                    v290 = (unsigned int)v289;
                                                    method_42(v290, v267, v283);
                                                    break;
                                                }
                                                default: {
                                                    assert("Invalid tag." && false); __trap();
                                                }
                                            }
                                            break;
                                        }
                                        default: {
                                            assert("Invalid tag." && false); __trap();
                                        }
                                    }
                                    v272 += 1 ;
                                }
                                int v291;
                                v291 = 0;
                                while (while_method_0(v291)){
                                    // 222;
                                    bool v293;
                                    v293 = 0 <= v291;
                                    bool v295;
                                    if (v293){
                                        bool v294;
                                        v294 = v291 < 2;
                                        v295 = v294;
                                    } else {
                                        v295 = false;
                                    }
                                    bool v296;
                                    v296 = v295 == false;
                                    if (v296){
                                        assert("Index must be in range." && v295);
                                    } else {
                                    }
                                    int v298;
                                    v298 = v203[v291];
                                    int v300;
                                    v300 = v291 * 11;
                                    int v301;
                                    v301 = 1794 + v300;
                                    bool v302;
                                    v302 = 0 <= v298;
                                    bool v304;
                                    if (v302){
                                        bool v303;
                                        v303 = v298 < 1023;
                                        v304 = v303;
                                    } else {
                                        v304 = false;
                                    }
                                    bool v305;
                                    v305 = v304 == false;
                                    if (v305){
                                        assert("Pickle failure. The input is out of the bounds of the given range." && v304);
                                    } else {
                                    }
                                    unsigned int v307;
                                    v307 = (unsigned int)v298;
                                    method_43(v307, v267, v301);
                                    v291 += 1 ;
                                }
                                int v308;
                                v308 = 0;
                                while (while_method_0(v308)){
                                    // 222;
                                    bool v310;
                                    v310 = 0 <= v308;
                                    bool v312;
                                    if (v310){
                                        bool v311;
                                        v311 = v308 < 2;
                                        v312 = v311;
                                    } else {
                                        v312 = false;
                                    }
                                    bool v313;
                                    v313 = v312 == false;
                                    if (v313){
                                        assert("Index must be in range." && v312);
                                    } else {
                                    }
                                    int v315;
                                    v315 = v216[v308];
                                    int v317;
                                    v317 = v308 * 11;
                                    int v318;
                                    v318 = 1817 + v317;
                                    bool v319;
                                    v319 = 0 <= v315;
                                    bool v321;
                                    if (v319){
                                        bool v320;
                                        v320 = v315 < 1023;
                                        v321 = v320;
                                    } else {
                                        v321 = false;
                                    }
                                    bool v322;
                                    v322 = v321 == false;
                                    if (v322){
                                        assert("Pickle failure. The input is out of the bounds of the given range." && v321);
                                    } else {
                                    }
                                    unsigned int v324;
                                    v324 = (unsigned int)v315;
                                    method_43(v324, v267, v318);
                                    v308 += 1 ;
                                }
                                int v325;
                                v325 = 0;
                                while (while_method_0(v325)){
                                    // 222;
                                    bool v327;
                                    v327 = 0 <= v325;
                                    bool v329;
                                    if (v327){
                                        bool v328;
                                        v328 = v325 < 2;
                                        v329 = v328;
                                    } else {
                                        v329 = false;
                                    }
                                    bool v330;
                                    v330 = v329 == false;
                                    if (v330){
                                        assert("Index must be in range." && v329);
                                    } else {
                                    }
                                    unsigned char v332;
                                    v332 = v233[v325];
                                    int v334;
                                    v334 = v325 * 17;
                                    int v335;
                                    v335 = 1840 + v334;
                                    unsigned char v336;
                                    v336 = v332 % 4u;
                                    int v337;
                                    v337 = (int)v336;
                                    unsigned char v338;
                                    v338 = v332 / 4u;
                                    int v339;
                                    v339 = (int)v338;
                                    unsigned int v340;
                                    v340 = (unsigned int)v337;
                                    int v341;
                                    v341 = (int)v340;
                                    bool v342;
                                    v342 = v341 < 4;
                                    bool v343;
                                    v343 = v342 == false;
                                    if (v343){
                                        assert("Pickle failure. Int value out of bounds." && v342);
                                    } else {
                                    }
                                    int v345;
                                    v345 = v335 + v341;
                                    v267[v345] = 1.0f;
                                    int v346;
                                    v346 = v335 + 4;
                                    unsigned int v347;
                                    v347 = (unsigned int)v339;
                                    int v348;
                                    v348 = (int)v347;
                                    bool v349;
                                    v349 = v348 < 13;
                                    bool v350;
                                    v350 = v349 == false;
                                    if (v350){
                                        assert("Pickle failure. Int value out of bounds." && v349);
                                    } else {
                                    }
                                    int v352;
                                    v352 = v346 + v348;
                                    v267[v352] = 1.0f;
                                    v325 += 1 ;
                                }
                                int v353;
                                v353 = v235.length;
                                bool v354;
                                v354 = v353 == 0;
                                if (v354){
                                    v267[1874] = 1.0f;
                                } else {
                                }
                                int v355;
                                v355 = v235.length;
                                int v356;
                                v356 = 0;
                                while (while_method_4(v355, v356)){
                                    unsigned char v358;
                                    v358 = v235[v356];
                                    int v360;
                                    v360 = v356 * 17;
                                    int v361;
                                    v361 = 1875 + v360;
                                    unsigned char v362;
                                    v362 = v358 % 4u;
                                    int v363;
                                    v363 = (int)v362;
                                    unsigned char v364;
                                    v364 = v358 / 4u;
                                    int v365;
                                    v365 = (int)v364;
                                    unsigned int v366;
                                    v366 = (unsigned int)v363;
                                    int v367;
                                    v367 = (int)v366;
                                    bool v368;
                                    v368 = v367 < 4;
                                    bool v369;
                                    v369 = v368 == false;
                                    if (v369){
                                        assert("Pickle failure. Int value out of bounds." && v368);
                                    } else {
                                    }
                                    int v371;
                                    v371 = v361 + v367;
                                    v267[v371] = 1.0f;
                                    int v372;
                                    v372 = v361 + 4;
                                    unsigned int v373;
                                    v373 = (unsigned int)v365;
                                    int v374;
                                    v374 = (int)v373;
                                    bool v375;
                                    v375 = v374 < 13;
                                    bool v376;
                                    v376 = v375 == false;
                                    if (v376){
                                        assert("Pickle failure. Int value out of bounds." && v375);
                                    } else {
                                    }
                                    int v378;
                                    v378 = v372 + v374;
                                    v267[v378] = 1.0f;
                                    v356 += 1 ;
                                }
                                __syncthreads();
                                int * v379;
                                v379 = reinterpret_cast<int *>(&v0[12845056ull]);
                                bool * v381;
                                v381 = reinterpret_cast<bool *>(&v0[12845072ull]);
                                float * v383;
                                v383 = reinterpret_cast<float *>(&v0[12845088ull]);
                                float * v385;
                                v385 = reinterpret_cast<float *>(&v0[12845104ull]);
                                int v387;
                                v387 = 0;
                                int v388;
                                v388 = 0;
                                while (while_method_3(v388)){
                                    assert("Tensor range check" && 0 <= v388 && v388 < 4);
                                    bool v390;
                                    v390 = v381[v388];
                                    int v392;
                                    if (v390){
                                        int v391;
                                        v391 = v387 + 1;
                                        v392 = v391;
                                    } else {
                                        v392 = v387;
                                    }
                                    v387 = v392;
                                    v388 += 1 ;
                                }
                                int v393;
                                v393 = 0;
                                int v394;
                                v394 = int_range_44(v387, v393, v162);
                                int v395;
                                v395 = 0;
                                int v396;
                                v396 = 0;
                                while (while_method_3(v396)){
                                    assert("Tensor range check" && 0 <= v396 && v396 < 4);
                                    bool v398;
                                    v398 = v381[v396];
                                    if (v398){
                                        bool v399;
                                        v399 = v394 == 0;
                                        if (v399){
                                            v395 = v396;
                                        } else {
                                        }
                                        int v400;
                                        v400 = v394 - 1;
                                        v394 = v400;
                                    } else {
                                    }
                                    v396 += 1 ;
                                }
                                extern __shared__ unsigned char v401[];
                                int * v402;
                                v402 = reinterpret_cast<int *>(&v401[0ull]);
                                int v404;
                                v404 = threadIdx.x;
                                bool v405;
                                v405 = v404 == 0;
                                if (v405){
                                    v402[0] = v395;
                                } else {
                                }
                                __syncthreads();
                                int v406;
                                v406 = v402[0];
                                __syncthreads();
                                float * v407;
                                v407 = reinterpret_cast<float *>(&v1[114819072ull]);
                                assert("Tensor range check" && 0 <= v406 && v406 < 4);
                                int v409;
                                v409 = 393216 * v406;
                                float * v410;
                                v410 = reinterpret_cast<float *>(&v1[106954752ull]);
                                float * v412;
                                v412 = reinterpret_cast<float *>(&v1[94371840ull]);
                                float * v414;
                                v414 = reinterpret_cast<float *>(&v1[81788928ull]);
                                float * v416;
                                v416 = reinterpret_cast<float *>(&v1[69206016ull]);
                                float * v418;
                                v418 = reinterpret_cast<float *>(&v1[56623104ull]);
                                float * v420;
                                v420 = reinterpret_cast<float *>(&v1[0ull]);
                                float * v422;
                                v422 = reinterpret_cast<float *>(&v0[0ull]);
                                float * v424;
                                v424 = reinterpret_cast<float *>(&v2[0ull]);
                                assert("Tensor range check" && 0 <= v406 && v406 < 4);
                                int v426;
                                v426 = 524288 * v406;
                                float * v427;
                                v427 = reinterpret_cast<float *>(&v1[50331648ull]);
                                block_matmul_45(v427, v422, v426, v420);
                                block_map_46(v418, v427);
                                float * v429;
                                v429 = reinterpret_cast<float *>(&v0[8388608ull]);
                                float * v431;
                                v431 = reinterpret_cast<float *>(&v2[8388608ull]);
                                assert("Tensor range check" && 0 <= v406 && v406 < 4);
                                int v433;
                                v433 = 65536 * v406;
                                float * v434;
                                v434 = reinterpret_cast<float *>(&v1[62914560ull]);
                                block_matmul_47(v434, v429, v433, v418);
                                block_map_46(v416, v434);
                                float * v436;
                                v436 = reinterpret_cast<float *>(&v0[9437184ull]);
                                float * v438;
                                v438 = reinterpret_cast<float *>(&v2[9437184ull]);
                                assert("Tensor range check" && 0 <= v406 && v406 < 4);
                                float * v440;
                                v440 = reinterpret_cast<float *>(&v1[75497472ull]);
                                block_matmul_47(v440, v436, v433, v416);
                                block_map_46(v414, v440);
                                float * v442;
                                v442 = reinterpret_cast<float *>(&v0[10485760ull]);
                                float * v444;
                                v444 = reinterpret_cast<float *>(&v2[10485760ull]);
                                assert("Tensor range check" && 0 <= v406 && v406 < 4);
                                float * v446;
                                v446 = reinterpret_cast<float *>(&v1[88080384ull]);
                                block_matmul_47(v446, v442, v433, v414);
                                block_map_46(v412, v446);
                                float * v448;
                                v448 = reinterpret_cast<float *>(&v0[11534336ull]);
                                float * v450;
                                v450 = reinterpret_cast<float *>(&v2[11534336ull]);
                                assert("Tensor range check" && 0 <= v406 && v406 < 4);
                                float * v452;
                                v452 = reinterpret_cast<float *>(&v1[100663296ull]);
                                block_matmul_47(v452, v448, v433, v412);
                                block_map_46(v410, v452);
                                float * v454;
                                v454 = reinterpret_cast<float *>(&v0[12582912ull]);
                                float * v456;
                                v456 = reinterpret_cast<float *>(&v2[12582912ull]);
                                assert("Tensor range check" && 0 <= v406 && v406 < 4);
                                int v458;
                                v458 = 16384 * v406;
                                float * v459;
                                v459 = reinterpret_cast<float *>(&v1[113246208ull]);
                                block_matmul_48(v459, v454, v458, v410);
                                block_row_map_49(v407, v409, v459);
                                int * v461;
                                v461 = reinterpret_cast<int *>(&v0[12845056ull]);
                                bool * v463;
                                v463 = reinterpret_cast<bool *>(&v0[12845072ull]);
                                float * v465;
                                v465 = reinterpret_cast<float *>(&v0[12845088ull]);
                                float * v467;
                                v467 = reinterpret_cast<float *>(&v0[12845104ull]);
                                double * v469;
                                v469 = reinterpret_cast<double *>(&v1[121110528ull]);
                                double * v471;
                                v471 = reinterpret_cast<double *>(&v1[121503744ull]);
                                __syncthreads();
                                float * v473;
                                v473 = reinterpret_cast<float *>(&v1[114819072ull]);
                                assert("Tensor range check" && 0 <= v406 && v406 < 4);
                                int v475;
                                v475 = blockIdx.x;
                                assert("Tensor range check" && 0 <= v475 && v475 < 24);
                                int v476;
                                v476 = 16384 * v475;
                                int v477;
                                v477 = v476 + v409;
                                int v478;
                                v478 = threadIdx.x;
                                assert("Tensor range check" && 0 <= v478 && v478 < 256);
                                int v479;
                                v479 = 64 * v478;
                                int v480;
                                v480 = v479 + v477;
                                float * v481;
                                v481 = v473+v480;
                                int v483;
                                v483 = sizeof(float *);
                                unsigned long long v484;
                                v484 = (unsigned long long)v483;
                                unsigned long long v485;
                                v485 = 256ull * v484;
                                unsigned long long v486;
                                v486 = v485 + 16ull;
                                unsigned long long v487;
                                v487 = v486 - 1ull;
                                unsigned long long v488;
                                v488 = v487 % 16ull;
                                unsigned long long v489;
                                v489 = v487 - v488;
                                unsigned long long v490;
                                v490 = v489 + 1024ull;
                                unsigned long long v491;
                                v491 = v490 + 16ull;
                                unsigned long long v492;
                                v492 = v491 - 1ull;
                                unsigned long long v493;
                                v493 = v492 % 16ull;
                                unsigned long long v494;
                                v494 = v492 - v493;
                                unsigned long long v495;
                                v495 = v494 + 1024ull;
                                bool v496;
                                v496 = v495 <= 98304ull;
                                bool v497;
                                v497 = v496 == false;
                                if (v497){
                                    assert("The dynamic shared memory is insufficient to allocate the tensor." && v496);
                                } else {
                                }
                                extern __shared__ unsigned char v499[];
                                bool v500;
                                v500 = v495 <= v495;
                                bool v501;
                                v501 = v500 == false;
                                if (v501){
                                    assert("The length of the partition has to be less than or equal to the length of the base array." && v500);
                                } else {
                                }
                                float * * v503;
                                v503 = reinterpret_cast<float * *>(&v499[0ull]);
                                float * v505;
                                v505 = reinterpret_cast<float *>(&v499[v489]);
                                int * v507;
                                v507 = reinterpret_cast<int *>(&v499[v494]);
                                int v509;
                                v509 = threadIdx.x;
                                assert("Tensor range check" && 0 <= v509 && v509 < 256);
                                v503[v509] = v481;
                                __syncthreads();
                                bool v510;
                                v510 = 0 <= v509;
                                bool v511;
                                v511 = v510 == false;
                                if (v511){
                                    assert("The index needs to be zero or positive." && v510);
                                } else {
                                }
                                int v513;
                                v513 = v509 % 16;
                                int v514;
                                v514 = v509 / 16;
                                bool v515;
                                v515 = v514 < 16;
                                bool v516;
                                v516 = v515 == false;
                                if (v516){
                                    assert("The last element of the projection dimensions needs to be greater than the index remainder." && v515);
                                } else {
                                }
                                assert("Tensor range check" && 0 <= v514 && v514 < 16);
                                int v518;
                                v518 = 0;
                                while (while_method_12(v518)){
                                    bool v520;
                                    v520 = 0 <= v514;
                                    bool v521;
                                    v521 = v520 && v515;
                                    bool v522;
                                    v522 = v521 == false;
                                    if (v522){
                                        assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v521);
                                    } else {
                                    }
                                    bool v524;
                                    v524 = 0 <= v518;
                                    bool v526;
                                    if (v524){
                                        bool v525;
                                        v525 = v518 < 16;
                                        v526 = v525;
                                    } else {
                                        v526 = false;
                                    }
                                    bool v527;
                                    v527 = v526 == false;
                                    if (v527){
                                        assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v526);
                                    } else {
                                    }
                                    int v529;
                                    v529 = v518 * 16;
                                    int v530;
                                    v530 = v529 + v514;
                                    assert("Tensor range check" && 0 <= v518 && v518 < 16);
                                    int v531;
                                    v531 = 16 * v518;
                                    int v532;
                                    v532 = v531 + v514;
                                    float * v533;
                                    v533 = v503[v532];
                                    int v534;
                                    v534 = blockIdx.x;
                                    int v535;
                                    v535 = v534 * 256;
                                    int v536;
                                    v536 = v535 + v530;
                                    assert("Tensor range check" && 0 <= v513 && v513 < 16);
                                    int v537;
                                    v537 = 4 * v513;
                                    float v538[4];
                                    int v539[4];
                                    int v540;
                                    v540 = 0;
                                    while (while_method_6(v540)){
                                        assert("Tensor range check" && 0 <= v540 && v540 < 1);
                                        int v542;
                                        v542 = 4 * v540;
                                        assert("Tensor range check" && 0 <= v540 && v540 < 1);
                                        int v543;
                                        v543 = 64 * v540;
                                        int v544;
                                        v544 = v543 + v537;
                                        int4* v545;
                                        v545 = reinterpret_cast<int4*>(v533 + v544);
                                        int4* v546;
                                        v546 = reinterpret_cast<int4*>(v538 + v542);
                                        assert("Pointer alignment check" && reinterpret_cast<unsigned long long>(v545) % 16 == 0 && reinterpret_cast<unsigned long long>(v546) % 16 == 0);
                                        *v546 = *v545;
                                        v540 += 1 ;
                                    }
                                    int v547;
                                    v547 = 0;
                                    while (while_method_6(v547)){
                                        int v549;
                                        v549 = 0;
                                        while (while_method_3(v549)){
                                            bool v551;
                                            v551 = 0 <= v549;
                                            bool v553;
                                            if (v551){
                                                bool v552;
                                                v552 = v549 < 4;
                                                v553 = v552;
                                            } else {
                                                v553 = false;
                                            }
                                            bool v554;
                                            v554 = v553 == false;
                                            if (v554){
                                                assert("The indices should be inside the range of the dimension." && v553);
                                            } else {
                                            }
                                            bool v556;
                                            v556 = 0 <= v513;
                                            bool v558;
                                            if (v556){
                                                bool v557;
                                                v557 = v513 < 16;
                                                v558 = v557;
                                            } else {
                                                v558 = false;
                                            }
                                            bool v559;
                                            v559 = v558 == false;
                                            if (v559){
                                                assert("The indices should be inside the range of the dimension." && v558);
                                            } else {
                                            }
                                            int v561;
                                            v561 = v513 * 4;
                                            int v562;
                                            v562 = v549 + v561;
                                            bool v563;
                                            v563 = 0 <= v547;
                                            bool v565;
                                            if (v563){
                                                bool v564;
                                                v564 = v547 < 1;
                                                v565 = v564;
                                            } else {
                                                v565 = false;
                                            }
                                            bool v566;
                                            v566 = v565 == false;
                                            if (v566){
                                                assert("The indices should be inside the range of the dimension." && v565);
                                            } else {
                                            }
                                            int v568;
                                            v568 = v547 * 64;
                                            int v569;
                                            v569 = v562 + v568;
                                            assert("Tensor range check" && 0 <= v547 && v547 < 1);
                                            assert("Tensor range check" && 0 <= v549 && v549 < 4);
                                            int v570;
                                            v570 = 4 * v547;
                                            int v571;
                                            v571 = v570 + v549;
                                            v539[v571] = v569;
                                            v549 += 1 ;
                                        }
                                        v547 += 1 ;
                                    }
                                    float v572[4];
                                    float v573;
                                    v573 = 0.0f;
                                    int v574;
                                    v574 = 0;
                                    while (while_method_6(v574)){
                                        assert("Tensor range check" && 0 <= v574 && v574 < 1);
                                        int v576;
                                        v576 = 4 * v574;
                                        assert("Tensor range check" && 0 <= v574 && v574 < 1);
                                        float v577;
                                        v577 = 0.0f;
                                        int v578;
                                        v578 = 0;
                                        while (while_method_3(v578)){
                                            assert("Tensor range check" && 0 <= v578 && v578 < 4);
                                            int v580;
                                            v580 = v578 + v576;
                                            float v581;
                                            v581 = v538[v580];
                                            float v582;
                                            v582 = v577 + v581;
                                            v577 = v582;
                                            v578 += 1 ;
                                        }
                                        auto v583 = cooperative_groups::coalesced_threads();
                                        int v584;
                                        v584 = threadIdx.x;
                                        int v585;
                                        v585 = v584 / 16;
                                        auto v586 = cooperative_groups::labeled_partition(v583,v585);
                                        Closure2 v587{};
                                        float v588;
                                        v588 = cooperative_groups::inclusive_scan(v586, v577, v587);
                                        float v589;
                                        v589 = v586.shfl_up(v588,1);
                                        bool v590;
                                        v590 = v586.thread_rank() == 0;
                                        float v591;
                                        if (v590){
                                            v591 = 0.0f;
                                        } else {
                                            v591 = v589;
                                        }
                                        float v592;
                                        v592 = v586.shfl(v588,v586.num_threads()-1);
                                        float v593;
                                        v593 = v573 + v591;
                                        float v594;
                                        v594 = v593;
                                        int v595;
                                        v595 = 0;
                                        while (while_method_3(v595)){
                                            assert("Tensor range check" && 0 <= v595 && v595 < 4);
                                            int v597;
                                            v597 = v595 + v576;
                                            float v598;
                                            v598 = v538[v597];
                                            float v599;
                                            v599 = v594 + v598;
                                            assert("Tensor range check" && 0 <= v595 && v595 < 4);
                                            v572[v597] = v599;
                                            v594 = v599;
                                            v595 += 1 ;
                                        }
                                        float v600;
                                        v600 = v573 + v592;
                                        v573 = v600;
                                        v574 += 1 ;
                                    }
                                    float v601[4];
                                    bool v602[4];
                                    int v603;
                                    v603 = 0;
                                    while (while_method_6(v603)){
                                        int v605;
                                        v605 = 0;
                                        while (while_method_3(v605)){
                                            assert("Tensor range check" && 0 <= v603 && v603 < 1);
                                            assert("Tensor range check" && 0 <= v605 && v605 < 4);
                                            int v607;
                                            v607 = 4 * v603;
                                            int v608;
                                            v608 = v607 + v605;
                                            float v609;
                                            v609 = v572[v608];
                                            float v610;
                                            v610 = v538[v608];
                                            bool v611;
                                            v611 = v610 > 0.0f;
                                            assert("Tensor range check" && 0 <= v603 && v603 < 1);
                                            assert("Tensor range check" && 0 <= v605 && v605 < 4);
                                            v601[v608] = v609;
                                            v602[v608] = v611;
                                            v605 += 1 ;
                                        }
                                        v603 += 1 ;
                                    }
                                    float v612; bool v613;
                                    Tuple14 tmp31 = Tuple14{-1.0f / 0.0f, false};
                                    v612 = tmp31.v0; v613 = tmp31.v1;
                                    int v614;
                                    v614 = 0;
                                    while (while_method_6(v614)){
                                        int v616;
                                        v616 = 0;
                                        while (while_method_3(v616)){
                                            assert("Tensor range check" && 0 <= v614 && v614 < 1);
                                            assert("Tensor range check" && 0 <= v616 && v616 < 4);
                                            int v618;
                                            v618 = 4 * v614;
                                            int v619;
                                            v619 = v618 + v616;
                                            float v620;
                                            v620 = v601[v619];
                                            bool v621;
                                            v621 = v602[v619];
                                            float v628; bool v629;
                                            if (v613){
                                                if (v621){
                                                    bool v622;
                                                    v622 = v612 >= v620;
                                                    float v623;
                                                    if (v622){
                                                        v623 = v612;
                                                    } else {
                                                        v623 = v620;
                                                    }
                                                    v628 = v623; v629 = true;
                                                } else {
                                                    v628 = v612; v629 = v613;
                                                }
                                            } else {
                                                if (v621){
                                                    v628 = v620; v629 = v621;
                                                } else {
                                                    v628 = v612; v629 = v613;
                                                }
                                            }
                                            v612 = v628;
                                            v613 = v629;
                                            v616 += 1 ;
                                        }
                                        v614 += 1 ;
                                    }
                                    auto v630 = cooperative_groups::coalesced_threads();
                                    int v631;
                                    v631 = threadIdx.x;
                                    int v632;
                                    v632 = v631 / 16;
                                    auto v633 = cooperative_groups::labeled_partition(v630,v632);
                                    Closure3 v634{};
                                    float v635; bool v636;
                                    Tuple14 tmp32 = cooperative_groups::reduce(v633, Tuple14{v612, v613}, v634);
                                    v635 = tmp32.v0; v636 = tmp32.v1;
                                    bool v637;
                                    v637 = v636 == false;
                                    if (v637){
                                        int v638;
                                        v638 = threadIdx.x;
                                        int v639;
                                        v639 = blockIdx.x;
                                        int v640;
                                        v640 = v639 * 256;
                                        int v641;
                                        v641 = v638 + v640;
                                        cuda::counting_semaphore<cuda::thread_scope_system, 1> & v642 = console_lock;
                                        auto v643 = cooperative_groups::coalesced_threads();
                                        v642.acquire();
                                        int v644;
                                        v644 = 0;
                                        printf("{%s = %d; %s = %c","tid", v641, "x'", '[');
                                        int v645;
                                        v645 = 0;
                                        while (while_method_6(v645)){
                                            int v647;
                                            v647 = v644;
                                            bool v648;
                                            v648 = v647 >= 100;
                                            if (v648){
                                                printf("%s"," ...");
                                                break;
                                            } else {
                                            }
                                            bool v649;
                                            v649 = v645 == 0;
                                            bool v650;
                                            v650 = v649 != true;
                                            if (v650){
                                                printf("%s","; ");
                                            } else {
                                            }
                                            printf("%c",'[');
                                            int v651;
                                            v651 = 0;
                                            while (while_method_3(v651)){
                                                int v653;
                                                v653 = v644;
                                                bool v654;
                                                v654 = v653 >= 100;
                                                if (v654){
                                                    printf("%s"," ...");
                                                    break;
                                                } else {
                                                }
                                                bool v655;
                                                v655 = v651 == 0;
                                                bool v656;
                                                v656 = v655 != true;
                                                if (v656){
                                                    printf("%s","; ");
                                                } else {
                                                }
                                                int v657;
                                                v657 = v644 + 1;
                                                v644 = v657;
                                                int v658;
                                                v658 = v645 * 4;
                                                int v659;
                                                v659 = v658 + v651;
                                                float v660;
                                                v660 = v601[v659];
                                                bool v661;
                                                v661 = v602[v659];
                                                const char * v664;
                                                if (v661){
                                                    const char * v662;
                                                    v662 = "true";
                                                    v664 = v662;
                                                } else {
                                                    const char * v663;
                                                    v663 = "false";
                                                    v664 = v663;
                                                }
                                                printf("%f, %s",v660, v664);
                                                v651 += 1 ;
                                            }
                                            printf("%c",']');
                                            v645 += 1 ;
                                        }
                                        printf("%c",']');
                                        printf("}\n");
                                        v642.release();
                                        v643.sync() ;
                                    } else {
                                    }
                                    if (v637){
                                        assert("The local reduce must be true." && v636);
                                    } else {
                                    }
                                    float v700[4];
                                    int v701[4];
                                    int v702;
                                    v702 = 0;
                                    while (while_method_6(v702)){
                                        int v704;
                                        v704 = 0;
                                        while (while_method_3(v704)){
                                            assert("Tensor range check" && 0 <= v702 && v702 < 1);
                                            assert("Tensor range check" && 0 <= v704 && v704 < 4);
                                            int v706;
                                            v706 = 4 * v702;
                                            int v707;
                                            v707 = v706 + v704;
                                            int v708;
                                            v708 = v539[v707];
                                            float v709;
                                            v709 = curand_uniform(&v162);
                                            assert("Tensor range check" && 0 <= v702 && v702 < 1);
                                            assert("Tensor range check" && 0 <= v704 && v704 < 4);
                                            v700[v707] = v709;
                                            v701[v707] = v708;
                                            v704 += 1 ;
                                        }
                                        v702 += 1 ;
                                    }
                                    float v710; int v711;
                                    Tuple15 tmp33 = Tuple15{0.0f, 2147483647};
                                    v710 = tmp33.v0; v711 = tmp33.v1;
                                    int v712;
                                    v712 = 0;
                                    while (while_method_6(v712)){
                                        int v714;
                                        v714 = 0;
                                        while (while_method_3(v714)){
                                            assert("Tensor range check" && 0 <= v712 && v712 < 1);
                                            assert("Tensor range check" && 0 <= v714 && v714 < 4);
                                            int v716;
                                            v716 = 4 * v712;
                                            int v717;
                                            v717 = v716 + v714;
                                            float v718;
                                            v718 = v700[v717];
                                            int v719;
                                            v719 = v701[v717];
                                            bool v720;
                                            v720 = v711 < v719;
                                            float v721; int v722;
                                            if (v720){
                                                v721 = v710; v722 = v711;
                                            } else {
                                                v721 = v718; v722 = v719;
                                            }
                                            v710 = v721;
                                            v711 = v722;
                                            v714 += 1 ;
                                        }
                                        v712 += 1 ;
                                    }
                                    auto v723 = cooperative_groups::coalesced_threads();
                                    int v724;
                                    v724 = threadIdx.x;
                                    int v725;
                                    v725 = v724 / 16;
                                    auto v726 = cooperative_groups::labeled_partition(v723,v725);
                                    Closure4 v727{};
                                    float v728; int v729;
                                    Tuple15 tmp34 = cooperative_groups::reduce(v726, Tuple15{v710, v711}, v727);
                                    v728 = tmp34.v0; v729 = tmp34.v1;
                                    float v730;
                                    v730 = v635 * v728;
                                    int v731[4];
                                    bool v732[4];
                                    int v733;
                                    v733 = 0;
                                    while (while_method_6(v733)){
                                        int v735;
                                        v735 = 0;
                                        while (while_method_3(v735)){
                                            assert("Tensor range check" && 0 <= v733 && v733 < 1);
                                            assert("Tensor range check" && 0 <= v735 && v735 < 4);
                                            int v737;
                                            v737 = 4 * v733;
                                            int v738;
                                            v738 = v737 + v735;
                                            float v739;
                                            v739 = v601[v738];
                                            bool v740;
                                            v740 = v602[v738];
                                            int v741;
                                            v741 = v539[v738];
                                            int v744; bool v745;
                                            if (v740){
                                                float v742;
                                                v742 = v739 - v730;
                                                bool v743;
                                                v743 = v742 >= 0.0f;
                                                v744 = v741; v745 = v743;
                                            } else {
                                                v744 = 2147483647; v745 = false;
                                            }
                                            assert("Tensor range check" && 0 <= v733 && v733 < 1);
                                            assert("Tensor range check" && 0 <= v735 && v735 < 4);
                                            v731[v738] = v744;
                                            v732[v738] = v745;
                                            v735 += 1 ;
                                        }
                                        v733 += 1 ;
                                    }
                                    int v746; bool v747;
                                    Tuple16 tmp35 = Tuple16{2147483647, false};
                                    v746 = tmp35.v0; v747 = tmp35.v1;
                                    int v748;
                                    v748 = 0;
                                    while (while_method_6(v748)){
                                        int v750;
                                        v750 = 0;
                                        while (while_method_3(v750)){
                                            assert("Tensor range check" && 0 <= v748 && v748 < 1);
                                            assert("Tensor range check" && 0 <= v750 && v750 < 4);
                                            int v752;
                                            v752 = 4 * v748;
                                            int v753;
                                            v753 = v752 + v750;
                                            int v754;
                                            v754 = v731[v753];
                                            bool v755;
                                            v755 = v732[v753];
                                            int v762; bool v763;
                                            if (v747){
                                                if (v755){
                                                    bool v756;
                                                    v756 = v746 < v754;
                                                    int v757;
                                                    if (v756){
                                                        v757 = v746;
                                                    } else {
                                                        v757 = v754;
                                                    }
                                                    v762 = v757; v763 = true;
                                                } else {
                                                    v762 = v746; v763 = v747;
                                                }
                                            } else {
                                                if (v755){
                                                    v762 = v754; v763 = v755;
                                                } else {
                                                    v762 = v746; v763 = v747;
                                                }
                                            }
                                            v746 = v762;
                                            v747 = v763;
                                            v750 += 1 ;
                                        }
                                        v748 += 1 ;
                                    }
                                    auto v764 = cooperative_groups::coalesced_threads();
                                    int v765;
                                    v765 = threadIdx.x;
                                    int v766;
                                    v766 = v765 / 16;
                                    auto v767 = cooperative_groups::labeled_partition(v764,v766);
                                    Closure5 v768{};
                                    int v769; bool v770;
                                    Tuple16 tmp36 = cooperative_groups::reduce(v767, Tuple16{v746, v747}, v768);
                                    v769 = tmp36.v0; v770 = tmp36.v1;
                                    bool v771;
                                    v771 = v770 == false;
                                    if (v771){
                                        int v772;
                                        v772 = threadIdx.x;
                                        int v773;
                                        v773 = blockIdx.x;
                                        int v774;
                                        v774 = v773 * 256;
                                        int v775;
                                        v775 = v772 + v774;
                                        cuda::counting_semaphore<cuda::thread_scope_system, 1> & v776 = console_lock;
                                        auto v777 = cooperative_groups::coalesced_threads();
                                        v776.acquire();
                                        int v778;
                                        v778 = 0;
                                        printf("{%s = %d; %s = %c","tid", v775, "x'", '[');
                                        int v779;
                                        v779 = 0;
                                        while (while_method_6(v779)){
                                            int v781;
                                            v781 = v778;
                                            bool v782;
                                            v782 = v781 >= 100;
                                            if (v782){
                                                printf("%s"," ...");
                                                break;
                                            } else {
                                            }
                                            bool v783;
                                            v783 = v779 == 0;
                                            bool v784;
                                            v784 = v783 != true;
                                            if (v784){
                                                printf("%s","; ");
                                            } else {
                                            }
                                            printf("%c",'[');
                                            int v785;
                                            v785 = 0;
                                            while (while_method_3(v785)){
                                                int v787;
                                                v787 = v778;
                                                bool v788;
                                                v788 = v787 >= 100;
                                                if (v788){
                                                    printf("%s"," ...");
                                                    break;
                                                } else {
                                                }
                                                bool v789;
                                                v789 = v785 == 0;
                                                bool v790;
                                                v790 = v789 != true;
                                                if (v790){
                                                    printf("%s","; ");
                                                } else {
                                                }
                                                int v791;
                                                v791 = v778 + 1;
                                                v778 = v791;
                                                int v792;
                                                v792 = v779 * 4;
                                                int v793;
                                                v793 = v792 + v785;
                                                int v794;
                                                v794 = v731[v793];
                                                bool v795;
                                                v795 = v732[v793];
                                                const char * v798;
                                                if (v795){
                                                    const char * v796;
                                                    v796 = "true";
                                                    v798 = v796;
                                                } else {
                                                    const char * v797;
                                                    v797 = "false";
                                                    v798 = v797;
                                                }
                                                printf("%d, %s",v794, v798);
                                                v785 += 1 ;
                                            }
                                            printf("%c",']');
                                            v779 += 1 ;
                                        }
                                        printf("%c",']');
                                        printf("}\n");
                                        v776.release();
                                        v777.sync() ;
                                    } else {
                                    }
                                    if (v771){
                                        assert("The local reduce must be true." && v770);
                                    } else {
                                    }
                                    float v834; int v835;
                                    Tuple15 tmp37 = Tuple15{0.0f, 2147483647};
                                    v834 = tmp37.v0; v835 = tmp37.v1;
                                    int v836;
                                    v836 = 0;
                                    while (while_method_6(v836)){
                                        int v838;
                                        v838 = 0;
                                        while (while_method_3(v838)){
                                            assert("Tensor range check" && 0 <= v836 && v836 < 1);
                                            assert("Tensor range check" && 0 <= v838 && v838 < 4);
                                            int v840;
                                            v840 = 4 * v836;
                                            int v841;
                                            v841 = v840 + v838;
                                            float v842;
                                            v842 = v538[v841];
                                            int v843;
                                            v843 = v539[v841];
                                            bool v844;
                                            v844 = v835 == v769;
                                            float v848; int v849;
                                            if (v844){
                                                v848 = v834; v849 = v835;
                                            } else {
                                                bool v845;
                                                v845 = v843 == v769;
                                                if (v845){
                                                    v848 = v842; v849 = v843;
                                                } else {
                                                    v848 = v834; v849 = v835;
                                                }
                                            }
                                            v834 = v848;
                                            v835 = v849;
                                            v838 += 1 ;
                                        }
                                        v836 += 1 ;
                                    }
                                    auto v850 = cooperative_groups::coalesced_threads();
                                    int v851;
                                    v851 = threadIdx.x;
                                    int v852;
                                    v852 = v851 / 16;
                                    auto v853 = cooperative_groups::labeled_partition(v850,v852);
                                    Closure6 v854{v769};
                                    float v855; int v856;
                                    Tuple15 tmp38 = cooperative_groups::reduce(v853, Tuple15{v834, v835}, v854);
                                    v855 = tmp38.v0; v856 = tmp38.v1;
                                    bool v857;
                                    v857 = v856 == 2147483647;
                                    bool v858;
                                    v858 = v857 != true;
                                    bool v859;
                                    v859 = v858 == false;
                                    if (v859){
                                        assert("Expected a valid action id in get_prob." && v858);
                                    } else {
                                    }
                                    int v861;
                                    v861 = 0;
                                    while (while_method_6(v861)){
                                        assert("Tensor range check" && 0 <= v861 && v861 < 1);
                                        assert("Tensor range check" && 0 <= v861 && v861 < 1);
                                        v861 += 1 ;
                                    }
                                    assert("Tensor range check" && 0 <= v530 && v530 < 256);
                                    v505[v530] = v855;
                                    v507[v530] = v769;
                                    v518 += 1 ;
                                }
                                __syncthreads();
                                assert("Tensor range check" && 0 <= v509 && v509 < 256);
                                float v863;
                                v863 = v505[v509];
                                int v864;
                                v864 = v507[v509];
                                __syncthreads();
                                bool v865;
                                v865 = 0 == v864;
                                Union10 v874;
                                if (v865){
                                    v874 = Union10{Union10_1{}};
                                } else {
                                    bool v867;
                                    v867 = 1 == v864;
                                    if (v867){
                                        v874 = Union10{Union10_0{}};
                                    } else {
                                        bool v869;
                                        v869 = 2 == v864;
                                        if (v869){
                                            v874 = Union10{Union10_2{1, 1}};
                                        } else {
                                            printf("%s\n", "Invalid output id in the NL Holdem model.");
                                            __trap();
                                        }
                                    }
                                }
                                Union1 v1002;
                                switch (v874.tag) {
                                    case 0: { // AA_Call
                                        v1002 = Union1{Union1_1{}};
                                        break;
                                    }
                                    case 1: { // AA_Fold
                                        int v875;
                                        v875 = v147[0];
                                        int v877; int v878;
                                        Tuple4 tmp39 = Tuple4{1, v875};
                                        v877 = tmp39.v0; v878 = tmp39.v1;
                                        while (while_method_0(v877)){
                                            bool v880;
                                            v880 = 0 <= v877;
                                            bool v882;
                                            if (v880){
                                                bool v881;
                                                v881 = v877 < 2;
                                                v882 = v881;
                                            } else {
                                                v882 = false;
                                            }
                                            bool v883;
                                            v883 = v882 == false;
                                            if (v883){
                                                assert("Index must be in range." && v882);
                                            } else {
                                            }
                                            int v885;
                                            v885 = v147[v877];
                                            bool v887;
                                            v887 = v878 >= v885;
                                            int v888;
                                            if (v887){
                                                v888 = v878;
                                            } else {
                                                v888 = v885;
                                            }
                                            v878 = v888;
                                            v877 += 1 ;
                                        }
                                        bool v890;
                                        if (v153){
                                            bool v889;
                                            v889 = v151 < 2;
                                            v890 = v889;
                                        } else {
                                            v890 = false;
                                        }
                                        bool v891;
                                        v891 = v890 == false;
                                        if (v891){
                                            assert("Index must be in range." && v890);
                                        } else {
                                        }
                                        int v893;
                                        v893 = v147[v151];
                                        bool v895;
                                        v895 = v893 == v878;
                                        if (v895){
                                            v1002 = Union1{Union1_1{}};
                                        } else {
                                            v1002 = Union1{Union1_2{}};
                                        }
                                        break;
                                    }
                                    case 2: { // AA_Raise
                                        int v900 = v874.case2.v0; int v901 = v874.case2.v1;
                                        static_array<int,2> v902;
                                        int v904;
                                        v904 = 0;
                                        while (while_method_0(v904)){
                                            bool v906;
                                            v906 = 0 <= v904;
                                            bool v908;
                                            if (v906){
                                                bool v907;
                                                v907 = v904 < 2;
                                                v908 = v907;
                                            } else {
                                                v908 = false;
                                            }
                                            bool v909;
                                            v909 = v908 == false;
                                            if (v909){
                                                assert("Index must be in range." && v908);
                                            } else {
                                            }
                                            int v911;
                                            v911 = v149[v904];
                                            bool v914;
                                            if (v906){
                                                bool v913;
                                                v913 = v904 < 2;
                                                v914 = v913;
                                            } else {
                                                v914 = false;
                                            }
                                            bool v915;
                                            v915 = v914 == false;
                                            if (v915){
                                                assert("Index must be in range." && v914);
                                            } else {
                                            }
                                            int v917;
                                            v917 = v147[v904];
                                            int v919;
                                            v919 = v911 + v917;
                                            v902[v904] = v919;
                                            v904 += 1 ;
                                        }
                                        int v920;
                                        v920 = v147[0];
                                        int v922; int v923;
                                        Tuple4 tmp40 = Tuple4{1, v920};
                                        v922 = tmp40.v0; v923 = tmp40.v1;
                                        while (while_method_0(v922)){
                                            bool v925;
                                            v925 = 0 <= v922;
                                            bool v927;
                                            if (v925){
                                                bool v926;
                                                v926 = v922 < 2;
                                                v927 = v926;
                                            } else {
                                                v927 = false;
                                            }
                                            bool v928;
                                            v928 = v927 == false;
                                            if (v928){
                                                assert("Index must be in range." && v927);
                                            } else {
                                            }
                                            int v930;
                                            v930 = v147[v922];
                                            bool v932;
                                            v932 = v923 >= v930;
                                            int v933;
                                            if (v932){
                                                v933 = v923;
                                            } else {
                                                v933 = v930;
                                            }
                                            v923 = v933;
                                            v922 += 1 ;
                                        }
                                        bool v935;
                                        if (v153){
                                            bool v934;
                                            v934 = v151 < 2;
                                            v935 = v934;
                                        } else {
                                            v935 = false;
                                        }
                                        bool v936;
                                        v936 = v935 == false;
                                        if (v936){
                                            assert("Index must be in range." && v935);
                                        } else {
                                        }
                                        int v938;
                                        v938 = v902[v151];
                                        bool v940;
                                        v940 = v923 < v938;
                                        int v941;
                                        if (v940){
                                            v941 = v923;
                                        } else {
                                            v941 = v938;
                                        }
                                        static_array<int,2> v942;
                                        int v944;
                                        v944 = 0;
                                        while (while_method_0(v944)){
                                            bool v946;
                                            v946 = 0 <= v944;
                                            bool v948;
                                            if (v946){
                                                bool v947;
                                                v947 = v944 < 2;
                                                v948 = v947;
                                            } else {
                                                v948 = false;
                                            }
                                            bool v949;
                                            v949 = v948 == false;
                                            if (v949){
                                                assert("Index must be in range." && v948);
                                            } else {
                                            }
                                            int v951;
                                            v951 = v147[v944];
                                            bool v953;
                                            v953 = v151 == v944;
                                            int v954;
                                            if (v953){
                                                v954 = v941;
                                            } else {
                                                v954 = v951;
                                            }
                                            v942[v944] = v954;
                                            v944 += 1 ;
                                        }
                                        int v955;
                                        v955 = v942[0];
                                        int v957; int v958;
                                        Tuple4 tmp41 = Tuple4{1, v955};
                                        v957 = tmp41.v0; v958 = tmp41.v1;
                                        while (while_method_0(v957)){
                                            bool v960;
                                            v960 = 0 <= v957;
                                            bool v962;
                                            if (v960){
                                                bool v961;
                                                v961 = v957 < 2;
                                                v962 = v961;
                                            } else {
                                                v962 = false;
                                            }
                                            bool v963;
                                            v963 = v962 == false;
                                            if (v963){
                                                assert("Index must be in range." && v962);
                                            } else {
                                            }
                                            int v965;
                                            v965 = v942[v957];
                                            int v967;
                                            v967 = v958 + v965;
                                            v958 = v967;
                                            v957 += 1 ;
                                        }
                                        static_array<int,2> v968;
                                        int v970;
                                        v970 = 0;
                                        while (while_method_0(v970)){
                                            bool v972;
                                            v972 = 0 <= v970;
                                            bool v974;
                                            if (v972){
                                                bool v973;
                                                v973 = v970 < 2;
                                                v974 = v973;
                                            } else {
                                                v974 = false;
                                            }
                                            bool v975;
                                            v975 = v974 == false;
                                            if (v975){
                                                assert("Index must be in range." && v974);
                                            } else {
                                            }
                                            int v977;
                                            v977 = v902[v970];
                                            bool v980;
                                            if (v972){
                                                bool v979;
                                                v979 = v970 < 2;
                                                v980 = v979;
                                            } else {
                                                v980 = false;
                                            }
                                            bool v981;
                                            v981 = v980 == false;
                                            if (v981){
                                                assert("Index must be in range." && v980);
                                            } else {
                                            }
                                            int v983;
                                            v983 = v942[v970];
                                            int v985;
                                            v985 = v977 - v983;
                                            v968[v970] = v985;
                                            v970 += 1 ;
                                        }
                                        int v986;
                                        v986 = v900 * v958;
                                        int v987;
                                        v987 = v986 / v901;
                                        bool v988;
                                        v988 = v145 >= v987;
                                        int v989;
                                        if (v988){
                                            v989 = v145;
                                        } else {
                                            v989 = v987;
                                        }
                                        bool v991;
                                        if (v153){
                                            bool v990;
                                            v990 = v151 < 2;
                                            v991 = v990;
                                        } else {
                                            v991 = false;
                                        }
                                        bool v992;
                                        v992 = v991 == false;
                                        if (v992){
                                            assert("Index must be in range." && v991);
                                        } else {
                                        }
                                        int v994;
                                        v994 = v968[v151];
                                        bool v996;
                                        v996 = v989 >= v994;
                                        if (v996){
                                            v1002 = Union1{Union1_0{}};
                                        } else {
                                            v1002 = Union1{Union1_3{v989}};
                                        }
                                        break;
                                    }
                                    default: {
                                        assert("Invalid tag." && false); __trap();
                                    }
                                }
                                int v1003;
                                v1003 = sizeof(Union1);
                                unsigned long long v1004;
                                v1004 = (unsigned long long)v1003;
                                bool v1005;
                                v1005 = v1004 <= 98304ull;
                                bool v1006;
                                v1006 = v1005 == false;
                                if (v1006){
                                    assert("The dynamic shared memory is insufficient to allocate the tensor." && v1005);
                                } else {
                                }
                                extern __shared__ unsigned char v1008[];
                                bool v1009;
                                v1009 = v1004 <= v1004;
                                bool v1010;
                                v1010 = v1009 == false;
                                if (v1010){
                                    assert("The length of the partition has to be less than or equal to the length of the base array." && v1009);
                                } else {
                                }
                                Union1 * v1012;
                                v1012 = reinterpret_cast<Union1 *>(&v1008[0ull]);
                                int v1014;
                                v1014 = threadIdx.x;
                                bool v1015;
                                v1015 = v1014 == 0;
                                if (v1015){
                                    v1012[0] = v1002;
                                } else {
                                }
                                __syncthreads();
                                Union1 v1016;
                                v1016 = v1012[0];
                                __syncthreads();
                                Union6 v1017;
                                v1017 = Union6{Union6_2{v151, v1016}};
                                v5.push(v1017);
                                Union4 v1345;
                                switch (v1016.tag) {
                                    case 0: { // A_All_In
                                        static_array<int,2> v1221;
                                        int v1223;
                                        v1223 = 0;
                                        while (while_method_0(v1223)){
                                            bool v1225;
                                            v1225 = 0 <= v1223;
                                            bool v1227;
                                            if (v1225){
                                                bool v1226;
                                                v1226 = v1223 < 2;
                                                v1227 = v1226;
                                            } else {
                                                v1227 = false;
                                            }
                                            bool v1228;
                                            v1228 = v1227 == false;
                                            if (v1228){
                                                assert("Index must be in range." && v1227);
                                            } else {
                                            }
                                            int v1230;
                                            v1230 = v149[v1223];
                                            bool v1233;
                                            if (v1225){
                                                bool v1232;
                                                v1232 = v1223 < 2;
                                                v1233 = v1232;
                                            } else {
                                                v1233 = false;
                                            }
                                            bool v1234;
                                            v1234 = v1233 == false;
                                            if (v1234){
                                                assert("Index must be in range." && v1233);
                                            } else {
                                            }
                                            int v1236;
                                            v1236 = v147[v1223];
                                            int v1238;
                                            v1238 = v1230 + v1236;
                                            v1221[v1223] = v1238;
                                            v1223 += 1 ;
                                        }
                                        int v1239;
                                        v1239 = v147[0];
                                        int v1241; int v1242;
                                        Tuple4 tmp42 = Tuple4{1, v1239};
                                        v1241 = tmp42.v0; v1242 = tmp42.v1;
                                        while (while_method_0(v1241)){
                                            bool v1244;
                                            v1244 = 0 <= v1241;
                                            bool v1246;
                                            if (v1244){
                                                bool v1245;
                                                v1245 = v1241 < 2;
                                                v1246 = v1245;
                                            } else {
                                                v1246 = false;
                                            }
                                            bool v1247;
                                            v1247 = v1246 == false;
                                            if (v1247){
                                                assert("Index must be in range." && v1246);
                                            } else {
                                            }
                                            int v1249;
                                            v1249 = v147[v1241];
                                            bool v1251;
                                            v1251 = v1242 >= v1249;
                                            int v1252;
                                            if (v1251){
                                                v1252 = v1242;
                                            } else {
                                                v1252 = v1249;
                                            }
                                            v1242 = v1252;
                                            v1241 += 1 ;
                                        }
                                        bool v1254;
                                        if (v153){
                                            bool v1253;
                                            v1253 = v151 < 2;
                                            v1254 = v1253;
                                        } else {
                                            v1254 = false;
                                        }
                                        bool v1255;
                                        v1255 = v1254 == false;
                                        if (v1255){
                                            assert("Index must be in range." && v1254);
                                        } else {
                                        }
                                        int v1257;
                                        v1257 = v1221[v151];
                                        bool v1259;
                                        v1259 = v1242 < v1257;
                                        int v1260;
                                        if (v1259){
                                            v1260 = v1242;
                                        } else {
                                            v1260 = v1257;
                                        }
                                        static_array<int,2> v1261;
                                        int v1263;
                                        v1263 = 0;
                                        while (while_method_0(v1263)){
                                            bool v1265;
                                            v1265 = 0 <= v1263;
                                            bool v1267;
                                            if (v1265){
                                                bool v1266;
                                                v1266 = v1263 < 2;
                                                v1267 = v1266;
                                            } else {
                                                v1267 = false;
                                            }
                                            bool v1268;
                                            v1268 = v1267 == false;
                                            if (v1268){
                                                assert("Index must be in range." && v1267);
                                            } else {
                                            }
                                            int v1270;
                                            v1270 = v147[v1263];
                                            bool v1272;
                                            v1272 = v151 == v1263;
                                            int v1273;
                                            if (v1272){
                                                v1273 = v1260;
                                            } else {
                                                v1273 = v1270;
                                            }
                                            v1261[v1263] = v1273;
                                            v1263 += 1 ;
                                        }
                                        static_array<int,2> v1274;
                                        int v1276;
                                        v1276 = 0;
                                        while (while_method_0(v1276)){
                                            bool v1278;
                                            v1278 = 0 <= v1276;
                                            bool v1280;
                                            if (v1278){
                                                bool v1279;
                                                v1279 = v1276 < 2;
                                                v1280 = v1279;
                                            } else {
                                                v1280 = false;
                                            }
                                            bool v1281;
                                            v1281 = v1280 == false;
                                            if (v1281){
                                                assert("Index must be in range." && v1280);
                                            } else {
                                            }
                                            int v1283;
                                            v1283 = v1221[v1276];
                                            bool v1286;
                                            if (v1278){
                                                bool v1285;
                                                v1285 = v1276 < 2;
                                                v1286 = v1285;
                                            } else {
                                                v1286 = false;
                                            }
                                            bool v1287;
                                            v1287 = v1286 == false;
                                            if (v1287){
                                                assert("Index must be in range." && v1286);
                                            } else {
                                            }
                                            int v1289;
                                            v1289 = v1261[v1276];
                                            int v1291;
                                            v1291 = v1283 - v1289;
                                            v1274[v1276] = v1291;
                                            v1276 += 1 ;
                                        }
                                        bool v1293;
                                        if (v153){
                                            bool v1292;
                                            v1292 = v151 < 2;
                                            v1293 = v1292;
                                        } else {
                                            v1293 = false;
                                        }
                                        bool v1294;
                                        v1294 = v1293 == false;
                                        if (v1294){
                                            assert("Index must be in range." && v1293);
                                        } else {
                                        }
                                        int v1296;
                                        v1296 = v1274[v151];
                                        int v1298;
                                        v1298 = v1242 + v1296;
                                        bool v1300;
                                        if (v153){
                                            bool v1299;
                                            v1299 = v151 < 2;
                                            v1300 = v1299;
                                        } else {
                                            v1300 = false;
                                        }
                                        bool v1301;
                                        v1301 = v1300 == false;
                                        if (v1301){
                                            assert("Index must be in range." && v1300);
                                        } else {
                                        }
                                        int v1303;
                                        v1303 = v1221[v151];
                                        bool v1305;
                                        v1305 = v1298 < v1303;
                                        int v1306;
                                        if (v1305){
                                            v1306 = v1298;
                                        } else {
                                            v1306 = v1303;
                                        }
                                        static_array<int,2> v1307;
                                        int v1309;
                                        v1309 = 0;
                                        while (while_method_0(v1309)){
                                            bool v1311;
                                            v1311 = 0 <= v1309;
                                            bool v1313;
                                            if (v1311){
                                                bool v1312;
                                                v1312 = v1309 < 2;
                                                v1313 = v1312;
                                            } else {
                                                v1313 = false;
                                            }
                                            bool v1314;
                                            v1314 = v1313 == false;
                                            if (v1314){
                                                assert("Index must be in range." && v1313);
                                            } else {
                                            }
                                            int v1316;
                                            v1316 = v147[v1309];
                                            bool v1318;
                                            v1318 = v151 == v1309;
                                            int v1319;
                                            if (v1318){
                                                v1319 = v1306;
                                            } else {
                                                v1319 = v1316;
                                            }
                                            v1307[v1309] = v1319;
                                            v1309 += 1 ;
                                        }
                                        static_array<int,2> v1320;
                                        int v1322;
                                        v1322 = 0;
                                        while (while_method_0(v1322)){
                                            bool v1324;
                                            v1324 = 0 <= v1322;
                                            bool v1326;
                                            if (v1324){
                                                bool v1325;
                                                v1325 = v1322 < 2;
                                                v1326 = v1325;
                                            } else {
                                                v1326 = false;
                                            }
                                            bool v1327;
                                            v1327 = v1326 == false;
                                            if (v1327){
                                                assert("Index must be in range." && v1326);
                                            } else {
                                            }
                                            int v1329;
                                            v1329 = v1221[v1322];
                                            bool v1332;
                                            if (v1324){
                                                bool v1331;
                                                v1331 = v1322 < 2;
                                                v1332 = v1331;
                                            } else {
                                                v1332 = false;
                                            }
                                            bool v1333;
                                            v1333 = v1332 == false;
                                            if (v1333){
                                                assert("Index must be in range." && v1332);
                                            } else {
                                            }
                                            int v1335;
                                            v1335 = v1307[v1322];
                                            int v1337;
                                            v1337 = v1329 - v1335;
                                            v1320[v1322] = v1337;
                                            v1322 += 1 ;
                                        }
                                        bool v1338;
                                        v1338 = v1296 >= v145;
                                        int v1339;
                                        if (v1338){
                                            v1339 = v1296;
                                        } else {
                                            v1339 = v145;
                                        }
                                        int v1340;
                                        v1340 = v148 + 1;
                                        v1345 = try_round_36(v1339, v146, v1307, v1340, v1320, v150);
                                        break;
                                    }
                                    case 1: { // A_Call
                                        static_array<int,2> v1019;
                                        int v1021;
                                        v1021 = 0;
                                        while (while_method_0(v1021)){
                                            bool v1023;
                                            v1023 = 0 <= v1021;
                                            bool v1025;
                                            if (v1023){
                                                bool v1024;
                                                v1024 = v1021 < 2;
                                                v1025 = v1024;
                                            } else {
                                                v1025 = false;
                                            }
                                            bool v1026;
                                            v1026 = v1025 == false;
                                            if (v1026){
                                                assert("Index must be in range." && v1025);
                                            } else {
                                            }
                                            int v1028;
                                            v1028 = v149[v1021];
                                            bool v1031;
                                            if (v1023){
                                                bool v1030;
                                                v1030 = v1021 < 2;
                                                v1031 = v1030;
                                            } else {
                                                v1031 = false;
                                            }
                                            bool v1032;
                                            v1032 = v1031 == false;
                                            if (v1032){
                                                assert("Index must be in range." && v1031);
                                            } else {
                                            }
                                            int v1034;
                                            v1034 = v147[v1021];
                                            int v1036;
                                            v1036 = v1028 + v1034;
                                            v1019[v1021] = v1036;
                                            v1021 += 1 ;
                                        }
                                        int v1037;
                                        v1037 = v147[0];
                                        int v1039; int v1040;
                                        Tuple4 tmp43 = Tuple4{1, v1037};
                                        v1039 = tmp43.v0; v1040 = tmp43.v1;
                                        while (while_method_0(v1039)){
                                            bool v1042;
                                            v1042 = 0 <= v1039;
                                            bool v1044;
                                            if (v1042){
                                                bool v1043;
                                                v1043 = v1039 < 2;
                                                v1044 = v1043;
                                            } else {
                                                v1044 = false;
                                            }
                                            bool v1045;
                                            v1045 = v1044 == false;
                                            if (v1045){
                                                assert("Index must be in range." && v1044);
                                            } else {
                                            }
                                            int v1047;
                                            v1047 = v147[v1039];
                                            bool v1049;
                                            v1049 = v1040 >= v1047;
                                            int v1050;
                                            if (v1049){
                                                v1050 = v1040;
                                            } else {
                                                v1050 = v1047;
                                            }
                                            v1040 = v1050;
                                            v1039 += 1 ;
                                        }
                                        bool v1052;
                                        if (v153){
                                            bool v1051;
                                            v1051 = v151 < 2;
                                            v1052 = v1051;
                                        } else {
                                            v1052 = false;
                                        }
                                        bool v1053;
                                        v1053 = v1052 == false;
                                        if (v1053){
                                            assert("Index must be in range." && v1052);
                                        } else {
                                        }
                                        int v1055;
                                        v1055 = v1019[v151];
                                        bool v1057;
                                        v1057 = v1040 < v1055;
                                        int v1058;
                                        if (v1057){
                                            v1058 = v1040;
                                        } else {
                                            v1058 = v1055;
                                        }
                                        static_array<int,2> v1059;
                                        int v1061;
                                        v1061 = 0;
                                        while (while_method_0(v1061)){
                                            bool v1063;
                                            v1063 = 0 <= v1061;
                                            bool v1065;
                                            if (v1063){
                                                bool v1064;
                                                v1064 = v1061 < 2;
                                                v1065 = v1064;
                                            } else {
                                                v1065 = false;
                                            }
                                            bool v1066;
                                            v1066 = v1065 == false;
                                            if (v1066){
                                                assert("Index must be in range." && v1065);
                                            } else {
                                            }
                                            int v1068;
                                            v1068 = v147[v1061];
                                            bool v1070;
                                            v1070 = v151 == v1061;
                                            int v1071;
                                            if (v1070){
                                                v1071 = v1058;
                                            } else {
                                                v1071 = v1068;
                                            }
                                            v1059[v1061] = v1071;
                                            v1061 += 1 ;
                                        }
                                        static_array<int,2> v1072;
                                        int v1074;
                                        v1074 = 0;
                                        while (while_method_0(v1074)){
                                            bool v1076;
                                            v1076 = 0 <= v1074;
                                            bool v1078;
                                            if (v1076){
                                                bool v1077;
                                                v1077 = v1074 < 2;
                                                v1078 = v1077;
                                            } else {
                                                v1078 = false;
                                            }
                                            bool v1079;
                                            v1079 = v1078 == false;
                                            if (v1079){
                                                assert("Index must be in range." && v1078);
                                            } else {
                                            }
                                            int v1081;
                                            v1081 = v1019[v1074];
                                            bool v1084;
                                            if (v1076){
                                                bool v1083;
                                                v1083 = v1074 < 2;
                                                v1084 = v1083;
                                            } else {
                                                v1084 = false;
                                            }
                                            bool v1085;
                                            v1085 = v1084 == false;
                                            if (v1085){
                                                assert("Index must be in range." && v1084);
                                            } else {
                                            }
                                            int v1087;
                                            v1087 = v1059[v1074];
                                            int v1089;
                                            v1089 = v1081 - v1087;
                                            v1072[v1074] = v1089;
                                            v1074 += 1 ;
                                        }
                                        bool v1090;
                                        v1090 = v151 < 2;
                                        if (v1090){
                                            int v1091;
                                            v1091 = v148 + 1;
                                            v1345 = try_round_36(v145, v146, v1059, v1091, v1072, v150);
                                        } else {
                                            v1345 = go_next_street_38(v145, v146, v1059, v148, v1072, v150);
                                        }
                                        break;
                                    }
                                    case 2: { // A_Fold
                                        v1345 = Union4{Union4_1{v145, v146, v147, v148, v149, v150}};
                                        break;
                                    }
                                    case 3: { // A_Raise
                                        int v1095 = v1016.case3.v0;
                                        bool v1096;
                                        v1096 = v145 <= v1095;
                                        bool v1097;
                                        v1097 = v1096 == false;
                                        if (v1097){
                                            assert("The raise amount must match the minimum." && v1096);
                                        } else {
                                        }
                                        static_array<int,2> v1099;
                                        int v1101;
                                        v1101 = 0;
                                        while (while_method_0(v1101)){
                                            bool v1103;
                                            v1103 = 0 <= v1101;
                                            bool v1105;
                                            if (v1103){
                                                bool v1104;
                                                v1104 = v1101 < 2;
                                                v1105 = v1104;
                                            } else {
                                                v1105 = false;
                                            }
                                            bool v1106;
                                            v1106 = v1105 == false;
                                            if (v1106){
                                                assert("Index must be in range." && v1105);
                                            } else {
                                            }
                                            int v1108;
                                            v1108 = v149[v1101];
                                            bool v1111;
                                            if (v1103){
                                                bool v1110;
                                                v1110 = v1101 < 2;
                                                v1111 = v1110;
                                            } else {
                                                v1111 = false;
                                            }
                                            bool v1112;
                                            v1112 = v1111 == false;
                                            if (v1112){
                                                assert("Index must be in range." && v1111);
                                            } else {
                                            }
                                            int v1114;
                                            v1114 = v147[v1101];
                                            int v1116;
                                            v1116 = v1108 + v1114;
                                            v1099[v1101] = v1116;
                                            v1101 += 1 ;
                                        }
                                        int v1117;
                                        v1117 = v147[0];
                                        int v1119; int v1120;
                                        Tuple4 tmp44 = Tuple4{1, v1117};
                                        v1119 = tmp44.v0; v1120 = tmp44.v1;
                                        while (while_method_0(v1119)){
                                            bool v1122;
                                            v1122 = 0 <= v1119;
                                            bool v1124;
                                            if (v1122){
                                                bool v1123;
                                                v1123 = v1119 < 2;
                                                v1124 = v1123;
                                            } else {
                                                v1124 = false;
                                            }
                                            bool v1125;
                                            v1125 = v1124 == false;
                                            if (v1125){
                                                assert("Index must be in range." && v1124);
                                            } else {
                                            }
                                            int v1127;
                                            v1127 = v147[v1119];
                                            bool v1129;
                                            v1129 = v1120 >= v1127;
                                            int v1130;
                                            if (v1129){
                                                v1130 = v1120;
                                            } else {
                                                v1130 = v1127;
                                            }
                                            v1120 = v1130;
                                            v1119 += 1 ;
                                        }
                                        bool v1132;
                                        if (v153){
                                            bool v1131;
                                            v1131 = v151 < 2;
                                            v1132 = v1131;
                                        } else {
                                            v1132 = false;
                                        }
                                        bool v1133;
                                        v1133 = v1132 == false;
                                        if (v1133){
                                            assert("Index must be in range." && v1132);
                                        } else {
                                        }
                                        int v1135;
                                        v1135 = v1099[v151];
                                        bool v1137;
                                        v1137 = v1120 < v1135;
                                        int v1138;
                                        if (v1137){
                                            v1138 = v1120;
                                        } else {
                                            v1138 = v1135;
                                        }
                                        static_array<int,2> v1139;
                                        int v1141;
                                        v1141 = 0;
                                        while (while_method_0(v1141)){
                                            bool v1143;
                                            v1143 = 0 <= v1141;
                                            bool v1145;
                                            if (v1143){
                                                bool v1144;
                                                v1144 = v1141 < 2;
                                                v1145 = v1144;
                                            } else {
                                                v1145 = false;
                                            }
                                            bool v1146;
                                            v1146 = v1145 == false;
                                            if (v1146){
                                                assert("Index must be in range." && v1145);
                                            } else {
                                            }
                                            int v1148;
                                            v1148 = v147[v1141];
                                            bool v1150;
                                            v1150 = v151 == v1141;
                                            int v1151;
                                            if (v1150){
                                                v1151 = v1138;
                                            } else {
                                                v1151 = v1148;
                                            }
                                            v1139[v1141] = v1151;
                                            v1141 += 1 ;
                                        }
                                        static_array<int,2> v1152;
                                        int v1154;
                                        v1154 = 0;
                                        while (while_method_0(v1154)){
                                            bool v1156;
                                            v1156 = 0 <= v1154;
                                            bool v1158;
                                            if (v1156){
                                                bool v1157;
                                                v1157 = v1154 < 2;
                                                v1158 = v1157;
                                            } else {
                                                v1158 = false;
                                            }
                                            bool v1159;
                                            v1159 = v1158 == false;
                                            if (v1159){
                                                assert("Index must be in range." && v1158);
                                            } else {
                                            }
                                            int v1161;
                                            v1161 = v1099[v1154];
                                            bool v1164;
                                            if (v1156){
                                                bool v1163;
                                                v1163 = v1154 < 2;
                                                v1164 = v1163;
                                            } else {
                                                v1164 = false;
                                            }
                                            bool v1165;
                                            v1165 = v1164 == false;
                                            if (v1165){
                                                assert("Index must be in range." && v1164);
                                            } else {
                                            }
                                            int v1167;
                                            v1167 = v1139[v1154];
                                            int v1169;
                                            v1169 = v1161 - v1167;
                                            v1152[v1154] = v1169;
                                            v1154 += 1 ;
                                        }
                                        bool v1171;
                                        if (v153){
                                            bool v1170;
                                            v1170 = v151 < 2;
                                            v1171 = v1170;
                                        } else {
                                            v1171 = false;
                                        }
                                        bool v1172;
                                        v1172 = v1171 == false;
                                        if (v1172){
                                            assert("Index must be in range." && v1171);
                                        } else {
                                        }
                                        int v1174;
                                        v1174 = v1152[v151];
                                        bool v1176;
                                        v1176 = v1095 < v1174;
                                        bool v1177;
                                        v1177 = v1176 == false;
                                        if (v1177){
                                            assert("The raise amount must be less than the stack size after calling." && v1176);
                                        } else {
                                        }
                                        int v1179;
                                        v1179 = v1120 + v1095;
                                        bool v1181;
                                        if (v153){
                                            bool v1180;
                                            v1180 = v151 < 2;
                                            v1181 = v1180;
                                        } else {
                                            v1181 = false;
                                        }
                                        bool v1182;
                                        v1182 = v1181 == false;
                                        if (v1182){
                                            assert("Index must be in range." && v1181);
                                        } else {
                                        }
                                        int v1184;
                                        v1184 = v1099[v151];
                                        bool v1186;
                                        v1186 = v1179 < v1184;
                                        int v1187;
                                        if (v1186){
                                            v1187 = v1179;
                                        } else {
                                            v1187 = v1184;
                                        }
                                        static_array<int,2> v1188;
                                        int v1190;
                                        v1190 = 0;
                                        while (while_method_0(v1190)){
                                            bool v1192;
                                            v1192 = 0 <= v1190;
                                            bool v1194;
                                            if (v1192){
                                                bool v1193;
                                                v1193 = v1190 < 2;
                                                v1194 = v1193;
                                            } else {
                                                v1194 = false;
                                            }
                                            bool v1195;
                                            v1195 = v1194 == false;
                                            if (v1195){
                                                assert("Index must be in range." && v1194);
                                            } else {
                                            }
                                            int v1197;
                                            v1197 = v147[v1190];
                                            bool v1199;
                                            v1199 = v151 == v1190;
                                            int v1200;
                                            if (v1199){
                                                v1200 = v1187;
                                            } else {
                                                v1200 = v1197;
                                            }
                                            v1188[v1190] = v1200;
                                            v1190 += 1 ;
                                        }
                                        static_array<int,2> v1201;
                                        int v1203;
                                        v1203 = 0;
                                        while (while_method_0(v1203)){
                                            bool v1205;
                                            v1205 = 0 <= v1203;
                                            bool v1207;
                                            if (v1205){
                                                bool v1206;
                                                v1206 = v1203 < 2;
                                                v1207 = v1206;
                                            } else {
                                                v1207 = false;
                                            }
                                            bool v1208;
                                            v1208 = v1207 == false;
                                            if (v1208){
                                                assert("Index must be in range." && v1207);
                                            } else {
                                            }
                                            int v1210;
                                            v1210 = v1099[v1203];
                                            bool v1213;
                                            if (v1205){
                                                bool v1212;
                                                v1212 = v1203 < 2;
                                                v1213 = v1212;
                                            } else {
                                                v1213 = false;
                                            }
                                            bool v1214;
                                            v1214 = v1213 == false;
                                            if (v1214){
                                                assert("Index must be in range." && v1213);
                                            } else {
                                            }
                                            int v1216;
                                            v1216 = v1188[v1203];
                                            int v1218;
                                            v1218 = v1210 - v1216;
                                            v1201[v1203] = v1218;
                                            v1203 += 1 ;
                                        }
                                        int v1219;
                                        v1219 = v148 + 1;
                                        v1345 = try_round_36(v1095, v146, v1188, v1219, v1201, v150);
                                        break;
                                    }
                                    default: {
                                        assert("Invalid tag." && false); __trap();
                                    }
                                }
                                v2401 = Union3{Union3_1{v1345}};
                                break;
                            }
                            case 2: { // Human
                                Union7 v1347;
                                v1347 = Union7{Union7_2{v145, v146, v147, v148, v149, v150}};
                                v3.v5 = v1347;
                                Union3 v1348;
                                v1348 = Union3{Union3_1{v10}};
                                v3.v1 = v1348;
                                v2401 = Union3{Union3_0{}};
                                break;
                            }
                            case 3: { // Random
                                curandStatePhilox4_32_10_t & v1350 = v3.v4;
                                curandStatePhilox4_32_10_t & v1351 = v1350;
                                static_array<int,2> v1352;
                                int v1354;
                                v1354 = 0;
                                while (while_method_0(v1354)){
                                    bool v1356;
                                    v1356 = 0 <= v1354;
                                    bool v1358;
                                    if (v1356){
                                        bool v1357;
                                        v1357 = v1354 < 2;
                                        v1358 = v1357;
                                    } else {
                                        v1358 = false;
                                    }
                                    bool v1359;
                                    v1359 = v1358 == false;
                                    if (v1359){
                                        assert("Index must be in range." && v1358);
                                    } else {
                                    }
                                    int v1361;
                                    v1361 = v149[v1354];
                                    bool v1364;
                                    if (v1356){
                                        bool v1363;
                                        v1363 = v1354 < 2;
                                        v1364 = v1363;
                                    } else {
                                        v1364 = false;
                                    }
                                    bool v1365;
                                    v1365 = v1364 == false;
                                    if (v1365){
                                        assert("Index must be in range." && v1364);
                                    } else {
                                    }
                                    int v1367;
                                    v1367 = v147[v1354];
                                    int v1369;
                                    v1369 = v1361 + v1367;
                                    v1352[v1354] = v1369;
                                    v1354 += 1 ;
                                }
                                int v1370;
                                v1370 = v147[0];
                                int v1372; int v1373;
                                Tuple4 tmp45 = Tuple4{1, v1370};
                                v1372 = tmp45.v0; v1373 = tmp45.v1;
                                while (while_method_0(v1372)){
                                    bool v1375;
                                    v1375 = 0 <= v1372;
                                    bool v1377;
                                    if (v1375){
                                        bool v1376;
                                        v1376 = v1372 < 2;
                                        v1377 = v1376;
                                    } else {
                                        v1377 = false;
                                    }
                                    bool v1378;
                                    v1378 = v1377 == false;
                                    if (v1378){
                                        assert("Index must be in range." && v1377);
                                    } else {
                                    }
                                    int v1380;
                                    v1380 = v147[v1372];
                                    bool v1382;
                                    v1382 = v1373 >= v1380;
                                    int v1383;
                                    if (v1382){
                                        v1383 = v1373;
                                    } else {
                                        v1383 = v1380;
                                    }
                                    v1373 = v1383;
                                    v1372 += 1 ;
                                }
                                bool v1385;
                                if (v153){
                                    bool v1384;
                                    v1384 = v151 < 2;
                                    v1385 = v1384;
                                } else {
                                    v1385 = false;
                                }
                                bool v1386;
                                v1386 = v1385 == false;
                                if (v1386){
                                    assert("Index must be in range." && v1385);
                                } else {
                                }
                                int v1388;
                                v1388 = v1352[v151];
                                bool v1390;
                                v1390 = v1373 < v1388;
                                int v1391;
                                if (v1390){
                                    v1391 = v1373;
                                } else {
                                    v1391 = v1388;
                                }
                                static_array<int,2> v1392;
                                int v1394;
                                v1394 = 0;
                                while (while_method_0(v1394)){
                                    bool v1396;
                                    v1396 = 0 <= v1394;
                                    bool v1398;
                                    if (v1396){
                                        bool v1397;
                                        v1397 = v1394 < 2;
                                        v1398 = v1397;
                                    } else {
                                        v1398 = false;
                                    }
                                    bool v1399;
                                    v1399 = v1398 == false;
                                    if (v1399){
                                        assert("Index must be in range." && v1398);
                                    } else {
                                    }
                                    int v1401;
                                    v1401 = v147[v1394];
                                    bool v1403;
                                    v1403 = v151 == v1394;
                                    int v1404;
                                    if (v1403){
                                        v1404 = v1391;
                                    } else {
                                        v1404 = v1401;
                                    }
                                    v1392[v1394] = v1404;
                                    v1394 += 1 ;
                                }
                                int v1405;
                                v1405 = v1392[0];
                                int v1407; int v1408;
                                Tuple4 tmp46 = Tuple4{1, v1405};
                                v1407 = tmp46.v0; v1408 = tmp46.v1;
                                while (while_method_0(v1407)){
                                    bool v1410;
                                    v1410 = 0 <= v1407;
                                    bool v1412;
                                    if (v1410){
                                        bool v1411;
                                        v1411 = v1407 < 2;
                                        v1412 = v1411;
                                    } else {
                                        v1412 = false;
                                    }
                                    bool v1413;
                                    v1413 = v1412 == false;
                                    if (v1413){
                                        assert("Index must be in range." && v1412);
                                    } else {
                                    }
                                    int v1415;
                                    v1415 = v1392[v1407];
                                    int v1417;
                                    v1417 = v1408 + v1415;
                                    v1408 = v1417;
                                    v1407 += 1 ;
                                }
                                static_array<int,2> v1418;
                                int v1420;
                                v1420 = 0;
                                while (while_method_0(v1420)){
                                    bool v1422;
                                    v1422 = 0 <= v1420;
                                    bool v1424;
                                    if (v1422){
                                        bool v1423;
                                        v1423 = v1420 < 2;
                                        v1424 = v1423;
                                    } else {
                                        v1424 = false;
                                    }
                                    bool v1425;
                                    v1425 = v1424 == false;
                                    if (v1425){
                                        assert("Index must be in range." && v1424);
                                    } else {
                                    }
                                    int v1427;
                                    v1427 = v1352[v1420];
                                    bool v1430;
                                    if (v1422){
                                        bool v1429;
                                        v1429 = v1420 < 2;
                                        v1430 = v1429;
                                    } else {
                                        v1430 = false;
                                    }
                                    bool v1431;
                                    v1431 = v1430 == false;
                                    if (v1431){
                                        assert("Index must be in range." && v1430);
                                    } else {
                                    }
                                    int v1433;
                                    v1433 = v1392[v1420];
                                    int v1435;
                                    v1435 = v1427 - v1433;
                                    v1418[v1420] = v1435;
                                    v1420 += 1 ;
                                }
                                bool v1437;
                                if (v153){
                                    bool v1436;
                                    v1436 = v151 < 2;
                                    v1437 = v1436;
                                } else {
                                    v1437 = false;
                                }
                                bool v1438;
                                v1438 = v1437 == false;
                                if (v1438){
                                    assert("Index must be in range." && v1437);
                                } else {
                                }
                                int v1440;
                                v1440 = v147[v151];
                                bool v1442;
                                v1442 = v1440 < v1373;
                                float v1443;
                                if (v1442){
                                    v1443 = 1.0f;
                                } else {
                                    v1443 = 0.0f;
                                }
                                int v1444;
                                v1444 = v1408 / 3;
                                bool v1445;
                                v1445 = v145 <= v1444;
                                bool v1453;
                                if (v1445){
                                    bool v1447;
                                    if (v153){
                                        bool v1446;
                                        v1446 = v151 < 2;
                                        v1447 = v1446;
                                    } else {
                                        v1447 = false;
                                    }
                                    bool v1448;
                                    v1448 = v1447 == false;
                                    if (v1448){
                                        assert("Index must be in range." && v1447);
                                    } else {
                                    }
                                    int v1450;
                                    v1450 = v1418[v151];
                                    bool v1452;
                                    v1452 = v1444 < v1450;
                                    v1453 = v1452;
                                } else {
                                    v1453 = false;
                                }
                                float v1454;
                                if (v1453){
                                    v1454 = 1.0f;
                                } else {
                                    v1454 = 0.0f;
                                }
                                int v1455;
                                v1455 = v1408 / 2;
                                bool v1456;
                                v1456 = v145 <= v1455;
                                bool v1464;
                                if (v1456){
                                    bool v1458;
                                    if (v153){
                                        bool v1457;
                                        v1457 = v151 < 2;
                                        v1458 = v1457;
                                    } else {
                                        v1458 = false;
                                    }
                                    bool v1459;
                                    v1459 = v1458 == false;
                                    if (v1459){
                                        assert("Index must be in range." && v1458);
                                    } else {
                                    }
                                    int v1461;
                                    v1461 = v1418[v151];
                                    bool v1463;
                                    v1463 = v1455 < v1461;
                                    v1464 = v1463;
                                } else {
                                    v1464 = false;
                                }
                                float v1465;
                                if (v1464){
                                    v1465 = 1.0f;
                                } else {
                                    v1465 = 0.0f;
                                }
                                bool v1466;
                                v1466 = v145 <= v1408;
                                bool v1474;
                                if (v1466){
                                    bool v1468;
                                    if (v153){
                                        bool v1467;
                                        v1467 = v151 < 2;
                                        v1468 = v1467;
                                    } else {
                                        v1468 = false;
                                    }
                                    bool v1469;
                                    v1469 = v1468 == false;
                                    if (v1469){
                                        assert("Index must be in range." && v1468);
                                    } else {
                                    }
                                    int v1471;
                                    v1471 = v1418[v151];
                                    bool v1473;
                                    v1473 = v1408 < v1471;
                                    v1474 = v1473;
                                } else {
                                    v1474 = false;
                                }
                                float v1475;
                                if (v1474){
                                    v1475 = 1.0f;
                                } else {
                                    v1475 = 0.0f;
                                }
                                static_array<Tuple17,6> v1476;
                                Union1 v1478;
                                v1478 = Union1{Union1_2{}};
                                v1476[0] = Tuple17{v1478, v1443};
                                Union1 v1480;
                                v1480 = Union1{Union1_1{}};
                                v1476[1] = Tuple17{v1480, 4.0f};
                                Union1 v1482;
                                v1482 = Union1{Union1_3{v1444}};
                                v1476[2] = Tuple17{v1482, v1454};
                                Union1 v1484;
                                v1484 = Union1{Union1_3{v1455}};
                                v1476[3] = Tuple17{v1484, v1465};
                                Union1 v1486;
                                v1486 = Union1{Union1_3{v1408}};
                                v1476[4] = Tuple17{v1486, v1475};
                                Union1 v1488;
                                v1488 = Union1{Union1_0{}};
                                v1476[5] = Tuple17{v1488, 1.0f};
                                Union1 v1490;
                                v1490 = sample_discrete_50(v1476, v1351);
                                int v1491;
                                v1491 = sizeof(Union1);
                                unsigned long long v1492;
                                v1492 = (unsigned long long)v1491;
                                bool v1493;
                                v1493 = v1492 <= 98304ull;
                                bool v1494;
                                v1494 = v1493 == false;
                                if (v1494){
                                    assert("The dynamic shared memory is insufficient to allocate the tensor." && v1493);
                                } else {
                                }
                                extern __shared__ unsigned char v1496[];
                                bool v1497;
                                v1497 = v1492 <= v1492;
                                bool v1498;
                                v1498 = v1497 == false;
                                if (v1498){
                                    assert("The length of the partition has to be less than or equal to the length of the base array." && v1497);
                                } else {
                                }
                                Union1 * v1500;
                                v1500 = reinterpret_cast<Union1 *>(&v1496[0ull]);
                                int v1502;
                                v1502 = threadIdx.x;
                                bool v1503;
                                v1503 = v1502 == 0;
                                if (v1503){
                                    v1500[0] = v1490;
                                } else {
                                }
                                __syncthreads();
                                Union1 v1504;
                                v1504 = v1500[0];
                                __syncthreads();
                                Union6 v1505;
                                v1505 = Union6{Union6_2{v151, v1504}};
                                v5.push(v1505);
                                Union4 v1833;
                                switch (v1504.tag) {
                                    case 0: { // A_All_In
                                        static_array<int,2> v1709;
                                        int v1711;
                                        v1711 = 0;
                                        while (while_method_0(v1711)){
                                            bool v1713;
                                            v1713 = 0 <= v1711;
                                            bool v1715;
                                            if (v1713){
                                                bool v1714;
                                                v1714 = v1711 < 2;
                                                v1715 = v1714;
                                            } else {
                                                v1715 = false;
                                            }
                                            bool v1716;
                                            v1716 = v1715 == false;
                                            if (v1716){
                                                assert("Index must be in range." && v1715);
                                            } else {
                                            }
                                            int v1718;
                                            v1718 = v149[v1711];
                                            bool v1721;
                                            if (v1713){
                                                bool v1720;
                                                v1720 = v1711 < 2;
                                                v1721 = v1720;
                                            } else {
                                                v1721 = false;
                                            }
                                            bool v1722;
                                            v1722 = v1721 == false;
                                            if (v1722){
                                                assert("Index must be in range." && v1721);
                                            } else {
                                            }
                                            int v1724;
                                            v1724 = v147[v1711];
                                            int v1726;
                                            v1726 = v1718 + v1724;
                                            v1709[v1711] = v1726;
                                            v1711 += 1 ;
                                        }
                                        int v1727;
                                        v1727 = v147[0];
                                        int v1729; int v1730;
                                        Tuple4 tmp49 = Tuple4{1, v1727};
                                        v1729 = tmp49.v0; v1730 = tmp49.v1;
                                        while (while_method_0(v1729)){
                                            bool v1732;
                                            v1732 = 0 <= v1729;
                                            bool v1734;
                                            if (v1732){
                                                bool v1733;
                                                v1733 = v1729 < 2;
                                                v1734 = v1733;
                                            } else {
                                                v1734 = false;
                                            }
                                            bool v1735;
                                            v1735 = v1734 == false;
                                            if (v1735){
                                                assert("Index must be in range." && v1734);
                                            } else {
                                            }
                                            int v1737;
                                            v1737 = v147[v1729];
                                            bool v1739;
                                            v1739 = v1730 >= v1737;
                                            int v1740;
                                            if (v1739){
                                                v1740 = v1730;
                                            } else {
                                                v1740 = v1737;
                                            }
                                            v1730 = v1740;
                                            v1729 += 1 ;
                                        }
                                        bool v1742;
                                        if (v153){
                                            bool v1741;
                                            v1741 = v151 < 2;
                                            v1742 = v1741;
                                        } else {
                                            v1742 = false;
                                        }
                                        bool v1743;
                                        v1743 = v1742 == false;
                                        if (v1743){
                                            assert("Index must be in range." && v1742);
                                        } else {
                                        }
                                        int v1745;
                                        v1745 = v1709[v151];
                                        bool v1747;
                                        v1747 = v1730 < v1745;
                                        int v1748;
                                        if (v1747){
                                            v1748 = v1730;
                                        } else {
                                            v1748 = v1745;
                                        }
                                        static_array<int,2> v1749;
                                        int v1751;
                                        v1751 = 0;
                                        while (while_method_0(v1751)){
                                            bool v1753;
                                            v1753 = 0 <= v1751;
                                            bool v1755;
                                            if (v1753){
                                                bool v1754;
                                                v1754 = v1751 < 2;
                                                v1755 = v1754;
                                            } else {
                                                v1755 = false;
                                            }
                                            bool v1756;
                                            v1756 = v1755 == false;
                                            if (v1756){
                                                assert("Index must be in range." && v1755);
                                            } else {
                                            }
                                            int v1758;
                                            v1758 = v147[v1751];
                                            bool v1760;
                                            v1760 = v151 == v1751;
                                            int v1761;
                                            if (v1760){
                                                v1761 = v1748;
                                            } else {
                                                v1761 = v1758;
                                            }
                                            v1749[v1751] = v1761;
                                            v1751 += 1 ;
                                        }
                                        static_array<int,2> v1762;
                                        int v1764;
                                        v1764 = 0;
                                        while (while_method_0(v1764)){
                                            bool v1766;
                                            v1766 = 0 <= v1764;
                                            bool v1768;
                                            if (v1766){
                                                bool v1767;
                                                v1767 = v1764 < 2;
                                                v1768 = v1767;
                                            } else {
                                                v1768 = false;
                                            }
                                            bool v1769;
                                            v1769 = v1768 == false;
                                            if (v1769){
                                                assert("Index must be in range." && v1768);
                                            } else {
                                            }
                                            int v1771;
                                            v1771 = v1709[v1764];
                                            bool v1774;
                                            if (v1766){
                                                bool v1773;
                                                v1773 = v1764 < 2;
                                                v1774 = v1773;
                                            } else {
                                                v1774 = false;
                                            }
                                            bool v1775;
                                            v1775 = v1774 == false;
                                            if (v1775){
                                                assert("Index must be in range." && v1774);
                                            } else {
                                            }
                                            int v1777;
                                            v1777 = v1749[v1764];
                                            int v1779;
                                            v1779 = v1771 - v1777;
                                            v1762[v1764] = v1779;
                                            v1764 += 1 ;
                                        }
                                        bool v1781;
                                        if (v153){
                                            bool v1780;
                                            v1780 = v151 < 2;
                                            v1781 = v1780;
                                        } else {
                                            v1781 = false;
                                        }
                                        bool v1782;
                                        v1782 = v1781 == false;
                                        if (v1782){
                                            assert("Index must be in range." && v1781);
                                        } else {
                                        }
                                        int v1784;
                                        v1784 = v1762[v151];
                                        int v1786;
                                        v1786 = v1730 + v1784;
                                        bool v1788;
                                        if (v153){
                                            bool v1787;
                                            v1787 = v151 < 2;
                                            v1788 = v1787;
                                        } else {
                                            v1788 = false;
                                        }
                                        bool v1789;
                                        v1789 = v1788 == false;
                                        if (v1789){
                                            assert("Index must be in range." && v1788);
                                        } else {
                                        }
                                        int v1791;
                                        v1791 = v1709[v151];
                                        bool v1793;
                                        v1793 = v1786 < v1791;
                                        int v1794;
                                        if (v1793){
                                            v1794 = v1786;
                                        } else {
                                            v1794 = v1791;
                                        }
                                        static_array<int,2> v1795;
                                        int v1797;
                                        v1797 = 0;
                                        while (while_method_0(v1797)){
                                            bool v1799;
                                            v1799 = 0 <= v1797;
                                            bool v1801;
                                            if (v1799){
                                                bool v1800;
                                                v1800 = v1797 < 2;
                                                v1801 = v1800;
                                            } else {
                                                v1801 = false;
                                            }
                                            bool v1802;
                                            v1802 = v1801 == false;
                                            if (v1802){
                                                assert("Index must be in range." && v1801);
                                            } else {
                                            }
                                            int v1804;
                                            v1804 = v147[v1797];
                                            bool v1806;
                                            v1806 = v151 == v1797;
                                            int v1807;
                                            if (v1806){
                                                v1807 = v1794;
                                            } else {
                                                v1807 = v1804;
                                            }
                                            v1795[v1797] = v1807;
                                            v1797 += 1 ;
                                        }
                                        static_array<int,2> v1808;
                                        int v1810;
                                        v1810 = 0;
                                        while (while_method_0(v1810)){
                                            bool v1812;
                                            v1812 = 0 <= v1810;
                                            bool v1814;
                                            if (v1812){
                                                bool v1813;
                                                v1813 = v1810 < 2;
                                                v1814 = v1813;
                                            } else {
                                                v1814 = false;
                                            }
                                            bool v1815;
                                            v1815 = v1814 == false;
                                            if (v1815){
                                                assert("Index must be in range." && v1814);
                                            } else {
                                            }
                                            int v1817;
                                            v1817 = v1709[v1810];
                                            bool v1820;
                                            if (v1812){
                                                bool v1819;
                                                v1819 = v1810 < 2;
                                                v1820 = v1819;
                                            } else {
                                                v1820 = false;
                                            }
                                            bool v1821;
                                            v1821 = v1820 == false;
                                            if (v1821){
                                                assert("Index must be in range." && v1820);
                                            } else {
                                            }
                                            int v1823;
                                            v1823 = v1795[v1810];
                                            int v1825;
                                            v1825 = v1817 - v1823;
                                            v1808[v1810] = v1825;
                                            v1810 += 1 ;
                                        }
                                        bool v1826;
                                        v1826 = v1784 >= v145;
                                        int v1827;
                                        if (v1826){
                                            v1827 = v1784;
                                        } else {
                                            v1827 = v145;
                                        }
                                        int v1828;
                                        v1828 = v148 + 1;
                                        v1833 = try_round_36(v1827, v146, v1795, v1828, v1808, v150);
                                        break;
                                    }
                                    case 1: { // A_Call
                                        static_array<int,2> v1507;
                                        int v1509;
                                        v1509 = 0;
                                        while (while_method_0(v1509)){
                                            bool v1511;
                                            v1511 = 0 <= v1509;
                                            bool v1513;
                                            if (v1511){
                                                bool v1512;
                                                v1512 = v1509 < 2;
                                                v1513 = v1512;
                                            } else {
                                                v1513 = false;
                                            }
                                            bool v1514;
                                            v1514 = v1513 == false;
                                            if (v1514){
                                                assert("Index must be in range." && v1513);
                                            } else {
                                            }
                                            int v1516;
                                            v1516 = v149[v1509];
                                            bool v1519;
                                            if (v1511){
                                                bool v1518;
                                                v1518 = v1509 < 2;
                                                v1519 = v1518;
                                            } else {
                                                v1519 = false;
                                            }
                                            bool v1520;
                                            v1520 = v1519 == false;
                                            if (v1520){
                                                assert("Index must be in range." && v1519);
                                            } else {
                                            }
                                            int v1522;
                                            v1522 = v147[v1509];
                                            int v1524;
                                            v1524 = v1516 + v1522;
                                            v1507[v1509] = v1524;
                                            v1509 += 1 ;
                                        }
                                        int v1525;
                                        v1525 = v147[0];
                                        int v1527; int v1528;
                                        Tuple4 tmp50 = Tuple4{1, v1525};
                                        v1527 = tmp50.v0; v1528 = tmp50.v1;
                                        while (while_method_0(v1527)){
                                            bool v1530;
                                            v1530 = 0 <= v1527;
                                            bool v1532;
                                            if (v1530){
                                                bool v1531;
                                                v1531 = v1527 < 2;
                                                v1532 = v1531;
                                            } else {
                                                v1532 = false;
                                            }
                                            bool v1533;
                                            v1533 = v1532 == false;
                                            if (v1533){
                                                assert("Index must be in range." && v1532);
                                            } else {
                                            }
                                            int v1535;
                                            v1535 = v147[v1527];
                                            bool v1537;
                                            v1537 = v1528 >= v1535;
                                            int v1538;
                                            if (v1537){
                                                v1538 = v1528;
                                            } else {
                                                v1538 = v1535;
                                            }
                                            v1528 = v1538;
                                            v1527 += 1 ;
                                        }
                                        bool v1540;
                                        if (v153){
                                            bool v1539;
                                            v1539 = v151 < 2;
                                            v1540 = v1539;
                                        } else {
                                            v1540 = false;
                                        }
                                        bool v1541;
                                        v1541 = v1540 == false;
                                        if (v1541){
                                            assert("Index must be in range." && v1540);
                                        } else {
                                        }
                                        int v1543;
                                        v1543 = v1507[v151];
                                        bool v1545;
                                        v1545 = v1528 < v1543;
                                        int v1546;
                                        if (v1545){
                                            v1546 = v1528;
                                        } else {
                                            v1546 = v1543;
                                        }
                                        static_array<int,2> v1547;
                                        int v1549;
                                        v1549 = 0;
                                        while (while_method_0(v1549)){
                                            bool v1551;
                                            v1551 = 0 <= v1549;
                                            bool v1553;
                                            if (v1551){
                                                bool v1552;
                                                v1552 = v1549 < 2;
                                                v1553 = v1552;
                                            } else {
                                                v1553 = false;
                                            }
                                            bool v1554;
                                            v1554 = v1553 == false;
                                            if (v1554){
                                                assert("Index must be in range." && v1553);
                                            } else {
                                            }
                                            int v1556;
                                            v1556 = v147[v1549];
                                            bool v1558;
                                            v1558 = v151 == v1549;
                                            int v1559;
                                            if (v1558){
                                                v1559 = v1546;
                                            } else {
                                                v1559 = v1556;
                                            }
                                            v1547[v1549] = v1559;
                                            v1549 += 1 ;
                                        }
                                        static_array<int,2> v1560;
                                        int v1562;
                                        v1562 = 0;
                                        while (while_method_0(v1562)){
                                            bool v1564;
                                            v1564 = 0 <= v1562;
                                            bool v1566;
                                            if (v1564){
                                                bool v1565;
                                                v1565 = v1562 < 2;
                                                v1566 = v1565;
                                            } else {
                                                v1566 = false;
                                            }
                                            bool v1567;
                                            v1567 = v1566 == false;
                                            if (v1567){
                                                assert("Index must be in range." && v1566);
                                            } else {
                                            }
                                            int v1569;
                                            v1569 = v1507[v1562];
                                            bool v1572;
                                            if (v1564){
                                                bool v1571;
                                                v1571 = v1562 < 2;
                                                v1572 = v1571;
                                            } else {
                                                v1572 = false;
                                            }
                                            bool v1573;
                                            v1573 = v1572 == false;
                                            if (v1573){
                                                assert("Index must be in range." && v1572);
                                            } else {
                                            }
                                            int v1575;
                                            v1575 = v1547[v1562];
                                            int v1577;
                                            v1577 = v1569 - v1575;
                                            v1560[v1562] = v1577;
                                            v1562 += 1 ;
                                        }
                                        bool v1578;
                                        v1578 = v151 < 2;
                                        if (v1578){
                                            int v1579;
                                            v1579 = v148 + 1;
                                            v1833 = try_round_36(v145, v146, v1547, v1579, v1560, v150);
                                        } else {
                                            v1833 = go_next_street_38(v145, v146, v1547, v148, v1560, v150);
                                        }
                                        break;
                                    }
                                    case 2: { // A_Fold
                                        v1833 = Union4{Union4_1{v145, v146, v147, v148, v149, v150}};
                                        break;
                                    }
                                    case 3: { // A_Raise
                                        int v1583 = v1504.case3.v0;
                                        bool v1584;
                                        v1584 = v145 <= v1583;
                                        bool v1585;
                                        v1585 = v1584 == false;
                                        if (v1585){
                                            assert("The raise amount must match the minimum." && v1584);
                                        } else {
                                        }
                                        static_array<int,2> v1587;
                                        int v1589;
                                        v1589 = 0;
                                        while (while_method_0(v1589)){
                                            bool v1591;
                                            v1591 = 0 <= v1589;
                                            bool v1593;
                                            if (v1591){
                                                bool v1592;
                                                v1592 = v1589 < 2;
                                                v1593 = v1592;
                                            } else {
                                                v1593 = false;
                                            }
                                            bool v1594;
                                            v1594 = v1593 == false;
                                            if (v1594){
                                                assert("Index must be in range." && v1593);
                                            } else {
                                            }
                                            int v1596;
                                            v1596 = v149[v1589];
                                            bool v1599;
                                            if (v1591){
                                                bool v1598;
                                                v1598 = v1589 < 2;
                                                v1599 = v1598;
                                            } else {
                                                v1599 = false;
                                            }
                                            bool v1600;
                                            v1600 = v1599 == false;
                                            if (v1600){
                                                assert("Index must be in range." && v1599);
                                            } else {
                                            }
                                            int v1602;
                                            v1602 = v147[v1589];
                                            int v1604;
                                            v1604 = v1596 + v1602;
                                            v1587[v1589] = v1604;
                                            v1589 += 1 ;
                                        }
                                        int v1605;
                                        v1605 = v147[0];
                                        int v1607; int v1608;
                                        Tuple4 tmp51 = Tuple4{1, v1605};
                                        v1607 = tmp51.v0; v1608 = tmp51.v1;
                                        while (while_method_0(v1607)){
                                            bool v1610;
                                            v1610 = 0 <= v1607;
                                            bool v1612;
                                            if (v1610){
                                                bool v1611;
                                                v1611 = v1607 < 2;
                                                v1612 = v1611;
                                            } else {
                                                v1612 = false;
                                            }
                                            bool v1613;
                                            v1613 = v1612 == false;
                                            if (v1613){
                                                assert("Index must be in range." && v1612);
                                            } else {
                                            }
                                            int v1615;
                                            v1615 = v147[v1607];
                                            bool v1617;
                                            v1617 = v1608 >= v1615;
                                            int v1618;
                                            if (v1617){
                                                v1618 = v1608;
                                            } else {
                                                v1618 = v1615;
                                            }
                                            v1608 = v1618;
                                            v1607 += 1 ;
                                        }
                                        bool v1620;
                                        if (v153){
                                            bool v1619;
                                            v1619 = v151 < 2;
                                            v1620 = v1619;
                                        } else {
                                            v1620 = false;
                                        }
                                        bool v1621;
                                        v1621 = v1620 == false;
                                        if (v1621){
                                            assert("Index must be in range." && v1620);
                                        } else {
                                        }
                                        int v1623;
                                        v1623 = v1587[v151];
                                        bool v1625;
                                        v1625 = v1608 < v1623;
                                        int v1626;
                                        if (v1625){
                                            v1626 = v1608;
                                        } else {
                                            v1626 = v1623;
                                        }
                                        static_array<int,2> v1627;
                                        int v1629;
                                        v1629 = 0;
                                        while (while_method_0(v1629)){
                                            bool v1631;
                                            v1631 = 0 <= v1629;
                                            bool v1633;
                                            if (v1631){
                                                bool v1632;
                                                v1632 = v1629 < 2;
                                                v1633 = v1632;
                                            } else {
                                                v1633 = false;
                                            }
                                            bool v1634;
                                            v1634 = v1633 == false;
                                            if (v1634){
                                                assert("Index must be in range." && v1633);
                                            } else {
                                            }
                                            int v1636;
                                            v1636 = v147[v1629];
                                            bool v1638;
                                            v1638 = v151 == v1629;
                                            int v1639;
                                            if (v1638){
                                                v1639 = v1626;
                                            } else {
                                                v1639 = v1636;
                                            }
                                            v1627[v1629] = v1639;
                                            v1629 += 1 ;
                                        }
                                        static_array<int,2> v1640;
                                        int v1642;
                                        v1642 = 0;
                                        while (while_method_0(v1642)){
                                            bool v1644;
                                            v1644 = 0 <= v1642;
                                            bool v1646;
                                            if (v1644){
                                                bool v1645;
                                                v1645 = v1642 < 2;
                                                v1646 = v1645;
                                            } else {
                                                v1646 = false;
                                            }
                                            bool v1647;
                                            v1647 = v1646 == false;
                                            if (v1647){
                                                assert("Index must be in range." && v1646);
                                            } else {
                                            }
                                            int v1649;
                                            v1649 = v1587[v1642];
                                            bool v1652;
                                            if (v1644){
                                                bool v1651;
                                                v1651 = v1642 < 2;
                                                v1652 = v1651;
                                            } else {
                                                v1652 = false;
                                            }
                                            bool v1653;
                                            v1653 = v1652 == false;
                                            if (v1653){
                                                assert("Index must be in range." && v1652);
                                            } else {
                                            }
                                            int v1655;
                                            v1655 = v1627[v1642];
                                            int v1657;
                                            v1657 = v1649 - v1655;
                                            v1640[v1642] = v1657;
                                            v1642 += 1 ;
                                        }
                                        bool v1659;
                                        if (v153){
                                            bool v1658;
                                            v1658 = v151 < 2;
                                            v1659 = v1658;
                                        } else {
                                            v1659 = false;
                                        }
                                        bool v1660;
                                        v1660 = v1659 == false;
                                        if (v1660){
                                            assert("Index must be in range." && v1659);
                                        } else {
                                        }
                                        int v1662;
                                        v1662 = v1640[v151];
                                        bool v1664;
                                        v1664 = v1583 < v1662;
                                        bool v1665;
                                        v1665 = v1664 == false;
                                        if (v1665){
                                            assert("The raise amount must be less than the stack size after calling." && v1664);
                                        } else {
                                        }
                                        int v1667;
                                        v1667 = v1608 + v1583;
                                        bool v1669;
                                        if (v153){
                                            bool v1668;
                                            v1668 = v151 < 2;
                                            v1669 = v1668;
                                        } else {
                                            v1669 = false;
                                        }
                                        bool v1670;
                                        v1670 = v1669 == false;
                                        if (v1670){
                                            assert("Index must be in range." && v1669);
                                        } else {
                                        }
                                        int v1672;
                                        v1672 = v1587[v151];
                                        bool v1674;
                                        v1674 = v1667 < v1672;
                                        int v1675;
                                        if (v1674){
                                            v1675 = v1667;
                                        } else {
                                            v1675 = v1672;
                                        }
                                        static_array<int,2> v1676;
                                        int v1678;
                                        v1678 = 0;
                                        while (while_method_0(v1678)){
                                            bool v1680;
                                            v1680 = 0 <= v1678;
                                            bool v1682;
                                            if (v1680){
                                                bool v1681;
                                                v1681 = v1678 < 2;
                                                v1682 = v1681;
                                            } else {
                                                v1682 = false;
                                            }
                                            bool v1683;
                                            v1683 = v1682 == false;
                                            if (v1683){
                                                assert("Index must be in range." && v1682);
                                            } else {
                                            }
                                            int v1685;
                                            v1685 = v147[v1678];
                                            bool v1687;
                                            v1687 = v151 == v1678;
                                            int v1688;
                                            if (v1687){
                                                v1688 = v1675;
                                            } else {
                                                v1688 = v1685;
                                            }
                                            v1676[v1678] = v1688;
                                            v1678 += 1 ;
                                        }
                                        static_array<int,2> v1689;
                                        int v1691;
                                        v1691 = 0;
                                        while (while_method_0(v1691)){
                                            bool v1693;
                                            v1693 = 0 <= v1691;
                                            bool v1695;
                                            if (v1693){
                                                bool v1694;
                                                v1694 = v1691 < 2;
                                                v1695 = v1694;
                                            } else {
                                                v1695 = false;
                                            }
                                            bool v1696;
                                            v1696 = v1695 == false;
                                            if (v1696){
                                                assert("Index must be in range." && v1695);
                                            } else {
                                            }
                                            int v1698;
                                            v1698 = v1587[v1691];
                                            bool v1701;
                                            if (v1693){
                                                bool v1700;
                                                v1700 = v1691 < 2;
                                                v1701 = v1700;
                                            } else {
                                                v1701 = false;
                                            }
                                            bool v1702;
                                            v1702 = v1701 == false;
                                            if (v1702){
                                                assert("Index must be in range." && v1701);
                                            } else {
                                            }
                                            int v1704;
                                            v1704 = v1676[v1691];
                                            int v1706;
                                            v1706 = v1698 - v1704;
                                            v1689[v1691] = v1706;
                                            v1691 += 1 ;
                                        }
                                        int v1707;
                                        v1707 = v148 + 1;
                                        v1833 = try_round_36(v1583, v146, v1676, v1707, v1689, v150);
                                        break;
                                    }
                                    default: {
                                        assert("Invalid tag." && false); __trap();
                                    }
                                }
                                v2401 = Union3{Union3_1{v1833}};
                                break;
                            }
                            default: {
                                assert("Invalid tag." && false); __trap();
                            }
                        }
                        break;
                    }
                    case 5: { // G_Round'
                        int v1918 = v10.case5.v0; static_array<static_array<unsigned char,2>,2> v1919 = v10.case5.v1; static_array<int,2> v1920 = v10.case5.v2; int v1921 = v10.case5.v3; static_array<int,2> v1922 = v10.case5.v4; Union5 v1923 = v10.case5.v5; Union1 v1924 = v10.case5.v6;
                        int v1925;
                        v1925 = v1921 % 2;
                        Union6 v1926;
                        v1926 = Union6{Union6_2{v1925, v1924}};
                        v5.push(v1926);
                        Union4 v2257;
                        switch (v1924.tag) {
                            case 0: { // A_All_In
                                static_array<int,2> v2132;
                                int v2134;
                                v2134 = 0;
                                while (while_method_0(v2134)){
                                    bool v2136;
                                    v2136 = 0 <= v2134;
                                    bool v2138;
                                    if (v2136){
                                        bool v2137;
                                        v2137 = v2134 < 2;
                                        v2138 = v2137;
                                    } else {
                                        v2138 = false;
                                    }
                                    bool v2139;
                                    v2139 = v2138 == false;
                                    if (v2139){
                                        assert("Index must be in range." && v2138);
                                    } else {
                                    }
                                    int v2141;
                                    v2141 = v1922[v2134];
                                    bool v2144;
                                    if (v2136){
                                        bool v2143;
                                        v2143 = v2134 < 2;
                                        v2144 = v2143;
                                    } else {
                                        v2144 = false;
                                    }
                                    bool v2145;
                                    v2145 = v2144 == false;
                                    if (v2145){
                                        assert("Index must be in range." && v2144);
                                    } else {
                                    }
                                    int v2147;
                                    v2147 = v1920[v2134];
                                    int v2149;
                                    v2149 = v2141 + v2147;
                                    v2132[v2134] = v2149;
                                    v2134 += 1 ;
                                }
                                int v2150;
                                v2150 = v1920[0];
                                int v2152; int v2153;
                                Tuple4 tmp52 = Tuple4{1, v2150};
                                v2152 = tmp52.v0; v2153 = tmp52.v1;
                                while (while_method_0(v2152)){
                                    bool v2155;
                                    v2155 = 0 <= v2152;
                                    bool v2157;
                                    if (v2155){
                                        bool v2156;
                                        v2156 = v2152 < 2;
                                        v2157 = v2156;
                                    } else {
                                        v2157 = false;
                                    }
                                    bool v2158;
                                    v2158 = v2157 == false;
                                    if (v2158){
                                        assert("Index must be in range." && v2157);
                                    } else {
                                    }
                                    int v2160;
                                    v2160 = v1920[v2152];
                                    bool v2162;
                                    v2162 = v2153 >= v2160;
                                    int v2163;
                                    if (v2162){
                                        v2163 = v2153;
                                    } else {
                                        v2163 = v2160;
                                    }
                                    v2153 = v2163;
                                    v2152 += 1 ;
                                }
                                bool v2164;
                                v2164 = 0 <= v1925;
                                bool v2166;
                                if (v2164){
                                    bool v2165;
                                    v2165 = v1925 < 2;
                                    v2166 = v2165;
                                } else {
                                    v2166 = false;
                                }
                                bool v2167;
                                v2167 = v2166 == false;
                                if (v2167){
                                    assert("Index must be in range." && v2166);
                                } else {
                                }
                                int v2169;
                                v2169 = v2132[v1925];
                                bool v2171;
                                v2171 = v2153 < v2169;
                                int v2172;
                                if (v2171){
                                    v2172 = v2153;
                                } else {
                                    v2172 = v2169;
                                }
                                static_array<int,2> v2173;
                                int v2175;
                                v2175 = 0;
                                while (while_method_0(v2175)){
                                    bool v2177;
                                    v2177 = 0 <= v2175;
                                    bool v2179;
                                    if (v2177){
                                        bool v2178;
                                        v2178 = v2175 < 2;
                                        v2179 = v2178;
                                    } else {
                                        v2179 = false;
                                    }
                                    bool v2180;
                                    v2180 = v2179 == false;
                                    if (v2180){
                                        assert("Index must be in range." && v2179);
                                    } else {
                                    }
                                    int v2182;
                                    v2182 = v1920[v2175];
                                    bool v2184;
                                    v2184 = v1925 == v2175;
                                    int v2185;
                                    if (v2184){
                                        v2185 = v2172;
                                    } else {
                                        v2185 = v2182;
                                    }
                                    v2173[v2175] = v2185;
                                    v2175 += 1 ;
                                }
                                static_array<int,2> v2186;
                                int v2188;
                                v2188 = 0;
                                while (while_method_0(v2188)){
                                    bool v2190;
                                    v2190 = 0 <= v2188;
                                    bool v2192;
                                    if (v2190){
                                        bool v2191;
                                        v2191 = v2188 < 2;
                                        v2192 = v2191;
                                    } else {
                                        v2192 = false;
                                    }
                                    bool v2193;
                                    v2193 = v2192 == false;
                                    if (v2193){
                                        assert("Index must be in range." && v2192);
                                    } else {
                                    }
                                    int v2195;
                                    v2195 = v2132[v2188];
                                    bool v2198;
                                    if (v2190){
                                        bool v2197;
                                        v2197 = v2188 < 2;
                                        v2198 = v2197;
                                    } else {
                                        v2198 = false;
                                    }
                                    bool v2199;
                                    v2199 = v2198 == false;
                                    if (v2199){
                                        assert("Index must be in range." && v2198);
                                    } else {
                                    }
                                    int v2201;
                                    v2201 = v2173[v2188];
                                    int v2203;
                                    v2203 = v2195 - v2201;
                                    v2186[v2188] = v2203;
                                    v2188 += 1 ;
                                }
                                bool v2205;
                                if (v2164){
                                    bool v2204;
                                    v2204 = v1925 < 2;
                                    v2205 = v2204;
                                } else {
                                    v2205 = false;
                                }
                                bool v2206;
                                v2206 = v2205 == false;
                                if (v2206){
                                    assert("Index must be in range." && v2205);
                                } else {
                                }
                                int v2208;
                                v2208 = v2186[v1925];
                                int v2210;
                                v2210 = v2153 + v2208;
                                bool v2212;
                                if (v2164){
                                    bool v2211;
                                    v2211 = v1925 < 2;
                                    v2212 = v2211;
                                } else {
                                    v2212 = false;
                                }
                                bool v2213;
                                v2213 = v2212 == false;
                                if (v2213){
                                    assert("Index must be in range." && v2212);
                                } else {
                                }
                                int v2215;
                                v2215 = v2132[v1925];
                                bool v2217;
                                v2217 = v2210 < v2215;
                                int v2218;
                                if (v2217){
                                    v2218 = v2210;
                                } else {
                                    v2218 = v2215;
                                }
                                static_array<int,2> v2219;
                                int v2221;
                                v2221 = 0;
                                while (while_method_0(v2221)){
                                    bool v2223;
                                    v2223 = 0 <= v2221;
                                    bool v2225;
                                    if (v2223){
                                        bool v2224;
                                        v2224 = v2221 < 2;
                                        v2225 = v2224;
                                    } else {
                                        v2225 = false;
                                    }
                                    bool v2226;
                                    v2226 = v2225 == false;
                                    if (v2226){
                                        assert("Index must be in range." && v2225);
                                    } else {
                                    }
                                    int v2228;
                                    v2228 = v1920[v2221];
                                    bool v2230;
                                    v2230 = v1925 == v2221;
                                    int v2231;
                                    if (v2230){
                                        v2231 = v2218;
                                    } else {
                                        v2231 = v2228;
                                    }
                                    v2219[v2221] = v2231;
                                    v2221 += 1 ;
                                }
                                static_array<int,2> v2232;
                                int v2234;
                                v2234 = 0;
                                while (while_method_0(v2234)){
                                    bool v2236;
                                    v2236 = 0 <= v2234;
                                    bool v2238;
                                    if (v2236){
                                        bool v2237;
                                        v2237 = v2234 < 2;
                                        v2238 = v2237;
                                    } else {
                                        v2238 = false;
                                    }
                                    bool v2239;
                                    v2239 = v2238 == false;
                                    if (v2239){
                                        assert("Index must be in range." && v2238);
                                    } else {
                                    }
                                    int v2241;
                                    v2241 = v2132[v2234];
                                    bool v2244;
                                    if (v2236){
                                        bool v2243;
                                        v2243 = v2234 < 2;
                                        v2244 = v2243;
                                    } else {
                                        v2244 = false;
                                    }
                                    bool v2245;
                                    v2245 = v2244 == false;
                                    if (v2245){
                                        assert("Index must be in range." && v2244);
                                    } else {
                                    }
                                    int v2247;
                                    v2247 = v2219[v2234];
                                    int v2249;
                                    v2249 = v2241 - v2247;
                                    v2232[v2234] = v2249;
                                    v2234 += 1 ;
                                }
                                bool v2250;
                                v2250 = v2208 >= v1918;
                                int v2251;
                                if (v2250){
                                    v2251 = v2208;
                                } else {
                                    v2251 = v1918;
                                }
                                int v2252;
                                v2252 = v1921 + 1;
                                v2257 = try_round_36(v2251, v1919, v2219, v2252, v2232, v1923);
                                break;
                            }
                            case 1: { // A_Call
                                static_array<int,2> v1928;
                                int v1930;
                                v1930 = 0;
                                while (while_method_0(v1930)){
                                    bool v1932;
                                    v1932 = 0 <= v1930;
                                    bool v1934;
                                    if (v1932){
                                        bool v1933;
                                        v1933 = v1930 < 2;
                                        v1934 = v1933;
                                    } else {
                                        v1934 = false;
                                    }
                                    bool v1935;
                                    v1935 = v1934 == false;
                                    if (v1935){
                                        assert("Index must be in range." && v1934);
                                    } else {
                                    }
                                    int v1937;
                                    v1937 = v1922[v1930];
                                    bool v1940;
                                    if (v1932){
                                        bool v1939;
                                        v1939 = v1930 < 2;
                                        v1940 = v1939;
                                    } else {
                                        v1940 = false;
                                    }
                                    bool v1941;
                                    v1941 = v1940 == false;
                                    if (v1941){
                                        assert("Index must be in range." && v1940);
                                    } else {
                                    }
                                    int v1943;
                                    v1943 = v1920[v1930];
                                    int v1945;
                                    v1945 = v1937 + v1943;
                                    v1928[v1930] = v1945;
                                    v1930 += 1 ;
                                }
                                int v1946;
                                v1946 = v1920[0];
                                int v1948; int v1949;
                                Tuple4 tmp53 = Tuple4{1, v1946};
                                v1948 = tmp53.v0; v1949 = tmp53.v1;
                                while (while_method_0(v1948)){
                                    bool v1951;
                                    v1951 = 0 <= v1948;
                                    bool v1953;
                                    if (v1951){
                                        bool v1952;
                                        v1952 = v1948 < 2;
                                        v1953 = v1952;
                                    } else {
                                        v1953 = false;
                                    }
                                    bool v1954;
                                    v1954 = v1953 == false;
                                    if (v1954){
                                        assert("Index must be in range." && v1953);
                                    } else {
                                    }
                                    int v1956;
                                    v1956 = v1920[v1948];
                                    bool v1958;
                                    v1958 = v1949 >= v1956;
                                    int v1959;
                                    if (v1958){
                                        v1959 = v1949;
                                    } else {
                                        v1959 = v1956;
                                    }
                                    v1949 = v1959;
                                    v1948 += 1 ;
                                }
                                bool v1960;
                                v1960 = 0 <= v1925;
                                bool v1962;
                                if (v1960){
                                    bool v1961;
                                    v1961 = v1925 < 2;
                                    v1962 = v1961;
                                } else {
                                    v1962 = false;
                                }
                                bool v1963;
                                v1963 = v1962 == false;
                                if (v1963){
                                    assert("Index must be in range." && v1962);
                                } else {
                                }
                                int v1965;
                                v1965 = v1928[v1925];
                                bool v1967;
                                v1967 = v1949 < v1965;
                                int v1968;
                                if (v1967){
                                    v1968 = v1949;
                                } else {
                                    v1968 = v1965;
                                }
                                static_array<int,2> v1969;
                                int v1971;
                                v1971 = 0;
                                while (while_method_0(v1971)){
                                    bool v1973;
                                    v1973 = 0 <= v1971;
                                    bool v1975;
                                    if (v1973){
                                        bool v1974;
                                        v1974 = v1971 < 2;
                                        v1975 = v1974;
                                    } else {
                                        v1975 = false;
                                    }
                                    bool v1976;
                                    v1976 = v1975 == false;
                                    if (v1976){
                                        assert("Index must be in range." && v1975);
                                    } else {
                                    }
                                    int v1978;
                                    v1978 = v1920[v1971];
                                    bool v1980;
                                    v1980 = v1925 == v1971;
                                    int v1981;
                                    if (v1980){
                                        v1981 = v1968;
                                    } else {
                                        v1981 = v1978;
                                    }
                                    v1969[v1971] = v1981;
                                    v1971 += 1 ;
                                }
                                static_array<int,2> v1982;
                                int v1984;
                                v1984 = 0;
                                while (while_method_0(v1984)){
                                    bool v1986;
                                    v1986 = 0 <= v1984;
                                    bool v1988;
                                    if (v1986){
                                        bool v1987;
                                        v1987 = v1984 < 2;
                                        v1988 = v1987;
                                    } else {
                                        v1988 = false;
                                    }
                                    bool v1989;
                                    v1989 = v1988 == false;
                                    if (v1989){
                                        assert("Index must be in range." && v1988);
                                    } else {
                                    }
                                    int v1991;
                                    v1991 = v1928[v1984];
                                    bool v1994;
                                    if (v1986){
                                        bool v1993;
                                        v1993 = v1984 < 2;
                                        v1994 = v1993;
                                    } else {
                                        v1994 = false;
                                    }
                                    bool v1995;
                                    v1995 = v1994 == false;
                                    if (v1995){
                                        assert("Index must be in range." && v1994);
                                    } else {
                                    }
                                    int v1997;
                                    v1997 = v1969[v1984];
                                    int v1999;
                                    v1999 = v1991 - v1997;
                                    v1982[v1984] = v1999;
                                    v1984 += 1 ;
                                }
                                bool v2000;
                                v2000 = v1925 < 2;
                                if (v2000){
                                    int v2001;
                                    v2001 = v1921 + 1;
                                    v2257 = try_round_36(v1918, v1919, v1969, v2001, v1982, v1923);
                                } else {
                                    v2257 = go_next_street_38(v1918, v1919, v1969, v1921, v1982, v1923);
                                }
                                break;
                            }
                            case 2: { // A_Fold
                                v2257 = Union4{Union4_1{v1918, v1919, v1920, v1921, v1922, v1923}};
                                break;
                            }
                            case 3: { // A_Raise
                                int v2005 = v1924.case3.v0;
                                bool v2006;
                                v2006 = v1918 <= v2005;
                                bool v2007;
                                v2007 = v2006 == false;
                                if (v2007){
                                    assert("The raise amount must match the minimum." && v2006);
                                } else {
                                }
                                static_array<int,2> v2009;
                                int v2011;
                                v2011 = 0;
                                while (while_method_0(v2011)){
                                    bool v2013;
                                    v2013 = 0 <= v2011;
                                    bool v2015;
                                    if (v2013){
                                        bool v2014;
                                        v2014 = v2011 < 2;
                                        v2015 = v2014;
                                    } else {
                                        v2015 = false;
                                    }
                                    bool v2016;
                                    v2016 = v2015 == false;
                                    if (v2016){
                                        assert("Index must be in range." && v2015);
                                    } else {
                                    }
                                    int v2018;
                                    v2018 = v1922[v2011];
                                    bool v2021;
                                    if (v2013){
                                        bool v2020;
                                        v2020 = v2011 < 2;
                                        v2021 = v2020;
                                    } else {
                                        v2021 = false;
                                    }
                                    bool v2022;
                                    v2022 = v2021 == false;
                                    if (v2022){
                                        assert("Index must be in range." && v2021);
                                    } else {
                                    }
                                    int v2024;
                                    v2024 = v1920[v2011];
                                    int v2026;
                                    v2026 = v2018 + v2024;
                                    v2009[v2011] = v2026;
                                    v2011 += 1 ;
                                }
                                int v2027;
                                v2027 = v1920[0];
                                int v2029; int v2030;
                                Tuple4 tmp54 = Tuple4{1, v2027};
                                v2029 = tmp54.v0; v2030 = tmp54.v1;
                                while (while_method_0(v2029)){
                                    bool v2032;
                                    v2032 = 0 <= v2029;
                                    bool v2034;
                                    if (v2032){
                                        bool v2033;
                                        v2033 = v2029 < 2;
                                        v2034 = v2033;
                                    } else {
                                        v2034 = false;
                                    }
                                    bool v2035;
                                    v2035 = v2034 == false;
                                    if (v2035){
                                        assert("Index must be in range." && v2034);
                                    } else {
                                    }
                                    int v2037;
                                    v2037 = v1920[v2029];
                                    bool v2039;
                                    v2039 = v2030 >= v2037;
                                    int v2040;
                                    if (v2039){
                                        v2040 = v2030;
                                    } else {
                                        v2040 = v2037;
                                    }
                                    v2030 = v2040;
                                    v2029 += 1 ;
                                }
                                bool v2041;
                                v2041 = 0 <= v1925;
                                bool v2043;
                                if (v2041){
                                    bool v2042;
                                    v2042 = v1925 < 2;
                                    v2043 = v2042;
                                } else {
                                    v2043 = false;
                                }
                                bool v2044;
                                v2044 = v2043 == false;
                                if (v2044){
                                    assert("Index must be in range." && v2043);
                                } else {
                                }
                                int v2046;
                                v2046 = v2009[v1925];
                                bool v2048;
                                v2048 = v2030 < v2046;
                                int v2049;
                                if (v2048){
                                    v2049 = v2030;
                                } else {
                                    v2049 = v2046;
                                }
                                static_array<int,2> v2050;
                                int v2052;
                                v2052 = 0;
                                while (while_method_0(v2052)){
                                    bool v2054;
                                    v2054 = 0 <= v2052;
                                    bool v2056;
                                    if (v2054){
                                        bool v2055;
                                        v2055 = v2052 < 2;
                                        v2056 = v2055;
                                    } else {
                                        v2056 = false;
                                    }
                                    bool v2057;
                                    v2057 = v2056 == false;
                                    if (v2057){
                                        assert("Index must be in range." && v2056);
                                    } else {
                                    }
                                    int v2059;
                                    v2059 = v1920[v2052];
                                    bool v2061;
                                    v2061 = v1925 == v2052;
                                    int v2062;
                                    if (v2061){
                                        v2062 = v2049;
                                    } else {
                                        v2062 = v2059;
                                    }
                                    v2050[v2052] = v2062;
                                    v2052 += 1 ;
                                }
                                static_array<int,2> v2063;
                                int v2065;
                                v2065 = 0;
                                while (while_method_0(v2065)){
                                    bool v2067;
                                    v2067 = 0 <= v2065;
                                    bool v2069;
                                    if (v2067){
                                        bool v2068;
                                        v2068 = v2065 < 2;
                                        v2069 = v2068;
                                    } else {
                                        v2069 = false;
                                    }
                                    bool v2070;
                                    v2070 = v2069 == false;
                                    if (v2070){
                                        assert("Index must be in range." && v2069);
                                    } else {
                                    }
                                    int v2072;
                                    v2072 = v2009[v2065];
                                    bool v2075;
                                    if (v2067){
                                        bool v2074;
                                        v2074 = v2065 < 2;
                                        v2075 = v2074;
                                    } else {
                                        v2075 = false;
                                    }
                                    bool v2076;
                                    v2076 = v2075 == false;
                                    if (v2076){
                                        assert("Index must be in range." && v2075);
                                    } else {
                                    }
                                    int v2078;
                                    v2078 = v2050[v2065];
                                    int v2080;
                                    v2080 = v2072 - v2078;
                                    v2063[v2065] = v2080;
                                    v2065 += 1 ;
                                }
                                bool v2082;
                                if (v2041){
                                    bool v2081;
                                    v2081 = v1925 < 2;
                                    v2082 = v2081;
                                } else {
                                    v2082 = false;
                                }
                                bool v2083;
                                v2083 = v2082 == false;
                                if (v2083){
                                    assert("Index must be in range." && v2082);
                                } else {
                                }
                                int v2085;
                                v2085 = v2063[v1925];
                                bool v2087;
                                v2087 = v2005 < v2085;
                                bool v2088;
                                v2088 = v2087 == false;
                                if (v2088){
                                    assert("The raise amount must be less than the stack size after calling." && v2087);
                                } else {
                                }
                                int v2090;
                                v2090 = v2030 + v2005;
                                bool v2092;
                                if (v2041){
                                    bool v2091;
                                    v2091 = v1925 < 2;
                                    v2092 = v2091;
                                } else {
                                    v2092 = false;
                                }
                                bool v2093;
                                v2093 = v2092 == false;
                                if (v2093){
                                    assert("Index must be in range." && v2092);
                                } else {
                                }
                                int v2095;
                                v2095 = v2009[v1925];
                                bool v2097;
                                v2097 = v2090 < v2095;
                                int v2098;
                                if (v2097){
                                    v2098 = v2090;
                                } else {
                                    v2098 = v2095;
                                }
                                static_array<int,2> v2099;
                                int v2101;
                                v2101 = 0;
                                while (while_method_0(v2101)){
                                    bool v2103;
                                    v2103 = 0 <= v2101;
                                    bool v2105;
                                    if (v2103){
                                        bool v2104;
                                        v2104 = v2101 < 2;
                                        v2105 = v2104;
                                    } else {
                                        v2105 = false;
                                    }
                                    bool v2106;
                                    v2106 = v2105 == false;
                                    if (v2106){
                                        assert("Index must be in range." && v2105);
                                    } else {
                                    }
                                    int v2108;
                                    v2108 = v1920[v2101];
                                    bool v2110;
                                    v2110 = v1925 == v2101;
                                    int v2111;
                                    if (v2110){
                                        v2111 = v2098;
                                    } else {
                                        v2111 = v2108;
                                    }
                                    v2099[v2101] = v2111;
                                    v2101 += 1 ;
                                }
                                static_array<int,2> v2112;
                                int v2114;
                                v2114 = 0;
                                while (while_method_0(v2114)){
                                    bool v2116;
                                    v2116 = 0 <= v2114;
                                    bool v2118;
                                    if (v2116){
                                        bool v2117;
                                        v2117 = v2114 < 2;
                                        v2118 = v2117;
                                    } else {
                                        v2118 = false;
                                    }
                                    bool v2119;
                                    v2119 = v2118 == false;
                                    if (v2119){
                                        assert("Index must be in range." && v2118);
                                    } else {
                                    }
                                    int v2121;
                                    v2121 = v2009[v2114];
                                    bool v2124;
                                    if (v2116){
                                        bool v2123;
                                        v2123 = v2114 < 2;
                                        v2124 = v2123;
                                    } else {
                                        v2124 = false;
                                    }
                                    bool v2125;
                                    v2125 = v2124 == false;
                                    if (v2125){
                                        assert("Index must be in range." && v2124);
                                    } else {
                                    }
                                    int v2127;
                                    v2127 = v2099[v2114];
                                    int v2129;
                                    v2129 = v2121 - v2127;
                                    v2112[v2114] = v2129;
                                    v2114 += 1 ;
                                }
                                int v2130;
                                v2130 = v1921 + 1;
                                v2257 = try_round_36(v2005, v1919, v2099, v2130, v2112, v1923);
                                break;
                            }
                            default: {
                                assert("Invalid tag." && false); __trap();
                            }
                        }
                        v2401 = Union3{Union3_1{v2257}};
                        break;
                    }
                    case 6: { // G_Showdown
                        int v31 = v10.case6.v0; static_array<static_array<unsigned char,2>,2> v32 = v10.case6.v1; static_array<int,2> v33 = v10.case6.v2; int v34 = v10.case6.v3; static_array<int,2> v35 = v10.case6.v4; Union5 v36 = v10.case6.v5;
                        static_array<unsigned char,5> v39;
                        switch (v36.tag) {
                            case 2: { // River
                                static_array<unsigned char,5> v37 = v36.case2.v0;
                                v39 = v37;
                                break;
                            }
                            default: {
                                printf("%s\n", "Invalid street in showdown.");
                                __trap();
                            }
                        }
                        static_array<unsigned char,2> v40;
                        v40 = v32[0];
                        static_array<unsigned char,7> v42;
                        int v44;
                        v44 = 0;
                        while (while_method_0(v44)){
                            bool v46;
                            v46 = 0 <= v44;
                            bool v48;
                            if (v46){
                                bool v47;
                                v47 = v44 < 2;
                                v48 = v47;
                            } else {
                                v48 = false;
                            }
                            bool v49;
                            v49 = v48 == false;
                            if (v49){
                                assert("Index must be in range." && v48);
                            } else {
                            }
                            unsigned char v51;
                            v51 = v40[v44];
                            v42[v44] = v51;
                            v44 += 1 ;
                        }
                        int v53;
                        v53 = 0;
                        while (while_method_2(v53)){
                            bool v55;
                            v55 = 0 <= v53;
                            bool v57;
                            if (v55){
                                bool v56;
                                v56 = v53 < 5;
                                v57 = v56;
                            } else {
                                v57 = false;
                            }
                            bool v58;
                            v58 = v57 == false;
                            if (v58){
                                assert("Index must be in range." && v57);
                            } else {
                            }
                            unsigned char v60;
                            v60 = v39[v53];
                            int v62;
                            v62 = 2 + v53;
                            v42[v62] = v60;
                            v53 += 1 ;
                        }
                        static_array<unsigned char,5> v63; char v64;
                        Tuple0 tmp79 = score_54(v42);
                        v63 = tmp79.v0; v64 = tmp79.v1;
                        static_array<unsigned char,2> v65;
                        v65 = v32[1];
                        static_array<unsigned char,7> v67;
                        int v69;
                        v69 = 0;
                        while (while_method_0(v69)){
                            bool v71;
                            v71 = 0 <= v69;
                            bool v73;
                            if (v71){
                                bool v72;
                                v72 = v69 < 2;
                                v73 = v72;
                            } else {
                                v73 = false;
                            }
                            bool v74;
                            v74 = v73 == false;
                            if (v74){
                                assert("Index must be in range." && v73);
                            } else {
                            }
                            unsigned char v76;
                            v76 = v65[v69];
                            v67[v69] = v76;
                            v69 += 1 ;
                        }
                        int v78;
                        v78 = 0;
                        while (while_method_2(v78)){
                            bool v80;
                            v80 = 0 <= v78;
                            bool v82;
                            if (v80){
                                bool v81;
                                v81 = v78 < 5;
                                v82 = v81;
                            } else {
                                v82 = false;
                            }
                            bool v83;
                            v83 = v82 == false;
                            if (v83){
                                assert("Index must be in range." && v82);
                            } else {
                            }
                            unsigned char v85;
                            v85 = v39[v78];
                            int v87;
                            v87 = 2 + v78;
                            v67[v87] = v85;
                            v78 += 1 ;
                        }
                        static_array<unsigned char,5> v88; char v89;
                        Tuple0 tmp80 = score_54(v67);
                        v88 = tmp80.v0; v89 = tmp80.v1;
                        int v90;
                        v90 = v34 % 2;
                        bool v91;
                        v91 = 0 <= v90;
                        bool v93;
                        if (v91){
                            bool v92;
                            v92 = v90 < 2;
                            v93 = v92;
                        } else {
                            v93 = false;
                        }
                        bool v94;
                        v94 = v93 == false;
                        if (v94){
                            assert("Index must be in range." && v93);
                        } else {
                        }
                        int v96;
                        v96 = v33[v90];
                        bool v98;
                        v98 = v64 < v89;
                        Union11 v104;
                        if (v98){
                            v104 = Union11{Union11_2{}};
                        } else {
                            bool v100;
                            v100 = v64 > v89;
                            if (v100){
                                v104 = Union11{Union11_1{}};
                            } else {
                                v104 = Union11{Union11_0{}};
                            }
                        }
                        Union11 v132;
                        switch (v104.tag) {
                            case 0: { // Eq
                                Union11 v105;
                                v105 = Union11{Union11_0{}};
                                int v106;
                                v106 = 0;
                                while (while_method_2(v106)){
                                    bool v108;
                                    v108 = 0 <= v106;
                                    bool v110;
                                    if (v108){
                                        bool v109;
                                        v109 = v106 < 5;
                                        v110 = v109;
                                    } else {
                                        v110 = false;
                                    }
                                    bool v111;
                                    v111 = v110 == false;
                                    if (v111){
                                        assert("Index must be in range." && v110);
                                    } else {
                                    }
                                    unsigned char v113;
                                    v113 = v63[v106];
                                    bool v116;
                                    if (v108){
                                        bool v115;
                                        v115 = v106 < 5;
                                        v116 = v115;
                                    } else {
                                        v116 = false;
                                    }
                                    bool v117;
                                    v117 = v116 == false;
                                    if (v117){
                                        assert("Index must be in range." && v116);
                                    } else {
                                    }
                                    unsigned char v119;
                                    v119 = v88[v106];
                                    unsigned char v121;
                                    v121 = v113 / 4u;
                                    unsigned char v122;
                                    v122 = v119 / 4u;
                                    bool v123;
                                    v123 = v121 < v122;
                                    Union11 v129;
                                    if (v123){
                                        v129 = Union11{Union11_2{}};
                                    } else {
                                        bool v125;
                                        v125 = v121 > v122;
                                        if (v125){
                                            v129 = Union11{Union11_1{}};
                                        } else {
                                            v129 = Union11{Union11_0{}};
                                        }
                                    }
                                    bool v130;
                                    switch (v129.tag) {
                                        case 0: { // Eq
                                            v130 = true;
                                            break;
                                        }
                                        default: {
                                            v130 = false;
                                        }
                                    }
                                    bool v131;
                                    v131 = v130 == false;
                                    if (v131){
                                        v105 = v129;
                                        break;
                                    } else {
                                    }
                                    v106 += 1 ;
                                }
                                v132 = v105;
                                break;
                            }
                            default: {
                                v132 = v104;
                            }
                        }
                        int v137; int v138;
                        switch (v132.tag) {
                            case 0: { // Eq
                                v137 = 0; v138 = -1;
                                break;
                            }
                            case 1: { // Gt
                                v137 = v96; v138 = 0;
                                break;
                            }
                            case 2: { // Lt
                                v137 = v96; v138 = 1;
                                break;
                            }
                            default: {
                                assert("Invalid tag." && false); __trap();
                            }
                        }
                        static_array<Tuple0,2> v139;
                        v139[0] = Tuple0{v63, v64};
                        v139[1] = Tuple0{v88, v89};
                        Union6 v141;
                        v141 = Union6{Union6_4{v137, v139, v138}};
                        v5.push(v141);
                        Union7 v142;
                        v142 = Union7{Union7_1{v31, v32, v33, v34, v35, v36}};
                        v3.v5 = v142;
                        Union3 v143;
                        v143 = Union3{Union3_0{}};
                        v3.v1 = v143;
                        v2401 = Union3{Union3_0{}};
                        break;
                    }
                    case 7: { // G_Turn
                        int v2278 = v10.case7.v0; static_array<static_array<unsigned char,2>,2> v2279 = v10.case7.v1; static_array<int,2> v2280 = v10.case7.v2; int v2281 = v10.case7.v3; static_array<int,2> v2282 = v10.case7.v4; Union5 v2283 = v10.case7.v5;
                        curandStatePhilox4_32_10_t & v2284 = v3.v4;
                        curandStatePhilox4_32_10_t & v2285 = v2284;
                        static_array<unsigned char,1> v2286; unsigned long long v2287;
                        Tuple12 tmp81 = draw_cards_40(v2285, v6);
                        v2286 = tmp81.v0; v2287 = tmp81.v1;
                        v3.v0 = v2287;
                        static_array_list<unsigned char,5> v2288;
                        v2288 = get_community_cards_41(v2283, v2286);
                        Union6 v2289;
                        v2289 = Union6{Union6_0{v2288}};
                        v5.push(v2289);
                        Union5 v2314;
                        switch (v2283.tag) {
                            case 0: { // Flop
                                static_array<unsigned char,3> v2290 = v2283.case0.v0;
                                static_array<unsigned char,4> v2291;
                                int v2293;
                                v2293 = 0;
                                while (while_method_1(v2293)){
                                    bool v2295;
                                    v2295 = 0 <= v2293;
                                    bool v2297;
                                    if (v2295){
                                        bool v2296;
                                        v2296 = v2293 < 3;
                                        v2297 = v2296;
                                    } else {
                                        v2297 = false;
                                    }
                                    bool v2298;
                                    v2298 = v2297 == false;
                                    if (v2298){
                                        assert("Index must be in range." && v2297);
                                    } else {
                                    }
                                    unsigned char v2300;
                                    v2300 = v2290[v2293];
                                    v2291[v2293] = v2300;
                                    v2293 += 1 ;
                                }
                                int v2302;
                                v2302 = 0;
                                while (while_method_6(v2302)){
                                    bool v2304;
                                    v2304 = 0 <= v2302;
                                    bool v2306;
                                    if (v2304){
                                        bool v2305;
                                        v2305 = v2302 < 1;
                                        v2306 = v2305;
                                    } else {
                                        v2306 = false;
                                    }
                                    bool v2307;
                                    v2307 = v2306 == false;
                                    if (v2307){
                                        assert("Index must be in range." && v2306);
                                    } else {
                                    }
                                    unsigned char v2309;
                                    v2309 = v2286[v2302];
                                    int v2311;
                                    v2311 = 3 + v2302;
                                    v2291[v2311] = v2309;
                                    v2302 += 1 ;
                                }
                                v2314 = Union5{Union5_3{v2291}};
                                break;
                            }
                            default: {
                                printf("%s\n", "Invalid street in turn.");
                                __trap();
                            }
                        }
                        int v2315;
                        v2315 = 2;
                        int v2316;
                        v2316 = 0;
                        Union4 v2317;
                        v2317 = try_round_36(v2315, v2279, v2280, v2316, v2282, v2314);
                        v2401 = Union3{Union3_1{v2317}};
                        break;
                    }
                    default: {
                        assert("Invalid tag." && false); __trap();
                    }
                }
                break;
            }
            default: {
                assert("Invalid tag." && false); __trap();
            }
        }
        v8 = v2401;
    }
    return ;
}
__device__ void f_56(unsigned char * v0, unsigned long long v1){
    unsigned long long * v2;
    v2 = (unsigned long long *)(v0+0ull);
    v2[0] = v1;
    return ;
}
__device__ void f_57(unsigned char * v0, int v1){
    int * v2;
    v2 = (int *)(v0+8ull);
    v2[0] = v1;
    return ;
}
__device__ void f_58(unsigned char * v0){
    return ;
}
__device__ void f_60(unsigned char * v0, int v1){
    int * v2;
    v2 = (int *)(v0+0ull);
    v2[0] = v1;
    return ;
}
__device__ void f_64(unsigned char * v0, unsigned char v1){
    unsigned char * v2;
    v2 = (unsigned char *)(v0+0ull);
    v2[0] = v1;
    return ;
}
__device__ void f_63(unsigned char * v0, unsigned char v1){
    return f_64(v0, v1);
}
__device__ void f_62(unsigned char * v0, static_array<unsigned char,2> v1){
    int v2;
    v2 = 0;
    while (while_method_0(v2)){
        unsigned long long v4;
        v4 = (unsigned long long)v2;
        unsigned char * v5;
        v5 = (unsigned char *)(v0+v4);
        bool v7;
        v7 = 0 <= v2;
        bool v9;
        if (v7){
            bool v8;
            v8 = v2 < 2;
            v9 = v8;
        } else {
            v9 = false;
        }
        bool v10;
        v10 = v9 == false;
        if (v10){
            assert("Index must be in range." && v9);
        } else {
        }
        unsigned char v12;
        v12 = v1[v2];
        f_63(v5, v12);
        v2 += 1 ;
    }
    return ;
}
__device__ void f_65(unsigned char * v0, int v1){
    int * v2;
    v2 = (int *)(v0+28ull);
    v2[0] = v1;
    return ;
}
__device__ void f_66(unsigned char * v0, static_array<unsigned char,3> v1){
    int v2;
    v2 = 0;
    while (while_method_1(v2)){
        unsigned long long v4;
        v4 = (unsigned long long)v2;
        unsigned char * v5;
        v5 = (unsigned char *)(v0+v4);
        bool v7;
        v7 = 0 <= v2;
        bool v9;
        if (v7){
            bool v8;
            v8 = v2 < 3;
            v9 = v8;
        } else {
            v9 = false;
        }
        bool v10;
        v10 = v9 == false;
        if (v10){
            assert("Index must be in range." && v9);
        } else {
        }
        unsigned char v12;
        v12 = v1[v2];
        f_63(v5, v12);
        v2 += 1 ;
    }
    return ;
}
__device__ void f_67(unsigned char * v0, static_array<unsigned char,5> v1){
    int v2;
    v2 = 0;
    while (while_method_2(v2)){
        unsigned long long v4;
        v4 = (unsigned long long)v2;
        unsigned char * v5;
        v5 = (unsigned char *)(v0+v4);
        bool v7;
        v7 = 0 <= v2;
        bool v9;
        if (v7){
            bool v8;
            v8 = v2 < 5;
            v9 = v8;
        } else {
            v9 = false;
        }
        bool v10;
        v10 = v9 == false;
        if (v10){
            assert("Index must be in range." && v9);
        } else {
        }
        unsigned char v12;
        v12 = v1[v2];
        f_63(v5, v12);
        v2 += 1 ;
    }
    return ;
}
__device__ void f_68(unsigned char * v0, static_array<unsigned char,4> v1){
    int v2;
    v2 = 0;
    while (while_method_3(v2)){
        unsigned long long v4;
        v4 = (unsigned long long)v2;
        unsigned char * v5;
        v5 = (unsigned char *)(v0+v4);
        bool v7;
        v7 = 0 <= v2;
        bool v9;
        if (v7){
            bool v8;
            v8 = v2 < 4;
            v9 = v8;
        } else {
            v9 = false;
        }
        bool v10;
        v10 = v9 == false;
        if (v10){
            assert("Index must be in range." && v9);
        } else {
        }
        unsigned char v12;
        v12 = v1[v2];
        f_63(v5, v12);
        v2 += 1 ;
    }
    return ;
}
__device__ void f_61(unsigned char * v0, int v1, static_array<static_array<unsigned char,2>,2> v2, static_array<int,2> v3, int v4, static_array<int,2> v5, Union5 v6){
    int * v7;
    v7 = (int *)(v0+0ull);
    v7[0] = v1;
    int v9;
    v9 = 0;
    while (while_method_0(v9)){
        unsigned long long v11;
        v11 = (unsigned long long)v9;
        unsigned long long v12;
        v12 = v11 * 2ull;
        unsigned long long v13;
        v13 = 4ull + v12;
        unsigned char * v14;
        v14 = (unsigned char *)(v0+v13);
        bool v16;
        v16 = 0 <= v9;
        bool v18;
        if (v16){
            bool v17;
            v17 = v9 < 2;
            v18 = v17;
        } else {
            v18 = false;
        }
        bool v19;
        v19 = v18 == false;
        if (v19){
            assert("Index must be in range." && v18);
        } else {
        }
        static_array<unsigned char,2> v21;
        v21 = v2[v9];
        f_62(v14, v21);
        v9 += 1 ;
    }
    int v23;
    v23 = 0;
    while (while_method_0(v23)){
        unsigned long long v25;
        v25 = (unsigned long long)v23;
        unsigned long long v26;
        v26 = v25 * 4ull;
        unsigned long long v27;
        v27 = 8ull + v26;
        unsigned char * v28;
        v28 = (unsigned char *)(v0+v27);
        bool v30;
        v30 = 0 <= v23;
        bool v32;
        if (v30){
            bool v31;
            v31 = v23 < 2;
            v32 = v31;
        } else {
            v32 = false;
        }
        bool v33;
        v33 = v32 == false;
        if (v33){
            assert("Index must be in range." && v32);
        } else {
        }
        int v35;
        v35 = v3[v23];
        f_60(v28, v35);
        v23 += 1 ;
    }
    int * v37;
    v37 = (int *)(v0+16ull);
    v37[0] = v4;
    int v39;
    v39 = 0;
    while (while_method_0(v39)){
        unsigned long long v41;
        v41 = (unsigned long long)v39;
        unsigned long long v42;
        v42 = v41 * 4ull;
        unsigned long long v43;
        v43 = 20ull + v42;
        unsigned char * v44;
        v44 = (unsigned char *)(v0+v43);
        bool v46;
        v46 = 0 <= v39;
        bool v48;
        if (v46){
            bool v47;
            v47 = v39 < 2;
            v48 = v47;
        } else {
            v48 = false;
        }
        bool v49;
        v49 = v48 == false;
        if (v49){
            assert("Index must be in range." && v48);
        } else {
        }
        int v51;
        v51 = v5[v39];
        f_60(v44, v51);
        v39 += 1 ;
    }
    int v53;
    v53 = v6.tag;
    f_65(v0, v53);
    unsigned char * v54;
    v54 = (unsigned char *)(v0+32ull);
    switch (v6.tag) {
        case 0: { // Flop
            static_array<unsigned char,3> v56 = v6.case0.v0;
            return f_66(v54, v56);
            break;
        }
        case 1: { // Preflop
            return f_58(v54);
            break;
        }
        case 2: { // River
            static_array<unsigned char,5> v57 = v6.case2.v0;
            return f_67(v54, v57);
            break;
        }
        case 3: { // Turn
            static_array<unsigned char,4> v58 = v6.case3.v0;
            return f_68(v54, v58);
            break;
        }
        default: {
            assert("Invalid tag." && false); __trap();
        }
    }
}
__device__ void f_70(unsigned char * v0, int v1){
    int * v2;
    v2 = (int *)(v0+40ull);
    v2[0] = v1;
    return ;
}
__device__ void f_69(unsigned char * v0, int v1, static_array<static_array<unsigned char,2>,2> v2, static_array<int,2> v3, int v4, static_array<int,2> v5, Union5 v6, Union1 v7){
    int * v8;
    v8 = (int *)(v0+0ull);
    v8[0] = v1;
    int v10;
    v10 = 0;
    while (while_method_0(v10)){
        unsigned long long v12;
        v12 = (unsigned long long)v10;
        unsigned long long v13;
        v13 = v12 * 2ull;
        unsigned long long v14;
        v14 = 4ull + v13;
        unsigned char * v15;
        v15 = (unsigned char *)(v0+v14);
        bool v17;
        v17 = 0 <= v10;
        bool v19;
        if (v17){
            bool v18;
            v18 = v10 < 2;
            v19 = v18;
        } else {
            v19 = false;
        }
        bool v20;
        v20 = v19 == false;
        if (v20){
            assert("Index must be in range." && v19);
        } else {
        }
        static_array<unsigned char,2> v22;
        v22 = v2[v10];
        f_62(v15, v22);
        v10 += 1 ;
    }
    int v24;
    v24 = 0;
    while (while_method_0(v24)){
        unsigned long long v26;
        v26 = (unsigned long long)v24;
        unsigned long long v27;
        v27 = v26 * 4ull;
        unsigned long long v28;
        v28 = 8ull + v27;
        unsigned char * v29;
        v29 = (unsigned char *)(v0+v28);
        bool v31;
        v31 = 0 <= v24;
        bool v33;
        if (v31){
            bool v32;
            v32 = v24 < 2;
            v33 = v32;
        } else {
            v33 = false;
        }
        bool v34;
        v34 = v33 == false;
        if (v34){
            assert("Index must be in range." && v33);
        } else {
        }
        int v36;
        v36 = v3[v24];
        f_60(v29, v36);
        v24 += 1 ;
    }
    int * v38;
    v38 = (int *)(v0+16ull);
    v38[0] = v4;
    int v40;
    v40 = 0;
    while (while_method_0(v40)){
        unsigned long long v42;
        v42 = (unsigned long long)v40;
        unsigned long long v43;
        v43 = v42 * 4ull;
        unsigned long long v44;
        v44 = 20ull + v43;
        unsigned char * v45;
        v45 = (unsigned char *)(v0+v44);
        bool v47;
        v47 = 0 <= v40;
        bool v49;
        if (v47){
            bool v48;
            v48 = v40 < 2;
            v49 = v48;
        } else {
            v49 = false;
        }
        bool v50;
        v50 = v49 == false;
        if (v50){
            assert("Index must be in range." && v49);
        } else {
        }
        int v52;
        v52 = v5[v40];
        f_60(v45, v52);
        v40 += 1 ;
    }
    int v54;
    v54 = v6.tag;
    f_65(v0, v54);
    unsigned char * v55;
    v55 = (unsigned char *)(v0+32ull);
    switch (v6.tag) {
        case 0: { // Flop
            static_array<unsigned char,3> v57 = v6.case0.v0;
            f_66(v55, v57);
            break;
        }
        case 1: { // Preflop
            f_58(v55);
            break;
        }
        case 2: { // River
            static_array<unsigned char,5> v58 = v6.case2.v0;
            f_67(v55, v58);
            break;
        }
        case 3: { // Turn
            static_array<unsigned char,4> v59 = v6.case3.v0;
            f_68(v55, v59);
            break;
        }
        default: {
            assert("Invalid tag." && false); __trap();
        }
    }
    int v60;
    v60 = v7.tag;
    f_70(v0, v60);
    unsigned char * v61;
    v61 = (unsigned char *)(v0+44ull);
    switch (v7.tag) {
        case 0: { // A_All_In
            return f_58(v61);
            break;
        }
        case 1: { // A_Call
            return f_58(v61);
            break;
        }
        case 2: { // A_Fold
            return f_58(v61);
            break;
        }
        case 3: { // A_Raise
            int v63 = v7.case3.v0;
            return f_60(v61, v63);
            break;
        }
        default: {
            assert("Invalid tag." && false); __trap();
        }
    }
}
__device__ void f_59(unsigned char * v0, Union4 v1){
    int v2;
    v2 = v1.tag;
    f_60(v0, v2);
    unsigned char * v3;
    v3 = (unsigned char *)(v0+16ull);
    switch (v1.tag) {
        case 0: { // G_Flop
            int v5 = v1.case0.v0; static_array<static_array<unsigned char,2>,2> v6 = v1.case0.v1; static_array<int,2> v7 = v1.case0.v2; int v8 = v1.case0.v3; static_array<int,2> v9 = v1.case0.v4; Union5 v10 = v1.case0.v5;
            return f_61(v3, v5, v6, v7, v8, v9, v10);
            break;
        }
        case 1: { // G_Fold
            int v11 = v1.case1.v0; static_array<static_array<unsigned char,2>,2> v12 = v1.case1.v1; static_array<int,2> v13 = v1.case1.v2; int v14 = v1.case1.v3; static_array<int,2> v15 = v1.case1.v4; Union5 v16 = v1.case1.v5;
            return f_61(v3, v11, v12, v13, v14, v15, v16);
            break;
        }
        case 2: { // G_Preflop
            return f_58(v3);
            break;
        }
        case 3: { // G_River
            int v17 = v1.case3.v0; static_array<static_array<unsigned char,2>,2> v18 = v1.case3.v1; static_array<int,2> v19 = v1.case3.v2; int v20 = v1.case3.v3; static_array<int,2> v21 = v1.case3.v4; Union5 v22 = v1.case3.v5;
            return f_61(v3, v17, v18, v19, v20, v21, v22);
            break;
        }
        case 4: { // G_Round
            int v23 = v1.case4.v0; static_array<static_array<unsigned char,2>,2> v24 = v1.case4.v1; static_array<int,2> v25 = v1.case4.v2; int v26 = v1.case4.v3; static_array<int,2> v27 = v1.case4.v4; Union5 v28 = v1.case4.v5;
            return f_61(v3, v23, v24, v25, v26, v27, v28);
            break;
        }
        case 5: { // G_Round'
            int v29 = v1.case5.v0; static_array<static_array<unsigned char,2>,2> v30 = v1.case5.v1; static_array<int,2> v31 = v1.case5.v2; int v32 = v1.case5.v3; static_array<int,2> v33 = v1.case5.v4; Union5 v34 = v1.case5.v5; Union1 v35 = v1.case5.v6;
            return f_69(v3, v29, v30, v31, v32, v33, v34, v35);
            break;
        }
        case 6: { // G_Showdown
            int v36 = v1.case6.v0; static_array<static_array<unsigned char,2>,2> v37 = v1.case6.v1; static_array<int,2> v38 = v1.case6.v2; int v39 = v1.case6.v3; static_array<int,2> v40 = v1.case6.v4; Union5 v41 = v1.case6.v5;
            return f_61(v3, v36, v37, v38, v39, v40, v41);
            break;
        }
        case 7: { // G_Turn
            int v42 = v1.case7.v0; static_array<static_array<unsigned char,2>,2> v43 = v1.case7.v1; static_array<int,2> v44 = v1.case7.v2; int v45 = v1.case7.v3; static_array<int,2> v46 = v1.case7.v4; Union5 v47 = v1.case7.v5;
            return f_61(v3, v42, v43, v44, v45, v46, v47);
            break;
        }
        default: {
            assert("Invalid tag." && false); __trap();
        }
    }
}
__device__ void f_71(unsigned char * v0, int v1){
    int * v2;
    v2 = (int *)(v0+80ull);
    v2[0] = v1;
    return ;
}
__device__ void f_73(unsigned char * v0, static_array_list<unsigned char,5> v1){
    int v2;
    v2 = v1.length;
    f_60(v0, v2);
    int v3;
    v3 = v1.length;
    int v4;
    v4 = 0;
    while (while_method_4(v3, v4)){
        unsigned long long v6;
        v6 = (unsigned long long)v4;
        unsigned long long v7;
        v7 = 4ull + v6;
        unsigned char * v8;
        v8 = (unsigned char *)(v0+v7);
        unsigned char v10;
        v10 = v1[v4];
        f_63(v8, v10);
        v4 += 1 ;
    }
    return ;
}
__device__ void f_74(unsigned char * v0, int v1, int v2){
    int * v3;
    v3 = (int *)(v0+0ull);
    v3[0] = v1;
    int * v5;
    v5 = (int *)(v0+4ull);
    v5[0] = v2;
    return ;
}
__device__ void f_76(unsigned char * v0, int v1){
    int * v2;
    v2 = (int *)(v0+4ull);
    v2[0] = v1;
    return ;
}
__device__ void f_75(unsigned char * v0, int v1, Union1 v2){
    int * v3;
    v3 = (int *)(v0+0ull);
    v3[0] = v1;
    int v5;
    v5 = v2.tag;
    f_76(v0, v5);
    unsigned char * v6;
    v6 = (unsigned char *)(v0+8ull);
    switch (v2.tag) {
        case 0: { // A_All_In
            return f_58(v6);
            break;
        }
        case 1: { // A_Call
            return f_58(v6);
            break;
        }
        case 2: { // A_Fold
            return f_58(v6);
            break;
        }
        case 3: { // A_Raise
            int v8 = v2.case3.v0;
            return f_60(v6, v8);
            break;
        }
        default: {
            assert("Invalid tag." && false); __trap();
        }
    }
}
__device__ void f_77(unsigned char * v0, int v1, static_array<unsigned char,2> v2){
    int * v3;
    v3 = (int *)(v0+0ull);
    v3[0] = v1;
    int v5;
    v5 = 0;
    while (while_method_0(v5)){
        unsigned long long v7;
        v7 = (unsigned long long)v5;
        unsigned long long v8;
        v8 = 4ull + v7;
        unsigned char * v9;
        v9 = (unsigned char *)(v0+v8);
        bool v11;
        v11 = 0 <= v5;
        bool v13;
        if (v11){
            bool v12;
            v12 = v5 < 2;
            v13 = v12;
        } else {
            v13 = false;
        }
        bool v14;
        v14 = v13 == false;
        if (v14){
            assert("Index must be in range." && v13);
        } else {
        }
        unsigned char v16;
        v16 = v2[v5];
        f_63(v9, v16);
        v5 += 1 ;
    }
    return ;
}
__device__ void f_80(unsigned char * v0, static_array<unsigned char,5> v1, char v2){
    int v3;
    v3 = 0;
    while (while_method_2(v3)){
        unsigned long long v5;
        v5 = (unsigned long long)v3;
        unsigned char * v6;
        v6 = (unsigned char *)(v0+v5);
        bool v8;
        v8 = 0 <= v3;
        bool v10;
        if (v8){
            bool v9;
            v9 = v3 < 5;
            v10 = v9;
        } else {
            v10 = false;
        }
        bool v11;
        v11 = v10 == false;
        if (v11){
            assert("Index must be in range." && v10);
        } else {
        }
        unsigned char v13;
        v13 = v1[v3];
        f_63(v6, v13);
        v3 += 1 ;
    }
    char * v15;
    v15 = (char *)(v0+5ull);
    v15[0] = v2;
    return ;
}
__device__ void f_79(unsigned char * v0, static_array<unsigned char,5> v1, char v2){
    return f_80(v0, v1, v2);
}
__device__ void f_78(unsigned char * v0, int v1, static_array<Tuple0,2> v2, int v3){
    int * v4;
    v4 = (int *)(v0+0ull);
    v4[0] = v1;
    int v6;
    v6 = 0;
    while (while_method_0(v6)){
        unsigned long long v8;
        v8 = (unsigned long long)v6;
        unsigned long long v9;
        v9 = v8 * 8ull;
        unsigned long long v10;
        v10 = 8ull + v9;
        unsigned char * v11;
        v11 = (unsigned char *)(v0+v10);
        bool v13;
        v13 = 0 <= v6;
        bool v15;
        if (v13){
            bool v14;
            v14 = v6 < 2;
            v15 = v14;
        } else {
            v15 = false;
        }
        bool v16;
        v16 = v15 == false;
        if (v16){
            assert("Index must be in range." && v15);
        } else {
        }
        static_array<unsigned char,5> v18; char v19;
        Tuple0 tmp82 = v2[v6];
        v18 = tmp82.v0; v19 = tmp82.v1;
        f_79(v11, v18, v19);
        v6 += 1 ;
    }
    int * v22;
    v22 = (int *)(v0+24ull);
    v22[0] = v3;
    return ;
}
__device__ void f_72(unsigned char * v0, Union6 v1){
    int v2;
    v2 = v1.tag;
    f_60(v0, v2);
    unsigned char * v3;
    v3 = (unsigned char *)(v0+16ull);
    switch (v1.tag) {
        case 0: { // CommunityCardsAre
            static_array_list<unsigned char,5> v5 = v1.case0.v0;
            return f_73(v3, v5);
            break;
        }
        case 1: { // Fold
            int v6 = v1.case1.v0; int v7 = v1.case1.v1;
            return f_74(v3, v6, v7);
            break;
        }
        case 2: { // PlayerAction
            int v8 = v1.case2.v0; Union1 v9 = v1.case2.v1;
            return f_75(v3, v8, v9);
            break;
        }
        case 3: { // PlayerGotCards
            int v10 = v1.case3.v0; static_array<unsigned char,2> v11 = v1.case3.v1;
            return f_77(v3, v10, v11);
            break;
        }
        case 4: { // Showdown
            int v12 = v1.case4.v0; static_array<Tuple0,2> v13 = v1.case4.v1; int v14 = v1.case4.v2;
            return f_78(v3, v12, v13, v14);
            break;
        }
        default: {
            assert("Invalid tag." && false); __trap();
        }
    }
}
__device__ void f_81(unsigned char * v0, Union2 v1){
    int v2;
    v2 = v1.tag;
    f_60(v0, v2);
    unsigned char * v3;
    v3 = (unsigned char *)(v0+4ull);
    switch (v1.tag) {
        case 0: { // CallingMachine
            return f_58(v3);
            break;
        }
        case 1: { // Computer
            return f_58(v3);
            break;
        }
        case 2: { // Human
            return f_58(v3);
            break;
        }
        case 3: { // Random
            return f_58(v3);
            break;
        }
        default: {
            assert("Invalid tag." && false); __trap();
        }
    }
}
__device__ void f_82(unsigned char * v0, int v1){
    int * v2;
    v2 = (int *)(v0+6248ull);
    v2[0] = v1;
    return ;
}
__device__ void f_55(unsigned char * v0, unsigned long long v1, Union3 v2, static_array_list<Union6,128> v3, static_array<Union2,2> v4, Union7 v5){
    f_56(v0, v1);
    int v6;
    v6 = v2.tag;
    f_57(v0, v6);
    unsigned char * v7;
    v7 = (unsigned char *)(v0+16ull);
    switch (v2.tag) {
        case 0: { // None
            f_58(v7);
            break;
        }
        case 1: { // Some
            Union4 v9 = v2.case1.v0;
            f_59(v7, v9);
            break;
        }
        default: {
            assert("Invalid tag." && false); __trap();
        }
    }
    int v10;
    v10 = v3.length;
    f_71(v0, v10);
    int v11;
    v11 = v3.length;
    int v12;
    v12 = 0;
    while (while_method_4(v11, v12)){
        unsigned long long v14;
        v14 = (unsigned long long)v12;
        unsigned long long v15;
        v15 = v14 * 48ull;
        unsigned long long v16;
        v16 = 96ull + v15;
        unsigned char * v17;
        v17 = (unsigned char *)(v0+v16);
        Union6 v19;
        v19 = v3[v12];
        f_72(v17, v19);
        v12 += 1 ;
    }
    int v21;
    v21 = 0;
    while (while_method_0(v21)){
        unsigned long long v23;
        v23 = (unsigned long long)v21;
        unsigned long long v24;
        v24 = v23 * 4ull;
        unsigned long long v25;
        v25 = 6240ull + v24;
        unsigned char * v26;
        v26 = (unsigned char *)(v0+v25);
        bool v28;
        v28 = 0 <= v21;
        bool v30;
        if (v28){
            bool v29;
            v29 = v21 < 2;
            v30 = v29;
        } else {
            v30 = false;
        }
        bool v31;
        v31 = v30 == false;
        if (v31){
            assert("Index must be in range." && v30);
        } else {
        }
        Union2 v33;
        v33 = v4[v21];
        f_81(v26, v33);
        v21 += 1 ;
    }
    int v35;
    v35 = v5.tag;
    f_82(v0, v35);
    unsigned char * v36;
    v36 = (unsigned char *)(v0+6256ull);
    switch (v5.tag) {
        case 0: { // GameNotStarted
            return f_58(v36);
            break;
        }
        case 1: { // GameOver
            int v38 = v5.case1.v0; static_array<static_array<unsigned char,2>,2> v39 = v5.case1.v1; static_array<int,2> v40 = v5.case1.v2; int v41 = v5.case1.v3; static_array<int,2> v42 = v5.case1.v4; Union5 v43 = v5.case1.v5;
            return f_61(v36, v38, v39, v40, v41, v42, v43);
            break;
        }
        case 2: { // WaitingForActionFromPlayerId
            int v44 = v5.case2.v0; static_array<static_array<unsigned char,2>,2> v45 = v5.case2.v1; static_array<int,2> v46 = v5.case2.v2; int v47 = v5.case2.v3; static_array<int,2> v48 = v5.case2.v4; Union5 v49 = v5.case2.v5;
            return f_61(v36, v44, v45, v46, v47, v48, v49);
            break;
        }
        default: {
            assert("Invalid tag." && false); __trap();
        }
    }
}
__device__ inline bool while_method_23(int v0){
    bool v1;
    v1 = v0 < 2048;
    return v1;
}
__device__ inline bool while_method_24(int v0){
    bool v1;
    v1 = v0 < 32;
    return v1;
}
__device__ inline bool while_method_25(Union3 v0){
    switch (v0.tag) {
        case 0: { // None
            return false;
            break;
        }
        case 1: { // Some
            Union4 v1 = v0.case1.v0;
            return true;
            break;
        }
        default: {
            assert("Invalid tag." && false); __trap();
        }
    }
}
__device__ static_array_list<unsigned char,5> get_community_cards_84(Union5 v0, static_array<unsigned char,3> v1){
    static_array_list<unsigned char,5> v2;
    v2 = static_array_list<unsigned char,5>{};
    switch (v0.tag) {
        case 0: { // Flop
            static_array<unsigned char,3> v4 = v0.case0.v0;
            int v5;
            v5 = 0;
            while (while_method_1(v5)){
                bool v7;
                v7 = 0 <= v5;
                bool v9;
                if (v7){
                    bool v8;
                    v8 = v5 < 3;
                    v9 = v8;
                } else {
                    v9 = false;
                }
                bool v10;
                v10 = v9 == false;
                if (v10){
                    assert("Index must be in range." && v9);
                } else {
                }
                unsigned char v12;
                v12 = v4[v5];
                v2.push(v12);
                v5 += 1 ;
            }
            break;
        }
        case 1: { // Preflop
            break;
        }
        case 2: { // River
            static_array<unsigned char,5> v24 = v0.case2.v0;
            int v25;
            v25 = 0;
            while (while_method_2(v25)){
                bool v27;
                v27 = 0 <= v25;
                bool v29;
                if (v27){
                    bool v28;
                    v28 = v25 < 5;
                    v29 = v28;
                } else {
                    v29 = false;
                }
                bool v30;
                v30 = v29 == false;
                if (v30){
                    assert("Index must be in range." && v29);
                } else {
                }
                unsigned char v32;
                v32 = v24[v25];
                v2.push(v32);
                v25 += 1 ;
            }
            break;
        }
        case 3: { // Turn
            static_array<unsigned char,4> v14 = v0.case3.v0;
            int v15;
            v15 = 0;
            while (while_method_3(v15)){
                bool v17;
                v17 = 0 <= v15;
                bool v19;
                if (v17){
                    bool v18;
                    v18 = v15 < 4;
                    v19 = v18;
                } else {
                    v19 = false;
                }
                bool v20;
                v20 = v19 == false;
                if (v20){
                    assert("Index must be in range." && v19);
                } else {
                }
                unsigned char v22;
                v22 = v14[v15];
                v2.push(v22);
                v15 += 1 ;
            }
            break;
        }
        default: {
            assert("Invalid tag." && false); __trap();
        }
    }
    int v34;
    v34 = 0;
    while (while_method_1(v34)){
        bool v36;
        v36 = 0 <= v34;
        bool v38;
        if (v36){
            bool v37;
            v37 = v34 < 3;
            v38 = v37;
        } else {
            v38 = false;
        }
        bool v39;
        v39 = v38 == false;
        if (v39){
            assert("Index must be in range." && v38);
        } else {
        }
        unsigned char v41;
        v41 = v1[v34];
        v2.push(v41);
        v34 += 1 ;
    }
    return v2;
}
__device__ static_array_list<unsigned char,5> get_community_cards_85(Union5 v0, static_array<unsigned char,1> v1){
    static_array_list<unsigned char,5> v2;
    v2 = static_array_list<unsigned char,5>{};
    switch (v0.tag) {
        case 0: { // Flop
            static_array<unsigned char,3> v4 = v0.case0.v0;
            int v5;
            v5 = 0;
            while (while_method_1(v5)){
                bool v7;
                v7 = 0 <= v5;
                bool v9;
                if (v7){
                    bool v8;
                    v8 = v5 < 3;
                    v9 = v8;
                } else {
                    v9 = false;
                }
                bool v10;
                v10 = v9 == false;
                if (v10){
                    assert("Index must be in range." && v9);
                } else {
                }
                unsigned char v12;
                v12 = v4[v5];
                v2.push(v12);
                v5 += 1 ;
            }
            break;
        }
        case 1: { // Preflop
            break;
        }
        case 2: { // River
            static_array<unsigned char,5> v24 = v0.case2.v0;
            int v25;
            v25 = 0;
            while (while_method_2(v25)){
                bool v27;
                v27 = 0 <= v25;
                bool v29;
                if (v27){
                    bool v28;
                    v28 = v25 < 5;
                    v29 = v28;
                } else {
                    v29 = false;
                }
                bool v30;
                v30 = v29 == false;
                if (v30){
                    assert("Index must be in range." && v29);
                } else {
                }
                unsigned char v32;
                v32 = v24[v25];
                v2.push(v32);
                v25 += 1 ;
            }
            break;
        }
        case 3: { // Turn
            static_array<unsigned char,4> v14 = v0.case3.v0;
            int v15;
            v15 = 0;
            while (while_method_3(v15)){
                bool v17;
                v17 = 0 <= v15;
                bool v19;
                if (v17){
                    bool v18;
                    v18 = v15 < 4;
                    v19 = v18;
                } else {
                    v19 = false;
                }
                bool v20;
                v20 = v19 == false;
                if (v20){
                    assert("Index must be in range." && v19);
                } else {
                }
                unsigned char v22;
                v22 = v14[v15];
                v2.push(v22);
                v15 += 1 ;
            }
            break;
        }
        default: {
            assert("Invalid tag." && false); __trap();
        }
    }
    int v34;
    v34 = 0;
    while (while_method_6(v34)){
        bool v36;
        v36 = 0 <= v34;
        bool v38;
        if (v36){
            bool v37;
            v37 = v34 < 1;
            v38 = v37;
        } else {
            v38 = false;
        }
        bool v39;
        v39 = v38 == false;
        if (v39){
            assert("Index must be in range." && v38);
        } else {
        }
        unsigned char v41;
        v41 = v1[v34];
        v2.push(v41);
        v34 += 1 ;
    }
    return v2;
}
__device__ void method_83(unsigned char * v0, unsigned char * v1, unsigned char * v2, StackMut1 & v3, int v4, Union4 v5){
    v3.v0 = 4503599627370495ull;
    static_array<float,2> v6;
    v6[0] = 0.0f;
    v6[1] = 0.0f;
    v3.v4 = v6;
    static_array_list<Union6,128> & v8 = v3.v2;
    v8.unsafe_set_length(0);
    static_array<Union2,2> v9;
    Union2 v11;
    v11 = Union2{Union2_1{}};
    v9[0] = v11;
    Union2 v13;
    v13 = Union2{Union2_1{}};
    v9[1] = v13;
    int v15;
    v15 = v4 ^ 1;
    Union2 v16;
    v16 = Union2{Union2_0{}};
    v9[v15] = v16;
    v3.v3 = v9;
    static_array_list<Union6,128> & v18 = v3.v2;
    unsigned long long & v19 = v3.v0;
    Union3 v20;
    v20 = Union3{Union3_1{v5}};
    Union3 v21;
    v21 = v20;
    while (while_method_25(v21)){
        Union3 v1719;
        switch (v21.tag) {
            case 0: { // None
                v1719 = Union3{Union3_0{}};
                break;
            }
            case 1: { // Some
                Union4 v23 = v21.case1.v0;
                Union18 v1370;
                switch (v23.tag) {
                    case 0: { // G_Flop
                        int v1231 = v23.case0.v0; static_array<static_array<unsigned char,2>,2> v1232 = v23.case0.v1; static_array<int,2> v1233 = v23.case0.v2; int v1234 = v23.case0.v3; static_array<int,2> v1235 = v23.case0.v4; Union5 v1236 = v23.case0.v5;
                        curandStatePhilox4_32_10_t & v1237 = v3.v5;
                        curandStatePhilox4_32_10_t & v1238 = v1237;
                        static_array<unsigned char,3> v1239; unsigned long long v1240;
                        Tuple8 tmp83 = draw_cards_32(v1238, v19);
                        v1239 = tmp83.v0; v1240 = tmp83.v1;
                        v3.v0 = v1240;
                        static_array_list<unsigned char,5> v1241;
                        v1241 = get_community_cards_84(v1236, v1239);
                        Union6 v1242;
                        v1242 = Union6{Union6_0{v1241}};
                        v18.push(v1242);
                        Union5 v1245;
                        switch (v1236.tag) {
                            case 1: { // Preflop
                                v1245 = Union5{Union5_0{v1239}};
                                break;
                            }
                            default: {
                                printf("%s\n", "Invalid street in flop.");
                                __trap();
                            }
                        }
                        int v1246;
                        v1246 = 2;
                        int v1247;
                        v1247 = 0;
                        Union4 v1248;
                        v1248 = try_round_36(v1246, v1232, v1233, v1247, v1235, v1245);
                        v1370 = Union18{Union18_2{v1248}};
                        break;
                    }
                    case 1: { // G_Fold
                        int v24 = v23.case1.v0; static_array<static_array<unsigned char,2>,2> v25 = v23.case1.v1; static_array<int,2> v26 = v23.case1.v2; int v27 = v23.case1.v3; static_array<int,2> v28 = v23.case1.v4; Union5 v29 = v23.case1.v5;
                        int v30;
                        v30 = v27 % 2;
                        bool v31;
                        v31 = 0 <= v30;
                        bool v33;
                        if (v31){
                            bool v32;
                            v32 = v30 < 2;
                            v33 = v32;
                        } else {
                            v33 = false;
                        }
                        bool v34;
                        v34 = v33 == false;
                        if (v34){
                            assert("Index must be in range." && v33);
                        } else {
                        }
                        int v36;
                        v36 = v26[v30];
                        int v38;
                        v38 = -v36;
                        float v39;
                        v39 = (float)v38;
                        static_array<float,2> & v40 = v3.v4;
                        v40[v30] = v39;
                        int v41;
                        v41 = v30 ^ 1;
                        float v42;
                        v42 = -v39;
                        v40[v41] = v42;
                        int v43;
                        v43 = v27 + 1;
                        int v44;
                        v44 = v43 % 2;
                        Union6 v45;
                        v45 = Union6{Union6_1{v36, v44}};
                        v18.push(v45);
                        v1370 = Union18{Union18_0{}};
                        break;
                    }
                    case 2: { // G_Preflop
                        curandStatePhilox4_32_10_t & v1332 = v3.v5;
                        curandStatePhilox4_32_10_t & v1333 = v1332;
                        static_array<unsigned char,2> v1334; unsigned long long v1335;
                        Tuple11 tmp84 = draw_cards_39(v1333, v19);
                        v1334 = tmp84.v0; v1335 = tmp84.v1;
                        v3.v0 = v1335;
                        curandStatePhilox4_32_10_t & v1336 = v3.v5;
                        curandStatePhilox4_32_10_t & v1337 = v1336;
                        static_array<unsigned char,2> v1338; unsigned long long v1339;
                        Tuple11 tmp85 = draw_cards_39(v1337, v19);
                        v1338 = tmp85.v0; v1339 = tmp85.v1;
                        v3.v0 = v1339;
                        Union6 v1340;
                        v1340 = Union6{Union6_3{0, v1334}};
                        v18.push(v1340);
                        Union6 v1341;
                        v1341 = Union6{Union6_3{1, v1338}};
                        v18.push(v1341);
                        static_array<static_array<unsigned char,2>,2> v1342;
                        v1342[0] = v1334;
                        v1342[1] = v1338;
                        static_array<int,2> v1344;
                        v1344[0] = 2;
                        v1344[1] = 1;
                        static_array<int,2> v1346;
                        int v1348;
                        v1348 = 0;
                        while (while_method_0(v1348)){
                            bool v1350;
                            v1350 = 0 <= v1348;
                            bool v1352;
                            if (v1350){
                                bool v1351;
                                v1351 = v1348 < 2;
                                v1352 = v1351;
                            } else {
                                v1352 = false;
                            }
                            bool v1353;
                            v1353 = v1352 == false;
                            if (v1353){
                                assert("Index must be in range." && v1352);
                            } else {
                            }
                            int v1355;
                            v1355 = v1344[v1348];
                            int v1357;
                            v1357 = 100 - v1355;
                            v1346[v1348] = v1357;
                            v1348 += 1 ;
                        }
                        int v1358;
                        v1358 = 2;
                        int v1359;
                        v1359 = 0;
                        Union5 v1360;
                        v1360 = Union5{Union5_1{}};
                        Union4 v1361;
                        v1361 = try_round_36(v1358, v1342, v1344, v1359, v1346, v1360);
                        v1370 = Union18{Union18_2{v1361}};
                        break;
                    }
                    case 3: { // G_River
                        int v1291 = v23.case3.v0; static_array<static_array<unsigned char,2>,2> v1292 = v23.case3.v1; static_array<int,2> v1293 = v23.case3.v2; int v1294 = v23.case3.v3; static_array<int,2> v1295 = v23.case3.v4; Union5 v1296 = v23.case3.v5;
                        curandStatePhilox4_32_10_t & v1297 = v3.v5;
                        curandStatePhilox4_32_10_t & v1298 = v1297;
                        static_array<unsigned char,1> v1299; unsigned long long v1300;
                        Tuple12 tmp86 = draw_cards_40(v1298, v19);
                        v1299 = tmp86.v0; v1300 = tmp86.v1;
                        v3.v0 = v1300;
                        static_array_list<unsigned char,5> v1301;
                        v1301 = get_community_cards_85(v1296, v1299);
                        Union6 v1302;
                        v1302 = Union6{Union6_0{v1301}};
                        v18.push(v1302);
                        Union5 v1327;
                        switch (v1296.tag) {
                            case 3: { // Turn
                                static_array<unsigned char,4> v1303 = v1296.case3.v0;
                                static_array<unsigned char,5> v1304;
                                int v1306;
                                v1306 = 0;
                                while (while_method_3(v1306)){
                                    bool v1308;
                                    v1308 = 0 <= v1306;
                                    bool v1310;
                                    if (v1308){
                                        bool v1309;
                                        v1309 = v1306 < 4;
                                        v1310 = v1309;
                                    } else {
                                        v1310 = false;
                                    }
                                    bool v1311;
                                    v1311 = v1310 == false;
                                    if (v1311){
                                        assert("Index must be in range." && v1310);
                                    } else {
                                    }
                                    unsigned char v1313;
                                    v1313 = v1303[v1306];
                                    v1304[v1306] = v1313;
                                    v1306 += 1 ;
                                }
                                int v1315;
                                v1315 = 0;
                                while (while_method_6(v1315)){
                                    bool v1317;
                                    v1317 = 0 <= v1315;
                                    bool v1319;
                                    if (v1317){
                                        bool v1318;
                                        v1318 = v1315 < 1;
                                        v1319 = v1318;
                                    } else {
                                        v1319 = false;
                                    }
                                    bool v1320;
                                    v1320 = v1319 == false;
                                    if (v1320){
                                        assert("Index must be in range." && v1319);
                                    } else {
                                    }
                                    unsigned char v1322;
                                    v1322 = v1299[v1315];
                                    int v1324;
                                    v1324 = 4 + v1315;
                                    v1304[v1324] = v1322;
                                    v1315 += 1 ;
                                }
                                v1327 = Union5{Union5_2{v1304}};
                                break;
                            }
                            default: {
                                printf("%s\n", "Invalid street in river.");
                                __trap();
                            }
                        }
                        int v1328;
                        v1328 = 2;
                        int v1329;
                        v1329 = 0;
                        Union4 v1330;
                        v1330 = try_round_36(v1328, v1292, v1293, v1329, v1295, v1327);
                        v1370 = Union18{Union18_2{v1330}};
                        break;
                    }
                    case 4: { // G_Round
                        int v166 = v23.case4.v0; static_array<static_array<unsigned char,2>,2> v167 = v23.case4.v1; static_array<int,2> v168 = v23.case4.v2; int v169 = v23.case4.v3; static_array<int,2> v170 = v23.case4.v4; Union5 v171 = v23.case4.v5;
                        int v172;
                        v172 = v169 % 2;
                        static_array<Union2,2> & v173 = v3.v3;
                        bool v174;
                        v174 = 0 <= v172;
                        bool v176;
                        if (v174){
                            bool v175;
                            v175 = v172 < 2;
                            v176 = v175;
                        } else {
                            v176 = false;
                        }
                        bool v177;
                        v177 = v176 == false;
                        if (v177){
                            assert("Index must be in range." && v176);
                        } else {
                        }
                        Union2 v179;
                        v179 = v173[v172];
                        Union1 v1218;
                        switch (v179.tag) {
                            case 0: { // CallingMachine
                                v1218 = Union1{Union1_1{}};
                                break;
                            }
                            case 1: { // Computer
                                static_array_list<Union6,128> & v182 = v3.v2;
                                curandStatePhilox4_32_10_t & v183 = v3.v5;
                                curandStatePhilox4_32_10_t & v184 = v183;
                                float * v185;
                                v185 = reinterpret_cast<float *>(&v1[114819072ull]);
                                float * v187;
                                v187 = reinterpret_cast<float *>(&v1[0ull]);
                                float * v189;
                                v189 = reinterpret_cast<float *>(&v1[0ull]);
                                int v191;
                                v191 = blockIdx.x;
                                assert("Tensor range check" && 0 <= v191 && v191 < 24);
                                int v192;
                                v192 = 524288 * v191;
                                int v193;
                                v193 = threadIdx.x;
                                int v194;
                                v194 = v193;
                                while (while_method_7(v194)){
                                    bool v196;
                                    v196 = 0 <= v194;
                                    bool v197;
                                    v197 = v196 == false;
                                    if (v197){
                                        assert("The index needs to be zero or positive." && v196);
                                    } else {
                                    }
                                    int v199;
                                    v199 = v194 % 2048;
                                    int v200;
                                    v200 = v194 / 2048;
                                    bool v201;
                                    v201 = v200 < 256;
                                    bool v202;
                                    v202 = v201 == false;
                                    if (v202){
                                        assert("The last element of the projection dimensions needs to be greater than the index remainder." && v201);
                                    } else {
                                    }
                                    assert("Tensor range check" && 0 <= v200 && v200 < 256);
                                    assert("Tensor range check" && 0 <= v199 && v199 < 2048);
                                    int v204;
                                    v204 = v199 + v192;
                                    int v205;
                                    v205 = 2048 * v200;
                                    int v206;
                                    v206 = v205 + v204;
                                    v189[v206] = 0.0f;
                                    v194 += 256 ;
                                }
                                __syncthreads();
                                int v207;
                                v207 = threadIdx.x;
                                assert("Tensor range check" && 0 <= v207 && v207 < 256);
                                int v208;
                                v208 = 2048 * v207;
                                int v209;
                                v209 = v208 + v192;
                                int v210;
                                v210 = v182.length;
                                bool v211;
                                v211 = 128 >= v210;
                                bool v212;
                                v212 = v211 == false;
                                if (v212){
                                    assert("The type level dimension has to equal the value passed at runtime into create." && v211);
                                } else {
                                }
                                static_array_list<Union8,128> v214;
                                v214 = static_array_list<Union8,128>{};
                                v214.unsafe_set_length(v210);
                                int v216;
                                v216 = 0;
                                while (while_method_4(v210, v216)){
                                    Union6 v218;
                                    v218 = v182[v216];
                                    Union8 v224;
                                    switch (v218.tag) {
                                        case 2: { // PlayerAction
                                            int v220 = v218.case2.v0; Union1 v221 = v218.case2.v1;
                                            v224 = Union8{Union8_1{v221}};
                                            break;
                                        }
                                        default: {
                                            v224 = Union8{Union8_0{}};
                                        }
                                    }
                                    v214[v216] = v224;
                                    v216 += 1 ;
                                }
                                static_array<int,2> v225;
                                int v227;
                                v227 = 0;
                                while (while_method_0(v227)){
                                    int v229;
                                    v229 = v227 + v169;
                                    int v230;
                                    v230 = v229 % 2;
                                    bool v231;
                                    v231 = 0 <= v230;
                                    bool v233;
                                    if (v231){
                                        bool v232;
                                        v232 = v230 < 2;
                                        v233 = v232;
                                    } else {
                                        v233 = false;
                                    }
                                    bool v234;
                                    v234 = v233 == false;
                                    if (v234){
                                        assert("Index must be in range." && v233);
                                    } else {
                                    }
                                    int v236;
                                    v236 = v168[v230];
                                    v225[v227] = v236;
                                    v227 += 1 ;
                                }
                                static_array<int,2> v238;
                                int v240;
                                v240 = 0;
                                while (while_method_0(v240)){
                                    int v242;
                                    v242 = v240 + v169;
                                    int v243;
                                    v243 = v242 % 2;
                                    bool v244;
                                    v244 = 0 <= v243;
                                    bool v246;
                                    if (v244){
                                        bool v245;
                                        v245 = v243 < 2;
                                        v246 = v245;
                                    } else {
                                        v246 = false;
                                    }
                                    bool v247;
                                    v247 = v246 == false;
                                    if (v247){
                                        assert("Index must be in range." && v246);
                                    } else {
                                    }
                                    int v249;
                                    v249 = v170[v243];
                                    v238[v240] = v249;
                                    v240 += 1 ;
                                }
                                bool v252;
                                if (v174){
                                    bool v251;
                                    v251 = v172 < 2;
                                    v252 = v251;
                                } else {
                                    v252 = false;
                                }
                                bool v253;
                                v253 = v252 == false;
                                if (v253){
                                    assert("Index must be in range." && v252);
                                } else {
                                }
                                static_array<unsigned char,2> v255;
                                v255 = v167[v172];
                                static_array_list<unsigned char,5> v257;
                                v257 = static_array_list<unsigned char,5>{};
                                switch (v171.tag) {
                                    case 0: { // Flop
                                        static_array<unsigned char,3> v259 = v171.case0.v0;
                                        int v260;
                                        v260 = 0;
                                        while (while_method_1(v260)){
                                            bool v262;
                                            v262 = 0 <= v260;
                                            bool v264;
                                            if (v262){
                                                bool v263;
                                                v263 = v260 < 3;
                                                v264 = v263;
                                            } else {
                                                v264 = false;
                                            }
                                            bool v265;
                                            v265 = v264 == false;
                                            if (v265){
                                                assert("Index must be in range." && v264);
                                            } else {
                                            }
                                            unsigned char v267;
                                            v267 = v259[v260];
                                            v257.push(v267);
                                            v260 += 1 ;
                                        }
                                        break;
                                    }
                                    case 1: { // Preflop
                                        break;
                                    }
                                    case 2: { // River
                                        static_array<unsigned char,5> v279 = v171.case2.v0;
                                        int v280;
                                        v280 = 0;
                                        while (while_method_2(v280)){
                                            bool v282;
                                            v282 = 0 <= v280;
                                            bool v284;
                                            if (v282){
                                                bool v283;
                                                v283 = v280 < 5;
                                                v284 = v283;
                                            } else {
                                                v284 = false;
                                            }
                                            bool v285;
                                            v285 = v284 == false;
                                            if (v285){
                                                assert("Index must be in range." && v284);
                                            } else {
                                            }
                                            unsigned char v287;
                                            v287 = v279[v280];
                                            v257.push(v287);
                                            v280 += 1 ;
                                        }
                                        break;
                                    }
                                    case 3: { // Turn
                                        static_array<unsigned char,4> v269 = v171.case3.v0;
                                        int v270;
                                        v270 = 0;
                                        while (while_method_3(v270)){
                                            bool v272;
                                            v272 = 0 <= v270;
                                            bool v274;
                                            if (v272){
                                                bool v273;
                                                v273 = v270 < 4;
                                                v274 = v273;
                                            } else {
                                                v274 = false;
                                            }
                                            bool v275;
                                            v275 = v274 == false;
                                            if (v275){
                                                assert("Index must be in range." && v274);
                                            } else {
                                            }
                                            unsigned char v277;
                                            v277 = v269[v270];
                                            v257.push(v277);
                                            v270 += 1 ;
                                        }
                                        break;
                                    }
                                    default: {
                                        assert("Invalid tag." && false); __trap();
                                    }
                                }
                                float * v289;
                                v289 = v189+v209;
                                int v291;
                                v291 = v214.length;
                                bool v292;
                                v292 = v291 == 0;
                                if (v292){
                                    v289[0] = 1.0f;
                                } else {
                                }
                                int v293;
                                v293 = v214.length;
                                int v294;
                                v294 = 0;
                                while (while_method_4(v293, v294)){
                                    Union8 v296;
                                    v296 = v214[v294];
                                    int v298;
                                    v298 = v294 * 14;
                                    int v299;
                                    v299 = 1 + v298;
                                    switch (v296.tag) {
                                        case 0: { // None
                                            v289[v299] = 1.0f;
                                            break;
                                        }
                                        case 1: { // Some
                                            Union1 v300 = v296.case1.v0;
                                            int v301;
                                            v301 = v299 + 1;
                                            switch (v300.tag) {
                                                case 0: { // A_All_In
                                                    v289[v301] = 1.0f;
                                                    break;
                                                }
                                                case 1: { // A_Call
                                                    int v302;
                                                    v302 = v301 + 1;
                                                    v289[v302] = 1.0f;
                                                    break;
                                                }
                                                case 2: { // A_Fold
                                                    int v303;
                                                    v303 = v301 + 2;
                                                    v289[v303] = 1.0f;
                                                    break;
                                                }
                                                case 3: { // A_Raise
                                                    int v304 = v300.case3.v0;
                                                    int v305;
                                                    v305 = v301 + 3;
                                                    bool v306;
                                                    v306 = 1 <= v304;
                                                    bool v308;
                                                    if (v306){
                                                        bool v307;
                                                        v307 = v304 < 1023;
                                                        v308 = v307;
                                                    } else {
                                                        v308 = false;
                                                    }
                                                    bool v309;
                                                    v309 = v308 == false;
                                                    if (v309){
                                                        assert("Pickle failure. The input is out of the bounds of the given range." && v308);
                                                    } else {
                                                    }
                                                    int v311;
                                                    v311 = v304 - 1;
                                                    unsigned int v312;
                                                    v312 = (unsigned int)v311;
                                                    method_42(v312, v289, v305);
                                                    break;
                                                }
                                                default: {
                                                    assert("Invalid tag." && false); __trap();
                                                }
                                            }
                                            break;
                                        }
                                        default: {
                                            assert("Invalid tag." && false); __trap();
                                        }
                                    }
                                    v294 += 1 ;
                                }
                                int v313;
                                v313 = 0;
                                while (while_method_0(v313)){
                                    // 222;
                                    bool v315;
                                    v315 = 0 <= v313;
                                    bool v317;
                                    if (v315){
                                        bool v316;
                                        v316 = v313 < 2;
                                        v317 = v316;
                                    } else {
                                        v317 = false;
                                    }
                                    bool v318;
                                    v318 = v317 == false;
                                    if (v318){
                                        assert("Index must be in range." && v317);
                                    } else {
                                    }
                                    int v320;
                                    v320 = v225[v313];
                                    int v322;
                                    v322 = v313 * 11;
                                    int v323;
                                    v323 = 1794 + v322;
                                    bool v324;
                                    v324 = 0 <= v320;
                                    bool v326;
                                    if (v324){
                                        bool v325;
                                        v325 = v320 < 1023;
                                        v326 = v325;
                                    } else {
                                        v326 = false;
                                    }
                                    bool v327;
                                    v327 = v326 == false;
                                    if (v327){
                                        assert("Pickle failure. The input is out of the bounds of the given range." && v326);
                                    } else {
                                    }
                                    unsigned int v329;
                                    v329 = (unsigned int)v320;
                                    method_43(v329, v289, v323);
                                    v313 += 1 ;
                                }
                                int v330;
                                v330 = 0;
                                while (while_method_0(v330)){
                                    // 222;
                                    bool v332;
                                    v332 = 0 <= v330;
                                    bool v334;
                                    if (v332){
                                        bool v333;
                                        v333 = v330 < 2;
                                        v334 = v333;
                                    } else {
                                        v334 = false;
                                    }
                                    bool v335;
                                    v335 = v334 == false;
                                    if (v335){
                                        assert("Index must be in range." && v334);
                                    } else {
                                    }
                                    int v337;
                                    v337 = v238[v330];
                                    int v339;
                                    v339 = v330 * 11;
                                    int v340;
                                    v340 = 1817 + v339;
                                    bool v341;
                                    v341 = 0 <= v337;
                                    bool v343;
                                    if (v341){
                                        bool v342;
                                        v342 = v337 < 1023;
                                        v343 = v342;
                                    } else {
                                        v343 = false;
                                    }
                                    bool v344;
                                    v344 = v343 == false;
                                    if (v344){
                                        assert("Pickle failure. The input is out of the bounds of the given range." && v343);
                                    } else {
                                    }
                                    unsigned int v346;
                                    v346 = (unsigned int)v337;
                                    method_43(v346, v289, v340);
                                    v330 += 1 ;
                                }
                                int v347;
                                v347 = 0;
                                while (while_method_0(v347)){
                                    // 222;
                                    bool v349;
                                    v349 = 0 <= v347;
                                    bool v351;
                                    if (v349){
                                        bool v350;
                                        v350 = v347 < 2;
                                        v351 = v350;
                                    } else {
                                        v351 = false;
                                    }
                                    bool v352;
                                    v352 = v351 == false;
                                    if (v352){
                                        assert("Index must be in range." && v351);
                                    } else {
                                    }
                                    unsigned char v354;
                                    v354 = v255[v347];
                                    int v356;
                                    v356 = v347 * 17;
                                    int v357;
                                    v357 = 1840 + v356;
                                    unsigned char v358;
                                    v358 = v354 % 4u;
                                    int v359;
                                    v359 = (int)v358;
                                    unsigned char v360;
                                    v360 = v354 / 4u;
                                    int v361;
                                    v361 = (int)v360;
                                    unsigned int v362;
                                    v362 = (unsigned int)v359;
                                    int v363;
                                    v363 = (int)v362;
                                    bool v364;
                                    v364 = v363 < 4;
                                    bool v365;
                                    v365 = v364 == false;
                                    if (v365){
                                        assert("Pickle failure. Int value out of bounds." && v364);
                                    } else {
                                    }
                                    int v367;
                                    v367 = v357 + v363;
                                    v289[v367] = 1.0f;
                                    int v368;
                                    v368 = v357 + 4;
                                    unsigned int v369;
                                    v369 = (unsigned int)v361;
                                    int v370;
                                    v370 = (int)v369;
                                    bool v371;
                                    v371 = v370 < 13;
                                    bool v372;
                                    v372 = v371 == false;
                                    if (v372){
                                        assert("Pickle failure. Int value out of bounds." && v371);
                                    } else {
                                    }
                                    int v374;
                                    v374 = v368 + v370;
                                    v289[v374] = 1.0f;
                                    v347 += 1 ;
                                }
                                int v375;
                                v375 = v257.length;
                                bool v376;
                                v376 = v375 == 0;
                                if (v376){
                                    v289[1874] = 1.0f;
                                } else {
                                }
                                int v377;
                                v377 = v257.length;
                                int v378;
                                v378 = 0;
                                while (while_method_4(v377, v378)){
                                    unsigned char v380;
                                    v380 = v257[v378];
                                    int v382;
                                    v382 = v378 * 17;
                                    int v383;
                                    v383 = 1875 + v382;
                                    unsigned char v384;
                                    v384 = v380 % 4u;
                                    int v385;
                                    v385 = (int)v384;
                                    unsigned char v386;
                                    v386 = v380 / 4u;
                                    int v387;
                                    v387 = (int)v386;
                                    unsigned int v388;
                                    v388 = (unsigned int)v385;
                                    int v389;
                                    v389 = (int)v388;
                                    bool v390;
                                    v390 = v389 < 4;
                                    bool v391;
                                    v391 = v390 == false;
                                    if (v391){
                                        assert("Pickle failure. Int value out of bounds." && v390);
                                    } else {
                                    }
                                    int v393;
                                    v393 = v383 + v389;
                                    v289[v393] = 1.0f;
                                    int v394;
                                    v394 = v383 + 4;
                                    unsigned int v395;
                                    v395 = (unsigned int)v387;
                                    int v396;
                                    v396 = (int)v395;
                                    bool v397;
                                    v397 = v396 < 13;
                                    bool v398;
                                    v398 = v397 == false;
                                    if (v398){
                                        assert("Pickle failure. Int value out of bounds." && v397);
                                    } else {
                                    }
                                    int v400;
                                    v400 = v394 + v396;
                                    v289[v400] = 1.0f;
                                    v378 += 1 ;
                                }
                                __syncthreads();
                                int v401;
                                v401 = 0;
                                while (while_method_3(v401)){
                                    float * v403;
                                    v403 = reinterpret_cast<float *>(&v1[114819072ull]);
                                    assert("Tensor range check" && 0 <= v401 && v401 < 4);
                                    int v405;
                                    v405 = 393216 * v401;
                                    float * v406;
                                    v406 = reinterpret_cast<float *>(&v1[106954752ull]);
                                    float * v408;
                                    v408 = reinterpret_cast<float *>(&v1[94371840ull]);
                                    float * v410;
                                    v410 = reinterpret_cast<float *>(&v1[81788928ull]);
                                    float * v412;
                                    v412 = reinterpret_cast<float *>(&v1[69206016ull]);
                                    float * v414;
                                    v414 = reinterpret_cast<float *>(&v1[56623104ull]);
                                    float * v416;
                                    v416 = reinterpret_cast<float *>(&v1[0ull]);
                                    float * v418;
                                    v418 = reinterpret_cast<float *>(&v0[0ull]);
                                    float * v420;
                                    v420 = reinterpret_cast<float *>(&v2[0ull]);
                                    assert("Tensor range check" && 0 <= v401 && v401 < 4);
                                    int v422;
                                    v422 = 524288 * v401;
                                    float * v423;
                                    v423 = reinterpret_cast<float *>(&v1[50331648ull]);
                                    block_matmul_45(v423, v418, v422, v416);
                                    block_map_46(v414, v423);
                                    float * v425;
                                    v425 = reinterpret_cast<float *>(&v0[8388608ull]);
                                    float * v427;
                                    v427 = reinterpret_cast<float *>(&v2[8388608ull]);
                                    assert("Tensor range check" && 0 <= v401 && v401 < 4);
                                    int v429;
                                    v429 = 65536 * v401;
                                    float * v430;
                                    v430 = reinterpret_cast<float *>(&v1[62914560ull]);
                                    block_matmul_47(v430, v425, v429, v414);
                                    block_map_46(v412, v430);
                                    float * v432;
                                    v432 = reinterpret_cast<float *>(&v0[9437184ull]);
                                    float * v434;
                                    v434 = reinterpret_cast<float *>(&v2[9437184ull]);
                                    assert("Tensor range check" && 0 <= v401 && v401 < 4);
                                    float * v436;
                                    v436 = reinterpret_cast<float *>(&v1[75497472ull]);
                                    block_matmul_47(v436, v432, v429, v412);
                                    block_map_46(v410, v436);
                                    float * v438;
                                    v438 = reinterpret_cast<float *>(&v0[10485760ull]);
                                    float * v440;
                                    v440 = reinterpret_cast<float *>(&v2[10485760ull]);
                                    assert("Tensor range check" && 0 <= v401 && v401 < 4);
                                    float * v442;
                                    v442 = reinterpret_cast<float *>(&v1[88080384ull]);
                                    block_matmul_47(v442, v438, v429, v410);
                                    block_map_46(v408, v442);
                                    float * v444;
                                    v444 = reinterpret_cast<float *>(&v0[11534336ull]);
                                    float * v446;
                                    v446 = reinterpret_cast<float *>(&v2[11534336ull]);
                                    assert("Tensor range check" && 0 <= v401 && v401 < 4);
                                    float * v448;
                                    v448 = reinterpret_cast<float *>(&v1[100663296ull]);
                                    block_matmul_47(v448, v444, v429, v408);
                                    block_map_46(v406, v448);
                                    float * v450;
                                    v450 = reinterpret_cast<float *>(&v0[12582912ull]);
                                    float * v452;
                                    v452 = reinterpret_cast<float *>(&v2[12582912ull]);
                                    assert("Tensor range check" && 0 <= v401 && v401 < 4);
                                    int v454;
                                    v454 = 16384 * v401;
                                    float * v455;
                                    v455 = reinterpret_cast<float *>(&v1[113246208ull]);
                                    block_matmul_48(v455, v450, v454, v406);
                                    block_row_map_49(v403, v405, v455);
                                    int * v457;
                                    v457 = reinterpret_cast<int *>(&v0[12845056ull]);
                                    bool * v459;
                                    v459 = reinterpret_cast<bool *>(&v0[12845072ull]);
                                    float * v461;
                                    v461 = reinterpret_cast<float *>(&v0[12845088ull]);
                                    float * v463;
                                    v463 = reinterpret_cast<float *>(&v0[12845104ull]);
                                    double * v465;
                                    v465 = reinterpret_cast<double *>(&v1[121110528ull]);
                                    double * v467;
                                    v467 = reinterpret_cast<double *>(&v1[121503744ull]);
                                    v401 += 1 ;
                                }
                                __syncthreads();
                                int * v469;
                                v469 = reinterpret_cast<int *>(&v0[12845056ull]);
                                bool * v471;
                                v471 = reinterpret_cast<bool *>(&v0[12845072ull]);
                                float * v473;
                                v473 = reinterpret_cast<float *>(&v0[12845088ull]);
                                float * v475;
                                v475 = reinterpret_cast<float *>(&v0[12845104ull]);
                                int v477;
                                v477 = v469[0];
                                float * v478;
                                v478 = reinterpret_cast<float *>(&v1[114819072ull]);
                                assert("Tensor range check" && 0 <= v477 && v477 < 4);
                                int v480;
                                v480 = 393216 * v477;
                                int v481;
                                v481 = blockIdx.x;
                                assert("Tensor range check" && 0 <= v481 && v481 < 24);
                                int v482;
                                v482 = 16384 * v481;
                                int v483;
                                v483 = v482 + v480;
                                int v484;
                                v484 = threadIdx.x;
                                assert("Tensor range check" && 0 <= v484 && v484 < 256);
                                int v485;
                                v485 = 64 * v484;
                                int v486;
                                v486 = v485 + v483;
                                float * v487;
                                v487 = v478+v486;
                                int v489;
                                v489 = sizeof(float *);
                                unsigned long long v490;
                                v490 = (unsigned long long)v489;
                                unsigned long long v491;
                                v491 = 256ull * v490;
                                unsigned long long v492;
                                v492 = v491 + 16ull;
                                unsigned long long v493;
                                v493 = v492 - 1ull;
                                unsigned long long v494;
                                v494 = v493 % 16ull;
                                unsigned long long v495;
                                v495 = v493 - v494;
                                unsigned long long v496;
                                v496 = v495 + 1024ull;
                                unsigned long long v497;
                                v497 = v496 + 16ull;
                                unsigned long long v498;
                                v498 = v497 - 1ull;
                                unsigned long long v499;
                                v499 = v498 % 16ull;
                                unsigned long long v500;
                                v500 = v498 - v499;
                                unsigned long long v501;
                                v501 = v500 + 1024ull;
                                bool v502;
                                v502 = v501 <= 98304ull;
                                bool v503;
                                v503 = v502 == false;
                                if (v503){
                                    assert("The dynamic shared memory is insufficient to allocate the tensor." && v502);
                                } else {
                                }
                                extern __shared__ unsigned char v505[];
                                bool v506;
                                v506 = v501 <= v501;
                                bool v507;
                                v507 = v506 == false;
                                if (v507){
                                    assert("The length of the partition has to be less than or equal to the length of the base array." && v506);
                                } else {
                                }
                                float * * v509;
                                v509 = reinterpret_cast<float * *>(&v505[0ull]);
                                float * v511;
                                v511 = reinterpret_cast<float *>(&v505[v495]);
                                int * v513;
                                v513 = reinterpret_cast<int *>(&v505[v500]);
                                int v515;
                                v515 = threadIdx.x;
                                assert("Tensor range check" && 0 <= v515 && v515 < 256);
                                v509[v515] = v487;
                                __syncthreads();
                                bool v516;
                                v516 = 0 <= v515;
                                bool v517;
                                v517 = v516 == false;
                                if (v517){
                                    assert("The index needs to be zero or positive." && v516);
                                } else {
                                }
                                int v519;
                                v519 = v515 % 16;
                                int v520;
                                v520 = v515 / 16;
                                bool v521;
                                v521 = v520 < 16;
                                bool v522;
                                v522 = v521 == false;
                                if (v522){
                                    assert("The last element of the projection dimensions needs to be greater than the index remainder." && v521);
                                } else {
                                }
                                assert("Tensor range check" && 0 <= v520 && v520 < 16);
                                int v524;
                                v524 = 0;
                                while (while_method_12(v524)){
                                    bool v526;
                                    v526 = 0 <= v520;
                                    bool v527;
                                    v527 = v526 && v521;
                                    bool v528;
                                    v528 = v527 == false;
                                    if (v528){
                                        assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v527);
                                    } else {
                                    }
                                    bool v530;
                                    v530 = 0 <= v524;
                                    bool v532;
                                    if (v530){
                                        bool v531;
                                        v531 = v524 < 16;
                                        v532 = v531;
                                    } else {
                                        v532 = false;
                                    }
                                    bool v533;
                                    v533 = v532 == false;
                                    if (v533){
                                        assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v532);
                                    } else {
                                    }
                                    int v535;
                                    v535 = v524 * 16;
                                    int v536;
                                    v536 = v535 + v520;
                                    assert("Tensor range check" && 0 <= v524 && v524 < 16);
                                    int v537;
                                    v537 = 16 * v524;
                                    int v538;
                                    v538 = v537 + v520;
                                    float * v539;
                                    v539 = v509[v538];
                                    int v540;
                                    v540 = blockIdx.x;
                                    int v541;
                                    v541 = v540 * 256;
                                    int v542;
                                    v542 = v541 + v536;
                                    assert("Tensor range check" && 0 <= v519 && v519 < 16);
                                    int v543;
                                    v543 = 4 * v519;
                                    float v544[4];
                                    int v545[4];
                                    int v546;
                                    v546 = 0;
                                    while (while_method_6(v546)){
                                        assert("Tensor range check" && 0 <= v546 && v546 < 1);
                                        int v548;
                                        v548 = 4 * v546;
                                        assert("Tensor range check" && 0 <= v546 && v546 < 1);
                                        int v549;
                                        v549 = 64 * v546;
                                        int v550;
                                        v550 = v549 + v543;
                                        int4* v551;
                                        v551 = reinterpret_cast<int4*>(v539 + v550);
                                        int4* v552;
                                        v552 = reinterpret_cast<int4*>(v544 + v548);
                                        assert("Pointer alignment check" && reinterpret_cast<unsigned long long>(v551) % 16 == 0 && reinterpret_cast<unsigned long long>(v552) % 16 == 0);
                                        *v552 = *v551;
                                        v546 += 1 ;
                                    }
                                    int v553;
                                    v553 = 0;
                                    while (while_method_6(v553)){
                                        int v555;
                                        v555 = 0;
                                        while (while_method_3(v555)){
                                            bool v557;
                                            v557 = 0 <= v555;
                                            bool v559;
                                            if (v557){
                                                bool v558;
                                                v558 = v555 < 4;
                                                v559 = v558;
                                            } else {
                                                v559 = false;
                                            }
                                            bool v560;
                                            v560 = v559 == false;
                                            if (v560){
                                                assert("The indices should be inside the range of the dimension." && v559);
                                            } else {
                                            }
                                            bool v562;
                                            v562 = 0 <= v519;
                                            bool v564;
                                            if (v562){
                                                bool v563;
                                                v563 = v519 < 16;
                                                v564 = v563;
                                            } else {
                                                v564 = false;
                                            }
                                            bool v565;
                                            v565 = v564 == false;
                                            if (v565){
                                                assert("The indices should be inside the range of the dimension." && v564);
                                            } else {
                                            }
                                            int v567;
                                            v567 = v519 * 4;
                                            int v568;
                                            v568 = v555 + v567;
                                            bool v569;
                                            v569 = 0 <= v553;
                                            bool v571;
                                            if (v569){
                                                bool v570;
                                                v570 = v553 < 1;
                                                v571 = v570;
                                            } else {
                                                v571 = false;
                                            }
                                            bool v572;
                                            v572 = v571 == false;
                                            if (v572){
                                                assert("The indices should be inside the range of the dimension." && v571);
                                            } else {
                                            }
                                            int v574;
                                            v574 = v553 * 64;
                                            int v575;
                                            v575 = v568 + v574;
                                            assert("Tensor range check" && 0 <= v553 && v553 < 1);
                                            assert("Tensor range check" && 0 <= v555 && v555 < 4);
                                            int v576;
                                            v576 = 4 * v553;
                                            int v577;
                                            v577 = v576 + v555;
                                            v545[v577] = v575;
                                            v555 += 1 ;
                                        }
                                        v553 += 1 ;
                                    }
                                    float v578[4];
                                    float v579;
                                    v579 = 0.0f;
                                    int v580;
                                    v580 = 0;
                                    while (while_method_6(v580)){
                                        assert("Tensor range check" && 0 <= v580 && v580 < 1);
                                        int v582;
                                        v582 = 4 * v580;
                                        assert("Tensor range check" && 0 <= v580 && v580 < 1);
                                        float v583;
                                        v583 = 0.0f;
                                        int v584;
                                        v584 = 0;
                                        while (while_method_3(v584)){
                                            assert("Tensor range check" && 0 <= v584 && v584 < 4);
                                            int v586;
                                            v586 = v584 + v582;
                                            float v587;
                                            v587 = v544[v586];
                                            float v588;
                                            v588 = v583 + v587;
                                            v583 = v588;
                                            v584 += 1 ;
                                        }
                                        auto v589 = cooperative_groups::coalesced_threads();
                                        int v590;
                                        v590 = threadIdx.x;
                                        int v591;
                                        v591 = v590 / 16;
                                        auto v592 = cooperative_groups::labeled_partition(v589,v591);
                                        Closure2 v593{};
                                        float v594;
                                        v594 = cooperative_groups::inclusive_scan(v592, v583, v593);
                                        float v595;
                                        v595 = v592.shfl_up(v594,1);
                                        bool v596;
                                        v596 = v592.thread_rank() == 0;
                                        float v597;
                                        if (v596){
                                            v597 = 0.0f;
                                        } else {
                                            v597 = v595;
                                        }
                                        float v598;
                                        v598 = v592.shfl(v594,v592.num_threads()-1);
                                        float v599;
                                        v599 = v579 + v597;
                                        float v600;
                                        v600 = v599;
                                        int v601;
                                        v601 = 0;
                                        while (while_method_3(v601)){
                                            assert("Tensor range check" && 0 <= v601 && v601 < 4);
                                            int v603;
                                            v603 = v601 + v582;
                                            float v604;
                                            v604 = v544[v603];
                                            float v605;
                                            v605 = v600 + v604;
                                            assert("Tensor range check" && 0 <= v601 && v601 < 4);
                                            v578[v603] = v605;
                                            v600 = v605;
                                            v601 += 1 ;
                                        }
                                        float v606;
                                        v606 = v579 + v598;
                                        v579 = v606;
                                        v580 += 1 ;
                                    }
                                    float v607[4];
                                    bool v608[4];
                                    int v609;
                                    v609 = 0;
                                    while (while_method_6(v609)){
                                        int v611;
                                        v611 = 0;
                                        while (while_method_3(v611)){
                                            assert("Tensor range check" && 0 <= v609 && v609 < 1);
                                            assert("Tensor range check" && 0 <= v611 && v611 < 4);
                                            int v613;
                                            v613 = 4 * v609;
                                            int v614;
                                            v614 = v613 + v611;
                                            float v615;
                                            v615 = v578[v614];
                                            float v616;
                                            v616 = v544[v614];
                                            bool v617;
                                            v617 = v616 > 0.0f;
                                            assert("Tensor range check" && 0 <= v609 && v609 < 1);
                                            assert("Tensor range check" && 0 <= v611 && v611 < 4);
                                            v607[v614] = v615;
                                            v608[v614] = v617;
                                            v611 += 1 ;
                                        }
                                        v609 += 1 ;
                                    }
                                    float v618; bool v619;
                                    Tuple14 tmp87 = Tuple14{-1.0f / 0.0f, false};
                                    v618 = tmp87.v0; v619 = tmp87.v1;
                                    int v620;
                                    v620 = 0;
                                    while (while_method_6(v620)){
                                        int v622;
                                        v622 = 0;
                                        while (while_method_3(v622)){
                                            assert("Tensor range check" && 0 <= v620 && v620 < 1);
                                            assert("Tensor range check" && 0 <= v622 && v622 < 4);
                                            int v624;
                                            v624 = 4 * v620;
                                            int v625;
                                            v625 = v624 + v622;
                                            float v626;
                                            v626 = v607[v625];
                                            bool v627;
                                            v627 = v608[v625];
                                            float v634; bool v635;
                                            if (v619){
                                                if (v627){
                                                    bool v628;
                                                    v628 = v618 >= v626;
                                                    float v629;
                                                    if (v628){
                                                        v629 = v618;
                                                    } else {
                                                        v629 = v626;
                                                    }
                                                    v634 = v629; v635 = true;
                                                } else {
                                                    v634 = v618; v635 = v619;
                                                }
                                            } else {
                                                if (v627){
                                                    v634 = v626; v635 = v627;
                                                } else {
                                                    v634 = v618; v635 = v619;
                                                }
                                            }
                                            v618 = v634;
                                            v619 = v635;
                                            v622 += 1 ;
                                        }
                                        v620 += 1 ;
                                    }
                                    auto v636 = cooperative_groups::coalesced_threads();
                                    int v637;
                                    v637 = threadIdx.x;
                                    int v638;
                                    v638 = v637 / 16;
                                    auto v639 = cooperative_groups::labeled_partition(v636,v638);
                                    Closure3 v640{};
                                    float v641; bool v642;
                                    Tuple14 tmp88 = cooperative_groups::reduce(v639, Tuple14{v618, v619}, v640);
                                    v641 = tmp88.v0; v642 = tmp88.v1;
                                    bool v643;
                                    v643 = v642 == false;
                                    if (v643){
                                        int v644;
                                        v644 = threadIdx.x;
                                        int v645;
                                        v645 = blockIdx.x;
                                        int v646;
                                        v646 = v645 * 256;
                                        int v647;
                                        v647 = v644 + v646;
                                        cuda::counting_semaphore<cuda::thread_scope_system, 1> & v648 = console_lock;
                                        auto v649 = cooperative_groups::coalesced_threads();
                                        v648.acquire();
                                        int v650;
                                        v650 = 0;
                                        printf("{%s = %d; %s = %c","tid", v647, "x'", '[');
                                        int v651;
                                        v651 = 0;
                                        while (while_method_6(v651)){
                                            int v653;
                                            v653 = v650;
                                            bool v654;
                                            v654 = v653 >= 100;
                                            if (v654){
                                                printf("%s"," ...");
                                                break;
                                            } else {
                                            }
                                            bool v655;
                                            v655 = v651 == 0;
                                            bool v656;
                                            v656 = v655 != true;
                                            if (v656){
                                                printf("%s","; ");
                                            } else {
                                            }
                                            printf("%c",'[');
                                            int v657;
                                            v657 = 0;
                                            while (while_method_3(v657)){
                                                int v659;
                                                v659 = v650;
                                                bool v660;
                                                v660 = v659 >= 100;
                                                if (v660){
                                                    printf("%s"," ...");
                                                    break;
                                                } else {
                                                }
                                                bool v661;
                                                v661 = v657 == 0;
                                                bool v662;
                                                v662 = v661 != true;
                                                if (v662){
                                                    printf("%s","; ");
                                                } else {
                                                }
                                                int v663;
                                                v663 = v650 + 1;
                                                v650 = v663;
                                                int v664;
                                                v664 = v651 * 4;
                                                int v665;
                                                v665 = v664 + v657;
                                                float v666;
                                                v666 = v607[v665];
                                                bool v667;
                                                v667 = v608[v665];
                                                const char * v670;
                                                if (v667){
                                                    const char * v668;
                                                    v668 = "true";
                                                    v670 = v668;
                                                } else {
                                                    const char * v669;
                                                    v669 = "false";
                                                    v670 = v669;
                                                }
                                                printf("%f, %s",v666, v670);
                                                v657 += 1 ;
                                            }
                                            printf("%c",']');
                                            v651 += 1 ;
                                        }
                                        printf("%c",']');
                                        printf("}\n");
                                        v648.release();
                                        v649.sync() ;
                                    } else {
                                    }
                                    if (v643){
                                        assert("The local reduce must be true." && v642);
                                    } else {
                                    }
                                    float v706[4];
                                    int v707[4];
                                    int v708;
                                    v708 = 0;
                                    while (while_method_6(v708)){
                                        int v710;
                                        v710 = 0;
                                        while (while_method_3(v710)){
                                            assert("Tensor range check" && 0 <= v708 && v708 < 1);
                                            assert("Tensor range check" && 0 <= v710 && v710 < 4);
                                            int v712;
                                            v712 = 4 * v708;
                                            int v713;
                                            v713 = v712 + v710;
                                            int v714;
                                            v714 = v545[v713];
                                            float v715;
                                            v715 = curand_uniform(&v184);
                                            assert("Tensor range check" && 0 <= v708 && v708 < 1);
                                            assert("Tensor range check" && 0 <= v710 && v710 < 4);
                                            v706[v713] = v715;
                                            v707[v713] = v714;
                                            v710 += 1 ;
                                        }
                                        v708 += 1 ;
                                    }
                                    float v716; int v717;
                                    Tuple15 tmp89 = Tuple15{0.0f, 2147483647};
                                    v716 = tmp89.v0; v717 = tmp89.v1;
                                    int v718;
                                    v718 = 0;
                                    while (while_method_6(v718)){
                                        int v720;
                                        v720 = 0;
                                        while (while_method_3(v720)){
                                            assert("Tensor range check" && 0 <= v718 && v718 < 1);
                                            assert("Tensor range check" && 0 <= v720 && v720 < 4);
                                            int v722;
                                            v722 = 4 * v718;
                                            int v723;
                                            v723 = v722 + v720;
                                            float v724;
                                            v724 = v706[v723];
                                            int v725;
                                            v725 = v707[v723];
                                            bool v726;
                                            v726 = v717 < v725;
                                            float v727; int v728;
                                            if (v726){
                                                v727 = v716; v728 = v717;
                                            } else {
                                                v727 = v724; v728 = v725;
                                            }
                                            v716 = v727;
                                            v717 = v728;
                                            v720 += 1 ;
                                        }
                                        v718 += 1 ;
                                    }
                                    auto v729 = cooperative_groups::coalesced_threads();
                                    int v730;
                                    v730 = threadIdx.x;
                                    int v731;
                                    v731 = v730 / 16;
                                    auto v732 = cooperative_groups::labeled_partition(v729,v731);
                                    Closure4 v733{};
                                    float v734; int v735;
                                    Tuple15 tmp90 = cooperative_groups::reduce(v732, Tuple15{v716, v717}, v733);
                                    v734 = tmp90.v0; v735 = tmp90.v1;
                                    float v736;
                                    v736 = v641 * v734;
                                    int v737[4];
                                    bool v738[4];
                                    int v739;
                                    v739 = 0;
                                    while (while_method_6(v739)){
                                        int v741;
                                        v741 = 0;
                                        while (while_method_3(v741)){
                                            assert("Tensor range check" && 0 <= v739 && v739 < 1);
                                            assert("Tensor range check" && 0 <= v741 && v741 < 4);
                                            int v743;
                                            v743 = 4 * v739;
                                            int v744;
                                            v744 = v743 + v741;
                                            float v745;
                                            v745 = v607[v744];
                                            bool v746;
                                            v746 = v608[v744];
                                            int v747;
                                            v747 = v545[v744];
                                            int v750; bool v751;
                                            if (v746){
                                                float v748;
                                                v748 = v745 - v736;
                                                bool v749;
                                                v749 = v748 >= 0.0f;
                                                v750 = v747; v751 = v749;
                                            } else {
                                                v750 = 2147483647; v751 = false;
                                            }
                                            assert("Tensor range check" && 0 <= v739 && v739 < 1);
                                            assert("Tensor range check" && 0 <= v741 && v741 < 4);
                                            v737[v744] = v750;
                                            v738[v744] = v751;
                                            v741 += 1 ;
                                        }
                                        v739 += 1 ;
                                    }
                                    int v752; bool v753;
                                    Tuple16 tmp91 = Tuple16{2147483647, false};
                                    v752 = tmp91.v0; v753 = tmp91.v1;
                                    int v754;
                                    v754 = 0;
                                    while (while_method_6(v754)){
                                        int v756;
                                        v756 = 0;
                                        while (while_method_3(v756)){
                                            assert("Tensor range check" && 0 <= v754 && v754 < 1);
                                            assert("Tensor range check" && 0 <= v756 && v756 < 4);
                                            int v758;
                                            v758 = 4 * v754;
                                            int v759;
                                            v759 = v758 + v756;
                                            int v760;
                                            v760 = v737[v759];
                                            bool v761;
                                            v761 = v738[v759];
                                            int v768; bool v769;
                                            if (v753){
                                                if (v761){
                                                    bool v762;
                                                    v762 = v752 < v760;
                                                    int v763;
                                                    if (v762){
                                                        v763 = v752;
                                                    } else {
                                                        v763 = v760;
                                                    }
                                                    v768 = v763; v769 = true;
                                                } else {
                                                    v768 = v752; v769 = v753;
                                                }
                                            } else {
                                                if (v761){
                                                    v768 = v760; v769 = v761;
                                                } else {
                                                    v768 = v752; v769 = v753;
                                                }
                                            }
                                            v752 = v768;
                                            v753 = v769;
                                            v756 += 1 ;
                                        }
                                        v754 += 1 ;
                                    }
                                    auto v770 = cooperative_groups::coalesced_threads();
                                    int v771;
                                    v771 = threadIdx.x;
                                    int v772;
                                    v772 = v771 / 16;
                                    auto v773 = cooperative_groups::labeled_partition(v770,v772);
                                    Closure5 v774{};
                                    int v775; bool v776;
                                    Tuple16 tmp92 = cooperative_groups::reduce(v773, Tuple16{v752, v753}, v774);
                                    v775 = tmp92.v0; v776 = tmp92.v1;
                                    bool v777;
                                    v777 = v776 == false;
                                    if (v777){
                                        int v778;
                                        v778 = threadIdx.x;
                                        int v779;
                                        v779 = blockIdx.x;
                                        int v780;
                                        v780 = v779 * 256;
                                        int v781;
                                        v781 = v778 + v780;
                                        cuda::counting_semaphore<cuda::thread_scope_system, 1> & v782 = console_lock;
                                        auto v783 = cooperative_groups::coalesced_threads();
                                        v782.acquire();
                                        int v784;
                                        v784 = 0;
                                        printf("{%s = %d; %s = %c","tid", v781, "x'", '[');
                                        int v785;
                                        v785 = 0;
                                        while (while_method_6(v785)){
                                            int v787;
                                            v787 = v784;
                                            bool v788;
                                            v788 = v787 >= 100;
                                            if (v788){
                                                printf("%s"," ...");
                                                break;
                                            } else {
                                            }
                                            bool v789;
                                            v789 = v785 == 0;
                                            bool v790;
                                            v790 = v789 != true;
                                            if (v790){
                                                printf("%s","; ");
                                            } else {
                                            }
                                            printf("%c",'[');
                                            int v791;
                                            v791 = 0;
                                            while (while_method_3(v791)){
                                                int v793;
                                                v793 = v784;
                                                bool v794;
                                                v794 = v793 >= 100;
                                                if (v794){
                                                    printf("%s"," ...");
                                                    break;
                                                } else {
                                                }
                                                bool v795;
                                                v795 = v791 == 0;
                                                bool v796;
                                                v796 = v795 != true;
                                                if (v796){
                                                    printf("%s","; ");
                                                } else {
                                                }
                                                int v797;
                                                v797 = v784 + 1;
                                                v784 = v797;
                                                int v798;
                                                v798 = v785 * 4;
                                                int v799;
                                                v799 = v798 + v791;
                                                int v800;
                                                v800 = v737[v799];
                                                bool v801;
                                                v801 = v738[v799];
                                                const char * v804;
                                                if (v801){
                                                    const char * v802;
                                                    v802 = "true";
                                                    v804 = v802;
                                                } else {
                                                    const char * v803;
                                                    v803 = "false";
                                                    v804 = v803;
                                                }
                                                printf("%d, %s",v800, v804);
                                                v791 += 1 ;
                                            }
                                            printf("%c",']');
                                            v785 += 1 ;
                                        }
                                        printf("%c",']');
                                        printf("}\n");
                                        v782.release();
                                        v783.sync() ;
                                    } else {
                                    }
                                    if (v777){
                                        assert("The local reduce must be true." && v776);
                                    } else {
                                    }
                                    float v840; int v841;
                                    Tuple15 tmp93 = Tuple15{0.0f, 2147483647};
                                    v840 = tmp93.v0; v841 = tmp93.v1;
                                    int v842;
                                    v842 = 0;
                                    while (while_method_6(v842)){
                                        int v844;
                                        v844 = 0;
                                        while (while_method_3(v844)){
                                            assert("Tensor range check" && 0 <= v842 && v842 < 1);
                                            assert("Tensor range check" && 0 <= v844 && v844 < 4);
                                            int v846;
                                            v846 = 4 * v842;
                                            int v847;
                                            v847 = v846 + v844;
                                            float v848;
                                            v848 = v544[v847];
                                            int v849;
                                            v849 = v545[v847];
                                            bool v850;
                                            v850 = v841 == v775;
                                            float v854; int v855;
                                            if (v850){
                                                v854 = v840; v855 = v841;
                                            } else {
                                                bool v851;
                                                v851 = v849 == v775;
                                                if (v851){
                                                    v854 = v848; v855 = v849;
                                                } else {
                                                    v854 = v840; v855 = v841;
                                                }
                                            }
                                            v840 = v854;
                                            v841 = v855;
                                            v844 += 1 ;
                                        }
                                        v842 += 1 ;
                                    }
                                    auto v856 = cooperative_groups::coalesced_threads();
                                    int v857;
                                    v857 = threadIdx.x;
                                    int v858;
                                    v858 = v857 / 16;
                                    auto v859 = cooperative_groups::labeled_partition(v856,v858);
                                    Closure6 v860{v775};
                                    float v861; int v862;
                                    Tuple15 tmp94 = cooperative_groups::reduce(v859, Tuple15{v840, v841}, v860);
                                    v861 = tmp94.v0; v862 = tmp94.v1;
                                    bool v863;
                                    v863 = v862 == 2147483647;
                                    bool v864;
                                    v864 = v863 != true;
                                    bool v865;
                                    v865 = v864 == false;
                                    if (v865){
                                        assert("Expected a valid action id in get_prob." && v864);
                                    } else {
                                    }
                                    int v867;
                                    v867 = 0;
                                    while (while_method_6(v867)){
                                        assert("Tensor range check" && 0 <= v867 && v867 < 1);
                                        assert("Tensor range check" && 0 <= v867 && v867 < 1);
                                        v867 += 1 ;
                                    }
                                    assert("Tensor range check" && 0 <= v536 && v536 < 256);
                                    v511[v536] = v861;
                                    v513[v536] = v775;
                                    v524 += 1 ;
                                }
                                __syncthreads();
                                assert("Tensor range check" && 0 <= v515 && v515 < 256);
                                float v869;
                                v869 = v511[v515];
                                int v870;
                                v870 = v513[v515];
                                __syncthreads();
                                extern __shared__ unsigned char v871[];
                                float * v872;
                                v872 = reinterpret_cast<float *>(&v871[0ull]);
                                int * v874;
                                v874 = reinterpret_cast<int *>(&v871[16ull]);
                                int v876;
                                v876 = threadIdx.x;
                                bool v877;
                                v877 = v876 == 0;
                                if (v877){
                                    v872[0] = v869;
                                    v874[0] = v870;
                                } else {
                                }
                                __syncthreads();
                                float v878;
                                v878 = v872[0];
                                int v879;
                                v879 = v874[0];
                                __syncthreads();
                                double * v880;
                                v880 = reinterpret_cast<double *>(&v1[121110528ull]);
                                double * v882;
                                v882 = reinterpret_cast<double *>(&v1[121503744ull]);
                                int v884;
                                v884 = threadIdx.x;
                                int v885;
                                v885 = blockIdx.x;
                                int v886;
                                v886 = v885 * 256;
                                int v887;
                                v887 = v884 + v886;
                                int v888;
                                v888 = 0;
                                while (while_method_3(v888)){
                                    float * v890;
                                    v890 = reinterpret_cast<float *>(&v1[114819072ull]);
                                    int v892;
                                    v892 = blockIdx.x;
                                    int v893;
                                    v893 = threadIdx.x;
                                    assert("Tensor range check" && 0 <= v888 && v888 < 4);
                                    assert("Tensor range check" && 0 <= v892 && v892 < 24);
                                    assert("Tensor range check" && 0 <= v893 && v893 < 256);
                                    assert("Tensor range check" && 0 <= v879 && v879 < 64);
                                    int v894;
                                    v894 = 64 * v893;
                                    int v895;
                                    v895 = v894 + v879;
                                    int v896;
                                    v896 = 16384 * v892;
                                    int v897;
                                    v897 = v896 + v895;
                                    int v898;
                                    v898 = 393216 * v888;
                                    int v899;
                                    v899 = v898 + v897;
                                    float v900;
                                    v900 = v890[v899];
                                    double v901;
                                    v901 = (double)v878;
                                    double v902;
                                    v902 = log(v901);
                                    double v903;
                                    v903 = (double)v900;
                                    double v904;
                                    v904 = log(v903);
                                    assert("Tensor range check" && 0 <= v888 && v888 < 4);
                                    assert("Tensor range check" && 0 <= v887 && v887 < 6144);
                                    assert("Tensor range check" && 0 <= v172 && v172 < 2);
                                    int v905;
                                    v905 = 2 * v887;
                                    int v906;
                                    v906 = v905 + v172;
                                    int v907;
                                    v907 = 12288 * v888;
                                    int v908;
                                    v908 = v907 + v906;
                                    double v909;
                                    v909 = v880[v908];
                                    double v910;
                                    v910 = v882[v908];
                                    double v911;
                                    v911 = v904 + v909;
                                    double v912;
                                    v912 = v902 + v910;
                                    bool v913;
                                    v913 = isnan(v912);
                                    bool v914;
                                    v914 = v913 == false;
                                    bool v915;
                                    v915 = v914 == false;
                                    if (v915){
                                        assert("The sampling log probability shouldn't be nan." && v914);
                                    } else {
                                    }
                                    bool v917;
                                    v917 = isnan(v911);
                                    bool v918;
                                    v918 = v917 == false;
                                    bool v919;
                                    v919 = v918 == false;
                                    if (v919){
                                        assert("The policy log probability shouldn't be nan." && v918);
                                    } else {
                                    }
                                    assert("Tensor range check" && 0 <= v888 && v888 < 4);
                                    assert("Tensor range check" && 0 <= v887 && v887 < 6144);
                                    assert("Tensor range check" && 0 <= v172 && v172 < 2);
                                    v880[v908] = v911;
                                    v882[v908] = v912;
                                    v888 += 1 ;
                                }
                                bool v921;
                                v921 = 0 == v879;
                                Union10 v930;
                                if (v921){
                                    v930 = Union10{Union10_1{}};
                                } else {
                                    bool v923;
                                    v923 = 1 == v879;
                                    if (v923){
                                        v930 = Union10{Union10_0{}};
                                    } else {
                                        bool v925;
                                        v925 = 2 == v879;
                                        if (v925){
                                            v930 = Union10{Union10_2{1, 1}};
                                        } else {
                                            printf("%s\n", "Invalid output id in the NL Holdem model.");
                                            __trap();
                                        }
                                    }
                                }
                                switch (v930.tag) {
                                    case 0: { // AA_Call
                                        v1218 = Union1{Union1_1{}};
                                        break;
                                    }
                                    case 1: { // AA_Fold
                                        int v931;
                                        v931 = v168[0];
                                        int v933; int v934;
                                        Tuple4 tmp95 = Tuple4{1, v931};
                                        v933 = tmp95.v0; v934 = tmp95.v1;
                                        while (while_method_0(v933)){
                                            bool v936;
                                            v936 = 0 <= v933;
                                            bool v938;
                                            if (v936){
                                                bool v937;
                                                v937 = v933 < 2;
                                                v938 = v937;
                                            } else {
                                                v938 = false;
                                            }
                                            bool v939;
                                            v939 = v938 == false;
                                            if (v939){
                                                assert("Index must be in range." && v938);
                                            } else {
                                            }
                                            int v941;
                                            v941 = v168[v933];
                                            bool v943;
                                            v943 = v934 >= v941;
                                            int v944;
                                            if (v943){
                                                v944 = v934;
                                            } else {
                                                v944 = v941;
                                            }
                                            v934 = v944;
                                            v933 += 1 ;
                                        }
                                        bool v946;
                                        if (v174){
                                            bool v945;
                                            v945 = v172 < 2;
                                            v946 = v945;
                                        } else {
                                            v946 = false;
                                        }
                                        bool v947;
                                        v947 = v946 == false;
                                        if (v947){
                                            assert("Index must be in range." && v946);
                                        } else {
                                        }
                                        int v949;
                                        v949 = v168[v172];
                                        bool v951;
                                        v951 = v949 == v934;
                                        if (v951){
                                            v1218 = Union1{Union1_1{}};
                                        } else {
                                            v1218 = Union1{Union1_2{}};
                                        }
                                        break;
                                    }
                                    case 2: { // AA_Raise
                                        int v956 = v930.case2.v0; int v957 = v930.case2.v1;
                                        static_array<int,2> v958;
                                        int v960;
                                        v960 = 0;
                                        while (while_method_0(v960)){
                                            bool v962;
                                            v962 = 0 <= v960;
                                            bool v964;
                                            if (v962){
                                                bool v963;
                                                v963 = v960 < 2;
                                                v964 = v963;
                                            } else {
                                                v964 = false;
                                            }
                                            bool v965;
                                            v965 = v964 == false;
                                            if (v965){
                                                assert("Index must be in range." && v964);
                                            } else {
                                            }
                                            int v967;
                                            v967 = v170[v960];
                                            bool v970;
                                            if (v962){
                                                bool v969;
                                                v969 = v960 < 2;
                                                v970 = v969;
                                            } else {
                                                v970 = false;
                                            }
                                            bool v971;
                                            v971 = v970 == false;
                                            if (v971){
                                                assert("Index must be in range." && v970);
                                            } else {
                                            }
                                            int v973;
                                            v973 = v168[v960];
                                            int v975;
                                            v975 = v967 + v973;
                                            v958[v960] = v975;
                                            v960 += 1 ;
                                        }
                                        int v976;
                                        v976 = v168[0];
                                        int v978; int v979;
                                        Tuple4 tmp96 = Tuple4{1, v976};
                                        v978 = tmp96.v0; v979 = tmp96.v1;
                                        while (while_method_0(v978)){
                                            bool v981;
                                            v981 = 0 <= v978;
                                            bool v983;
                                            if (v981){
                                                bool v982;
                                                v982 = v978 < 2;
                                                v983 = v982;
                                            } else {
                                                v983 = false;
                                            }
                                            bool v984;
                                            v984 = v983 == false;
                                            if (v984){
                                                assert("Index must be in range." && v983);
                                            } else {
                                            }
                                            int v986;
                                            v986 = v168[v978];
                                            bool v988;
                                            v988 = v979 >= v986;
                                            int v989;
                                            if (v988){
                                                v989 = v979;
                                            } else {
                                                v989 = v986;
                                            }
                                            v979 = v989;
                                            v978 += 1 ;
                                        }
                                        bool v991;
                                        if (v174){
                                            bool v990;
                                            v990 = v172 < 2;
                                            v991 = v990;
                                        } else {
                                            v991 = false;
                                        }
                                        bool v992;
                                        v992 = v991 == false;
                                        if (v992){
                                            assert("Index must be in range." && v991);
                                        } else {
                                        }
                                        int v994;
                                        v994 = v958[v172];
                                        bool v996;
                                        v996 = v979 < v994;
                                        int v997;
                                        if (v996){
                                            v997 = v979;
                                        } else {
                                            v997 = v994;
                                        }
                                        static_array<int,2> v998;
                                        int v1000;
                                        v1000 = 0;
                                        while (while_method_0(v1000)){
                                            bool v1002;
                                            v1002 = 0 <= v1000;
                                            bool v1004;
                                            if (v1002){
                                                bool v1003;
                                                v1003 = v1000 < 2;
                                                v1004 = v1003;
                                            } else {
                                                v1004 = false;
                                            }
                                            bool v1005;
                                            v1005 = v1004 == false;
                                            if (v1005){
                                                assert("Index must be in range." && v1004);
                                            } else {
                                            }
                                            int v1007;
                                            v1007 = v168[v1000];
                                            bool v1009;
                                            v1009 = v172 == v1000;
                                            int v1010;
                                            if (v1009){
                                                v1010 = v997;
                                            } else {
                                                v1010 = v1007;
                                            }
                                            v998[v1000] = v1010;
                                            v1000 += 1 ;
                                        }
                                        int v1011;
                                        v1011 = v998[0];
                                        int v1013; int v1014;
                                        Tuple4 tmp97 = Tuple4{1, v1011};
                                        v1013 = tmp97.v0; v1014 = tmp97.v1;
                                        while (while_method_0(v1013)){
                                            bool v1016;
                                            v1016 = 0 <= v1013;
                                            bool v1018;
                                            if (v1016){
                                                bool v1017;
                                                v1017 = v1013 < 2;
                                                v1018 = v1017;
                                            } else {
                                                v1018 = false;
                                            }
                                            bool v1019;
                                            v1019 = v1018 == false;
                                            if (v1019){
                                                assert("Index must be in range." && v1018);
                                            } else {
                                            }
                                            int v1021;
                                            v1021 = v998[v1013];
                                            int v1023;
                                            v1023 = v1014 + v1021;
                                            v1014 = v1023;
                                            v1013 += 1 ;
                                        }
                                        static_array<int,2> v1024;
                                        int v1026;
                                        v1026 = 0;
                                        while (while_method_0(v1026)){
                                            bool v1028;
                                            v1028 = 0 <= v1026;
                                            bool v1030;
                                            if (v1028){
                                                bool v1029;
                                                v1029 = v1026 < 2;
                                                v1030 = v1029;
                                            } else {
                                                v1030 = false;
                                            }
                                            bool v1031;
                                            v1031 = v1030 == false;
                                            if (v1031){
                                                assert("Index must be in range." && v1030);
                                            } else {
                                            }
                                            int v1033;
                                            v1033 = v958[v1026];
                                            bool v1036;
                                            if (v1028){
                                                bool v1035;
                                                v1035 = v1026 < 2;
                                                v1036 = v1035;
                                            } else {
                                                v1036 = false;
                                            }
                                            bool v1037;
                                            v1037 = v1036 == false;
                                            if (v1037){
                                                assert("Index must be in range." && v1036);
                                            } else {
                                            }
                                            int v1039;
                                            v1039 = v998[v1026];
                                            int v1041;
                                            v1041 = v1033 - v1039;
                                            v1024[v1026] = v1041;
                                            v1026 += 1 ;
                                        }
                                        int v1042;
                                        v1042 = v956 * v1014;
                                        int v1043;
                                        v1043 = v1042 / v957;
                                        bool v1044;
                                        v1044 = v166 >= v1043;
                                        int v1045;
                                        if (v1044){
                                            v1045 = v166;
                                        } else {
                                            v1045 = v1043;
                                        }
                                        bool v1047;
                                        if (v174){
                                            bool v1046;
                                            v1046 = v172 < 2;
                                            v1047 = v1046;
                                        } else {
                                            v1047 = false;
                                        }
                                        bool v1048;
                                        v1048 = v1047 == false;
                                        if (v1048){
                                            assert("Index must be in range." && v1047);
                                        } else {
                                        }
                                        int v1050;
                                        v1050 = v1024[v172];
                                        bool v1052;
                                        v1052 = v1045 >= v1050;
                                        if (v1052){
                                            v1218 = Union1{Union1_0{}};
                                        } else {
                                            v1218 = Union1{Union1_3{v1045}};
                                        }
                                        break;
                                    }
                                    default: {
                                        assert("Invalid tag." && false); __trap();
                                    }
                                }
                                break;
                            }
                            case 2: { // Human
                                printf("%s\n", "Humans aren't allowed during training.");
                                __trap();
                                break;
                            }
                            case 3: { // Random
                                curandStatePhilox4_32_10_t & v1059 = v3.v5;
                                curandStatePhilox4_32_10_t & v1060 = v1059;
                                static_array<int,2> v1061;
                                int v1063;
                                v1063 = 0;
                                while (while_method_0(v1063)){
                                    bool v1065;
                                    v1065 = 0 <= v1063;
                                    bool v1067;
                                    if (v1065){
                                        bool v1066;
                                        v1066 = v1063 < 2;
                                        v1067 = v1066;
                                    } else {
                                        v1067 = false;
                                    }
                                    bool v1068;
                                    v1068 = v1067 == false;
                                    if (v1068){
                                        assert("Index must be in range." && v1067);
                                    } else {
                                    }
                                    int v1070;
                                    v1070 = v170[v1063];
                                    bool v1073;
                                    if (v1065){
                                        bool v1072;
                                        v1072 = v1063 < 2;
                                        v1073 = v1072;
                                    } else {
                                        v1073 = false;
                                    }
                                    bool v1074;
                                    v1074 = v1073 == false;
                                    if (v1074){
                                        assert("Index must be in range." && v1073);
                                    } else {
                                    }
                                    int v1076;
                                    v1076 = v168[v1063];
                                    int v1078;
                                    v1078 = v1070 + v1076;
                                    v1061[v1063] = v1078;
                                    v1063 += 1 ;
                                }
                                int v1079;
                                v1079 = v168[0];
                                int v1081; int v1082;
                                Tuple4 tmp98 = Tuple4{1, v1079};
                                v1081 = tmp98.v0; v1082 = tmp98.v1;
                                while (while_method_0(v1081)){
                                    bool v1084;
                                    v1084 = 0 <= v1081;
                                    bool v1086;
                                    if (v1084){
                                        bool v1085;
                                        v1085 = v1081 < 2;
                                        v1086 = v1085;
                                    } else {
                                        v1086 = false;
                                    }
                                    bool v1087;
                                    v1087 = v1086 == false;
                                    if (v1087){
                                        assert("Index must be in range." && v1086);
                                    } else {
                                    }
                                    int v1089;
                                    v1089 = v168[v1081];
                                    bool v1091;
                                    v1091 = v1082 >= v1089;
                                    int v1092;
                                    if (v1091){
                                        v1092 = v1082;
                                    } else {
                                        v1092 = v1089;
                                    }
                                    v1082 = v1092;
                                    v1081 += 1 ;
                                }
                                bool v1094;
                                if (v174){
                                    bool v1093;
                                    v1093 = v172 < 2;
                                    v1094 = v1093;
                                } else {
                                    v1094 = false;
                                }
                                bool v1095;
                                v1095 = v1094 == false;
                                if (v1095){
                                    assert("Index must be in range." && v1094);
                                } else {
                                }
                                int v1097;
                                v1097 = v1061[v172];
                                bool v1099;
                                v1099 = v1082 < v1097;
                                int v1100;
                                if (v1099){
                                    v1100 = v1082;
                                } else {
                                    v1100 = v1097;
                                }
                                static_array<int,2> v1101;
                                int v1103;
                                v1103 = 0;
                                while (while_method_0(v1103)){
                                    bool v1105;
                                    v1105 = 0 <= v1103;
                                    bool v1107;
                                    if (v1105){
                                        bool v1106;
                                        v1106 = v1103 < 2;
                                        v1107 = v1106;
                                    } else {
                                        v1107 = false;
                                    }
                                    bool v1108;
                                    v1108 = v1107 == false;
                                    if (v1108){
                                        assert("Index must be in range." && v1107);
                                    } else {
                                    }
                                    int v1110;
                                    v1110 = v168[v1103];
                                    bool v1112;
                                    v1112 = v172 == v1103;
                                    int v1113;
                                    if (v1112){
                                        v1113 = v1100;
                                    } else {
                                        v1113 = v1110;
                                    }
                                    v1101[v1103] = v1113;
                                    v1103 += 1 ;
                                }
                                int v1114;
                                v1114 = v1101[0];
                                int v1116; int v1117;
                                Tuple4 tmp99 = Tuple4{1, v1114};
                                v1116 = tmp99.v0; v1117 = tmp99.v1;
                                while (while_method_0(v1116)){
                                    bool v1119;
                                    v1119 = 0 <= v1116;
                                    bool v1121;
                                    if (v1119){
                                        bool v1120;
                                        v1120 = v1116 < 2;
                                        v1121 = v1120;
                                    } else {
                                        v1121 = false;
                                    }
                                    bool v1122;
                                    v1122 = v1121 == false;
                                    if (v1122){
                                        assert("Index must be in range." && v1121);
                                    } else {
                                    }
                                    int v1124;
                                    v1124 = v1101[v1116];
                                    int v1126;
                                    v1126 = v1117 + v1124;
                                    v1117 = v1126;
                                    v1116 += 1 ;
                                }
                                static_array<int,2> v1127;
                                int v1129;
                                v1129 = 0;
                                while (while_method_0(v1129)){
                                    bool v1131;
                                    v1131 = 0 <= v1129;
                                    bool v1133;
                                    if (v1131){
                                        bool v1132;
                                        v1132 = v1129 < 2;
                                        v1133 = v1132;
                                    } else {
                                        v1133 = false;
                                    }
                                    bool v1134;
                                    v1134 = v1133 == false;
                                    if (v1134){
                                        assert("Index must be in range." && v1133);
                                    } else {
                                    }
                                    int v1136;
                                    v1136 = v1061[v1129];
                                    bool v1139;
                                    if (v1131){
                                        bool v1138;
                                        v1138 = v1129 < 2;
                                        v1139 = v1138;
                                    } else {
                                        v1139 = false;
                                    }
                                    bool v1140;
                                    v1140 = v1139 == false;
                                    if (v1140){
                                        assert("Index must be in range." && v1139);
                                    } else {
                                    }
                                    int v1142;
                                    v1142 = v1101[v1129];
                                    int v1144;
                                    v1144 = v1136 - v1142;
                                    v1127[v1129] = v1144;
                                    v1129 += 1 ;
                                }
                                bool v1146;
                                if (v174){
                                    bool v1145;
                                    v1145 = v172 < 2;
                                    v1146 = v1145;
                                } else {
                                    v1146 = false;
                                }
                                bool v1147;
                                v1147 = v1146 == false;
                                if (v1147){
                                    assert("Index must be in range." && v1146);
                                } else {
                                }
                                int v1149;
                                v1149 = v168[v172];
                                bool v1151;
                                v1151 = v1149 < v1082;
                                float v1152;
                                if (v1151){
                                    v1152 = 1.0f;
                                } else {
                                    v1152 = 0.0f;
                                }
                                int v1153;
                                v1153 = v1117 / 3;
                                bool v1154;
                                v1154 = v166 <= v1153;
                                bool v1162;
                                if (v1154){
                                    bool v1156;
                                    if (v174){
                                        bool v1155;
                                        v1155 = v172 < 2;
                                        v1156 = v1155;
                                    } else {
                                        v1156 = false;
                                    }
                                    bool v1157;
                                    v1157 = v1156 == false;
                                    if (v1157){
                                        assert("Index must be in range." && v1156);
                                    } else {
                                    }
                                    int v1159;
                                    v1159 = v1127[v172];
                                    bool v1161;
                                    v1161 = v1153 < v1159;
                                    v1162 = v1161;
                                } else {
                                    v1162 = false;
                                }
                                float v1163;
                                if (v1162){
                                    v1163 = 1.0f;
                                } else {
                                    v1163 = 0.0f;
                                }
                                int v1164;
                                v1164 = v1117 / 2;
                                bool v1165;
                                v1165 = v166 <= v1164;
                                bool v1173;
                                if (v1165){
                                    bool v1167;
                                    if (v174){
                                        bool v1166;
                                        v1166 = v172 < 2;
                                        v1167 = v1166;
                                    } else {
                                        v1167 = false;
                                    }
                                    bool v1168;
                                    v1168 = v1167 == false;
                                    if (v1168){
                                        assert("Index must be in range." && v1167);
                                    } else {
                                    }
                                    int v1170;
                                    v1170 = v1127[v172];
                                    bool v1172;
                                    v1172 = v1164 < v1170;
                                    v1173 = v1172;
                                } else {
                                    v1173 = false;
                                }
                                float v1174;
                                if (v1173){
                                    v1174 = 1.0f;
                                } else {
                                    v1174 = 0.0f;
                                }
                                bool v1175;
                                v1175 = v166 <= v1117;
                                bool v1183;
                                if (v1175){
                                    bool v1177;
                                    if (v174){
                                        bool v1176;
                                        v1176 = v172 < 2;
                                        v1177 = v1176;
                                    } else {
                                        v1177 = false;
                                    }
                                    bool v1178;
                                    v1178 = v1177 == false;
                                    if (v1178){
                                        assert("Index must be in range." && v1177);
                                    } else {
                                    }
                                    int v1180;
                                    v1180 = v1127[v172];
                                    bool v1182;
                                    v1182 = v1117 < v1180;
                                    v1183 = v1182;
                                } else {
                                    v1183 = false;
                                }
                                float v1184;
                                if (v1183){
                                    v1184 = 1.0f;
                                } else {
                                    v1184 = 0.0f;
                                }
                                static_array<Tuple17,6> v1185;
                                Union1 v1187;
                                v1187 = Union1{Union1_2{}};
                                v1185[0] = Tuple17{v1187, v1152};
                                Union1 v1189;
                                v1189 = Union1{Union1_1{}};
                                v1185[1] = Tuple17{v1189, 4.0f};
                                Union1 v1191;
                                v1191 = Union1{Union1_3{v1153}};
                                v1185[2] = Tuple17{v1191, v1163};
                                Union1 v1193;
                                v1193 = Union1{Union1_3{v1164}};
                                v1185[3] = Tuple17{v1193, v1174};
                                Union1 v1195;
                                v1195 = Union1{Union1_3{v1117}};
                                v1185[4] = Tuple17{v1195, v1184};
                                Union1 v1197;
                                v1197 = Union1{Union1_0{}};
                                v1185[5] = Tuple17{v1197, 1.0f};
                                Union1 v1199;
                                v1199 = sample_discrete_50(v1185, v1060);
                                int v1200;
                                v1200 = sizeof(Union1);
                                unsigned long long v1201;
                                v1201 = (unsigned long long)v1200;
                                bool v1202;
                                v1202 = v1201 <= 98304ull;
                                bool v1203;
                                v1203 = v1202 == false;
                                if (v1203){
                                    assert("The dynamic shared memory is insufficient to allocate the tensor." && v1202);
                                } else {
                                }
                                extern __shared__ unsigned char v1205[];
                                bool v1206;
                                v1206 = v1201 <= v1201;
                                bool v1207;
                                v1207 = v1206 == false;
                                if (v1207){
                                    assert("The length of the partition has to be less than or equal to the length of the base array." && v1206);
                                } else {
                                }
                                Union1 * v1209;
                                v1209 = reinterpret_cast<Union1 *>(&v1205[0ull]);
                                int v1211;
                                v1211 = threadIdx.x;
                                bool v1212;
                                v1212 = v1211 == 0;
                                if (v1212){
                                    v1209[0] = v1199;
                                } else {
                                }
                                __syncthreads();
                                Union1 v1213;
                                v1213 = v1209[0];
                                __syncthreads();
                                v1218 = v1213;
                                break;
                            }
                            default: {
                                assert("Invalid tag." && false); __trap();
                            }
                        }
                        Union6 v1219;
                        v1219 = Union6{Union6_2{v172, v1218}};
                        v18.push(v1219);
                        v1370 = Union18{Union18_1{v166, v167, v168, v169, v170, v171, v1218}};
                        break;
                    }
                    case 5: { // G_Round'
                        int v1221 = v23.case5.v0; static_array<static_array<unsigned char,2>,2> v1222 = v23.case5.v1; static_array<int,2> v1223 = v23.case5.v2; int v1224 = v23.case5.v3; static_array<int,2> v1225 = v23.case5.v4; Union5 v1226 = v23.case5.v5; Union1 v1227 = v23.case5.v6;
                        int v1228;
                        v1228 = v1224 % 2;
                        Union6 v1229;
                        v1229 = Union6{Union6_2{v1228, v1227}};
                        v18.push(v1229);
                        v1370 = Union18{Union18_1{v1221, v1222, v1223, v1224, v1225, v1226, v1227}};
                        break;
                    }
                    case 6: { // G_Showdown
                        int v47 = v23.case6.v0; static_array<static_array<unsigned char,2>,2> v48 = v23.case6.v1; static_array<int,2> v49 = v23.case6.v2; int v50 = v23.case6.v3; static_array<int,2> v51 = v23.case6.v4; Union5 v52 = v23.case6.v5;
                        static_array<unsigned char,5> v55;
                        switch (v52.tag) {
                            case 2: { // River
                                static_array<unsigned char,5> v53 = v52.case2.v0;
                                v55 = v53;
                                break;
                            }
                            default: {
                                printf("%s\n", "Invalid street in showdown.");
                                __trap();
                            }
                        }
                        static_array<unsigned char,2> v56;
                        v56 = v48[0];
                        static_array<unsigned char,7> v58;
                        int v60;
                        v60 = 0;
                        while (while_method_0(v60)){
                            bool v62;
                            v62 = 0 <= v60;
                            bool v64;
                            if (v62){
                                bool v63;
                                v63 = v60 < 2;
                                v64 = v63;
                            } else {
                                v64 = false;
                            }
                            bool v65;
                            v65 = v64 == false;
                            if (v65){
                                assert("Index must be in range." && v64);
                            } else {
                            }
                            unsigned char v67;
                            v67 = v56[v60];
                            v58[v60] = v67;
                            v60 += 1 ;
                        }
                        int v69;
                        v69 = 0;
                        while (while_method_2(v69)){
                            bool v71;
                            v71 = 0 <= v69;
                            bool v73;
                            if (v71){
                                bool v72;
                                v72 = v69 < 5;
                                v73 = v72;
                            } else {
                                v73 = false;
                            }
                            bool v74;
                            v74 = v73 == false;
                            if (v74){
                                assert("Index must be in range." && v73);
                            } else {
                            }
                            unsigned char v76;
                            v76 = v55[v69];
                            int v78;
                            v78 = 2 + v69;
                            v58[v78] = v76;
                            v69 += 1 ;
                        }
                        static_array<unsigned char,5> v79; char v80;
                        Tuple0 tmp100 = score_54(v58);
                        v79 = tmp100.v0; v80 = tmp100.v1;
                        static_array<unsigned char,2> v81;
                        v81 = v48[1];
                        static_array<unsigned char,7> v83;
                        int v85;
                        v85 = 0;
                        while (while_method_0(v85)){
                            bool v87;
                            v87 = 0 <= v85;
                            bool v89;
                            if (v87){
                                bool v88;
                                v88 = v85 < 2;
                                v89 = v88;
                            } else {
                                v89 = false;
                            }
                            bool v90;
                            v90 = v89 == false;
                            if (v90){
                                assert("Index must be in range." && v89);
                            } else {
                            }
                            unsigned char v92;
                            v92 = v81[v85];
                            v83[v85] = v92;
                            v85 += 1 ;
                        }
                        int v94;
                        v94 = 0;
                        while (while_method_2(v94)){
                            bool v96;
                            v96 = 0 <= v94;
                            bool v98;
                            if (v96){
                                bool v97;
                                v97 = v94 < 5;
                                v98 = v97;
                            } else {
                                v98 = false;
                            }
                            bool v99;
                            v99 = v98 == false;
                            if (v99){
                                assert("Index must be in range." && v98);
                            } else {
                            }
                            unsigned char v101;
                            v101 = v55[v94];
                            int v103;
                            v103 = 2 + v94;
                            v83[v103] = v101;
                            v94 += 1 ;
                        }
                        static_array<unsigned char,5> v104; char v105;
                        Tuple0 tmp101 = score_54(v83);
                        v104 = tmp101.v0; v105 = tmp101.v1;
                        int v106;
                        v106 = v50 % 2;
                        bool v107;
                        v107 = 0 <= v106;
                        bool v109;
                        if (v107){
                            bool v108;
                            v108 = v106 < 2;
                            v109 = v108;
                        } else {
                            v109 = false;
                        }
                        bool v110;
                        v110 = v109 == false;
                        if (v110){
                            assert("Index must be in range." && v109);
                        } else {
                        }
                        int v112;
                        v112 = v49[v106];
                        bool v114;
                        v114 = v80 < v105;
                        Union11 v120;
                        if (v114){
                            v120 = Union11{Union11_2{}};
                        } else {
                            bool v116;
                            v116 = v80 > v105;
                            if (v116){
                                v120 = Union11{Union11_1{}};
                            } else {
                                v120 = Union11{Union11_0{}};
                            }
                        }
                        Union11 v148;
                        switch (v120.tag) {
                            case 0: { // Eq
                                Union11 v121;
                                v121 = Union11{Union11_0{}};
                                int v122;
                                v122 = 0;
                                while (while_method_2(v122)){
                                    bool v124;
                                    v124 = 0 <= v122;
                                    bool v126;
                                    if (v124){
                                        bool v125;
                                        v125 = v122 < 5;
                                        v126 = v125;
                                    } else {
                                        v126 = false;
                                    }
                                    bool v127;
                                    v127 = v126 == false;
                                    if (v127){
                                        assert("Index must be in range." && v126);
                                    } else {
                                    }
                                    unsigned char v129;
                                    v129 = v79[v122];
                                    bool v132;
                                    if (v124){
                                        bool v131;
                                        v131 = v122 < 5;
                                        v132 = v131;
                                    } else {
                                        v132 = false;
                                    }
                                    bool v133;
                                    v133 = v132 == false;
                                    if (v133){
                                        assert("Index must be in range." && v132);
                                    } else {
                                    }
                                    unsigned char v135;
                                    v135 = v104[v122];
                                    unsigned char v137;
                                    v137 = v129 / 4u;
                                    unsigned char v138;
                                    v138 = v135 / 4u;
                                    bool v139;
                                    v139 = v137 < v138;
                                    Union11 v145;
                                    if (v139){
                                        v145 = Union11{Union11_2{}};
                                    } else {
                                        bool v141;
                                        v141 = v137 > v138;
                                        if (v141){
                                            v145 = Union11{Union11_1{}};
                                        } else {
                                            v145 = Union11{Union11_0{}};
                                        }
                                    }
                                    bool v146;
                                    switch (v145.tag) {
                                        case 0: { // Eq
                                            v146 = true;
                                            break;
                                        }
                                        default: {
                                            v146 = false;
                                        }
                                    }
                                    bool v147;
                                    v147 = v146 == false;
                                    if (v147){
                                        v121 = v145;
                                        break;
                                    } else {
                                    }
                                    v122 += 1 ;
                                }
                                v148 = v121;
                                break;
                            }
                            default: {
                                v148 = v120;
                            }
                        }
                        int v153; int v154;
                        switch (v148.tag) {
                            case 0: { // Eq
                                v153 = 0; v154 = -1;
                                break;
                            }
                            case 1: { // Gt
                                v153 = v112; v154 = 0;
                                break;
                            }
                            case 2: { // Lt
                                v153 = v112; v154 = 1;
                                break;
                            }
                            default: {
                                assert("Invalid tag." && false); __trap();
                            }
                        }
                        int v155;
                        v155 = -v154;
                        bool v156;
                        v156 = v154 >= v155;
                        int v157;
                        if (v156){
                            v157 = v154;
                        } else {
                            v157 = v155;
                        }
                        float v158;
                        v158 = (float)v153;
                        static_array<float,2> & v159 = v3.v4;
                        v159[v157] = v158;
                        int v160;
                        v160 = v157 ^ 1;
                        float v161;
                        v161 = -v158;
                        v159[v160] = v161;
                        static_array<Tuple0,2> v162;
                        v162[0] = Tuple0{v79, v80};
                        v162[1] = Tuple0{v104, v105};
                        Union6 v164;
                        v164 = Union6{Union6_4{v153, v162, v154}};
                        v18.push(v164);
                        v1370 = Union18{Union18_0{}};
                        break;
                    }
                    case 7: { // G_Turn
                        int v1250 = v23.case7.v0; static_array<static_array<unsigned char,2>,2> v1251 = v23.case7.v1; static_array<int,2> v1252 = v23.case7.v2; int v1253 = v23.case7.v3; static_array<int,2> v1254 = v23.case7.v4; Union5 v1255 = v23.case7.v5;
                        curandStatePhilox4_32_10_t & v1256 = v3.v5;
                        curandStatePhilox4_32_10_t & v1257 = v1256;
                        static_array<unsigned char,1> v1258; unsigned long long v1259;
                        Tuple12 tmp102 = draw_cards_40(v1257, v19);
                        v1258 = tmp102.v0; v1259 = tmp102.v1;
                        v3.v0 = v1259;
                        static_array_list<unsigned char,5> v1260;
                        v1260 = get_community_cards_85(v1255, v1258);
                        Union6 v1261;
                        v1261 = Union6{Union6_0{v1260}};
                        v18.push(v1261);
                        Union5 v1286;
                        switch (v1255.tag) {
                            case 0: { // Flop
                                static_array<unsigned char,3> v1262 = v1255.case0.v0;
                                static_array<unsigned char,4> v1263;
                                int v1265;
                                v1265 = 0;
                                while (while_method_1(v1265)){
                                    bool v1267;
                                    v1267 = 0 <= v1265;
                                    bool v1269;
                                    if (v1267){
                                        bool v1268;
                                        v1268 = v1265 < 3;
                                        v1269 = v1268;
                                    } else {
                                        v1269 = false;
                                    }
                                    bool v1270;
                                    v1270 = v1269 == false;
                                    if (v1270){
                                        assert("Index must be in range." && v1269);
                                    } else {
                                    }
                                    unsigned char v1272;
                                    v1272 = v1262[v1265];
                                    v1263[v1265] = v1272;
                                    v1265 += 1 ;
                                }
                                int v1274;
                                v1274 = 0;
                                while (while_method_6(v1274)){
                                    bool v1276;
                                    v1276 = 0 <= v1274;
                                    bool v1278;
                                    if (v1276){
                                        bool v1277;
                                        v1277 = v1274 < 1;
                                        v1278 = v1277;
                                    } else {
                                        v1278 = false;
                                    }
                                    bool v1279;
                                    v1279 = v1278 == false;
                                    if (v1279){
                                        assert("Index must be in range." && v1278);
                                    } else {
                                    }
                                    unsigned char v1281;
                                    v1281 = v1258[v1274];
                                    int v1283;
                                    v1283 = 3 + v1274;
                                    v1263[v1283] = v1281;
                                    v1274 += 1 ;
                                }
                                v1286 = Union5{Union5_3{v1263}};
                                break;
                            }
                            default: {
                                printf("%s\n", "Invalid street in turn.");
                                __trap();
                            }
                        }
                        int v1287;
                        v1287 = 2;
                        int v1288;
                        v1288 = 0;
                        Union4 v1289;
                        v1289 = try_round_36(v1287, v1251, v1252, v1288, v1254, v1286);
                        v1370 = Union18{Union18_2{v1289}};
                        break;
                    }
                    default: {
                        assert("Invalid tag." && false); __trap();
                    }
                }
                switch (v1370.tag) {
                    case 0: { // T_none
                        v1719 = Union3{Union3_0{}};
                        break;
                    }
                    case 1: { // T_round
                        int v1374 = v1370.case1.v0; static_array<static_array<unsigned char,2>,2> v1375 = v1370.case1.v1; static_array<int,2> v1376 = v1370.case1.v2; int v1377 = v1370.case1.v3; static_array<int,2> v1378 = v1370.case1.v4; Union5 v1379 = v1370.case1.v5; Union1 v1380 = v1370.case1.v6;
                        int v1381;
                        v1381 = v1377 % 2;
                        Union4 v1712;
                        switch (v1380.tag) {
                            case 0: { // A_All_In
                                static_array<int,2> v1587;
                                int v1589;
                                v1589 = 0;
                                while (while_method_0(v1589)){
                                    bool v1591;
                                    v1591 = 0 <= v1589;
                                    bool v1593;
                                    if (v1591){
                                        bool v1592;
                                        v1592 = v1589 < 2;
                                        v1593 = v1592;
                                    } else {
                                        v1593 = false;
                                    }
                                    bool v1594;
                                    v1594 = v1593 == false;
                                    if (v1594){
                                        assert("Index must be in range." && v1593);
                                    } else {
                                    }
                                    int v1596;
                                    v1596 = v1378[v1589];
                                    bool v1599;
                                    if (v1591){
                                        bool v1598;
                                        v1598 = v1589 < 2;
                                        v1599 = v1598;
                                    } else {
                                        v1599 = false;
                                    }
                                    bool v1600;
                                    v1600 = v1599 == false;
                                    if (v1600){
                                        assert("Index must be in range." && v1599);
                                    } else {
                                    }
                                    int v1602;
                                    v1602 = v1376[v1589];
                                    int v1604;
                                    v1604 = v1596 + v1602;
                                    v1587[v1589] = v1604;
                                    v1589 += 1 ;
                                }
                                int v1605;
                                v1605 = v1376[0];
                                int v1607; int v1608;
                                Tuple4 tmp103 = Tuple4{1, v1605};
                                v1607 = tmp103.v0; v1608 = tmp103.v1;
                                while (while_method_0(v1607)){
                                    bool v1610;
                                    v1610 = 0 <= v1607;
                                    bool v1612;
                                    if (v1610){
                                        bool v1611;
                                        v1611 = v1607 < 2;
                                        v1612 = v1611;
                                    } else {
                                        v1612 = false;
                                    }
                                    bool v1613;
                                    v1613 = v1612 == false;
                                    if (v1613){
                                        assert("Index must be in range." && v1612);
                                    } else {
                                    }
                                    int v1615;
                                    v1615 = v1376[v1607];
                                    bool v1617;
                                    v1617 = v1608 >= v1615;
                                    int v1618;
                                    if (v1617){
                                        v1618 = v1608;
                                    } else {
                                        v1618 = v1615;
                                    }
                                    v1608 = v1618;
                                    v1607 += 1 ;
                                }
                                bool v1619;
                                v1619 = 0 <= v1381;
                                bool v1621;
                                if (v1619){
                                    bool v1620;
                                    v1620 = v1381 < 2;
                                    v1621 = v1620;
                                } else {
                                    v1621 = false;
                                }
                                bool v1622;
                                v1622 = v1621 == false;
                                if (v1622){
                                    assert("Index must be in range." && v1621);
                                } else {
                                }
                                int v1624;
                                v1624 = v1587[v1381];
                                bool v1626;
                                v1626 = v1608 < v1624;
                                int v1627;
                                if (v1626){
                                    v1627 = v1608;
                                } else {
                                    v1627 = v1624;
                                }
                                static_array<int,2> v1628;
                                int v1630;
                                v1630 = 0;
                                while (while_method_0(v1630)){
                                    bool v1632;
                                    v1632 = 0 <= v1630;
                                    bool v1634;
                                    if (v1632){
                                        bool v1633;
                                        v1633 = v1630 < 2;
                                        v1634 = v1633;
                                    } else {
                                        v1634 = false;
                                    }
                                    bool v1635;
                                    v1635 = v1634 == false;
                                    if (v1635){
                                        assert("Index must be in range." && v1634);
                                    } else {
                                    }
                                    int v1637;
                                    v1637 = v1376[v1630];
                                    bool v1639;
                                    v1639 = v1381 == v1630;
                                    int v1640;
                                    if (v1639){
                                        v1640 = v1627;
                                    } else {
                                        v1640 = v1637;
                                    }
                                    v1628[v1630] = v1640;
                                    v1630 += 1 ;
                                }
                                static_array<int,2> v1641;
                                int v1643;
                                v1643 = 0;
                                while (while_method_0(v1643)){
                                    bool v1645;
                                    v1645 = 0 <= v1643;
                                    bool v1647;
                                    if (v1645){
                                        bool v1646;
                                        v1646 = v1643 < 2;
                                        v1647 = v1646;
                                    } else {
                                        v1647 = false;
                                    }
                                    bool v1648;
                                    v1648 = v1647 == false;
                                    if (v1648){
                                        assert("Index must be in range." && v1647);
                                    } else {
                                    }
                                    int v1650;
                                    v1650 = v1587[v1643];
                                    bool v1653;
                                    if (v1645){
                                        bool v1652;
                                        v1652 = v1643 < 2;
                                        v1653 = v1652;
                                    } else {
                                        v1653 = false;
                                    }
                                    bool v1654;
                                    v1654 = v1653 == false;
                                    if (v1654){
                                        assert("Index must be in range." && v1653);
                                    } else {
                                    }
                                    int v1656;
                                    v1656 = v1628[v1643];
                                    int v1658;
                                    v1658 = v1650 - v1656;
                                    v1641[v1643] = v1658;
                                    v1643 += 1 ;
                                }
                                bool v1660;
                                if (v1619){
                                    bool v1659;
                                    v1659 = v1381 < 2;
                                    v1660 = v1659;
                                } else {
                                    v1660 = false;
                                }
                                bool v1661;
                                v1661 = v1660 == false;
                                if (v1661){
                                    assert("Index must be in range." && v1660);
                                } else {
                                }
                                int v1663;
                                v1663 = v1641[v1381];
                                int v1665;
                                v1665 = v1608 + v1663;
                                bool v1667;
                                if (v1619){
                                    bool v1666;
                                    v1666 = v1381 < 2;
                                    v1667 = v1666;
                                } else {
                                    v1667 = false;
                                }
                                bool v1668;
                                v1668 = v1667 == false;
                                if (v1668){
                                    assert("Index must be in range." && v1667);
                                } else {
                                }
                                int v1670;
                                v1670 = v1587[v1381];
                                bool v1672;
                                v1672 = v1665 < v1670;
                                int v1673;
                                if (v1672){
                                    v1673 = v1665;
                                } else {
                                    v1673 = v1670;
                                }
                                static_array<int,2> v1674;
                                int v1676;
                                v1676 = 0;
                                while (while_method_0(v1676)){
                                    bool v1678;
                                    v1678 = 0 <= v1676;
                                    bool v1680;
                                    if (v1678){
                                        bool v1679;
                                        v1679 = v1676 < 2;
                                        v1680 = v1679;
                                    } else {
                                        v1680 = false;
                                    }
                                    bool v1681;
                                    v1681 = v1680 == false;
                                    if (v1681){
                                        assert("Index must be in range." && v1680);
                                    } else {
                                    }
                                    int v1683;
                                    v1683 = v1376[v1676];
                                    bool v1685;
                                    v1685 = v1381 == v1676;
                                    int v1686;
                                    if (v1685){
                                        v1686 = v1673;
                                    } else {
                                        v1686 = v1683;
                                    }
                                    v1674[v1676] = v1686;
                                    v1676 += 1 ;
                                }
                                static_array<int,2> v1687;
                                int v1689;
                                v1689 = 0;
                                while (while_method_0(v1689)){
                                    bool v1691;
                                    v1691 = 0 <= v1689;
                                    bool v1693;
                                    if (v1691){
                                        bool v1692;
                                        v1692 = v1689 < 2;
                                        v1693 = v1692;
                                    } else {
                                        v1693 = false;
                                    }
                                    bool v1694;
                                    v1694 = v1693 == false;
                                    if (v1694){
                                        assert("Index must be in range." && v1693);
                                    } else {
                                    }
                                    int v1696;
                                    v1696 = v1587[v1689];
                                    bool v1699;
                                    if (v1691){
                                        bool v1698;
                                        v1698 = v1689 < 2;
                                        v1699 = v1698;
                                    } else {
                                        v1699 = false;
                                    }
                                    bool v1700;
                                    v1700 = v1699 == false;
                                    if (v1700){
                                        assert("Index must be in range." && v1699);
                                    } else {
                                    }
                                    int v1702;
                                    v1702 = v1674[v1689];
                                    int v1704;
                                    v1704 = v1696 - v1702;
                                    v1687[v1689] = v1704;
                                    v1689 += 1 ;
                                }
                                bool v1705;
                                v1705 = v1663 >= v1374;
                                int v1706;
                                if (v1705){
                                    v1706 = v1663;
                                } else {
                                    v1706 = v1374;
                                }
                                int v1707;
                                v1707 = v1377 + 1;
                                v1712 = try_round_36(v1706, v1375, v1674, v1707, v1687, v1379);
                                break;
                            }
                            case 1: { // A_Call
                                static_array<int,2> v1383;
                                int v1385;
                                v1385 = 0;
                                while (while_method_0(v1385)){
                                    bool v1387;
                                    v1387 = 0 <= v1385;
                                    bool v1389;
                                    if (v1387){
                                        bool v1388;
                                        v1388 = v1385 < 2;
                                        v1389 = v1388;
                                    } else {
                                        v1389 = false;
                                    }
                                    bool v1390;
                                    v1390 = v1389 == false;
                                    if (v1390){
                                        assert("Index must be in range." && v1389);
                                    } else {
                                    }
                                    int v1392;
                                    v1392 = v1378[v1385];
                                    bool v1395;
                                    if (v1387){
                                        bool v1394;
                                        v1394 = v1385 < 2;
                                        v1395 = v1394;
                                    } else {
                                        v1395 = false;
                                    }
                                    bool v1396;
                                    v1396 = v1395 == false;
                                    if (v1396){
                                        assert("Index must be in range." && v1395);
                                    } else {
                                    }
                                    int v1398;
                                    v1398 = v1376[v1385];
                                    int v1400;
                                    v1400 = v1392 + v1398;
                                    v1383[v1385] = v1400;
                                    v1385 += 1 ;
                                }
                                int v1401;
                                v1401 = v1376[0];
                                int v1403; int v1404;
                                Tuple4 tmp104 = Tuple4{1, v1401};
                                v1403 = tmp104.v0; v1404 = tmp104.v1;
                                while (while_method_0(v1403)){
                                    bool v1406;
                                    v1406 = 0 <= v1403;
                                    bool v1408;
                                    if (v1406){
                                        bool v1407;
                                        v1407 = v1403 < 2;
                                        v1408 = v1407;
                                    } else {
                                        v1408 = false;
                                    }
                                    bool v1409;
                                    v1409 = v1408 == false;
                                    if (v1409){
                                        assert("Index must be in range." && v1408);
                                    } else {
                                    }
                                    int v1411;
                                    v1411 = v1376[v1403];
                                    bool v1413;
                                    v1413 = v1404 >= v1411;
                                    int v1414;
                                    if (v1413){
                                        v1414 = v1404;
                                    } else {
                                        v1414 = v1411;
                                    }
                                    v1404 = v1414;
                                    v1403 += 1 ;
                                }
                                bool v1415;
                                v1415 = 0 <= v1381;
                                bool v1417;
                                if (v1415){
                                    bool v1416;
                                    v1416 = v1381 < 2;
                                    v1417 = v1416;
                                } else {
                                    v1417 = false;
                                }
                                bool v1418;
                                v1418 = v1417 == false;
                                if (v1418){
                                    assert("Index must be in range." && v1417);
                                } else {
                                }
                                int v1420;
                                v1420 = v1383[v1381];
                                bool v1422;
                                v1422 = v1404 < v1420;
                                int v1423;
                                if (v1422){
                                    v1423 = v1404;
                                } else {
                                    v1423 = v1420;
                                }
                                static_array<int,2> v1424;
                                int v1426;
                                v1426 = 0;
                                while (while_method_0(v1426)){
                                    bool v1428;
                                    v1428 = 0 <= v1426;
                                    bool v1430;
                                    if (v1428){
                                        bool v1429;
                                        v1429 = v1426 < 2;
                                        v1430 = v1429;
                                    } else {
                                        v1430 = false;
                                    }
                                    bool v1431;
                                    v1431 = v1430 == false;
                                    if (v1431){
                                        assert("Index must be in range." && v1430);
                                    } else {
                                    }
                                    int v1433;
                                    v1433 = v1376[v1426];
                                    bool v1435;
                                    v1435 = v1381 == v1426;
                                    int v1436;
                                    if (v1435){
                                        v1436 = v1423;
                                    } else {
                                        v1436 = v1433;
                                    }
                                    v1424[v1426] = v1436;
                                    v1426 += 1 ;
                                }
                                static_array<int,2> v1437;
                                int v1439;
                                v1439 = 0;
                                while (while_method_0(v1439)){
                                    bool v1441;
                                    v1441 = 0 <= v1439;
                                    bool v1443;
                                    if (v1441){
                                        bool v1442;
                                        v1442 = v1439 < 2;
                                        v1443 = v1442;
                                    } else {
                                        v1443 = false;
                                    }
                                    bool v1444;
                                    v1444 = v1443 == false;
                                    if (v1444){
                                        assert("Index must be in range." && v1443);
                                    } else {
                                    }
                                    int v1446;
                                    v1446 = v1383[v1439];
                                    bool v1449;
                                    if (v1441){
                                        bool v1448;
                                        v1448 = v1439 < 2;
                                        v1449 = v1448;
                                    } else {
                                        v1449 = false;
                                    }
                                    bool v1450;
                                    v1450 = v1449 == false;
                                    if (v1450){
                                        assert("Index must be in range." && v1449);
                                    } else {
                                    }
                                    int v1452;
                                    v1452 = v1424[v1439];
                                    int v1454;
                                    v1454 = v1446 - v1452;
                                    v1437[v1439] = v1454;
                                    v1439 += 1 ;
                                }
                                bool v1455;
                                v1455 = v1381 < 2;
                                if (v1455){
                                    int v1456;
                                    v1456 = v1377 + 1;
                                    v1712 = try_round_36(v1374, v1375, v1424, v1456, v1437, v1379);
                                } else {
                                    v1712 = go_next_street_38(v1374, v1375, v1424, v1377, v1437, v1379);
                                }
                                break;
                            }
                            case 2: { // A_Fold
                                v1712 = Union4{Union4_1{v1374, v1375, v1376, v1377, v1378, v1379}};
                                break;
                            }
                            case 3: { // A_Raise
                                int v1460 = v1380.case3.v0;
                                bool v1461;
                                v1461 = v1374 <= v1460;
                                bool v1462;
                                v1462 = v1461 == false;
                                if (v1462){
                                    assert("The raise amount must match the minimum." && v1461);
                                } else {
                                }
                                static_array<int,2> v1464;
                                int v1466;
                                v1466 = 0;
                                while (while_method_0(v1466)){
                                    bool v1468;
                                    v1468 = 0 <= v1466;
                                    bool v1470;
                                    if (v1468){
                                        bool v1469;
                                        v1469 = v1466 < 2;
                                        v1470 = v1469;
                                    } else {
                                        v1470 = false;
                                    }
                                    bool v1471;
                                    v1471 = v1470 == false;
                                    if (v1471){
                                        assert("Index must be in range." && v1470);
                                    } else {
                                    }
                                    int v1473;
                                    v1473 = v1378[v1466];
                                    bool v1476;
                                    if (v1468){
                                        bool v1475;
                                        v1475 = v1466 < 2;
                                        v1476 = v1475;
                                    } else {
                                        v1476 = false;
                                    }
                                    bool v1477;
                                    v1477 = v1476 == false;
                                    if (v1477){
                                        assert("Index must be in range." && v1476);
                                    } else {
                                    }
                                    int v1479;
                                    v1479 = v1376[v1466];
                                    int v1481;
                                    v1481 = v1473 + v1479;
                                    v1464[v1466] = v1481;
                                    v1466 += 1 ;
                                }
                                int v1482;
                                v1482 = v1376[0];
                                int v1484; int v1485;
                                Tuple4 tmp105 = Tuple4{1, v1482};
                                v1484 = tmp105.v0; v1485 = tmp105.v1;
                                while (while_method_0(v1484)){
                                    bool v1487;
                                    v1487 = 0 <= v1484;
                                    bool v1489;
                                    if (v1487){
                                        bool v1488;
                                        v1488 = v1484 < 2;
                                        v1489 = v1488;
                                    } else {
                                        v1489 = false;
                                    }
                                    bool v1490;
                                    v1490 = v1489 == false;
                                    if (v1490){
                                        assert("Index must be in range." && v1489);
                                    } else {
                                    }
                                    int v1492;
                                    v1492 = v1376[v1484];
                                    bool v1494;
                                    v1494 = v1485 >= v1492;
                                    int v1495;
                                    if (v1494){
                                        v1495 = v1485;
                                    } else {
                                        v1495 = v1492;
                                    }
                                    v1485 = v1495;
                                    v1484 += 1 ;
                                }
                                bool v1496;
                                v1496 = 0 <= v1381;
                                bool v1498;
                                if (v1496){
                                    bool v1497;
                                    v1497 = v1381 < 2;
                                    v1498 = v1497;
                                } else {
                                    v1498 = false;
                                }
                                bool v1499;
                                v1499 = v1498 == false;
                                if (v1499){
                                    assert("Index must be in range." && v1498);
                                } else {
                                }
                                int v1501;
                                v1501 = v1464[v1381];
                                bool v1503;
                                v1503 = v1485 < v1501;
                                int v1504;
                                if (v1503){
                                    v1504 = v1485;
                                } else {
                                    v1504 = v1501;
                                }
                                static_array<int,2> v1505;
                                int v1507;
                                v1507 = 0;
                                while (while_method_0(v1507)){
                                    bool v1509;
                                    v1509 = 0 <= v1507;
                                    bool v1511;
                                    if (v1509){
                                        bool v1510;
                                        v1510 = v1507 < 2;
                                        v1511 = v1510;
                                    } else {
                                        v1511 = false;
                                    }
                                    bool v1512;
                                    v1512 = v1511 == false;
                                    if (v1512){
                                        assert("Index must be in range." && v1511);
                                    } else {
                                    }
                                    int v1514;
                                    v1514 = v1376[v1507];
                                    bool v1516;
                                    v1516 = v1381 == v1507;
                                    int v1517;
                                    if (v1516){
                                        v1517 = v1504;
                                    } else {
                                        v1517 = v1514;
                                    }
                                    v1505[v1507] = v1517;
                                    v1507 += 1 ;
                                }
                                static_array<int,2> v1518;
                                int v1520;
                                v1520 = 0;
                                while (while_method_0(v1520)){
                                    bool v1522;
                                    v1522 = 0 <= v1520;
                                    bool v1524;
                                    if (v1522){
                                        bool v1523;
                                        v1523 = v1520 < 2;
                                        v1524 = v1523;
                                    } else {
                                        v1524 = false;
                                    }
                                    bool v1525;
                                    v1525 = v1524 == false;
                                    if (v1525){
                                        assert("Index must be in range." && v1524);
                                    } else {
                                    }
                                    int v1527;
                                    v1527 = v1464[v1520];
                                    bool v1530;
                                    if (v1522){
                                        bool v1529;
                                        v1529 = v1520 < 2;
                                        v1530 = v1529;
                                    } else {
                                        v1530 = false;
                                    }
                                    bool v1531;
                                    v1531 = v1530 == false;
                                    if (v1531){
                                        assert("Index must be in range." && v1530);
                                    } else {
                                    }
                                    int v1533;
                                    v1533 = v1505[v1520];
                                    int v1535;
                                    v1535 = v1527 - v1533;
                                    v1518[v1520] = v1535;
                                    v1520 += 1 ;
                                }
                                bool v1537;
                                if (v1496){
                                    bool v1536;
                                    v1536 = v1381 < 2;
                                    v1537 = v1536;
                                } else {
                                    v1537 = false;
                                }
                                bool v1538;
                                v1538 = v1537 == false;
                                if (v1538){
                                    assert("Index must be in range." && v1537);
                                } else {
                                }
                                int v1540;
                                v1540 = v1518[v1381];
                                bool v1542;
                                v1542 = v1460 < v1540;
                                bool v1543;
                                v1543 = v1542 == false;
                                if (v1543){
                                    assert("The raise amount must be less than the stack size after calling." && v1542);
                                } else {
                                }
                                int v1545;
                                v1545 = v1485 + v1460;
                                bool v1547;
                                if (v1496){
                                    bool v1546;
                                    v1546 = v1381 < 2;
                                    v1547 = v1546;
                                } else {
                                    v1547 = false;
                                }
                                bool v1548;
                                v1548 = v1547 == false;
                                if (v1548){
                                    assert("Index must be in range." && v1547);
                                } else {
                                }
                                int v1550;
                                v1550 = v1464[v1381];
                                bool v1552;
                                v1552 = v1545 < v1550;
                                int v1553;
                                if (v1552){
                                    v1553 = v1545;
                                } else {
                                    v1553 = v1550;
                                }
                                static_array<int,2> v1554;
                                int v1556;
                                v1556 = 0;
                                while (while_method_0(v1556)){
                                    bool v1558;
                                    v1558 = 0 <= v1556;
                                    bool v1560;
                                    if (v1558){
                                        bool v1559;
                                        v1559 = v1556 < 2;
                                        v1560 = v1559;
                                    } else {
                                        v1560 = false;
                                    }
                                    bool v1561;
                                    v1561 = v1560 == false;
                                    if (v1561){
                                        assert("Index must be in range." && v1560);
                                    } else {
                                    }
                                    int v1563;
                                    v1563 = v1376[v1556];
                                    bool v1565;
                                    v1565 = v1381 == v1556;
                                    int v1566;
                                    if (v1565){
                                        v1566 = v1553;
                                    } else {
                                        v1566 = v1563;
                                    }
                                    v1554[v1556] = v1566;
                                    v1556 += 1 ;
                                }
                                static_array<int,2> v1567;
                                int v1569;
                                v1569 = 0;
                                while (while_method_0(v1569)){
                                    bool v1571;
                                    v1571 = 0 <= v1569;
                                    bool v1573;
                                    if (v1571){
                                        bool v1572;
                                        v1572 = v1569 < 2;
                                        v1573 = v1572;
                                    } else {
                                        v1573 = false;
                                    }
                                    bool v1574;
                                    v1574 = v1573 == false;
                                    if (v1574){
                                        assert("Index must be in range." && v1573);
                                    } else {
                                    }
                                    int v1576;
                                    v1576 = v1464[v1569];
                                    bool v1579;
                                    if (v1571){
                                        bool v1578;
                                        v1578 = v1569 < 2;
                                        v1579 = v1578;
                                    } else {
                                        v1579 = false;
                                    }
                                    bool v1580;
                                    v1580 = v1579 == false;
                                    if (v1580){
                                        assert("Index must be in range." && v1579);
                                    } else {
                                    }
                                    int v1582;
                                    v1582 = v1554[v1569];
                                    int v1584;
                                    v1584 = v1576 - v1582;
                                    v1567[v1569] = v1584;
                                    v1569 += 1 ;
                                }
                                int v1585;
                                v1585 = v1377 + 1;
                                v1712 = try_round_36(v1460, v1375, v1554, v1585, v1567, v1379);
                                break;
                            }
                            default: {
                                assert("Invalid tag." && false); __trap();
                            }
                        }
                        v1719 = Union3{Union3_1{v1712}};
                        break;
                    }
                    case 2: { // T_some
                        Union4 v1372 = v1370.case2.v0;
                        v1719 = Union3{Union3_1{v1372}};
                        break;
                    }
                    default: {
                        assert("Invalid tag." && false); __trap();
                    }
                }
                break;
            }
            default: {
                assert("Invalid tag." && false); __trap();
            }
        }
        v21 = v1719;
    }
    return ;
}
__device__ inline bool while_method_26(int v0){
    bool v1;
    v1 = v0 < 1024;
    return v1;
}
__device__ inline bool while_method_27(int v0){
    bool v1;
    v1 = v0 < 128;
    return v1;
}
__device__ inline bool while_method_28(int v0){
    bool v1;
    v1 = v0 < 256;
    return v1;
}
__device__ inline bool while_method_29(int v0){
    bool v1;
    v1 = v0 < 64;
    return v1;
}
__device__ inline bool while_method_30(int v0){
    bool v1;
    v1 = v0 < 131072;
    return v1;
}
__device__ inline bool while_method_31(int v0){
    bool v1;
    v1 = v0 < 24;
    return v1;
}
__device__ inline bool while_method_32(int v0){
    bool v1;
    v1 = v0 < 65536;
    return v1;
}
__device__ inline bool while_method_33(int v0){
    bool v1;
    v1 = v0 < 4096;
    return v1;
}
__device__ void method_86(unsigned char * v0, unsigned char * v1, unsigned char * v2, StackMut1 & v3, Union4 v4){
    v3.v0 = 4503599627370495ull;
    static_array<float,2> v5;
    v5[0] = 0.0f;
    v5[1] = 0.0f;
    v3.v4 = v5;
    static_array_list<Union6,128> & v7 = v3.v2;
    v7.unsafe_set_length(0);
    static_array<Union2,2> v8;
    Union2 v10;
    v10 = Union2{Union2_1{}};
    v8[0] = v10;
    Union2 v12;
    v12 = Union2{Union2_1{}};
    v8[1] = v12;
    v3.v3 = v8;
    static_array_list<Union6,128> & v14 = v3.v2;
    unsigned long long & v15 = v3.v0;
    Union3 v16;
    v16 = Union3{Union3_1{v4}};
    Union3 v17;
    v17 = v16;
    while (while_method_25(v17)){
        Union3 v1715;
        switch (v17.tag) {
            case 0: { // None
                v1715 = Union3{Union3_0{}};
                break;
            }
            case 1: { // Some
                Union4 v19 = v17.case1.v0;
                Union18 v1366;
                switch (v19.tag) {
                    case 0: { // G_Flop
                        int v1227 = v19.case0.v0; static_array<static_array<unsigned char,2>,2> v1228 = v19.case0.v1; static_array<int,2> v1229 = v19.case0.v2; int v1230 = v19.case0.v3; static_array<int,2> v1231 = v19.case0.v4; Union5 v1232 = v19.case0.v5;
                        curandStatePhilox4_32_10_t & v1233 = v3.v5;
                        curandStatePhilox4_32_10_t & v1234 = v1233;
                        static_array<unsigned char,3> v1235; unsigned long long v1236;
                        Tuple8 tmp115 = draw_cards_32(v1234, v15);
                        v1235 = tmp115.v0; v1236 = tmp115.v1;
                        v3.v0 = v1236;
                        static_array_list<unsigned char,5> v1237;
                        v1237 = get_community_cards_84(v1232, v1235);
                        Union6 v1238;
                        v1238 = Union6{Union6_0{v1237}};
                        v14.push(v1238);
                        Union5 v1241;
                        switch (v1232.tag) {
                            case 1: { // Preflop
                                v1241 = Union5{Union5_0{v1235}};
                                break;
                            }
                            default: {
                                printf("%s\n", "Invalid street in flop.");
                                __trap();
                            }
                        }
                        int v1242;
                        v1242 = 2;
                        int v1243;
                        v1243 = 0;
                        Union4 v1244;
                        v1244 = try_round_36(v1242, v1228, v1229, v1243, v1231, v1241);
                        v1366 = Union18{Union18_2{v1244}};
                        break;
                    }
                    case 1: { // G_Fold
                        int v20 = v19.case1.v0; static_array<static_array<unsigned char,2>,2> v21 = v19.case1.v1; static_array<int,2> v22 = v19.case1.v2; int v23 = v19.case1.v3; static_array<int,2> v24 = v19.case1.v4; Union5 v25 = v19.case1.v5;
                        int v26;
                        v26 = v23 % 2;
                        bool v27;
                        v27 = 0 <= v26;
                        bool v29;
                        if (v27){
                            bool v28;
                            v28 = v26 < 2;
                            v29 = v28;
                        } else {
                            v29 = false;
                        }
                        bool v30;
                        v30 = v29 == false;
                        if (v30){
                            assert("Index must be in range." && v29);
                        } else {
                        }
                        int v32;
                        v32 = v22[v26];
                        int v34;
                        v34 = -v32;
                        float v35;
                        v35 = (float)v34;
                        static_array<float,2> & v36 = v3.v4;
                        v36[v26] = v35;
                        int v37;
                        v37 = v26 ^ 1;
                        float v38;
                        v38 = -v35;
                        v36[v37] = v38;
                        int v39;
                        v39 = v23 + 1;
                        int v40;
                        v40 = v39 % 2;
                        Union6 v41;
                        v41 = Union6{Union6_1{v32, v40}};
                        v14.push(v41);
                        v1366 = Union18{Union18_0{}};
                        break;
                    }
                    case 2: { // G_Preflop
                        curandStatePhilox4_32_10_t & v1328 = v3.v5;
                        curandStatePhilox4_32_10_t & v1329 = v1328;
                        static_array<unsigned char,2> v1330; unsigned long long v1331;
                        Tuple11 tmp116 = draw_cards_39(v1329, v15);
                        v1330 = tmp116.v0; v1331 = tmp116.v1;
                        v3.v0 = v1331;
                        curandStatePhilox4_32_10_t & v1332 = v3.v5;
                        curandStatePhilox4_32_10_t & v1333 = v1332;
                        static_array<unsigned char,2> v1334; unsigned long long v1335;
                        Tuple11 tmp117 = draw_cards_39(v1333, v15);
                        v1334 = tmp117.v0; v1335 = tmp117.v1;
                        v3.v0 = v1335;
                        Union6 v1336;
                        v1336 = Union6{Union6_3{0, v1330}};
                        v14.push(v1336);
                        Union6 v1337;
                        v1337 = Union6{Union6_3{1, v1334}};
                        v14.push(v1337);
                        static_array<static_array<unsigned char,2>,2> v1338;
                        v1338[0] = v1330;
                        v1338[1] = v1334;
                        static_array<int,2> v1340;
                        v1340[0] = 2;
                        v1340[1] = 1;
                        static_array<int,2> v1342;
                        int v1344;
                        v1344 = 0;
                        while (while_method_0(v1344)){
                            bool v1346;
                            v1346 = 0 <= v1344;
                            bool v1348;
                            if (v1346){
                                bool v1347;
                                v1347 = v1344 < 2;
                                v1348 = v1347;
                            } else {
                                v1348 = false;
                            }
                            bool v1349;
                            v1349 = v1348 == false;
                            if (v1349){
                                assert("Index must be in range." && v1348);
                            } else {
                            }
                            int v1351;
                            v1351 = v1340[v1344];
                            int v1353;
                            v1353 = 100 - v1351;
                            v1342[v1344] = v1353;
                            v1344 += 1 ;
                        }
                        int v1354;
                        v1354 = 2;
                        int v1355;
                        v1355 = 0;
                        Union5 v1356;
                        v1356 = Union5{Union5_1{}};
                        Union4 v1357;
                        v1357 = try_round_36(v1354, v1338, v1340, v1355, v1342, v1356);
                        v1366 = Union18{Union18_2{v1357}};
                        break;
                    }
                    case 3: { // G_River
                        int v1287 = v19.case3.v0; static_array<static_array<unsigned char,2>,2> v1288 = v19.case3.v1; static_array<int,2> v1289 = v19.case3.v2; int v1290 = v19.case3.v3; static_array<int,2> v1291 = v19.case3.v4; Union5 v1292 = v19.case3.v5;
                        curandStatePhilox4_32_10_t & v1293 = v3.v5;
                        curandStatePhilox4_32_10_t & v1294 = v1293;
                        static_array<unsigned char,1> v1295; unsigned long long v1296;
                        Tuple12 tmp118 = draw_cards_40(v1294, v15);
                        v1295 = tmp118.v0; v1296 = tmp118.v1;
                        v3.v0 = v1296;
                        static_array_list<unsigned char,5> v1297;
                        v1297 = get_community_cards_85(v1292, v1295);
                        Union6 v1298;
                        v1298 = Union6{Union6_0{v1297}};
                        v14.push(v1298);
                        Union5 v1323;
                        switch (v1292.tag) {
                            case 3: { // Turn
                                static_array<unsigned char,4> v1299 = v1292.case3.v0;
                                static_array<unsigned char,5> v1300;
                                int v1302;
                                v1302 = 0;
                                while (while_method_3(v1302)){
                                    bool v1304;
                                    v1304 = 0 <= v1302;
                                    bool v1306;
                                    if (v1304){
                                        bool v1305;
                                        v1305 = v1302 < 4;
                                        v1306 = v1305;
                                    } else {
                                        v1306 = false;
                                    }
                                    bool v1307;
                                    v1307 = v1306 == false;
                                    if (v1307){
                                        assert("Index must be in range." && v1306);
                                    } else {
                                    }
                                    unsigned char v1309;
                                    v1309 = v1299[v1302];
                                    v1300[v1302] = v1309;
                                    v1302 += 1 ;
                                }
                                int v1311;
                                v1311 = 0;
                                while (while_method_6(v1311)){
                                    bool v1313;
                                    v1313 = 0 <= v1311;
                                    bool v1315;
                                    if (v1313){
                                        bool v1314;
                                        v1314 = v1311 < 1;
                                        v1315 = v1314;
                                    } else {
                                        v1315 = false;
                                    }
                                    bool v1316;
                                    v1316 = v1315 == false;
                                    if (v1316){
                                        assert("Index must be in range." && v1315);
                                    } else {
                                    }
                                    unsigned char v1318;
                                    v1318 = v1295[v1311];
                                    int v1320;
                                    v1320 = 4 + v1311;
                                    v1300[v1320] = v1318;
                                    v1311 += 1 ;
                                }
                                v1323 = Union5{Union5_2{v1300}};
                                break;
                            }
                            default: {
                                printf("%s\n", "Invalid street in river.");
                                __trap();
                            }
                        }
                        int v1324;
                        v1324 = 2;
                        int v1325;
                        v1325 = 0;
                        Union4 v1326;
                        v1326 = try_round_36(v1324, v1288, v1289, v1325, v1291, v1323);
                        v1366 = Union18{Union18_2{v1326}};
                        break;
                    }
                    case 4: { // G_Round
                        int v162 = v19.case4.v0; static_array<static_array<unsigned char,2>,2> v163 = v19.case4.v1; static_array<int,2> v164 = v19.case4.v2; int v165 = v19.case4.v3; static_array<int,2> v166 = v19.case4.v4; Union5 v167 = v19.case4.v5;
                        int v168;
                        v168 = v165 % 2;
                        static_array<Union2,2> & v169 = v3.v3;
                        bool v170;
                        v170 = 0 <= v168;
                        bool v172;
                        if (v170){
                            bool v171;
                            v171 = v168 < 2;
                            v172 = v171;
                        } else {
                            v172 = false;
                        }
                        bool v173;
                        v173 = v172 == false;
                        if (v173){
                            assert("Index must be in range." && v172);
                        } else {
                        }
                        Union2 v175;
                        v175 = v169[v168];
                        Union1 v1214;
                        switch (v175.tag) {
                            case 0: { // CallingMachine
                                v1214 = Union1{Union1_1{}};
                                break;
                            }
                            case 1: { // Computer
                                static_array_list<Union6,128> & v178 = v3.v2;
                                curandStatePhilox4_32_10_t & v179 = v3.v5;
                                curandStatePhilox4_32_10_t & v180 = v179;
                                float * v181;
                                v181 = reinterpret_cast<float *>(&v1[114819072ull]);
                                float * v183;
                                v183 = reinterpret_cast<float *>(&v1[0ull]);
                                float * v185;
                                v185 = reinterpret_cast<float *>(&v1[0ull]);
                                int v187;
                                v187 = blockIdx.x;
                                assert("Tensor range check" && 0 <= v187 && v187 < 24);
                                int v188;
                                v188 = 524288 * v187;
                                int v189;
                                v189 = threadIdx.x;
                                int v190;
                                v190 = v189;
                                while (while_method_7(v190)){
                                    bool v192;
                                    v192 = 0 <= v190;
                                    bool v193;
                                    v193 = v192 == false;
                                    if (v193){
                                        assert("The index needs to be zero or positive." && v192);
                                    } else {
                                    }
                                    int v195;
                                    v195 = v190 % 2048;
                                    int v196;
                                    v196 = v190 / 2048;
                                    bool v197;
                                    v197 = v196 < 256;
                                    bool v198;
                                    v198 = v197 == false;
                                    if (v198){
                                        assert("The last element of the projection dimensions needs to be greater than the index remainder." && v197);
                                    } else {
                                    }
                                    assert("Tensor range check" && 0 <= v196 && v196 < 256);
                                    assert("Tensor range check" && 0 <= v195 && v195 < 2048);
                                    int v200;
                                    v200 = v195 + v188;
                                    int v201;
                                    v201 = 2048 * v196;
                                    int v202;
                                    v202 = v201 + v200;
                                    v185[v202] = 0.0f;
                                    v190 += 256 ;
                                }
                                __syncthreads();
                                int v203;
                                v203 = threadIdx.x;
                                assert("Tensor range check" && 0 <= v203 && v203 < 256);
                                int v204;
                                v204 = 2048 * v203;
                                int v205;
                                v205 = v204 + v188;
                                int v206;
                                v206 = v178.length;
                                bool v207;
                                v207 = 128 >= v206;
                                bool v208;
                                v208 = v207 == false;
                                if (v208){
                                    assert("The type level dimension has to equal the value passed at runtime into create." && v207);
                                } else {
                                }
                                static_array_list<Union8,128> v210;
                                v210 = static_array_list<Union8,128>{};
                                v210.unsafe_set_length(v206);
                                int v212;
                                v212 = 0;
                                while (while_method_4(v206, v212)){
                                    Union6 v214;
                                    v214 = v178[v212];
                                    Union8 v220;
                                    switch (v214.tag) {
                                        case 2: { // PlayerAction
                                            int v216 = v214.case2.v0; Union1 v217 = v214.case2.v1;
                                            v220 = Union8{Union8_1{v217}};
                                            break;
                                        }
                                        default: {
                                            v220 = Union8{Union8_0{}};
                                        }
                                    }
                                    v210[v212] = v220;
                                    v212 += 1 ;
                                }
                                static_array<int,2> v221;
                                int v223;
                                v223 = 0;
                                while (while_method_0(v223)){
                                    int v225;
                                    v225 = v223 + v165;
                                    int v226;
                                    v226 = v225 % 2;
                                    bool v227;
                                    v227 = 0 <= v226;
                                    bool v229;
                                    if (v227){
                                        bool v228;
                                        v228 = v226 < 2;
                                        v229 = v228;
                                    } else {
                                        v229 = false;
                                    }
                                    bool v230;
                                    v230 = v229 == false;
                                    if (v230){
                                        assert("Index must be in range." && v229);
                                    } else {
                                    }
                                    int v232;
                                    v232 = v164[v226];
                                    v221[v223] = v232;
                                    v223 += 1 ;
                                }
                                static_array<int,2> v234;
                                int v236;
                                v236 = 0;
                                while (while_method_0(v236)){
                                    int v238;
                                    v238 = v236 + v165;
                                    int v239;
                                    v239 = v238 % 2;
                                    bool v240;
                                    v240 = 0 <= v239;
                                    bool v242;
                                    if (v240){
                                        bool v241;
                                        v241 = v239 < 2;
                                        v242 = v241;
                                    } else {
                                        v242 = false;
                                    }
                                    bool v243;
                                    v243 = v242 == false;
                                    if (v243){
                                        assert("Index must be in range." && v242);
                                    } else {
                                    }
                                    int v245;
                                    v245 = v166[v239];
                                    v234[v236] = v245;
                                    v236 += 1 ;
                                }
                                bool v248;
                                if (v170){
                                    bool v247;
                                    v247 = v168 < 2;
                                    v248 = v247;
                                } else {
                                    v248 = false;
                                }
                                bool v249;
                                v249 = v248 == false;
                                if (v249){
                                    assert("Index must be in range." && v248);
                                } else {
                                }
                                static_array<unsigned char,2> v251;
                                v251 = v163[v168];
                                static_array_list<unsigned char,5> v253;
                                v253 = static_array_list<unsigned char,5>{};
                                switch (v167.tag) {
                                    case 0: { // Flop
                                        static_array<unsigned char,3> v255 = v167.case0.v0;
                                        int v256;
                                        v256 = 0;
                                        while (while_method_1(v256)){
                                            bool v258;
                                            v258 = 0 <= v256;
                                            bool v260;
                                            if (v258){
                                                bool v259;
                                                v259 = v256 < 3;
                                                v260 = v259;
                                            } else {
                                                v260 = false;
                                            }
                                            bool v261;
                                            v261 = v260 == false;
                                            if (v261){
                                                assert("Index must be in range." && v260);
                                            } else {
                                            }
                                            unsigned char v263;
                                            v263 = v255[v256];
                                            v253.push(v263);
                                            v256 += 1 ;
                                        }
                                        break;
                                    }
                                    case 1: { // Preflop
                                        break;
                                    }
                                    case 2: { // River
                                        static_array<unsigned char,5> v275 = v167.case2.v0;
                                        int v276;
                                        v276 = 0;
                                        while (while_method_2(v276)){
                                            bool v278;
                                            v278 = 0 <= v276;
                                            bool v280;
                                            if (v278){
                                                bool v279;
                                                v279 = v276 < 5;
                                                v280 = v279;
                                            } else {
                                                v280 = false;
                                            }
                                            bool v281;
                                            v281 = v280 == false;
                                            if (v281){
                                                assert("Index must be in range." && v280);
                                            } else {
                                            }
                                            unsigned char v283;
                                            v283 = v275[v276];
                                            v253.push(v283);
                                            v276 += 1 ;
                                        }
                                        break;
                                    }
                                    case 3: { // Turn
                                        static_array<unsigned char,4> v265 = v167.case3.v0;
                                        int v266;
                                        v266 = 0;
                                        while (while_method_3(v266)){
                                            bool v268;
                                            v268 = 0 <= v266;
                                            bool v270;
                                            if (v268){
                                                bool v269;
                                                v269 = v266 < 4;
                                                v270 = v269;
                                            } else {
                                                v270 = false;
                                            }
                                            bool v271;
                                            v271 = v270 == false;
                                            if (v271){
                                                assert("Index must be in range." && v270);
                                            } else {
                                            }
                                            unsigned char v273;
                                            v273 = v265[v266];
                                            v253.push(v273);
                                            v266 += 1 ;
                                        }
                                        break;
                                    }
                                    default: {
                                        assert("Invalid tag." && false); __trap();
                                    }
                                }
                                float * v285;
                                v285 = v185+v205;
                                int v287;
                                v287 = v210.length;
                                bool v288;
                                v288 = v287 == 0;
                                if (v288){
                                    v285[0] = 1.0f;
                                } else {
                                }
                                int v289;
                                v289 = v210.length;
                                int v290;
                                v290 = 0;
                                while (while_method_4(v289, v290)){
                                    Union8 v292;
                                    v292 = v210[v290];
                                    int v294;
                                    v294 = v290 * 14;
                                    int v295;
                                    v295 = 1 + v294;
                                    switch (v292.tag) {
                                        case 0: { // None
                                            v285[v295] = 1.0f;
                                            break;
                                        }
                                        case 1: { // Some
                                            Union1 v296 = v292.case1.v0;
                                            int v297;
                                            v297 = v295 + 1;
                                            switch (v296.tag) {
                                                case 0: { // A_All_In
                                                    v285[v297] = 1.0f;
                                                    break;
                                                }
                                                case 1: { // A_Call
                                                    int v298;
                                                    v298 = v297 + 1;
                                                    v285[v298] = 1.0f;
                                                    break;
                                                }
                                                case 2: { // A_Fold
                                                    int v299;
                                                    v299 = v297 + 2;
                                                    v285[v299] = 1.0f;
                                                    break;
                                                }
                                                case 3: { // A_Raise
                                                    int v300 = v296.case3.v0;
                                                    int v301;
                                                    v301 = v297 + 3;
                                                    bool v302;
                                                    v302 = 1 <= v300;
                                                    bool v304;
                                                    if (v302){
                                                        bool v303;
                                                        v303 = v300 < 1023;
                                                        v304 = v303;
                                                    } else {
                                                        v304 = false;
                                                    }
                                                    bool v305;
                                                    v305 = v304 == false;
                                                    if (v305){
                                                        assert("Pickle failure. The input is out of the bounds of the given range." && v304);
                                                    } else {
                                                    }
                                                    int v307;
                                                    v307 = v300 - 1;
                                                    unsigned int v308;
                                                    v308 = (unsigned int)v307;
                                                    method_42(v308, v285, v301);
                                                    break;
                                                }
                                                default: {
                                                    assert("Invalid tag." && false); __trap();
                                                }
                                            }
                                            break;
                                        }
                                        default: {
                                            assert("Invalid tag." && false); __trap();
                                        }
                                    }
                                    v290 += 1 ;
                                }
                                int v309;
                                v309 = 0;
                                while (while_method_0(v309)){
                                    // 222;
                                    bool v311;
                                    v311 = 0 <= v309;
                                    bool v313;
                                    if (v311){
                                        bool v312;
                                        v312 = v309 < 2;
                                        v313 = v312;
                                    } else {
                                        v313 = false;
                                    }
                                    bool v314;
                                    v314 = v313 == false;
                                    if (v314){
                                        assert("Index must be in range." && v313);
                                    } else {
                                    }
                                    int v316;
                                    v316 = v221[v309];
                                    int v318;
                                    v318 = v309 * 11;
                                    int v319;
                                    v319 = 1794 + v318;
                                    bool v320;
                                    v320 = 0 <= v316;
                                    bool v322;
                                    if (v320){
                                        bool v321;
                                        v321 = v316 < 1023;
                                        v322 = v321;
                                    } else {
                                        v322 = false;
                                    }
                                    bool v323;
                                    v323 = v322 == false;
                                    if (v323){
                                        assert("Pickle failure. The input is out of the bounds of the given range." && v322);
                                    } else {
                                    }
                                    unsigned int v325;
                                    v325 = (unsigned int)v316;
                                    method_43(v325, v285, v319);
                                    v309 += 1 ;
                                }
                                int v326;
                                v326 = 0;
                                while (while_method_0(v326)){
                                    // 222;
                                    bool v328;
                                    v328 = 0 <= v326;
                                    bool v330;
                                    if (v328){
                                        bool v329;
                                        v329 = v326 < 2;
                                        v330 = v329;
                                    } else {
                                        v330 = false;
                                    }
                                    bool v331;
                                    v331 = v330 == false;
                                    if (v331){
                                        assert("Index must be in range." && v330);
                                    } else {
                                    }
                                    int v333;
                                    v333 = v234[v326];
                                    int v335;
                                    v335 = v326 * 11;
                                    int v336;
                                    v336 = 1817 + v335;
                                    bool v337;
                                    v337 = 0 <= v333;
                                    bool v339;
                                    if (v337){
                                        bool v338;
                                        v338 = v333 < 1023;
                                        v339 = v338;
                                    } else {
                                        v339 = false;
                                    }
                                    bool v340;
                                    v340 = v339 == false;
                                    if (v340){
                                        assert("Pickle failure. The input is out of the bounds of the given range." && v339);
                                    } else {
                                    }
                                    unsigned int v342;
                                    v342 = (unsigned int)v333;
                                    method_43(v342, v285, v336);
                                    v326 += 1 ;
                                }
                                int v343;
                                v343 = 0;
                                while (while_method_0(v343)){
                                    // 222;
                                    bool v345;
                                    v345 = 0 <= v343;
                                    bool v347;
                                    if (v345){
                                        bool v346;
                                        v346 = v343 < 2;
                                        v347 = v346;
                                    } else {
                                        v347 = false;
                                    }
                                    bool v348;
                                    v348 = v347 == false;
                                    if (v348){
                                        assert("Index must be in range." && v347);
                                    } else {
                                    }
                                    unsigned char v350;
                                    v350 = v251[v343];
                                    int v352;
                                    v352 = v343 * 17;
                                    int v353;
                                    v353 = 1840 + v352;
                                    unsigned char v354;
                                    v354 = v350 % 4u;
                                    int v355;
                                    v355 = (int)v354;
                                    unsigned char v356;
                                    v356 = v350 / 4u;
                                    int v357;
                                    v357 = (int)v356;
                                    unsigned int v358;
                                    v358 = (unsigned int)v355;
                                    int v359;
                                    v359 = (int)v358;
                                    bool v360;
                                    v360 = v359 < 4;
                                    bool v361;
                                    v361 = v360 == false;
                                    if (v361){
                                        assert("Pickle failure. Int value out of bounds." && v360);
                                    } else {
                                    }
                                    int v363;
                                    v363 = v353 + v359;
                                    v285[v363] = 1.0f;
                                    int v364;
                                    v364 = v353 + 4;
                                    unsigned int v365;
                                    v365 = (unsigned int)v357;
                                    int v366;
                                    v366 = (int)v365;
                                    bool v367;
                                    v367 = v366 < 13;
                                    bool v368;
                                    v368 = v367 == false;
                                    if (v368){
                                        assert("Pickle failure. Int value out of bounds." && v367);
                                    } else {
                                    }
                                    int v370;
                                    v370 = v364 + v366;
                                    v285[v370] = 1.0f;
                                    v343 += 1 ;
                                }
                                int v371;
                                v371 = v253.length;
                                bool v372;
                                v372 = v371 == 0;
                                if (v372){
                                    v285[1874] = 1.0f;
                                } else {
                                }
                                int v373;
                                v373 = v253.length;
                                int v374;
                                v374 = 0;
                                while (while_method_4(v373, v374)){
                                    unsigned char v376;
                                    v376 = v253[v374];
                                    int v378;
                                    v378 = v374 * 17;
                                    int v379;
                                    v379 = 1875 + v378;
                                    unsigned char v380;
                                    v380 = v376 % 4u;
                                    int v381;
                                    v381 = (int)v380;
                                    unsigned char v382;
                                    v382 = v376 / 4u;
                                    int v383;
                                    v383 = (int)v382;
                                    unsigned int v384;
                                    v384 = (unsigned int)v381;
                                    int v385;
                                    v385 = (int)v384;
                                    bool v386;
                                    v386 = v385 < 4;
                                    bool v387;
                                    v387 = v386 == false;
                                    if (v387){
                                        assert("Pickle failure. Int value out of bounds." && v386);
                                    } else {
                                    }
                                    int v389;
                                    v389 = v379 + v385;
                                    v285[v389] = 1.0f;
                                    int v390;
                                    v390 = v379 + 4;
                                    unsigned int v391;
                                    v391 = (unsigned int)v383;
                                    int v392;
                                    v392 = (int)v391;
                                    bool v393;
                                    v393 = v392 < 13;
                                    bool v394;
                                    v394 = v393 == false;
                                    if (v394){
                                        assert("Pickle failure. Int value out of bounds." && v393);
                                    } else {
                                    }
                                    int v396;
                                    v396 = v390 + v392;
                                    v285[v396] = 1.0f;
                                    v374 += 1 ;
                                }
                                __syncthreads();
                                int v397;
                                v397 = 0;
                                while (while_method_3(v397)){
                                    float * v399;
                                    v399 = reinterpret_cast<float *>(&v1[114819072ull]);
                                    assert("Tensor range check" && 0 <= v397 && v397 < 4);
                                    int v401;
                                    v401 = 393216 * v397;
                                    float * v402;
                                    v402 = reinterpret_cast<float *>(&v1[106954752ull]);
                                    float * v404;
                                    v404 = reinterpret_cast<float *>(&v1[94371840ull]);
                                    float * v406;
                                    v406 = reinterpret_cast<float *>(&v1[81788928ull]);
                                    float * v408;
                                    v408 = reinterpret_cast<float *>(&v1[69206016ull]);
                                    float * v410;
                                    v410 = reinterpret_cast<float *>(&v1[56623104ull]);
                                    float * v412;
                                    v412 = reinterpret_cast<float *>(&v1[0ull]);
                                    float * v414;
                                    v414 = reinterpret_cast<float *>(&v0[0ull]);
                                    float * v416;
                                    v416 = reinterpret_cast<float *>(&v2[0ull]);
                                    assert("Tensor range check" && 0 <= v397 && v397 < 4);
                                    int v418;
                                    v418 = 524288 * v397;
                                    float * v419;
                                    v419 = reinterpret_cast<float *>(&v1[50331648ull]);
                                    block_matmul_45(v419, v414, v418, v412);
                                    block_map_46(v410, v419);
                                    float * v421;
                                    v421 = reinterpret_cast<float *>(&v0[8388608ull]);
                                    float * v423;
                                    v423 = reinterpret_cast<float *>(&v2[8388608ull]);
                                    assert("Tensor range check" && 0 <= v397 && v397 < 4);
                                    int v425;
                                    v425 = 65536 * v397;
                                    float * v426;
                                    v426 = reinterpret_cast<float *>(&v1[62914560ull]);
                                    block_matmul_47(v426, v421, v425, v410);
                                    block_map_46(v408, v426);
                                    float * v428;
                                    v428 = reinterpret_cast<float *>(&v0[9437184ull]);
                                    float * v430;
                                    v430 = reinterpret_cast<float *>(&v2[9437184ull]);
                                    assert("Tensor range check" && 0 <= v397 && v397 < 4);
                                    float * v432;
                                    v432 = reinterpret_cast<float *>(&v1[75497472ull]);
                                    block_matmul_47(v432, v428, v425, v408);
                                    block_map_46(v406, v432);
                                    float * v434;
                                    v434 = reinterpret_cast<float *>(&v0[10485760ull]);
                                    float * v436;
                                    v436 = reinterpret_cast<float *>(&v2[10485760ull]);
                                    assert("Tensor range check" && 0 <= v397 && v397 < 4);
                                    float * v438;
                                    v438 = reinterpret_cast<float *>(&v1[88080384ull]);
                                    block_matmul_47(v438, v434, v425, v406);
                                    block_map_46(v404, v438);
                                    float * v440;
                                    v440 = reinterpret_cast<float *>(&v0[11534336ull]);
                                    float * v442;
                                    v442 = reinterpret_cast<float *>(&v2[11534336ull]);
                                    assert("Tensor range check" && 0 <= v397 && v397 < 4);
                                    float * v444;
                                    v444 = reinterpret_cast<float *>(&v1[100663296ull]);
                                    block_matmul_47(v444, v440, v425, v404);
                                    block_map_46(v402, v444);
                                    float * v446;
                                    v446 = reinterpret_cast<float *>(&v0[12582912ull]);
                                    float * v448;
                                    v448 = reinterpret_cast<float *>(&v2[12582912ull]);
                                    assert("Tensor range check" && 0 <= v397 && v397 < 4);
                                    int v450;
                                    v450 = 16384 * v397;
                                    float * v451;
                                    v451 = reinterpret_cast<float *>(&v1[113246208ull]);
                                    block_matmul_48(v451, v446, v450, v402);
                                    block_row_map_49(v399, v401, v451);
                                    int * v453;
                                    v453 = reinterpret_cast<int *>(&v0[12845056ull]);
                                    bool * v455;
                                    v455 = reinterpret_cast<bool *>(&v0[12845072ull]);
                                    float * v457;
                                    v457 = reinterpret_cast<float *>(&v0[12845088ull]);
                                    float * v459;
                                    v459 = reinterpret_cast<float *>(&v0[12845104ull]);
                                    double * v461;
                                    v461 = reinterpret_cast<double *>(&v1[121110528ull]);
                                    double * v463;
                                    v463 = reinterpret_cast<double *>(&v1[121503744ull]);
                                    v397 += 1 ;
                                }
                                __syncthreads();
                                int * v465;
                                v465 = reinterpret_cast<int *>(&v0[12845056ull]);
                                bool * v467;
                                v467 = reinterpret_cast<bool *>(&v0[12845072ull]);
                                float * v469;
                                v469 = reinterpret_cast<float *>(&v0[12845088ull]);
                                float * v471;
                                v471 = reinterpret_cast<float *>(&v0[12845104ull]);
                                int v473;
                                v473 = v465[0];
                                float * v474;
                                v474 = reinterpret_cast<float *>(&v1[114819072ull]);
                                assert("Tensor range check" && 0 <= v473 && v473 < 4);
                                int v476;
                                v476 = 393216 * v473;
                                int v477;
                                v477 = blockIdx.x;
                                assert("Tensor range check" && 0 <= v477 && v477 < 24);
                                int v478;
                                v478 = 16384 * v477;
                                int v479;
                                v479 = v478 + v476;
                                int v480;
                                v480 = threadIdx.x;
                                assert("Tensor range check" && 0 <= v480 && v480 < 256);
                                int v481;
                                v481 = 64 * v480;
                                int v482;
                                v482 = v481 + v479;
                                float * v483;
                                v483 = v474+v482;
                                int v485;
                                v485 = sizeof(float *);
                                unsigned long long v486;
                                v486 = (unsigned long long)v485;
                                unsigned long long v487;
                                v487 = 256ull * v486;
                                unsigned long long v488;
                                v488 = v487 + 16ull;
                                unsigned long long v489;
                                v489 = v488 - 1ull;
                                unsigned long long v490;
                                v490 = v489 % 16ull;
                                unsigned long long v491;
                                v491 = v489 - v490;
                                unsigned long long v492;
                                v492 = v491 + 1024ull;
                                unsigned long long v493;
                                v493 = v492 + 16ull;
                                unsigned long long v494;
                                v494 = v493 - 1ull;
                                unsigned long long v495;
                                v495 = v494 % 16ull;
                                unsigned long long v496;
                                v496 = v494 - v495;
                                unsigned long long v497;
                                v497 = v496 + 1024ull;
                                bool v498;
                                v498 = v497 <= 98304ull;
                                bool v499;
                                v499 = v498 == false;
                                if (v499){
                                    assert("The dynamic shared memory is insufficient to allocate the tensor." && v498);
                                } else {
                                }
                                extern __shared__ unsigned char v501[];
                                bool v502;
                                v502 = v497 <= v497;
                                bool v503;
                                v503 = v502 == false;
                                if (v503){
                                    assert("The length of the partition has to be less than or equal to the length of the base array." && v502);
                                } else {
                                }
                                float * * v505;
                                v505 = reinterpret_cast<float * *>(&v501[0ull]);
                                float * v507;
                                v507 = reinterpret_cast<float *>(&v501[v491]);
                                int * v509;
                                v509 = reinterpret_cast<int *>(&v501[v496]);
                                int v511;
                                v511 = threadIdx.x;
                                assert("Tensor range check" && 0 <= v511 && v511 < 256);
                                v505[v511] = v483;
                                __syncthreads();
                                bool v512;
                                v512 = 0 <= v511;
                                bool v513;
                                v513 = v512 == false;
                                if (v513){
                                    assert("The index needs to be zero or positive." && v512);
                                } else {
                                }
                                int v515;
                                v515 = v511 % 16;
                                int v516;
                                v516 = v511 / 16;
                                bool v517;
                                v517 = v516 < 16;
                                bool v518;
                                v518 = v517 == false;
                                if (v518){
                                    assert("The last element of the projection dimensions needs to be greater than the index remainder." && v517);
                                } else {
                                }
                                assert("Tensor range check" && 0 <= v516 && v516 < 16);
                                int v520;
                                v520 = 0;
                                while (while_method_12(v520)){
                                    bool v522;
                                    v522 = 0 <= v516;
                                    bool v523;
                                    v523 = v522 && v517;
                                    bool v524;
                                    v524 = v523 == false;
                                    if (v524){
                                        assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v523);
                                    } else {
                                    }
                                    bool v526;
                                    v526 = 0 <= v520;
                                    bool v528;
                                    if (v526){
                                        bool v527;
                                        v527 = v520 < 16;
                                        v528 = v527;
                                    } else {
                                        v528 = false;
                                    }
                                    bool v529;
                                    v529 = v528 == false;
                                    if (v529){
                                        assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v528);
                                    } else {
                                    }
                                    int v531;
                                    v531 = v520 * 16;
                                    int v532;
                                    v532 = v531 + v516;
                                    assert("Tensor range check" && 0 <= v520 && v520 < 16);
                                    int v533;
                                    v533 = 16 * v520;
                                    int v534;
                                    v534 = v533 + v516;
                                    float * v535;
                                    v535 = v505[v534];
                                    int v536;
                                    v536 = blockIdx.x;
                                    int v537;
                                    v537 = v536 * 256;
                                    int v538;
                                    v538 = v537 + v532;
                                    assert("Tensor range check" && 0 <= v515 && v515 < 16);
                                    int v539;
                                    v539 = 4 * v515;
                                    float v540[4];
                                    int v541[4];
                                    int v542;
                                    v542 = 0;
                                    while (while_method_6(v542)){
                                        assert("Tensor range check" && 0 <= v542 && v542 < 1);
                                        int v544;
                                        v544 = 4 * v542;
                                        assert("Tensor range check" && 0 <= v542 && v542 < 1);
                                        int v545;
                                        v545 = 64 * v542;
                                        int v546;
                                        v546 = v545 + v539;
                                        int4* v547;
                                        v547 = reinterpret_cast<int4*>(v535 + v546);
                                        int4* v548;
                                        v548 = reinterpret_cast<int4*>(v540 + v544);
                                        assert("Pointer alignment check" && reinterpret_cast<unsigned long long>(v547) % 16 == 0 && reinterpret_cast<unsigned long long>(v548) % 16 == 0);
                                        *v548 = *v547;
                                        v542 += 1 ;
                                    }
                                    int v549;
                                    v549 = 0;
                                    while (while_method_6(v549)){
                                        int v551;
                                        v551 = 0;
                                        while (while_method_3(v551)){
                                            bool v553;
                                            v553 = 0 <= v551;
                                            bool v555;
                                            if (v553){
                                                bool v554;
                                                v554 = v551 < 4;
                                                v555 = v554;
                                            } else {
                                                v555 = false;
                                            }
                                            bool v556;
                                            v556 = v555 == false;
                                            if (v556){
                                                assert("The indices should be inside the range of the dimension." && v555);
                                            } else {
                                            }
                                            bool v558;
                                            v558 = 0 <= v515;
                                            bool v560;
                                            if (v558){
                                                bool v559;
                                                v559 = v515 < 16;
                                                v560 = v559;
                                            } else {
                                                v560 = false;
                                            }
                                            bool v561;
                                            v561 = v560 == false;
                                            if (v561){
                                                assert("The indices should be inside the range of the dimension." && v560);
                                            } else {
                                            }
                                            int v563;
                                            v563 = v515 * 4;
                                            int v564;
                                            v564 = v551 + v563;
                                            bool v565;
                                            v565 = 0 <= v549;
                                            bool v567;
                                            if (v565){
                                                bool v566;
                                                v566 = v549 < 1;
                                                v567 = v566;
                                            } else {
                                                v567 = false;
                                            }
                                            bool v568;
                                            v568 = v567 == false;
                                            if (v568){
                                                assert("The indices should be inside the range of the dimension." && v567);
                                            } else {
                                            }
                                            int v570;
                                            v570 = v549 * 64;
                                            int v571;
                                            v571 = v564 + v570;
                                            assert("Tensor range check" && 0 <= v549 && v549 < 1);
                                            assert("Tensor range check" && 0 <= v551 && v551 < 4);
                                            int v572;
                                            v572 = 4 * v549;
                                            int v573;
                                            v573 = v572 + v551;
                                            v541[v573] = v571;
                                            v551 += 1 ;
                                        }
                                        v549 += 1 ;
                                    }
                                    float v574[4];
                                    float v575;
                                    v575 = 0.0f;
                                    int v576;
                                    v576 = 0;
                                    while (while_method_6(v576)){
                                        assert("Tensor range check" && 0 <= v576 && v576 < 1);
                                        int v578;
                                        v578 = 4 * v576;
                                        assert("Tensor range check" && 0 <= v576 && v576 < 1);
                                        float v579;
                                        v579 = 0.0f;
                                        int v580;
                                        v580 = 0;
                                        while (while_method_3(v580)){
                                            assert("Tensor range check" && 0 <= v580 && v580 < 4);
                                            int v582;
                                            v582 = v580 + v578;
                                            float v583;
                                            v583 = v540[v582];
                                            float v584;
                                            v584 = v579 + v583;
                                            v579 = v584;
                                            v580 += 1 ;
                                        }
                                        auto v585 = cooperative_groups::coalesced_threads();
                                        int v586;
                                        v586 = threadIdx.x;
                                        int v587;
                                        v587 = v586 / 16;
                                        auto v588 = cooperative_groups::labeled_partition(v585,v587);
                                        Closure2 v589{};
                                        float v590;
                                        v590 = cooperative_groups::inclusive_scan(v588, v579, v589);
                                        float v591;
                                        v591 = v588.shfl_up(v590,1);
                                        bool v592;
                                        v592 = v588.thread_rank() == 0;
                                        float v593;
                                        if (v592){
                                            v593 = 0.0f;
                                        } else {
                                            v593 = v591;
                                        }
                                        float v594;
                                        v594 = v588.shfl(v590,v588.num_threads()-1);
                                        float v595;
                                        v595 = v575 + v593;
                                        float v596;
                                        v596 = v595;
                                        int v597;
                                        v597 = 0;
                                        while (while_method_3(v597)){
                                            assert("Tensor range check" && 0 <= v597 && v597 < 4);
                                            int v599;
                                            v599 = v597 + v578;
                                            float v600;
                                            v600 = v540[v599];
                                            float v601;
                                            v601 = v596 + v600;
                                            assert("Tensor range check" && 0 <= v597 && v597 < 4);
                                            v574[v599] = v601;
                                            v596 = v601;
                                            v597 += 1 ;
                                        }
                                        float v602;
                                        v602 = v575 + v594;
                                        v575 = v602;
                                        v576 += 1 ;
                                    }
                                    float v603[4];
                                    bool v604[4];
                                    int v605;
                                    v605 = 0;
                                    while (while_method_6(v605)){
                                        int v607;
                                        v607 = 0;
                                        while (while_method_3(v607)){
                                            assert("Tensor range check" && 0 <= v605 && v605 < 1);
                                            assert("Tensor range check" && 0 <= v607 && v607 < 4);
                                            int v609;
                                            v609 = 4 * v605;
                                            int v610;
                                            v610 = v609 + v607;
                                            float v611;
                                            v611 = v574[v610];
                                            float v612;
                                            v612 = v540[v610];
                                            bool v613;
                                            v613 = v612 > 0.0f;
                                            assert("Tensor range check" && 0 <= v605 && v605 < 1);
                                            assert("Tensor range check" && 0 <= v607 && v607 < 4);
                                            v603[v610] = v611;
                                            v604[v610] = v613;
                                            v607 += 1 ;
                                        }
                                        v605 += 1 ;
                                    }
                                    float v614; bool v615;
                                    Tuple14 tmp119 = Tuple14{-1.0f / 0.0f, false};
                                    v614 = tmp119.v0; v615 = tmp119.v1;
                                    int v616;
                                    v616 = 0;
                                    while (while_method_6(v616)){
                                        int v618;
                                        v618 = 0;
                                        while (while_method_3(v618)){
                                            assert("Tensor range check" && 0 <= v616 && v616 < 1);
                                            assert("Tensor range check" && 0 <= v618 && v618 < 4);
                                            int v620;
                                            v620 = 4 * v616;
                                            int v621;
                                            v621 = v620 + v618;
                                            float v622;
                                            v622 = v603[v621];
                                            bool v623;
                                            v623 = v604[v621];
                                            float v630; bool v631;
                                            if (v615){
                                                if (v623){
                                                    bool v624;
                                                    v624 = v614 >= v622;
                                                    float v625;
                                                    if (v624){
                                                        v625 = v614;
                                                    } else {
                                                        v625 = v622;
                                                    }
                                                    v630 = v625; v631 = true;
                                                } else {
                                                    v630 = v614; v631 = v615;
                                                }
                                            } else {
                                                if (v623){
                                                    v630 = v622; v631 = v623;
                                                } else {
                                                    v630 = v614; v631 = v615;
                                                }
                                            }
                                            v614 = v630;
                                            v615 = v631;
                                            v618 += 1 ;
                                        }
                                        v616 += 1 ;
                                    }
                                    auto v632 = cooperative_groups::coalesced_threads();
                                    int v633;
                                    v633 = threadIdx.x;
                                    int v634;
                                    v634 = v633 / 16;
                                    auto v635 = cooperative_groups::labeled_partition(v632,v634);
                                    Closure3 v636{};
                                    float v637; bool v638;
                                    Tuple14 tmp120 = cooperative_groups::reduce(v635, Tuple14{v614, v615}, v636);
                                    v637 = tmp120.v0; v638 = tmp120.v1;
                                    bool v639;
                                    v639 = v638 == false;
                                    if (v639){
                                        int v640;
                                        v640 = threadIdx.x;
                                        int v641;
                                        v641 = blockIdx.x;
                                        int v642;
                                        v642 = v641 * 256;
                                        int v643;
                                        v643 = v640 + v642;
                                        cuda::counting_semaphore<cuda::thread_scope_system, 1> & v644 = console_lock;
                                        auto v645 = cooperative_groups::coalesced_threads();
                                        v644.acquire();
                                        int v646;
                                        v646 = 0;
                                        printf("{%s = %d; %s = %c","tid", v643, "x'", '[');
                                        int v647;
                                        v647 = 0;
                                        while (while_method_6(v647)){
                                            int v649;
                                            v649 = v646;
                                            bool v650;
                                            v650 = v649 >= 100;
                                            if (v650){
                                                printf("%s"," ...");
                                                break;
                                            } else {
                                            }
                                            bool v651;
                                            v651 = v647 == 0;
                                            bool v652;
                                            v652 = v651 != true;
                                            if (v652){
                                                printf("%s","; ");
                                            } else {
                                            }
                                            printf("%c",'[');
                                            int v653;
                                            v653 = 0;
                                            while (while_method_3(v653)){
                                                int v655;
                                                v655 = v646;
                                                bool v656;
                                                v656 = v655 >= 100;
                                                if (v656){
                                                    printf("%s"," ...");
                                                    break;
                                                } else {
                                                }
                                                bool v657;
                                                v657 = v653 == 0;
                                                bool v658;
                                                v658 = v657 != true;
                                                if (v658){
                                                    printf("%s","; ");
                                                } else {
                                                }
                                                int v659;
                                                v659 = v646 + 1;
                                                v646 = v659;
                                                int v660;
                                                v660 = v647 * 4;
                                                int v661;
                                                v661 = v660 + v653;
                                                float v662;
                                                v662 = v603[v661];
                                                bool v663;
                                                v663 = v604[v661];
                                                const char * v666;
                                                if (v663){
                                                    const char * v664;
                                                    v664 = "true";
                                                    v666 = v664;
                                                } else {
                                                    const char * v665;
                                                    v665 = "false";
                                                    v666 = v665;
                                                }
                                                printf("%f, %s",v662, v666);
                                                v653 += 1 ;
                                            }
                                            printf("%c",']');
                                            v647 += 1 ;
                                        }
                                        printf("%c",']');
                                        printf("}\n");
                                        v644.release();
                                        v645.sync() ;
                                    } else {
                                    }
                                    if (v639){
                                        assert("The local reduce must be true." && v638);
                                    } else {
                                    }
                                    float v702[4];
                                    int v703[4];
                                    int v704;
                                    v704 = 0;
                                    while (while_method_6(v704)){
                                        int v706;
                                        v706 = 0;
                                        while (while_method_3(v706)){
                                            assert("Tensor range check" && 0 <= v704 && v704 < 1);
                                            assert("Tensor range check" && 0 <= v706 && v706 < 4);
                                            int v708;
                                            v708 = 4 * v704;
                                            int v709;
                                            v709 = v708 + v706;
                                            int v710;
                                            v710 = v541[v709];
                                            float v711;
                                            v711 = curand_uniform(&v180);
                                            assert("Tensor range check" && 0 <= v704 && v704 < 1);
                                            assert("Tensor range check" && 0 <= v706 && v706 < 4);
                                            v702[v709] = v711;
                                            v703[v709] = v710;
                                            v706 += 1 ;
                                        }
                                        v704 += 1 ;
                                    }
                                    float v712; int v713;
                                    Tuple15 tmp121 = Tuple15{0.0f, 2147483647};
                                    v712 = tmp121.v0; v713 = tmp121.v1;
                                    int v714;
                                    v714 = 0;
                                    while (while_method_6(v714)){
                                        int v716;
                                        v716 = 0;
                                        while (while_method_3(v716)){
                                            assert("Tensor range check" && 0 <= v714 && v714 < 1);
                                            assert("Tensor range check" && 0 <= v716 && v716 < 4);
                                            int v718;
                                            v718 = 4 * v714;
                                            int v719;
                                            v719 = v718 + v716;
                                            float v720;
                                            v720 = v702[v719];
                                            int v721;
                                            v721 = v703[v719];
                                            bool v722;
                                            v722 = v713 < v721;
                                            float v723; int v724;
                                            if (v722){
                                                v723 = v712; v724 = v713;
                                            } else {
                                                v723 = v720; v724 = v721;
                                            }
                                            v712 = v723;
                                            v713 = v724;
                                            v716 += 1 ;
                                        }
                                        v714 += 1 ;
                                    }
                                    auto v725 = cooperative_groups::coalesced_threads();
                                    int v726;
                                    v726 = threadIdx.x;
                                    int v727;
                                    v727 = v726 / 16;
                                    auto v728 = cooperative_groups::labeled_partition(v725,v727);
                                    Closure4 v729{};
                                    float v730; int v731;
                                    Tuple15 tmp122 = cooperative_groups::reduce(v728, Tuple15{v712, v713}, v729);
                                    v730 = tmp122.v0; v731 = tmp122.v1;
                                    float v732;
                                    v732 = v637 * v730;
                                    int v733[4];
                                    bool v734[4];
                                    int v735;
                                    v735 = 0;
                                    while (while_method_6(v735)){
                                        int v737;
                                        v737 = 0;
                                        while (while_method_3(v737)){
                                            assert("Tensor range check" && 0 <= v735 && v735 < 1);
                                            assert("Tensor range check" && 0 <= v737 && v737 < 4);
                                            int v739;
                                            v739 = 4 * v735;
                                            int v740;
                                            v740 = v739 + v737;
                                            float v741;
                                            v741 = v603[v740];
                                            bool v742;
                                            v742 = v604[v740];
                                            int v743;
                                            v743 = v541[v740];
                                            int v746; bool v747;
                                            if (v742){
                                                float v744;
                                                v744 = v741 - v732;
                                                bool v745;
                                                v745 = v744 >= 0.0f;
                                                v746 = v743; v747 = v745;
                                            } else {
                                                v746 = 2147483647; v747 = false;
                                            }
                                            assert("Tensor range check" && 0 <= v735 && v735 < 1);
                                            assert("Tensor range check" && 0 <= v737 && v737 < 4);
                                            v733[v740] = v746;
                                            v734[v740] = v747;
                                            v737 += 1 ;
                                        }
                                        v735 += 1 ;
                                    }
                                    int v748; bool v749;
                                    Tuple16 tmp123 = Tuple16{2147483647, false};
                                    v748 = tmp123.v0; v749 = tmp123.v1;
                                    int v750;
                                    v750 = 0;
                                    while (while_method_6(v750)){
                                        int v752;
                                        v752 = 0;
                                        while (while_method_3(v752)){
                                            assert("Tensor range check" && 0 <= v750 && v750 < 1);
                                            assert("Tensor range check" && 0 <= v752 && v752 < 4);
                                            int v754;
                                            v754 = 4 * v750;
                                            int v755;
                                            v755 = v754 + v752;
                                            int v756;
                                            v756 = v733[v755];
                                            bool v757;
                                            v757 = v734[v755];
                                            int v764; bool v765;
                                            if (v749){
                                                if (v757){
                                                    bool v758;
                                                    v758 = v748 < v756;
                                                    int v759;
                                                    if (v758){
                                                        v759 = v748;
                                                    } else {
                                                        v759 = v756;
                                                    }
                                                    v764 = v759; v765 = true;
                                                } else {
                                                    v764 = v748; v765 = v749;
                                                }
                                            } else {
                                                if (v757){
                                                    v764 = v756; v765 = v757;
                                                } else {
                                                    v764 = v748; v765 = v749;
                                                }
                                            }
                                            v748 = v764;
                                            v749 = v765;
                                            v752 += 1 ;
                                        }
                                        v750 += 1 ;
                                    }
                                    auto v766 = cooperative_groups::coalesced_threads();
                                    int v767;
                                    v767 = threadIdx.x;
                                    int v768;
                                    v768 = v767 / 16;
                                    auto v769 = cooperative_groups::labeled_partition(v766,v768);
                                    Closure5 v770{};
                                    int v771; bool v772;
                                    Tuple16 tmp124 = cooperative_groups::reduce(v769, Tuple16{v748, v749}, v770);
                                    v771 = tmp124.v0; v772 = tmp124.v1;
                                    bool v773;
                                    v773 = v772 == false;
                                    if (v773){
                                        int v774;
                                        v774 = threadIdx.x;
                                        int v775;
                                        v775 = blockIdx.x;
                                        int v776;
                                        v776 = v775 * 256;
                                        int v777;
                                        v777 = v774 + v776;
                                        cuda::counting_semaphore<cuda::thread_scope_system, 1> & v778 = console_lock;
                                        auto v779 = cooperative_groups::coalesced_threads();
                                        v778.acquire();
                                        int v780;
                                        v780 = 0;
                                        printf("{%s = %d; %s = %c","tid", v777, "x'", '[');
                                        int v781;
                                        v781 = 0;
                                        while (while_method_6(v781)){
                                            int v783;
                                            v783 = v780;
                                            bool v784;
                                            v784 = v783 >= 100;
                                            if (v784){
                                                printf("%s"," ...");
                                                break;
                                            } else {
                                            }
                                            bool v785;
                                            v785 = v781 == 0;
                                            bool v786;
                                            v786 = v785 != true;
                                            if (v786){
                                                printf("%s","; ");
                                            } else {
                                            }
                                            printf("%c",'[');
                                            int v787;
                                            v787 = 0;
                                            while (while_method_3(v787)){
                                                int v789;
                                                v789 = v780;
                                                bool v790;
                                                v790 = v789 >= 100;
                                                if (v790){
                                                    printf("%s"," ...");
                                                    break;
                                                } else {
                                                }
                                                bool v791;
                                                v791 = v787 == 0;
                                                bool v792;
                                                v792 = v791 != true;
                                                if (v792){
                                                    printf("%s","; ");
                                                } else {
                                                }
                                                int v793;
                                                v793 = v780 + 1;
                                                v780 = v793;
                                                int v794;
                                                v794 = v781 * 4;
                                                int v795;
                                                v795 = v794 + v787;
                                                int v796;
                                                v796 = v733[v795];
                                                bool v797;
                                                v797 = v734[v795];
                                                const char * v800;
                                                if (v797){
                                                    const char * v798;
                                                    v798 = "true";
                                                    v800 = v798;
                                                } else {
                                                    const char * v799;
                                                    v799 = "false";
                                                    v800 = v799;
                                                }
                                                printf("%d, %s",v796, v800);
                                                v787 += 1 ;
                                            }
                                            printf("%c",']');
                                            v781 += 1 ;
                                        }
                                        printf("%c",']');
                                        printf("}\n");
                                        v778.release();
                                        v779.sync() ;
                                    } else {
                                    }
                                    if (v773){
                                        assert("The local reduce must be true." && v772);
                                    } else {
                                    }
                                    float v836; int v837;
                                    Tuple15 tmp125 = Tuple15{0.0f, 2147483647};
                                    v836 = tmp125.v0; v837 = tmp125.v1;
                                    int v838;
                                    v838 = 0;
                                    while (while_method_6(v838)){
                                        int v840;
                                        v840 = 0;
                                        while (while_method_3(v840)){
                                            assert("Tensor range check" && 0 <= v838 && v838 < 1);
                                            assert("Tensor range check" && 0 <= v840 && v840 < 4);
                                            int v842;
                                            v842 = 4 * v838;
                                            int v843;
                                            v843 = v842 + v840;
                                            float v844;
                                            v844 = v540[v843];
                                            int v845;
                                            v845 = v541[v843];
                                            bool v846;
                                            v846 = v837 == v771;
                                            float v850; int v851;
                                            if (v846){
                                                v850 = v836; v851 = v837;
                                            } else {
                                                bool v847;
                                                v847 = v845 == v771;
                                                if (v847){
                                                    v850 = v844; v851 = v845;
                                                } else {
                                                    v850 = v836; v851 = v837;
                                                }
                                            }
                                            v836 = v850;
                                            v837 = v851;
                                            v840 += 1 ;
                                        }
                                        v838 += 1 ;
                                    }
                                    auto v852 = cooperative_groups::coalesced_threads();
                                    int v853;
                                    v853 = threadIdx.x;
                                    int v854;
                                    v854 = v853 / 16;
                                    auto v855 = cooperative_groups::labeled_partition(v852,v854);
                                    Closure6 v856{v771};
                                    float v857; int v858;
                                    Tuple15 tmp126 = cooperative_groups::reduce(v855, Tuple15{v836, v837}, v856);
                                    v857 = tmp126.v0; v858 = tmp126.v1;
                                    bool v859;
                                    v859 = v858 == 2147483647;
                                    bool v860;
                                    v860 = v859 != true;
                                    bool v861;
                                    v861 = v860 == false;
                                    if (v861){
                                        assert("Expected a valid action id in get_prob." && v860);
                                    } else {
                                    }
                                    int v863;
                                    v863 = 0;
                                    while (while_method_6(v863)){
                                        assert("Tensor range check" && 0 <= v863 && v863 < 1);
                                        assert("Tensor range check" && 0 <= v863 && v863 < 1);
                                        v863 += 1 ;
                                    }
                                    assert("Tensor range check" && 0 <= v532 && v532 < 256);
                                    v507[v532] = v857;
                                    v509[v532] = v771;
                                    v520 += 1 ;
                                }
                                __syncthreads();
                                assert("Tensor range check" && 0 <= v511 && v511 < 256);
                                float v865;
                                v865 = v507[v511];
                                int v866;
                                v866 = v509[v511];
                                __syncthreads();
                                extern __shared__ unsigned char v867[];
                                float * v868;
                                v868 = reinterpret_cast<float *>(&v867[0ull]);
                                int * v870;
                                v870 = reinterpret_cast<int *>(&v867[16ull]);
                                int v872;
                                v872 = threadIdx.x;
                                bool v873;
                                v873 = v872 == 0;
                                if (v873){
                                    v868[0] = v865;
                                    v870[0] = v866;
                                } else {
                                }
                                __syncthreads();
                                float v874;
                                v874 = v868[0];
                                int v875;
                                v875 = v870[0];
                                __syncthreads();
                                double * v876;
                                v876 = reinterpret_cast<double *>(&v1[121110528ull]);
                                double * v878;
                                v878 = reinterpret_cast<double *>(&v1[121503744ull]);
                                int v880;
                                v880 = threadIdx.x;
                                int v881;
                                v881 = blockIdx.x;
                                int v882;
                                v882 = v881 * 256;
                                int v883;
                                v883 = v880 + v882;
                                int v884;
                                v884 = 0;
                                while (while_method_3(v884)){
                                    float * v886;
                                    v886 = reinterpret_cast<float *>(&v1[114819072ull]);
                                    int v888;
                                    v888 = blockIdx.x;
                                    int v889;
                                    v889 = threadIdx.x;
                                    assert("Tensor range check" && 0 <= v884 && v884 < 4);
                                    assert("Tensor range check" && 0 <= v888 && v888 < 24);
                                    assert("Tensor range check" && 0 <= v889 && v889 < 256);
                                    assert("Tensor range check" && 0 <= v875 && v875 < 64);
                                    int v890;
                                    v890 = 64 * v889;
                                    int v891;
                                    v891 = v890 + v875;
                                    int v892;
                                    v892 = 16384 * v888;
                                    int v893;
                                    v893 = v892 + v891;
                                    int v894;
                                    v894 = 393216 * v884;
                                    int v895;
                                    v895 = v894 + v893;
                                    float v896;
                                    v896 = v886[v895];
                                    double v897;
                                    v897 = (double)v874;
                                    double v898;
                                    v898 = log(v897);
                                    double v899;
                                    v899 = (double)v896;
                                    double v900;
                                    v900 = log(v899);
                                    assert("Tensor range check" && 0 <= v884 && v884 < 4);
                                    assert("Tensor range check" && 0 <= v883 && v883 < 6144);
                                    assert("Tensor range check" && 0 <= v168 && v168 < 2);
                                    int v901;
                                    v901 = 2 * v883;
                                    int v902;
                                    v902 = v901 + v168;
                                    int v903;
                                    v903 = 12288 * v884;
                                    int v904;
                                    v904 = v903 + v902;
                                    double v905;
                                    v905 = v876[v904];
                                    double v906;
                                    v906 = v878[v904];
                                    double v907;
                                    v907 = v900 + v905;
                                    double v908;
                                    v908 = v898 + v906;
                                    bool v909;
                                    v909 = isnan(v908);
                                    bool v910;
                                    v910 = v909 == false;
                                    bool v911;
                                    v911 = v910 == false;
                                    if (v911){
                                        assert("The sampling log probability shouldn't be nan." && v910);
                                    } else {
                                    }
                                    bool v913;
                                    v913 = isnan(v907);
                                    bool v914;
                                    v914 = v913 == false;
                                    bool v915;
                                    v915 = v914 == false;
                                    if (v915){
                                        assert("The policy log probability shouldn't be nan." && v914);
                                    } else {
                                    }
                                    assert("Tensor range check" && 0 <= v884 && v884 < 4);
                                    assert("Tensor range check" && 0 <= v883 && v883 < 6144);
                                    assert("Tensor range check" && 0 <= v168 && v168 < 2);
                                    v876[v904] = v907;
                                    v878[v904] = v908;
                                    v884 += 1 ;
                                }
                                bool v917;
                                v917 = 0 == v875;
                                Union10 v926;
                                if (v917){
                                    v926 = Union10{Union10_1{}};
                                } else {
                                    bool v919;
                                    v919 = 1 == v875;
                                    if (v919){
                                        v926 = Union10{Union10_0{}};
                                    } else {
                                        bool v921;
                                        v921 = 2 == v875;
                                        if (v921){
                                            v926 = Union10{Union10_2{1, 1}};
                                        } else {
                                            printf("%s\n", "Invalid output id in the NL Holdem model.");
                                            __trap();
                                        }
                                    }
                                }
                                switch (v926.tag) {
                                    case 0: { // AA_Call
                                        v1214 = Union1{Union1_1{}};
                                        break;
                                    }
                                    case 1: { // AA_Fold
                                        int v927;
                                        v927 = v164[0];
                                        int v929; int v930;
                                        Tuple4 tmp127 = Tuple4{1, v927};
                                        v929 = tmp127.v0; v930 = tmp127.v1;
                                        while (while_method_0(v929)){
                                            bool v932;
                                            v932 = 0 <= v929;
                                            bool v934;
                                            if (v932){
                                                bool v933;
                                                v933 = v929 < 2;
                                                v934 = v933;
                                            } else {
                                                v934 = false;
                                            }
                                            bool v935;
                                            v935 = v934 == false;
                                            if (v935){
                                                assert("Index must be in range." && v934);
                                            } else {
                                            }
                                            int v937;
                                            v937 = v164[v929];
                                            bool v939;
                                            v939 = v930 >= v937;
                                            int v940;
                                            if (v939){
                                                v940 = v930;
                                            } else {
                                                v940 = v937;
                                            }
                                            v930 = v940;
                                            v929 += 1 ;
                                        }
                                        bool v942;
                                        if (v170){
                                            bool v941;
                                            v941 = v168 < 2;
                                            v942 = v941;
                                        } else {
                                            v942 = false;
                                        }
                                        bool v943;
                                        v943 = v942 == false;
                                        if (v943){
                                            assert("Index must be in range." && v942);
                                        } else {
                                        }
                                        int v945;
                                        v945 = v164[v168];
                                        bool v947;
                                        v947 = v945 == v930;
                                        if (v947){
                                            v1214 = Union1{Union1_1{}};
                                        } else {
                                            v1214 = Union1{Union1_2{}};
                                        }
                                        break;
                                    }
                                    case 2: { // AA_Raise
                                        int v952 = v926.case2.v0; int v953 = v926.case2.v1;
                                        static_array<int,2> v954;
                                        int v956;
                                        v956 = 0;
                                        while (while_method_0(v956)){
                                            bool v958;
                                            v958 = 0 <= v956;
                                            bool v960;
                                            if (v958){
                                                bool v959;
                                                v959 = v956 < 2;
                                                v960 = v959;
                                            } else {
                                                v960 = false;
                                            }
                                            bool v961;
                                            v961 = v960 == false;
                                            if (v961){
                                                assert("Index must be in range." && v960);
                                            } else {
                                            }
                                            int v963;
                                            v963 = v166[v956];
                                            bool v966;
                                            if (v958){
                                                bool v965;
                                                v965 = v956 < 2;
                                                v966 = v965;
                                            } else {
                                                v966 = false;
                                            }
                                            bool v967;
                                            v967 = v966 == false;
                                            if (v967){
                                                assert("Index must be in range." && v966);
                                            } else {
                                            }
                                            int v969;
                                            v969 = v164[v956];
                                            int v971;
                                            v971 = v963 + v969;
                                            v954[v956] = v971;
                                            v956 += 1 ;
                                        }
                                        int v972;
                                        v972 = v164[0];
                                        int v974; int v975;
                                        Tuple4 tmp128 = Tuple4{1, v972};
                                        v974 = tmp128.v0; v975 = tmp128.v1;
                                        while (while_method_0(v974)){
                                            bool v977;
                                            v977 = 0 <= v974;
                                            bool v979;
                                            if (v977){
                                                bool v978;
                                                v978 = v974 < 2;
                                                v979 = v978;
                                            } else {
                                                v979 = false;
                                            }
                                            bool v980;
                                            v980 = v979 == false;
                                            if (v980){
                                                assert("Index must be in range." && v979);
                                            } else {
                                            }
                                            int v982;
                                            v982 = v164[v974];
                                            bool v984;
                                            v984 = v975 >= v982;
                                            int v985;
                                            if (v984){
                                                v985 = v975;
                                            } else {
                                                v985 = v982;
                                            }
                                            v975 = v985;
                                            v974 += 1 ;
                                        }
                                        bool v987;
                                        if (v170){
                                            bool v986;
                                            v986 = v168 < 2;
                                            v987 = v986;
                                        } else {
                                            v987 = false;
                                        }
                                        bool v988;
                                        v988 = v987 == false;
                                        if (v988){
                                            assert("Index must be in range." && v987);
                                        } else {
                                        }
                                        int v990;
                                        v990 = v954[v168];
                                        bool v992;
                                        v992 = v975 < v990;
                                        int v993;
                                        if (v992){
                                            v993 = v975;
                                        } else {
                                            v993 = v990;
                                        }
                                        static_array<int,2> v994;
                                        int v996;
                                        v996 = 0;
                                        while (while_method_0(v996)){
                                            bool v998;
                                            v998 = 0 <= v996;
                                            bool v1000;
                                            if (v998){
                                                bool v999;
                                                v999 = v996 < 2;
                                                v1000 = v999;
                                            } else {
                                                v1000 = false;
                                            }
                                            bool v1001;
                                            v1001 = v1000 == false;
                                            if (v1001){
                                                assert("Index must be in range." && v1000);
                                            } else {
                                            }
                                            int v1003;
                                            v1003 = v164[v996];
                                            bool v1005;
                                            v1005 = v168 == v996;
                                            int v1006;
                                            if (v1005){
                                                v1006 = v993;
                                            } else {
                                                v1006 = v1003;
                                            }
                                            v994[v996] = v1006;
                                            v996 += 1 ;
                                        }
                                        int v1007;
                                        v1007 = v994[0];
                                        int v1009; int v1010;
                                        Tuple4 tmp129 = Tuple4{1, v1007};
                                        v1009 = tmp129.v0; v1010 = tmp129.v1;
                                        while (while_method_0(v1009)){
                                            bool v1012;
                                            v1012 = 0 <= v1009;
                                            bool v1014;
                                            if (v1012){
                                                bool v1013;
                                                v1013 = v1009 < 2;
                                                v1014 = v1013;
                                            } else {
                                                v1014 = false;
                                            }
                                            bool v1015;
                                            v1015 = v1014 == false;
                                            if (v1015){
                                                assert("Index must be in range." && v1014);
                                            } else {
                                            }
                                            int v1017;
                                            v1017 = v994[v1009];
                                            int v1019;
                                            v1019 = v1010 + v1017;
                                            v1010 = v1019;
                                            v1009 += 1 ;
                                        }
                                        static_array<int,2> v1020;
                                        int v1022;
                                        v1022 = 0;
                                        while (while_method_0(v1022)){
                                            bool v1024;
                                            v1024 = 0 <= v1022;
                                            bool v1026;
                                            if (v1024){
                                                bool v1025;
                                                v1025 = v1022 < 2;
                                                v1026 = v1025;
                                            } else {
                                                v1026 = false;
                                            }
                                            bool v1027;
                                            v1027 = v1026 == false;
                                            if (v1027){
                                                assert("Index must be in range." && v1026);
                                            } else {
                                            }
                                            int v1029;
                                            v1029 = v954[v1022];
                                            bool v1032;
                                            if (v1024){
                                                bool v1031;
                                                v1031 = v1022 < 2;
                                                v1032 = v1031;
                                            } else {
                                                v1032 = false;
                                            }
                                            bool v1033;
                                            v1033 = v1032 == false;
                                            if (v1033){
                                                assert("Index must be in range." && v1032);
                                            } else {
                                            }
                                            int v1035;
                                            v1035 = v994[v1022];
                                            int v1037;
                                            v1037 = v1029 - v1035;
                                            v1020[v1022] = v1037;
                                            v1022 += 1 ;
                                        }
                                        int v1038;
                                        v1038 = v952 * v1010;
                                        int v1039;
                                        v1039 = v1038 / v953;
                                        bool v1040;
                                        v1040 = v162 >= v1039;
                                        int v1041;
                                        if (v1040){
                                            v1041 = v162;
                                        } else {
                                            v1041 = v1039;
                                        }
                                        bool v1043;
                                        if (v170){
                                            bool v1042;
                                            v1042 = v168 < 2;
                                            v1043 = v1042;
                                        } else {
                                            v1043 = false;
                                        }
                                        bool v1044;
                                        v1044 = v1043 == false;
                                        if (v1044){
                                            assert("Index must be in range." && v1043);
                                        } else {
                                        }
                                        int v1046;
                                        v1046 = v1020[v168];
                                        bool v1048;
                                        v1048 = v1041 >= v1046;
                                        if (v1048){
                                            v1214 = Union1{Union1_0{}};
                                        } else {
                                            v1214 = Union1{Union1_3{v1041}};
                                        }
                                        break;
                                    }
                                    default: {
                                        assert("Invalid tag." && false); __trap();
                                    }
                                }
                                break;
                            }
                            case 2: { // Human
                                printf("%s\n", "Humans aren't allowed during training.");
                                __trap();
                                break;
                            }
                            case 3: { // Random
                                curandStatePhilox4_32_10_t & v1055 = v3.v5;
                                curandStatePhilox4_32_10_t & v1056 = v1055;
                                static_array<int,2> v1057;
                                int v1059;
                                v1059 = 0;
                                while (while_method_0(v1059)){
                                    bool v1061;
                                    v1061 = 0 <= v1059;
                                    bool v1063;
                                    if (v1061){
                                        bool v1062;
                                        v1062 = v1059 < 2;
                                        v1063 = v1062;
                                    } else {
                                        v1063 = false;
                                    }
                                    bool v1064;
                                    v1064 = v1063 == false;
                                    if (v1064){
                                        assert("Index must be in range." && v1063);
                                    } else {
                                    }
                                    int v1066;
                                    v1066 = v166[v1059];
                                    bool v1069;
                                    if (v1061){
                                        bool v1068;
                                        v1068 = v1059 < 2;
                                        v1069 = v1068;
                                    } else {
                                        v1069 = false;
                                    }
                                    bool v1070;
                                    v1070 = v1069 == false;
                                    if (v1070){
                                        assert("Index must be in range." && v1069);
                                    } else {
                                    }
                                    int v1072;
                                    v1072 = v164[v1059];
                                    int v1074;
                                    v1074 = v1066 + v1072;
                                    v1057[v1059] = v1074;
                                    v1059 += 1 ;
                                }
                                int v1075;
                                v1075 = v164[0];
                                int v1077; int v1078;
                                Tuple4 tmp130 = Tuple4{1, v1075};
                                v1077 = tmp130.v0; v1078 = tmp130.v1;
                                while (while_method_0(v1077)){
                                    bool v1080;
                                    v1080 = 0 <= v1077;
                                    bool v1082;
                                    if (v1080){
                                        bool v1081;
                                        v1081 = v1077 < 2;
                                        v1082 = v1081;
                                    } else {
                                        v1082 = false;
                                    }
                                    bool v1083;
                                    v1083 = v1082 == false;
                                    if (v1083){
                                        assert("Index must be in range." && v1082);
                                    } else {
                                    }
                                    int v1085;
                                    v1085 = v164[v1077];
                                    bool v1087;
                                    v1087 = v1078 >= v1085;
                                    int v1088;
                                    if (v1087){
                                        v1088 = v1078;
                                    } else {
                                        v1088 = v1085;
                                    }
                                    v1078 = v1088;
                                    v1077 += 1 ;
                                }
                                bool v1090;
                                if (v170){
                                    bool v1089;
                                    v1089 = v168 < 2;
                                    v1090 = v1089;
                                } else {
                                    v1090 = false;
                                }
                                bool v1091;
                                v1091 = v1090 == false;
                                if (v1091){
                                    assert("Index must be in range." && v1090);
                                } else {
                                }
                                int v1093;
                                v1093 = v1057[v168];
                                bool v1095;
                                v1095 = v1078 < v1093;
                                int v1096;
                                if (v1095){
                                    v1096 = v1078;
                                } else {
                                    v1096 = v1093;
                                }
                                static_array<int,2> v1097;
                                int v1099;
                                v1099 = 0;
                                while (while_method_0(v1099)){
                                    bool v1101;
                                    v1101 = 0 <= v1099;
                                    bool v1103;
                                    if (v1101){
                                        bool v1102;
                                        v1102 = v1099 < 2;
                                        v1103 = v1102;
                                    } else {
                                        v1103 = false;
                                    }
                                    bool v1104;
                                    v1104 = v1103 == false;
                                    if (v1104){
                                        assert("Index must be in range." && v1103);
                                    } else {
                                    }
                                    int v1106;
                                    v1106 = v164[v1099];
                                    bool v1108;
                                    v1108 = v168 == v1099;
                                    int v1109;
                                    if (v1108){
                                        v1109 = v1096;
                                    } else {
                                        v1109 = v1106;
                                    }
                                    v1097[v1099] = v1109;
                                    v1099 += 1 ;
                                }
                                int v1110;
                                v1110 = v1097[0];
                                int v1112; int v1113;
                                Tuple4 tmp131 = Tuple4{1, v1110};
                                v1112 = tmp131.v0; v1113 = tmp131.v1;
                                while (while_method_0(v1112)){
                                    bool v1115;
                                    v1115 = 0 <= v1112;
                                    bool v1117;
                                    if (v1115){
                                        bool v1116;
                                        v1116 = v1112 < 2;
                                        v1117 = v1116;
                                    } else {
                                        v1117 = false;
                                    }
                                    bool v1118;
                                    v1118 = v1117 == false;
                                    if (v1118){
                                        assert("Index must be in range." && v1117);
                                    } else {
                                    }
                                    int v1120;
                                    v1120 = v1097[v1112];
                                    int v1122;
                                    v1122 = v1113 + v1120;
                                    v1113 = v1122;
                                    v1112 += 1 ;
                                }
                                static_array<int,2> v1123;
                                int v1125;
                                v1125 = 0;
                                while (while_method_0(v1125)){
                                    bool v1127;
                                    v1127 = 0 <= v1125;
                                    bool v1129;
                                    if (v1127){
                                        bool v1128;
                                        v1128 = v1125 < 2;
                                        v1129 = v1128;
                                    } else {
                                        v1129 = false;
                                    }
                                    bool v1130;
                                    v1130 = v1129 == false;
                                    if (v1130){
                                        assert("Index must be in range." && v1129);
                                    } else {
                                    }
                                    int v1132;
                                    v1132 = v1057[v1125];
                                    bool v1135;
                                    if (v1127){
                                        bool v1134;
                                        v1134 = v1125 < 2;
                                        v1135 = v1134;
                                    } else {
                                        v1135 = false;
                                    }
                                    bool v1136;
                                    v1136 = v1135 == false;
                                    if (v1136){
                                        assert("Index must be in range." && v1135);
                                    } else {
                                    }
                                    int v1138;
                                    v1138 = v1097[v1125];
                                    int v1140;
                                    v1140 = v1132 - v1138;
                                    v1123[v1125] = v1140;
                                    v1125 += 1 ;
                                }
                                bool v1142;
                                if (v170){
                                    bool v1141;
                                    v1141 = v168 < 2;
                                    v1142 = v1141;
                                } else {
                                    v1142 = false;
                                }
                                bool v1143;
                                v1143 = v1142 == false;
                                if (v1143){
                                    assert("Index must be in range." && v1142);
                                } else {
                                }
                                int v1145;
                                v1145 = v164[v168];
                                bool v1147;
                                v1147 = v1145 < v1078;
                                float v1148;
                                if (v1147){
                                    v1148 = 1.0f;
                                } else {
                                    v1148 = 0.0f;
                                }
                                int v1149;
                                v1149 = v1113 / 3;
                                bool v1150;
                                v1150 = v162 <= v1149;
                                bool v1158;
                                if (v1150){
                                    bool v1152;
                                    if (v170){
                                        bool v1151;
                                        v1151 = v168 < 2;
                                        v1152 = v1151;
                                    } else {
                                        v1152 = false;
                                    }
                                    bool v1153;
                                    v1153 = v1152 == false;
                                    if (v1153){
                                        assert("Index must be in range." && v1152);
                                    } else {
                                    }
                                    int v1155;
                                    v1155 = v1123[v168];
                                    bool v1157;
                                    v1157 = v1149 < v1155;
                                    v1158 = v1157;
                                } else {
                                    v1158 = false;
                                }
                                float v1159;
                                if (v1158){
                                    v1159 = 1.0f;
                                } else {
                                    v1159 = 0.0f;
                                }
                                int v1160;
                                v1160 = v1113 / 2;
                                bool v1161;
                                v1161 = v162 <= v1160;
                                bool v1169;
                                if (v1161){
                                    bool v1163;
                                    if (v170){
                                        bool v1162;
                                        v1162 = v168 < 2;
                                        v1163 = v1162;
                                    } else {
                                        v1163 = false;
                                    }
                                    bool v1164;
                                    v1164 = v1163 == false;
                                    if (v1164){
                                        assert("Index must be in range." && v1163);
                                    } else {
                                    }
                                    int v1166;
                                    v1166 = v1123[v168];
                                    bool v1168;
                                    v1168 = v1160 < v1166;
                                    v1169 = v1168;
                                } else {
                                    v1169 = false;
                                }
                                float v1170;
                                if (v1169){
                                    v1170 = 1.0f;
                                } else {
                                    v1170 = 0.0f;
                                }
                                bool v1171;
                                v1171 = v162 <= v1113;
                                bool v1179;
                                if (v1171){
                                    bool v1173;
                                    if (v170){
                                        bool v1172;
                                        v1172 = v168 < 2;
                                        v1173 = v1172;
                                    } else {
                                        v1173 = false;
                                    }
                                    bool v1174;
                                    v1174 = v1173 == false;
                                    if (v1174){
                                        assert("Index must be in range." && v1173);
                                    } else {
                                    }
                                    int v1176;
                                    v1176 = v1123[v168];
                                    bool v1178;
                                    v1178 = v1113 < v1176;
                                    v1179 = v1178;
                                } else {
                                    v1179 = false;
                                }
                                float v1180;
                                if (v1179){
                                    v1180 = 1.0f;
                                } else {
                                    v1180 = 0.0f;
                                }
                                static_array<Tuple17,6> v1181;
                                Union1 v1183;
                                v1183 = Union1{Union1_2{}};
                                v1181[0] = Tuple17{v1183, v1148};
                                Union1 v1185;
                                v1185 = Union1{Union1_1{}};
                                v1181[1] = Tuple17{v1185, 4.0f};
                                Union1 v1187;
                                v1187 = Union1{Union1_3{v1149}};
                                v1181[2] = Tuple17{v1187, v1159};
                                Union1 v1189;
                                v1189 = Union1{Union1_3{v1160}};
                                v1181[3] = Tuple17{v1189, v1170};
                                Union1 v1191;
                                v1191 = Union1{Union1_3{v1113}};
                                v1181[4] = Tuple17{v1191, v1180};
                                Union1 v1193;
                                v1193 = Union1{Union1_0{}};
                                v1181[5] = Tuple17{v1193, 1.0f};
                                Union1 v1195;
                                v1195 = sample_discrete_50(v1181, v1056);
                                int v1196;
                                v1196 = sizeof(Union1);
                                unsigned long long v1197;
                                v1197 = (unsigned long long)v1196;
                                bool v1198;
                                v1198 = v1197 <= 98304ull;
                                bool v1199;
                                v1199 = v1198 == false;
                                if (v1199){
                                    assert("The dynamic shared memory is insufficient to allocate the tensor." && v1198);
                                } else {
                                }
                                extern __shared__ unsigned char v1201[];
                                bool v1202;
                                v1202 = v1197 <= v1197;
                                bool v1203;
                                v1203 = v1202 == false;
                                if (v1203){
                                    assert("The length of the partition has to be less than or equal to the length of the base array." && v1202);
                                } else {
                                }
                                Union1 * v1205;
                                v1205 = reinterpret_cast<Union1 *>(&v1201[0ull]);
                                int v1207;
                                v1207 = threadIdx.x;
                                bool v1208;
                                v1208 = v1207 == 0;
                                if (v1208){
                                    v1205[0] = v1195;
                                } else {
                                }
                                __syncthreads();
                                Union1 v1209;
                                v1209 = v1205[0];
                                __syncthreads();
                                v1214 = v1209;
                                break;
                            }
                            default: {
                                assert("Invalid tag." && false); __trap();
                            }
                        }
                        Union6 v1215;
                        v1215 = Union6{Union6_2{v168, v1214}};
                        v14.push(v1215);
                        v1366 = Union18{Union18_1{v162, v163, v164, v165, v166, v167, v1214}};
                        break;
                    }
                    case 5: { // G_Round'
                        int v1217 = v19.case5.v0; static_array<static_array<unsigned char,2>,2> v1218 = v19.case5.v1; static_array<int,2> v1219 = v19.case5.v2; int v1220 = v19.case5.v3; static_array<int,2> v1221 = v19.case5.v4; Union5 v1222 = v19.case5.v5; Union1 v1223 = v19.case5.v6;
                        int v1224;
                        v1224 = v1220 % 2;
                        Union6 v1225;
                        v1225 = Union6{Union6_2{v1224, v1223}};
                        v14.push(v1225);
                        v1366 = Union18{Union18_1{v1217, v1218, v1219, v1220, v1221, v1222, v1223}};
                        break;
                    }
                    case 6: { // G_Showdown
                        int v43 = v19.case6.v0; static_array<static_array<unsigned char,2>,2> v44 = v19.case6.v1; static_array<int,2> v45 = v19.case6.v2; int v46 = v19.case6.v3; static_array<int,2> v47 = v19.case6.v4; Union5 v48 = v19.case6.v5;
                        static_array<unsigned char,5> v51;
                        switch (v48.tag) {
                            case 2: { // River
                                static_array<unsigned char,5> v49 = v48.case2.v0;
                                v51 = v49;
                                break;
                            }
                            default: {
                                printf("%s\n", "Invalid street in showdown.");
                                __trap();
                            }
                        }
                        static_array<unsigned char,2> v52;
                        v52 = v44[0];
                        static_array<unsigned char,7> v54;
                        int v56;
                        v56 = 0;
                        while (while_method_0(v56)){
                            bool v58;
                            v58 = 0 <= v56;
                            bool v60;
                            if (v58){
                                bool v59;
                                v59 = v56 < 2;
                                v60 = v59;
                            } else {
                                v60 = false;
                            }
                            bool v61;
                            v61 = v60 == false;
                            if (v61){
                                assert("Index must be in range." && v60);
                            } else {
                            }
                            unsigned char v63;
                            v63 = v52[v56];
                            v54[v56] = v63;
                            v56 += 1 ;
                        }
                        int v65;
                        v65 = 0;
                        while (while_method_2(v65)){
                            bool v67;
                            v67 = 0 <= v65;
                            bool v69;
                            if (v67){
                                bool v68;
                                v68 = v65 < 5;
                                v69 = v68;
                            } else {
                                v69 = false;
                            }
                            bool v70;
                            v70 = v69 == false;
                            if (v70){
                                assert("Index must be in range." && v69);
                            } else {
                            }
                            unsigned char v72;
                            v72 = v51[v65];
                            int v74;
                            v74 = 2 + v65;
                            v54[v74] = v72;
                            v65 += 1 ;
                        }
                        static_array<unsigned char,5> v75; char v76;
                        Tuple0 tmp132 = score_54(v54);
                        v75 = tmp132.v0; v76 = tmp132.v1;
                        static_array<unsigned char,2> v77;
                        v77 = v44[1];
                        static_array<unsigned char,7> v79;
                        int v81;
                        v81 = 0;
                        while (while_method_0(v81)){
                            bool v83;
                            v83 = 0 <= v81;
                            bool v85;
                            if (v83){
                                bool v84;
                                v84 = v81 < 2;
                                v85 = v84;
                            } else {
                                v85 = false;
                            }
                            bool v86;
                            v86 = v85 == false;
                            if (v86){
                                assert("Index must be in range." && v85);
                            } else {
                            }
                            unsigned char v88;
                            v88 = v77[v81];
                            v79[v81] = v88;
                            v81 += 1 ;
                        }
                        int v90;
                        v90 = 0;
                        while (while_method_2(v90)){
                            bool v92;
                            v92 = 0 <= v90;
                            bool v94;
                            if (v92){
                                bool v93;
                                v93 = v90 < 5;
                                v94 = v93;
                            } else {
                                v94 = false;
                            }
                            bool v95;
                            v95 = v94 == false;
                            if (v95){
                                assert("Index must be in range." && v94);
                            } else {
                            }
                            unsigned char v97;
                            v97 = v51[v90];
                            int v99;
                            v99 = 2 + v90;
                            v79[v99] = v97;
                            v90 += 1 ;
                        }
                        static_array<unsigned char,5> v100; char v101;
                        Tuple0 tmp133 = score_54(v79);
                        v100 = tmp133.v0; v101 = tmp133.v1;
                        int v102;
                        v102 = v46 % 2;
                        bool v103;
                        v103 = 0 <= v102;
                        bool v105;
                        if (v103){
                            bool v104;
                            v104 = v102 < 2;
                            v105 = v104;
                        } else {
                            v105 = false;
                        }
                        bool v106;
                        v106 = v105 == false;
                        if (v106){
                            assert("Index must be in range." && v105);
                        } else {
                        }
                        int v108;
                        v108 = v45[v102];
                        bool v110;
                        v110 = v76 < v101;
                        Union11 v116;
                        if (v110){
                            v116 = Union11{Union11_2{}};
                        } else {
                            bool v112;
                            v112 = v76 > v101;
                            if (v112){
                                v116 = Union11{Union11_1{}};
                            } else {
                                v116 = Union11{Union11_0{}};
                            }
                        }
                        Union11 v144;
                        switch (v116.tag) {
                            case 0: { // Eq
                                Union11 v117;
                                v117 = Union11{Union11_0{}};
                                int v118;
                                v118 = 0;
                                while (while_method_2(v118)){
                                    bool v120;
                                    v120 = 0 <= v118;
                                    bool v122;
                                    if (v120){
                                        bool v121;
                                        v121 = v118 < 5;
                                        v122 = v121;
                                    } else {
                                        v122 = false;
                                    }
                                    bool v123;
                                    v123 = v122 == false;
                                    if (v123){
                                        assert("Index must be in range." && v122);
                                    } else {
                                    }
                                    unsigned char v125;
                                    v125 = v75[v118];
                                    bool v128;
                                    if (v120){
                                        bool v127;
                                        v127 = v118 < 5;
                                        v128 = v127;
                                    } else {
                                        v128 = false;
                                    }
                                    bool v129;
                                    v129 = v128 == false;
                                    if (v129){
                                        assert("Index must be in range." && v128);
                                    } else {
                                    }
                                    unsigned char v131;
                                    v131 = v100[v118];
                                    unsigned char v133;
                                    v133 = v125 / 4u;
                                    unsigned char v134;
                                    v134 = v131 / 4u;
                                    bool v135;
                                    v135 = v133 < v134;
                                    Union11 v141;
                                    if (v135){
                                        v141 = Union11{Union11_2{}};
                                    } else {
                                        bool v137;
                                        v137 = v133 > v134;
                                        if (v137){
                                            v141 = Union11{Union11_1{}};
                                        } else {
                                            v141 = Union11{Union11_0{}};
                                        }
                                    }
                                    bool v142;
                                    switch (v141.tag) {
                                        case 0: { // Eq
                                            v142 = true;
                                            break;
                                        }
                                        default: {
                                            v142 = false;
                                        }
                                    }
                                    bool v143;
                                    v143 = v142 == false;
                                    if (v143){
                                        v117 = v141;
                                        break;
                                    } else {
                                    }
                                    v118 += 1 ;
                                }
                                v144 = v117;
                                break;
                            }
                            default: {
                                v144 = v116;
                            }
                        }
                        int v149; int v150;
                        switch (v144.tag) {
                            case 0: { // Eq
                                v149 = 0; v150 = -1;
                                break;
                            }
                            case 1: { // Gt
                                v149 = v108; v150 = 0;
                                break;
                            }
                            case 2: { // Lt
                                v149 = v108; v150 = 1;
                                break;
                            }
                            default: {
                                assert("Invalid tag." && false); __trap();
                            }
                        }
                        int v151;
                        v151 = -v150;
                        bool v152;
                        v152 = v150 >= v151;
                        int v153;
                        if (v152){
                            v153 = v150;
                        } else {
                            v153 = v151;
                        }
                        float v154;
                        v154 = (float)v149;
                        static_array<float,2> & v155 = v3.v4;
                        v155[v153] = v154;
                        int v156;
                        v156 = v153 ^ 1;
                        float v157;
                        v157 = -v154;
                        v155[v156] = v157;
                        static_array<Tuple0,2> v158;
                        v158[0] = Tuple0{v75, v76};
                        v158[1] = Tuple0{v100, v101};
                        Union6 v160;
                        v160 = Union6{Union6_4{v149, v158, v150}};
                        v14.push(v160);
                        v1366 = Union18{Union18_0{}};
                        break;
                    }
                    case 7: { // G_Turn
                        int v1246 = v19.case7.v0; static_array<static_array<unsigned char,2>,2> v1247 = v19.case7.v1; static_array<int,2> v1248 = v19.case7.v2; int v1249 = v19.case7.v3; static_array<int,2> v1250 = v19.case7.v4; Union5 v1251 = v19.case7.v5;
                        curandStatePhilox4_32_10_t & v1252 = v3.v5;
                        curandStatePhilox4_32_10_t & v1253 = v1252;
                        static_array<unsigned char,1> v1254; unsigned long long v1255;
                        Tuple12 tmp134 = draw_cards_40(v1253, v15);
                        v1254 = tmp134.v0; v1255 = tmp134.v1;
                        v3.v0 = v1255;
                        static_array_list<unsigned char,5> v1256;
                        v1256 = get_community_cards_85(v1251, v1254);
                        Union6 v1257;
                        v1257 = Union6{Union6_0{v1256}};
                        v14.push(v1257);
                        Union5 v1282;
                        switch (v1251.tag) {
                            case 0: { // Flop
                                static_array<unsigned char,3> v1258 = v1251.case0.v0;
                                static_array<unsigned char,4> v1259;
                                int v1261;
                                v1261 = 0;
                                while (while_method_1(v1261)){
                                    bool v1263;
                                    v1263 = 0 <= v1261;
                                    bool v1265;
                                    if (v1263){
                                        bool v1264;
                                        v1264 = v1261 < 3;
                                        v1265 = v1264;
                                    } else {
                                        v1265 = false;
                                    }
                                    bool v1266;
                                    v1266 = v1265 == false;
                                    if (v1266){
                                        assert("Index must be in range." && v1265);
                                    } else {
                                    }
                                    unsigned char v1268;
                                    v1268 = v1258[v1261];
                                    v1259[v1261] = v1268;
                                    v1261 += 1 ;
                                }
                                int v1270;
                                v1270 = 0;
                                while (while_method_6(v1270)){
                                    bool v1272;
                                    v1272 = 0 <= v1270;
                                    bool v1274;
                                    if (v1272){
                                        bool v1273;
                                        v1273 = v1270 < 1;
                                        v1274 = v1273;
                                    } else {
                                        v1274 = false;
                                    }
                                    bool v1275;
                                    v1275 = v1274 == false;
                                    if (v1275){
                                        assert("Index must be in range." && v1274);
                                    } else {
                                    }
                                    unsigned char v1277;
                                    v1277 = v1254[v1270];
                                    int v1279;
                                    v1279 = 3 + v1270;
                                    v1259[v1279] = v1277;
                                    v1270 += 1 ;
                                }
                                v1282 = Union5{Union5_3{v1259}};
                                break;
                            }
                            default: {
                                printf("%s\n", "Invalid street in turn.");
                                __trap();
                            }
                        }
                        int v1283;
                        v1283 = 2;
                        int v1284;
                        v1284 = 0;
                        Union4 v1285;
                        v1285 = try_round_36(v1283, v1247, v1248, v1284, v1250, v1282);
                        v1366 = Union18{Union18_2{v1285}};
                        break;
                    }
                    default: {
                        assert("Invalid tag." && false); __trap();
                    }
                }
                switch (v1366.tag) {
                    case 0: { // T_none
                        v1715 = Union3{Union3_0{}};
                        break;
                    }
                    case 1: { // T_round
                        int v1370 = v1366.case1.v0; static_array<static_array<unsigned char,2>,2> v1371 = v1366.case1.v1; static_array<int,2> v1372 = v1366.case1.v2; int v1373 = v1366.case1.v3; static_array<int,2> v1374 = v1366.case1.v4; Union5 v1375 = v1366.case1.v5; Union1 v1376 = v1366.case1.v6;
                        int v1377;
                        v1377 = v1373 % 2;
                        Union4 v1708;
                        switch (v1376.tag) {
                            case 0: { // A_All_In
                                static_array<int,2> v1583;
                                int v1585;
                                v1585 = 0;
                                while (while_method_0(v1585)){
                                    bool v1587;
                                    v1587 = 0 <= v1585;
                                    bool v1589;
                                    if (v1587){
                                        bool v1588;
                                        v1588 = v1585 < 2;
                                        v1589 = v1588;
                                    } else {
                                        v1589 = false;
                                    }
                                    bool v1590;
                                    v1590 = v1589 == false;
                                    if (v1590){
                                        assert("Index must be in range." && v1589);
                                    } else {
                                    }
                                    int v1592;
                                    v1592 = v1374[v1585];
                                    bool v1595;
                                    if (v1587){
                                        bool v1594;
                                        v1594 = v1585 < 2;
                                        v1595 = v1594;
                                    } else {
                                        v1595 = false;
                                    }
                                    bool v1596;
                                    v1596 = v1595 == false;
                                    if (v1596){
                                        assert("Index must be in range." && v1595);
                                    } else {
                                    }
                                    int v1598;
                                    v1598 = v1372[v1585];
                                    int v1600;
                                    v1600 = v1592 + v1598;
                                    v1583[v1585] = v1600;
                                    v1585 += 1 ;
                                }
                                int v1601;
                                v1601 = v1372[0];
                                int v1603; int v1604;
                                Tuple4 tmp135 = Tuple4{1, v1601};
                                v1603 = tmp135.v0; v1604 = tmp135.v1;
                                while (while_method_0(v1603)){
                                    bool v1606;
                                    v1606 = 0 <= v1603;
                                    bool v1608;
                                    if (v1606){
                                        bool v1607;
                                        v1607 = v1603 < 2;
                                        v1608 = v1607;
                                    } else {
                                        v1608 = false;
                                    }
                                    bool v1609;
                                    v1609 = v1608 == false;
                                    if (v1609){
                                        assert("Index must be in range." && v1608);
                                    } else {
                                    }
                                    int v1611;
                                    v1611 = v1372[v1603];
                                    bool v1613;
                                    v1613 = v1604 >= v1611;
                                    int v1614;
                                    if (v1613){
                                        v1614 = v1604;
                                    } else {
                                        v1614 = v1611;
                                    }
                                    v1604 = v1614;
                                    v1603 += 1 ;
                                }
                                bool v1615;
                                v1615 = 0 <= v1377;
                                bool v1617;
                                if (v1615){
                                    bool v1616;
                                    v1616 = v1377 < 2;
                                    v1617 = v1616;
                                } else {
                                    v1617 = false;
                                }
                                bool v1618;
                                v1618 = v1617 == false;
                                if (v1618){
                                    assert("Index must be in range." && v1617);
                                } else {
                                }
                                int v1620;
                                v1620 = v1583[v1377];
                                bool v1622;
                                v1622 = v1604 < v1620;
                                int v1623;
                                if (v1622){
                                    v1623 = v1604;
                                } else {
                                    v1623 = v1620;
                                }
                                static_array<int,2> v1624;
                                int v1626;
                                v1626 = 0;
                                while (while_method_0(v1626)){
                                    bool v1628;
                                    v1628 = 0 <= v1626;
                                    bool v1630;
                                    if (v1628){
                                        bool v1629;
                                        v1629 = v1626 < 2;
                                        v1630 = v1629;
                                    } else {
                                        v1630 = false;
                                    }
                                    bool v1631;
                                    v1631 = v1630 == false;
                                    if (v1631){
                                        assert("Index must be in range." && v1630);
                                    } else {
                                    }
                                    int v1633;
                                    v1633 = v1372[v1626];
                                    bool v1635;
                                    v1635 = v1377 == v1626;
                                    int v1636;
                                    if (v1635){
                                        v1636 = v1623;
                                    } else {
                                        v1636 = v1633;
                                    }
                                    v1624[v1626] = v1636;
                                    v1626 += 1 ;
                                }
                                static_array<int,2> v1637;
                                int v1639;
                                v1639 = 0;
                                while (while_method_0(v1639)){
                                    bool v1641;
                                    v1641 = 0 <= v1639;
                                    bool v1643;
                                    if (v1641){
                                        bool v1642;
                                        v1642 = v1639 < 2;
                                        v1643 = v1642;
                                    } else {
                                        v1643 = false;
                                    }
                                    bool v1644;
                                    v1644 = v1643 == false;
                                    if (v1644){
                                        assert("Index must be in range." && v1643);
                                    } else {
                                    }
                                    int v1646;
                                    v1646 = v1583[v1639];
                                    bool v1649;
                                    if (v1641){
                                        bool v1648;
                                        v1648 = v1639 < 2;
                                        v1649 = v1648;
                                    } else {
                                        v1649 = false;
                                    }
                                    bool v1650;
                                    v1650 = v1649 == false;
                                    if (v1650){
                                        assert("Index must be in range." && v1649);
                                    } else {
                                    }
                                    int v1652;
                                    v1652 = v1624[v1639];
                                    int v1654;
                                    v1654 = v1646 - v1652;
                                    v1637[v1639] = v1654;
                                    v1639 += 1 ;
                                }
                                bool v1656;
                                if (v1615){
                                    bool v1655;
                                    v1655 = v1377 < 2;
                                    v1656 = v1655;
                                } else {
                                    v1656 = false;
                                }
                                bool v1657;
                                v1657 = v1656 == false;
                                if (v1657){
                                    assert("Index must be in range." && v1656);
                                } else {
                                }
                                int v1659;
                                v1659 = v1637[v1377];
                                int v1661;
                                v1661 = v1604 + v1659;
                                bool v1663;
                                if (v1615){
                                    bool v1662;
                                    v1662 = v1377 < 2;
                                    v1663 = v1662;
                                } else {
                                    v1663 = false;
                                }
                                bool v1664;
                                v1664 = v1663 == false;
                                if (v1664){
                                    assert("Index must be in range." && v1663);
                                } else {
                                }
                                int v1666;
                                v1666 = v1583[v1377];
                                bool v1668;
                                v1668 = v1661 < v1666;
                                int v1669;
                                if (v1668){
                                    v1669 = v1661;
                                } else {
                                    v1669 = v1666;
                                }
                                static_array<int,2> v1670;
                                int v1672;
                                v1672 = 0;
                                while (while_method_0(v1672)){
                                    bool v1674;
                                    v1674 = 0 <= v1672;
                                    bool v1676;
                                    if (v1674){
                                        bool v1675;
                                        v1675 = v1672 < 2;
                                        v1676 = v1675;
                                    } else {
                                        v1676 = false;
                                    }
                                    bool v1677;
                                    v1677 = v1676 == false;
                                    if (v1677){
                                        assert("Index must be in range." && v1676);
                                    } else {
                                    }
                                    int v1679;
                                    v1679 = v1372[v1672];
                                    bool v1681;
                                    v1681 = v1377 == v1672;
                                    int v1682;
                                    if (v1681){
                                        v1682 = v1669;
                                    } else {
                                        v1682 = v1679;
                                    }
                                    v1670[v1672] = v1682;
                                    v1672 += 1 ;
                                }
                                static_array<int,2> v1683;
                                int v1685;
                                v1685 = 0;
                                while (while_method_0(v1685)){
                                    bool v1687;
                                    v1687 = 0 <= v1685;
                                    bool v1689;
                                    if (v1687){
                                        bool v1688;
                                        v1688 = v1685 < 2;
                                        v1689 = v1688;
                                    } else {
                                        v1689 = false;
                                    }
                                    bool v1690;
                                    v1690 = v1689 == false;
                                    if (v1690){
                                        assert("Index must be in range." && v1689);
                                    } else {
                                    }
                                    int v1692;
                                    v1692 = v1583[v1685];
                                    bool v1695;
                                    if (v1687){
                                        bool v1694;
                                        v1694 = v1685 < 2;
                                        v1695 = v1694;
                                    } else {
                                        v1695 = false;
                                    }
                                    bool v1696;
                                    v1696 = v1695 == false;
                                    if (v1696){
                                        assert("Index must be in range." && v1695);
                                    } else {
                                    }
                                    int v1698;
                                    v1698 = v1670[v1685];
                                    int v1700;
                                    v1700 = v1692 - v1698;
                                    v1683[v1685] = v1700;
                                    v1685 += 1 ;
                                }
                                bool v1701;
                                v1701 = v1659 >= v1370;
                                int v1702;
                                if (v1701){
                                    v1702 = v1659;
                                } else {
                                    v1702 = v1370;
                                }
                                int v1703;
                                v1703 = v1373 + 1;
                                v1708 = try_round_36(v1702, v1371, v1670, v1703, v1683, v1375);
                                break;
                            }
                            case 1: { // A_Call
                                static_array<int,2> v1379;
                                int v1381;
                                v1381 = 0;
                                while (while_method_0(v1381)){
                                    bool v1383;
                                    v1383 = 0 <= v1381;
                                    bool v1385;
                                    if (v1383){
                                        bool v1384;
                                        v1384 = v1381 < 2;
                                        v1385 = v1384;
                                    } else {
                                        v1385 = false;
                                    }
                                    bool v1386;
                                    v1386 = v1385 == false;
                                    if (v1386){
                                        assert("Index must be in range." && v1385);
                                    } else {
                                    }
                                    int v1388;
                                    v1388 = v1374[v1381];
                                    bool v1391;
                                    if (v1383){
                                        bool v1390;
                                        v1390 = v1381 < 2;
                                        v1391 = v1390;
                                    } else {
                                        v1391 = false;
                                    }
                                    bool v1392;
                                    v1392 = v1391 == false;
                                    if (v1392){
                                        assert("Index must be in range." && v1391);
                                    } else {
                                    }
                                    int v1394;
                                    v1394 = v1372[v1381];
                                    int v1396;
                                    v1396 = v1388 + v1394;
                                    v1379[v1381] = v1396;
                                    v1381 += 1 ;
                                }
                                int v1397;
                                v1397 = v1372[0];
                                int v1399; int v1400;
                                Tuple4 tmp136 = Tuple4{1, v1397};
                                v1399 = tmp136.v0; v1400 = tmp136.v1;
                                while (while_method_0(v1399)){
                                    bool v1402;
                                    v1402 = 0 <= v1399;
                                    bool v1404;
                                    if (v1402){
                                        bool v1403;
                                        v1403 = v1399 < 2;
                                        v1404 = v1403;
                                    } else {
                                        v1404 = false;
                                    }
                                    bool v1405;
                                    v1405 = v1404 == false;
                                    if (v1405){
                                        assert("Index must be in range." && v1404);
                                    } else {
                                    }
                                    int v1407;
                                    v1407 = v1372[v1399];
                                    bool v1409;
                                    v1409 = v1400 >= v1407;
                                    int v1410;
                                    if (v1409){
                                        v1410 = v1400;
                                    } else {
                                        v1410 = v1407;
                                    }
                                    v1400 = v1410;
                                    v1399 += 1 ;
                                }
                                bool v1411;
                                v1411 = 0 <= v1377;
                                bool v1413;
                                if (v1411){
                                    bool v1412;
                                    v1412 = v1377 < 2;
                                    v1413 = v1412;
                                } else {
                                    v1413 = false;
                                }
                                bool v1414;
                                v1414 = v1413 == false;
                                if (v1414){
                                    assert("Index must be in range." && v1413);
                                } else {
                                }
                                int v1416;
                                v1416 = v1379[v1377];
                                bool v1418;
                                v1418 = v1400 < v1416;
                                int v1419;
                                if (v1418){
                                    v1419 = v1400;
                                } else {
                                    v1419 = v1416;
                                }
                                static_array<int,2> v1420;
                                int v1422;
                                v1422 = 0;
                                while (while_method_0(v1422)){
                                    bool v1424;
                                    v1424 = 0 <= v1422;
                                    bool v1426;
                                    if (v1424){
                                        bool v1425;
                                        v1425 = v1422 < 2;
                                        v1426 = v1425;
                                    } else {
                                        v1426 = false;
                                    }
                                    bool v1427;
                                    v1427 = v1426 == false;
                                    if (v1427){
                                        assert("Index must be in range." && v1426);
                                    } else {
                                    }
                                    int v1429;
                                    v1429 = v1372[v1422];
                                    bool v1431;
                                    v1431 = v1377 == v1422;
                                    int v1432;
                                    if (v1431){
                                        v1432 = v1419;
                                    } else {
                                        v1432 = v1429;
                                    }
                                    v1420[v1422] = v1432;
                                    v1422 += 1 ;
                                }
                                static_array<int,2> v1433;
                                int v1435;
                                v1435 = 0;
                                while (while_method_0(v1435)){
                                    bool v1437;
                                    v1437 = 0 <= v1435;
                                    bool v1439;
                                    if (v1437){
                                        bool v1438;
                                        v1438 = v1435 < 2;
                                        v1439 = v1438;
                                    } else {
                                        v1439 = false;
                                    }
                                    bool v1440;
                                    v1440 = v1439 == false;
                                    if (v1440){
                                        assert("Index must be in range." && v1439);
                                    } else {
                                    }
                                    int v1442;
                                    v1442 = v1379[v1435];
                                    bool v1445;
                                    if (v1437){
                                        bool v1444;
                                        v1444 = v1435 < 2;
                                        v1445 = v1444;
                                    } else {
                                        v1445 = false;
                                    }
                                    bool v1446;
                                    v1446 = v1445 == false;
                                    if (v1446){
                                        assert("Index must be in range." && v1445);
                                    } else {
                                    }
                                    int v1448;
                                    v1448 = v1420[v1435];
                                    int v1450;
                                    v1450 = v1442 - v1448;
                                    v1433[v1435] = v1450;
                                    v1435 += 1 ;
                                }
                                bool v1451;
                                v1451 = v1377 < 2;
                                if (v1451){
                                    int v1452;
                                    v1452 = v1373 + 1;
                                    v1708 = try_round_36(v1370, v1371, v1420, v1452, v1433, v1375);
                                } else {
                                    v1708 = go_next_street_38(v1370, v1371, v1420, v1373, v1433, v1375);
                                }
                                break;
                            }
                            case 2: { // A_Fold
                                v1708 = Union4{Union4_1{v1370, v1371, v1372, v1373, v1374, v1375}};
                                break;
                            }
                            case 3: { // A_Raise
                                int v1456 = v1376.case3.v0;
                                bool v1457;
                                v1457 = v1370 <= v1456;
                                bool v1458;
                                v1458 = v1457 == false;
                                if (v1458){
                                    assert("The raise amount must match the minimum." && v1457);
                                } else {
                                }
                                static_array<int,2> v1460;
                                int v1462;
                                v1462 = 0;
                                while (while_method_0(v1462)){
                                    bool v1464;
                                    v1464 = 0 <= v1462;
                                    bool v1466;
                                    if (v1464){
                                        bool v1465;
                                        v1465 = v1462 < 2;
                                        v1466 = v1465;
                                    } else {
                                        v1466 = false;
                                    }
                                    bool v1467;
                                    v1467 = v1466 == false;
                                    if (v1467){
                                        assert("Index must be in range." && v1466);
                                    } else {
                                    }
                                    int v1469;
                                    v1469 = v1374[v1462];
                                    bool v1472;
                                    if (v1464){
                                        bool v1471;
                                        v1471 = v1462 < 2;
                                        v1472 = v1471;
                                    } else {
                                        v1472 = false;
                                    }
                                    bool v1473;
                                    v1473 = v1472 == false;
                                    if (v1473){
                                        assert("Index must be in range." && v1472);
                                    } else {
                                    }
                                    int v1475;
                                    v1475 = v1372[v1462];
                                    int v1477;
                                    v1477 = v1469 + v1475;
                                    v1460[v1462] = v1477;
                                    v1462 += 1 ;
                                }
                                int v1478;
                                v1478 = v1372[0];
                                int v1480; int v1481;
                                Tuple4 tmp137 = Tuple4{1, v1478};
                                v1480 = tmp137.v0; v1481 = tmp137.v1;
                                while (while_method_0(v1480)){
                                    bool v1483;
                                    v1483 = 0 <= v1480;
                                    bool v1485;
                                    if (v1483){
                                        bool v1484;
                                        v1484 = v1480 < 2;
                                        v1485 = v1484;
                                    } else {
                                        v1485 = false;
                                    }
                                    bool v1486;
                                    v1486 = v1485 == false;
                                    if (v1486){
                                        assert("Index must be in range." && v1485);
                                    } else {
                                    }
                                    int v1488;
                                    v1488 = v1372[v1480];
                                    bool v1490;
                                    v1490 = v1481 >= v1488;
                                    int v1491;
                                    if (v1490){
                                        v1491 = v1481;
                                    } else {
                                        v1491 = v1488;
                                    }
                                    v1481 = v1491;
                                    v1480 += 1 ;
                                }
                                bool v1492;
                                v1492 = 0 <= v1377;
                                bool v1494;
                                if (v1492){
                                    bool v1493;
                                    v1493 = v1377 < 2;
                                    v1494 = v1493;
                                } else {
                                    v1494 = false;
                                }
                                bool v1495;
                                v1495 = v1494 == false;
                                if (v1495){
                                    assert("Index must be in range." && v1494);
                                } else {
                                }
                                int v1497;
                                v1497 = v1460[v1377];
                                bool v1499;
                                v1499 = v1481 < v1497;
                                int v1500;
                                if (v1499){
                                    v1500 = v1481;
                                } else {
                                    v1500 = v1497;
                                }
                                static_array<int,2> v1501;
                                int v1503;
                                v1503 = 0;
                                while (while_method_0(v1503)){
                                    bool v1505;
                                    v1505 = 0 <= v1503;
                                    bool v1507;
                                    if (v1505){
                                        bool v1506;
                                        v1506 = v1503 < 2;
                                        v1507 = v1506;
                                    } else {
                                        v1507 = false;
                                    }
                                    bool v1508;
                                    v1508 = v1507 == false;
                                    if (v1508){
                                        assert("Index must be in range." && v1507);
                                    } else {
                                    }
                                    int v1510;
                                    v1510 = v1372[v1503];
                                    bool v1512;
                                    v1512 = v1377 == v1503;
                                    int v1513;
                                    if (v1512){
                                        v1513 = v1500;
                                    } else {
                                        v1513 = v1510;
                                    }
                                    v1501[v1503] = v1513;
                                    v1503 += 1 ;
                                }
                                static_array<int,2> v1514;
                                int v1516;
                                v1516 = 0;
                                while (while_method_0(v1516)){
                                    bool v1518;
                                    v1518 = 0 <= v1516;
                                    bool v1520;
                                    if (v1518){
                                        bool v1519;
                                        v1519 = v1516 < 2;
                                        v1520 = v1519;
                                    } else {
                                        v1520 = false;
                                    }
                                    bool v1521;
                                    v1521 = v1520 == false;
                                    if (v1521){
                                        assert("Index must be in range." && v1520);
                                    } else {
                                    }
                                    int v1523;
                                    v1523 = v1460[v1516];
                                    bool v1526;
                                    if (v1518){
                                        bool v1525;
                                        v1525 = v1516 < 2;
                                        v1526 = v1525;
                                    } else {
                                        v1526 = false;
                                    }
                                    bool v1527;
                                    v1527 = v1526 == false;
                                    if (v1527){
                                        assert("Index must be in range." && v1526);
                                    } else {
                                    }
                                    int v1529;
                                    v1529 = v1501[v1516];
                                    int v1531;
                                    v1531 = v1523 - v1529;
                                    v1514[v1516] = v1531;
                                    v1516 += 1 ;
                                }
                                bool v1533;
                                if (v1492){
                                    bool v1532;
                                    v1532 = v1377 < 2;
                                    v1533 = v1532;
                                } else {
                                    v1533 = false;
                                }
                                bool v1534;
                                v1534 = v1533 == false;
                                if (v1534){
                                    assert("Index must be in range." && v1533);
                                } else {
                                }
                                int v1536;
                                v1536 = v1514[v1377];
                                bool v1538;
                                v1538 = v1456 < v1536;
                                bool v1539;
                                v1539 = v1538 == false;
                                if (v1539){
                                    assert("The raise amount must be less than the stack size after calling." && v1538);
                                } else {
                                }
                                int v1541;
                                v1541 = v1481 + v1456;
                                bool v1543;
                                if (v1492){
                                    bool v1542;
                                    v1542 = v1377 < 2;
                                    v1543 = v1542;
                                } else {
                                    v1543 = false;
                                }
                                bool v1544;
                                v1544 = v1543 == false;
                                if (v1544){
                                    assert("Index must be in range." && v1543);
                                } else {
                                }
                                int v1546;
                                v1546 = v1460[v1377];
                                bool v1548;
                                v1548 = v1541 < v1546;
                                int v1549;
                                if (v1548){
                                    v1549 = v1541;
                                } else {
                                    v1549 = v1546;
                                }
                                static_array<int,2> v1550;
                                int v1552;
                                v1552 = 0;
                                while (while_method_0(v1552)){
                                    bool v1554;
                                    v1554 = 0 <= v1552;
                                    bool v1556;
                                    if (v1554){
                                        bool v1555;
                                        v1555 = v1552 < 2;
                                        v1556 = v1555;
                                    } else {
                                        v1556 = false;
                                    }
                                    bool v1557;
                                    v1557 = v1556 == false;
                                    if (v1557){
                                        assert("Index must be in range." && v1556);
                                    } else {
                                    }
                                    int v1559;
                                    v1559 = v1372[v1552];
                                    bool v1561;
                                    v1561 = v1377 == v1552;
                                    int v1562;
                                    if (v1561){
                                        v1562 = v1549;
                                    } else {
                                        v1562 = v1559;
                                    }
                                    v1550[v1552] = v1562;
                                    v1552 += 1 ;
                                }
                                static_array<int,2> v1563;
                                int v1565;
                                v1565 = 0;
                                while (while_method_0(v1565)){
                                    bool v1567;
                                    v1567 = 0 <= v1565;
                                    bool v1569;
                                    if (v1567){
                                        bool v1568;
                                        v1568 = v1565 < 2;
                                        v1569 = v1568;
                                    } else {
                                        v1569 = false;
                                    }
                                    bool v1570;
                                    v1570 = v1569 == false;
                                    if (v1570){
                                        assert("Index must be in range." && v1569);
                                    } else {
                                    }
                                    int v1572;
                                    v1572 = v1460[v1565];
                                    bool v1575;
                                    if (v1567){
                                        bool v1574;
                                        v1574 = v1565 < 2;
                                        v1575 = v1574;
                                    } else {
                                        v1575 = false;
                                    }
                                    bool v1576;
                                    v1576 = v1575 == false;
                                    if (v1576){
                                        assert("Index must be in range." && v1575);
                                    } else {
                                    }
                                    int v1578;
                                    v1578 = v1550[v1565];
                                    int v1580;
                                    v1580 = v1572 - v1578;
                                    v1563[v1565] = v1580;
                                    v1565 += 1 ;
                                }
                                int v1581;
                                v1581 = v1373 + 1;
                                v1708 = try_round_36(v1456, v1371, v1550, v1581, v1563, v1375);
                                break;
                            }
                            default: {
                                assert("Invalid tag." && false); __trap();
                            }
                        }
                        v1715 = Union3{Union3_1{v1708}};
                        break;
                    }
                    case 2: { // T_some
                        Union4 v1368 = v1366.case2.v0;
                        v1715 = Union3{Union3_1{v1368}};
                        break;
                    }
                    default: {
                        assert("Invalid tag." && false); __trap();
                    }
                }
                break;
            }
            default: {
                assert("Invalid tag." && false); __trap();
            }
        }
        v17 = v1715;
    }
    return ;
}
__device__ void method_87(unsigned char * v0, unsigned char * v1, unsigned char * v2, StackMut1 & v3, Union4 v4){
    v3.v0 = 4503599627370495ull;
    static_array<float,2> v5;
    v5[0] = 0.0f;
    v5[1] = 0.0f;
    v3.v4 = v5;
    static_array_list<Union6,128> & v7 = v3.v2;
    v7.unsafe_set_length(0);
    static_array<Union2,2> v8;
    Union2 v10;
    v10 = Union2{Union2_1{}};
    v8[0] = v10;
    Union2 v12;
    v12 = Union2{Union2_1{}};
    v8[1] = v12;
    v3.v3 = v8;
    static_array_list<Union6,128> & v14 = v3.v2;
    unsigned long long & v15 = v3.v0;
    Union3 v16;
    v16 = Union3{Union3_1{v4}};
    Union3 v17;
    v17 = v16;
    while (while_method_25(v17)){
        Union3 v1723;
        switch (v17.tag) {
            case 0: { // None
                v1723 = Union3{Union3_0{}};
                break;
            }
            case 1: { // Some
                Union4 v19 = v17.case1.v0;
                Union18 v1374;
                switch (v19.tag) {
                    case 0: { // G_Flop
                        int v1235 = v19.case0.v0; static_array<static_array<unsigned char,2>,2> v1236 = v19.case0.v1; static_array<int,2> v1237 = v19.case0.v2; int v1238 = v19.case0.v3; static_array<int,2> v1239 = v19.case0.v4; Union5 v1240 = v19.case0.v5;
                        curandStatePhilox4_32_10_t & v1241 = v3.v5;
                        curandStatePhilox4_32_10_t & v1242 = v1241;
                        static_array<unsigned char,3> v1243; unsigned long long v1244;
                        Tuple8 tmp140 = draw_cards_32(v1242, v15);
                        v1243 = tmp140.v0; v1244 = tmp140.v1;
                        v3.v0 = v1244;
                        static_array_list<unsigned char,5> v1245;
                        v1245 = get_community_cards_84(v1240, v1243);
                        Union6 v1246;
                        v1246 = Union6{Union6_0{v1245}};
                        v14.push(v1246);
                        Union5 v1249;
                        switch (v1240.tag) {
                            case 1: { // Preflop
                                v1249 = Union5{Union5_0{v1243}};
                                break;
                            }
                            default: {
                                printf("%s\n", "Invalid street in flop.");
                                __trap();
                            }
                        }
                        int v1250;
                        v1250 = 2;
                        int v1251;
                        v1251 = 0;
                        Union4 v1252;
                        v1252 = try_round_36(v1250, v1236, v1237, v1251, v1239, v1249);
                        v1374 = Union18{Union18_2{v1252}};
                        break;
                    }
                    case 1: { // G_Fold
                        int v20 = v19.case1.v0; static_array<static_array<unsigned char,2>,2> v21 = v19.case1.v1; static_array<int,2> v22 = v19.case1.v2; int v23 = v19.case1.v3; static_array<int,2> v24 = v19.case1.v4; Union5 v25 = v19.case1.v5;
                        int v26;
                        v26 = v23 % 2;
                        bool v27;
                        v27 = 0 <= v26;
                        bool v29;
                        if (v27){
                            bool v28;
                            v28 = v26 < 2;
                            v29 = v28;
                        } else {
                            v29 = false;
                        }
                        bool v30;
                        v30 = v29 == false;
                        if (v30){
                            assert("Index must be in range." && v29);
                        } else {
                        }
                        int v32;
                        v32 = v22[v26];
                        int v34;
                        v34 = -v32;
                        float v35;
                        v35 = (float)v34;
                        static_array<float,2> & v36 = v3.v4;
                        v36[v26] = v35;
                        int v37;
                        v37 = v26 ^ 1;
                        float v38;
                        v38 = -v35;
                        v36[v37] = v38;
                        int v39;
                        v39 = v23 + 1;
                        int v40;
                        v40 = v39 % 2;
                        Union6 v41;
                        v41 = Union6{Union6_1{v32, v40}};
                        v14.push(v41);
                        v1374 = Union18{Union18_0{}};
                        break;
                    }
                    case 2: { // G_Preflop
                        curandStatePhilox4_32_10_t & v1336 = v3.v5;
                        curandStatePhilox4_32_10_t & v1337 = v1336;
                        static_array<unsigned char,2> v1338; unsigned long long v1339;
                        Tuple11 tmp141 = draw_cards_39(v1337, v15);
                        v1338 = tmp141.v0; v1339 = tmp141.v1;
                        v3.v0 = v1339;
                        curandStatePhilox4_32_10_t & v1340 = v3.v5;
                        curandStatePhilox4_32_10_t & v1341 = v1340;
                        static_array<unsigned char,2> v1342; unsigned long long v1343;
                        Tuple11 tmp142 = draw_cards_39(v1341, v15);
                        v1342 = tmp142.v0; v1343 = tmp142.v1;
                        v3.v0 = v1343;
                        Union6 v1344;
                        v1344 = Union6{Union6_3{0, v1338}};
                        v14.push(v1344);
                        Union6 v1345;
                        v1345 = Union6{Union6_3{1, v1342}};
                        v14.push(v1345);
                        static_array<static_array<unsigned char,2>,2> v1346;
                        v1346[0] = v1338;
                        v1346[1] = v1342;
                        static_array<int,2> v1348;
                        v1348[0] = 2;
                        v1348[1] = 1;
                        static_array<int,2> v1350;
                        int v1352;
                        v1352 = 0;
                        while (while_method_0(v1352)){
                            bool v1354;
                            v1354 = 0 <= v1352;
                            bool v1356;
                            if (v1354){
                                bool v1355;
                                v1355 = v1352 < 2;
                                v1356 = v1355;
                            } else {
                                v1356 = false;
                            }
                            bool v1357;
                            v1357 = v1356 == false;
                            if (v1357){
                                assert("Index must be in range." && v1356);
                            } else {
                            }
                            int v1359;
                            v1359 = v1348[v1352];
                            int v1361;
                            v1361 = 100 - v1359;
                            v1350[v1352] = v1361;
                            v1352 += 1 ;
                        }
                        int v1362;
                        v1362 = 2;
                        int v1363;
                        v1363 = 0;
                        Union5 v1364;
                        v1364 = Union5{Union5_1{}};
                        Union4 v1365;
                        v1365 = try_round_36(v1362, v1346, v1348, v1363, v1350, v1364);
                        v1374 = Union18{Union18_2{v1365}};
                        break;
                    }
                    case 3: { // G_River
                        int v1295 = v19.case3.v0; static_array<static_array<unsigned char,2>,2> v1296 = v19.case3.v1; static_array<int,2> v1297 = v19.case3.v2; int v1298 = v19.case3.v3; static_array<int,2> v1299 = v19.case3.v4; Union5 v1300 = v19.case3.v5;
                        curandStatePhilox4_32_10_t & v1301 = v3.v5;
                        curandStatePhilox4_32_10_t & v1302 = v1301;
                        static_array<unsigned char,1> v1303; unsigned long long v1304;
                        Tuple12 tmp143 = draw_cards_40(v1302, v15);
                        v1303 = tmp143.v0; v1304 = tmp143.v1;
                        v3.v0 = v1304;
                        static_array_list<unsigned char,5> v1305;
                        v1305 = get_community_cards_85(v1300, v1303);
                        Union6 v1306;
                        v1306 = Union6{Union6_0{v1305}};
                        v14.push(v1306);
                        Union5 v1331;
                        switch (v1300.tag) {
                            case 3: { // Turn
                                static_array<unsigned char,4> v1307 = v1300.case3.v0;
                                static_array<unsigned char,5> v1308;
                                int v1310;
                                v1310 = 0;
                                while (while_method_3(v1310)){
                                    bool v1312;
                                    v1312 = 0 <= v1310;
                                    bool v1314;
                                    if (v1312){
                                        bool v1313;
                                        v1313 = v1310 < 4;
                                        v1314 = v1313;
                                    } else {
                                        v1314 = false;
                                    }
                                    bool v1315;
                                    v1315 = v1314 == false;
                                    if (v1315){
                                        assert("Index must be in range." && v1314);
                                    } else {
                                    }
                                    unsigned char v1317;
                                    v1317 = v1307[v1310];
                                    v1308[v1310] = v1317;
                                    v1310 += 1 ;
                                }
                                int v1319;
                                v1319 = 0;
                                while (while_method_6(v1319)){
                                    bool v1321;
                                    v1321 = 0 <= v1319;
                                    bool v1323;
                                    if (v1321){
                                        bool v1322;
                                        v1322 = v1319 < 1;
                                        v1323 = v1322;
                                    } else {
                                        v1323 = false;
                                    }
                                    bool v1324;
                                    v1324 = v1323 == false;
                                    if (v1324){
                                        assert("Index must be in range." && v1323);
                                    } else {
                                    }
                                    unsigned char v1326;
                                    v1326 = v1303[v1319];
                                    int v1328;
                                    v1328 = 4 + v1319;
                                    v1308[v1328] = v1326;
                                    v1319 += 1 ;
                                }
                                v1331 = Union5{Union5_2{v1308}};
                                break;
                            }
                            default: {
                                printf("%s\n", "Invalid street in river.");
                                __trap();
                            }
                        }
                        int v1332;
                        v1332 = 2;
                        int v1333;
                        v1333 = 0;
                        Union4 v1334;
                        v1334 = try_round_36(v1332, v1296, v1297, v1333, v1299, v1331);
                        v1374 = Union18{Union18_2{v1334}};
                        break;
                    }
                    case 4: { // G_Round
                        int v162 = v19.case4.v0; static_array<static_array<unsigned char,2>,2> v163 = v19.case4.v1; static_array<int,2> v164 = v19.case4.v2; int v165 = v19.case4.v3; static_array<int,2> v166 = v19.case4.v4; Union5 v167 = v19.case4.v5;
                        int v168;
                        v168 = v165 % 2;
                        static_array<Union2,2> & v169 = v3.v3;
                        bool v170;
                        v170 = 0 <= v168;
                        bool v172;
                        if (v170){
                            bool v171;
                            v171 = v168 < 2;
                            v172 = v171;
                        } else {
                            v172 = false;
                        }
                        bool v173;
                        v173 = v172 == false;
                        if (v173){
                            assert("Index must be in range." && v172);
                        } else {
                        }
                        Union2 v175;
                        v175 = v169[v168];
                        Union1 v1222;
                        switch (v175.tag) {
                            case 0: { // CallingMachine
                                v1222 = Union1{Union1_1{}};
                                break;
                            }
                            case 1: { // Computer
                                static_array_list<Union6,128> & v178 = v3.v2;
                                curandStatePhilox4_32_10_t & v179 = v3.v5;
                                curandStatePhilox4_32_10_t & v180 = v179;
                                float * v181;
                                v181 = reinterpret_cast<float *>(&v1[114819072ull]);
                                float * v183;
                                v183 = reinterpret_cast<float *>(&v1[0ull]);
                                float * v185;
                                v185 = reinterpret_cast<float *>(&v1[0ull]);
                                int v187;
                                v187 = blockIdx.x;
                                assert("Tensor range check" && 0 <= v187 && v187 < 24);
                                int v188;
                                v188 = 524288 * v187;
                                int v189;
                                v189 = threadIdx.x;
                                int v190;
                                v190 = v189;
                                while (while_method_7(v190)){
                                    bool v192;
                                    v192 = 0 <= v190;
                                    bool v193;
                                    v193 = v192 == false;
                                    if (v193){
                                        assert("The index needs to be zero or positive." && v192);
                                    } else {
                                    }
                                    int v195;
                                    v195 = v190 % 2048;
                                    int v196;
                                    v196 = v190 / 2048;
                                    bool v197;
                                    v197 = v196 < 256;
                                    bool v198;
                                    v198 = v197 == false;
                                    if (v198){
                                        assert("The last element of the projection dimensions needs to be greater than the index remainder." && v197);
                                    } else {
                                    }
                                    assert("Tensor range check" && 0 <= v196 && v196 < 256);
                                    assert("Tensor range check" && 0 <= v195 && v195 < 2048);
                                    int v200;
                                    v200 = v195 + v188;
                                    int v201;
                                    v201 = 2048 * v196;
                                    int v202;
                                    v202 = v201 + v200;
                                    v185[v202] = 0.0f;
                                    v190 += 256 ;
                                }
                                __syncthreads();
                                int v203;
                                v203 = threadIdx.x;
                                assert("Tensor range check" && 0 <= v203 && v203 < 256);
                                int v204;
                                v204 = 2048 * v203;
                                int v205;
                                v205 = v204 + v188;
                                int v206;
                                v206 = v178.length;
                                bool v207;
                                v207 = 128 >= v206;
                                bool v208;
                                v208 = v207 == false;
                                if (v208){
                                    assert("The type level dimension has to equal the value passed at runtime into create." && v207);
                                } else {
                                }
                                static_array_list<Union8,128> v210;
                                v210 = static_array_list<Union8,128>{};
                                v210.unsafe_set_length(v206);
                                int v212;
                                v212 = 0;
                                while (while_method_4(v206, v212)){
                                    Union6 v214;
                                    v214 = v178[v212];
                                    Union8 v220;
                                    switch (v214.tag) {
                                        case 2: { // PlayerAction
                                            int v216 = v214.case2.v0; Union1 v217 = v214.case2.v1;
                                            v220 = Union8{Union8_1{v217}};
                                            break;
                                        }
                                        default: {
                                            v220 = Union8{Union8_0{}};
                                        }
                                    }
                                    v210[v212] = v220;
                                    v212 += 1 ;
                                }
                                static_array<int,2> v221;
                                int v223;
                                v223 = 0;
                                while (while_method_0(v223)){
                                    int v225;
                                    v225 = v223 + v165;
                                    int v226;
                                    v226 = v225 % 2;
                                    bool v227;
                                    v227 = 0 <= v226;
                                    bool v229;
                                    if (v227){
                                        bool v228;
                                        v228 = v226 < 2;
                                        v229 = v228;
                                    } else {
                                        v229 = false;
                                    }
                                    bool v230;
                                    v230 = v229 == false;
                                    if (v230){
                                        assert("Index must be in range." && v229);
                                    } else {
                                    }
                                    int v232;
                                    v232 = v164[v226];
                                    v221[v223] = v232;
                                    v223 += 1 ;
                                }
                                static_array<int,2> v234;
                                int v236;
                                v236 = 0;
                                while (while_method_0(v236)){
                                    int v238;
                                    v238 = v236 + v165;
                                    int v239;
                                    v239 = v238 % 2;
                                    bool v240;
                                    v240 = 0 <= v239;
                                    bool v242;
                                    if (v240){
                                        bool v241;
                                        v241 = v239 < 2;
                                        v242 = v241;
                                    } else {
                                        v242 = false;
                                    }
                                    bool v243;
                                    v243 = v242 == false;
                                    if (v243){
                                        assert("Index must be in range." && v242);
                                    } else {
                                    }
                                    int v245;
                                    v245 = v166[v239];
                                    v234[v236] = v245;
                                    v236 += 1 ;
                                }
                                bool v248;
                                if (v170){
                                    bool v247;
                                    v247 = v168 < 2;
                                    v248 = v247;
                                } else {
                                    v248 = false;
                                }
                                bool v249;
                                v249 = v248 == false;
                                if (v249){
                                    assert("Index must be in range." && v248);
                                } else {
                                }
                                static_array<unsigned char,2> v251;
                                v251 = v163[v168];
                                static_array_list<unsigned char,5> v253;
                                v253 = static_array_list<unsigned char,5>{};
                                switch (v167.tag) {
                                    case 0: { // Flop
                                        static_array<unsigned char,3> v255 = v167.case0.v0;
                                        int v256;
                                        v256 = 0;
                                        while (while_method_1(v256)){
                                            bool v258;
                                            v258 = 0 <= v256;
                                            bool v260;
                                            if (v258){
                                                bool v259;
                                                v259 = v256 < 3;
                                                v260 = v259;
                                            } else {
                                                v260 = false;
                                            }
                                            bool v261;
                                            v261 = v260 == false;
                                            if (v261){
                                                assert("Index must be in range." && v260);
                                            } else {
                                            }
                                            unsigned char v263;
                                            v263 = v255[v256];
                                            v253.push(v263);
                                            v256 += 1 ;
                                        }
                                        break;
                                    }
                                    case 1: { // Preflop
                                        break;
                                    }
                                    case 2: { // River
                                        static_array<unsigned char,5> v275 = v167.case2.v0;
                                        int v276;
                                        v276 = 0;
                                        while (while_method_2(v276)){
                                            bool v278;
                                            v278 = 0 <= v276;
                                            bool v280;
                                            if (v278){
                                                bool v279;
                                                v279 = v276 < 5;
                                                v280 = v279;
                                            } else {
                                                v280 = false;
                                            }
                                            bool v281;
                                            v281 = v280 == false;
                                            if (v281){
                                                assert("Index must be in range." && v280);
                                            } else {
                                            }
                                            unsigned char v283;
                                            v283 = v275[v276];
                                            v253.push(v283);
                                            v276 += 1 ;
                                        }
                                        break;
                                    }
                                    case 3: { // Turn
                                        static_array<unsigned char,4> v265 = v167.case3.v0;
                                        int v266;
                                        v266 = 0;
                                        while (while_method_3(v266)){
                                            bool v268;
                                            v268 = 0 <= v266;
                                            bool v270;
                                            if (v268){
                                                bool v269;
                                                v269 = v266 < 4;
                                                v270 = v269;
                                            } else {
                                                v270 = false;
                                            }
                                            bool v271;
                                            v271 = v270 == false;
                                            if (v271){
                                                assert("Index must be in range." && v270);
                                            } else {
                                            }
                                            unsigned char v273;
                                            v273 = v265[v266];
                                            v253.push(v273);
                                            v266 += 1 ;
                                        }
                                        break;
                                    }
                                    default: {
                                        assert("Invalid tag." && false); __trap();
                                    }
                                }
                                float * v285;
                                v285 = v185+v205;
                                int v287;
                                v287 = v210.length;
                                bool v288;
                                v288 = v287 == 0;
                                if (v288){
                                    v285[0] = 1.0f;
                                } else {
                                }
                                int v289;
                                v289 = v210.length;
                                int v290;
                                v290 = 0;
                                while (while_method_4(v289, v290)){
                                    Union8 v292;
                                    v292 = v210[v290];
                                    int v294;
                                    v294 = v290 * 14;
                                    int v295;
                                    v295 = 1 + v294;
                                    switch (v292.tag) {
                                        case 0: { // None
                                            v285[v295] = 1.0f;
                                            break;
                                        }
                                        case 1: { // Some
                                            Union1 v296 = v292.case1.v0;
                                            int v297;
                                            v297 = v295 + 1;
                                            switch (v296.tag) {
                                                case 0: { // A_All_In
                                                    v285[v297] = 1.0f;
                                                    break;
                                                }
                                                case 1: { // A_Call
                                                    int v298;
                                                    v298 = v297 + 1;
                                                    v285[v298] = 1.0f;
                                                    break;
                                                }
                                                case 2: { // A_Fold
                                                    int v299;
                                                    v299 = v297 + 2;
                                                    v285[v299] = 1.0f;
                                                    break;
                                                }
                                                case 3: { // A_Raise
                                                    int v300 = v296.case3.v0;
                                                    int v301;
                                                    v301 = v297 + 3;
                                                    bool v302;
                                                    v302 = 1 <= v300;
                                                    bool v304;
                                                    if (v302){
                                                        bool v303;
                                                        v303 = v300 < 1023;
                                                        v304 = v303;
                                                    } else {
                                                        v304 = false;
                                                    }
                                                    bool v305;
                                                    v305 = v304 == false;
                                                    if (v305){
                                                        assert("Pickle failure. The input is out of the bounds of the given range." && v304);
                                                    } else {
                                                    }
                                                    int v307;
                                                    v307 = v300 - 1;
                                                    unsigned int v308;
                                                    v308 = (unsigned int)v307;
                                                    method_42(v308, v285, v301);
                                                    break;
                                                }
                                                default: {
                                                    assert("Invalid tag." && false); __trap();
                                                }
                                            }
                                            break;
                                        }
                                        default: {
                                            assert("Invalid tag." && false); __trap();
                                        }
                                    }
                                    v290 += 1 ;
                                }
                                int v309;
                                v309 = 0;
                                while (while_method_0(v309)){
                                    // 222;
                                    bool v311;
                                    v311 = 0 <= v309;
                                    bool v313;
                                    if (v311){
                                        bool v312;
                                        v312 = v309 < 2;
                                        v313 = v312;
                                    } else {
                                        v313 = false;
                                    }
                                    bool v314;
                                    v314 = v313 == false;
                                    if (v314){
                                        assert("Index must be in range." && v313);
                                    } else {
                                    }
                                    int v316;
                                    v316 = v221[v309];
                                    int v318;
                                    v318 = v309 * 11;
                                    int v319;
                                    v319 = 1794 + v318;
                                    bool v320;
                                    v320 = 0 <= v316;
                                    bool v322;
                                    if (v320){
                                        bool v321;
                                        v321 = v316 < 1023;
                                        v322 = v321;
                                    } else {
                                        v322 = false;
                                    }
                                    bool v323;
                                    v323 = v322 == false;
                                    if (v323){
                                        assert("Pickle failure. The input is out of the bounds of the given range." && v322);
                                    } else {
                                    }
                                    unsigned int v325;
                                    v325 = (unsigned int)v316;
                                    method_43(v325, v285, v319);
                                    v309 += 1 ;
                                }
                                int v326;
                                v326 = 0;
                                while (while_method_0(v326)){
                                    // 222;
                                    bool v328;
                                    v328 = 0 <= v326;
                                    bool v330;
                                    if (v328){
                                        bool v329;
                                        v329 = v326 < 2;
                                        v330 = v329;
                                    } else {
                                        v330 = false;
                                    }
                                    bool v331;
                                    v331 = v330 == false;
                                    if (v331){
                                        assert("Index must be in range." && v330);
                                    } else {
                                    }
                                    int v333;
                                    v333 = v234[v326];
                                    int v335;
                                    v335 = v326 * 11;
                                    int v336;
                                    v336 = 1817 + v335;
                                    bool v337;
                                    v337 = 0 <= v333;
                                    bool v339;
                                    if (v337){
                                        bool v338;
                                        v338 = v333 < 1023;
                                        v339 = v338;
                                    } else {
                                        v339 = false;
                                    }
                                    bool v340;
                                    v340 = v339 == false;
                                    if (v340){
                                        assert("Pickle failure. The input is out of the bounds of the given range." && v339);
                                    } else {
                                    }
                                    unsigned int v342;
                                    v342 = (unsigned int)v333;
                                    method_43(v342, v285, v336);
                                    v326 += 1 ;
                                }
                                int v343;
                                v343 = 0;
                                while (while_method_0(v343)){
                                    // 222;
                                    bool v345;
                                    v345 = 0 <= v343;
                                    bool v347;
                                    if (v345){
                                        bool v346;
                                        v346 = v343 < 2;
                                        v347 = v346;
                                    } else {
                                        v347 = false;
                                    }
                                    bool v348;
                                    v348 = v347 == false;
                                    if (v348){
                                        assert("Index must be in range." && v347);
                                    } else {
                                    }
                                    unsigned char v350;
                                    v350 = v251[v343];
                                    int v352;
                                    v352 = v343 * 17;
                                    int v353;
                                    v353 = 1840 + v352;
                                    unsigned char v354;
                                    v354 = v350 % 4u;
                                    int v355;
                                    v355 = (int)v354;
                                    unsigned char v356;
                                    v356 = v350 / 4u;
                                    int v357;
                                    v357 = (int)v356;
                                    unsigned int v358;
                                    v358 = (unsigned int)v355;
                                    int v359;
                                    v359 = (int)v358;
                                    bool v360;
                                    v360 = v359 < 4;
                                    bool v361;
                                    v361 = v360 == false;
                                    if (v361){
                                        assert("Pickle failure. Int value out of bounds." && v360);
                                    } else {
                                    }
                                    int v363;
                                    v363 = v353 + v359;
                                    v285[v363] = 1.0f;
                                    int v364;
                                    v364 = v353 + 4;
                                    unsigned int v365;
                                    v365 = (unsigned int)v357;
                                    int v366;
                                    v366 = (int)v365;
                                    bool v367;
                                    v367 = v366 < 13;
                                    bool v368;
                                    v368 = v367 == false;
                                    if (v368){
                                        assert("Pickle failure. Int value out of bounds." && v367);
                                    } else {
                                    }
                                    int v370;
                                    v370 = v364 + v366;
                                    v285[v370] = 1.0f;
                                    v343 += 1 ;
                                }
                                int v371;
                                v371 = v253.length;
                                bool v372;
                                v372 = v371 == 0;
                                if (v372){
                                    v285[1874] = 1.0f;
                                } else {
                                }
                                int v373;
                                v373 = v253.length;
                                int v374;
                                v374 = 0;
                                while (while_method_4(v373, v374)){
                                    unsigned char v376;
                                    v376 = v253[v374];
                                    int v378;
                                    v378 = v374 * 17;
                                    int v379;
                                    v379 = 1875 + v378;
                                    unsigned char v380;
                                    v380 = v376 % 4u;
                                    int v381;
                                    v381 = (int)v380;
                                    unsigned char v382;
                                    v382 = v376 / 4u;
                                    int v383;
                                    v383 = (int)v382;
                                    unsigned int v384;
                                    v384 = (unsigned int)v381;
                                    int v385;
                                    v385 = (int)v384;
                                    bool v386;
                                    v386 = v385 < 4;
                                    bool v387;
                                    v387 = v386 == false;
                                    if (v387){
                                        assert("Pickle failure. Int value out of bounds." && v386);
                                    } else {
                                    }
                                    int v389;
                                    v389 = v379 + v385;
                                    v285[v389] = 1.0f;
                                    int v390;
                                    v390 = v379 + 4;
                                    unsigned int v391;
                                    v391 = (unsigned int)v383;
                                    int v392;
                                    v392 = (int)v391;
                                    bool v393;
                                    v393 = v392 < 13;
                                    bool v394;
                                    v394 = v393 == false;
                                    if (v394){
                                        assert("Pickle failure. Int value out of bounds." && v393);
                                    } else {
                                    }
                                    int v396;
                                    v396 = v390 + v392;
                                    v285[v396] = 1.0f;
                                    v374 += 1 ;
                                }
                                __syncthreads();
                                int v397;
                                v397 = 0;
                                while (while_method_3(v397)){
                                    float * v399;
                                    v399 = reinterpret_cast<float *>(&v1[114819072ull]);
                                    assert("Tensor range check" && 0 <= v397 && v397 < 4);
                                    int v401;
                                    v401 = 393216 * v397;
                                    float * v402;
                                    v402 = reinterpret_cast<float *>(&v1[106954752ull]);
                                    float * v404;
                                    v404 = reinterpret_cast<float *>(&v1[94371840ull]);
                                    float * v406;
                                    v406 = reinterpret_cast<float *>(&v1[81788928ull]);
                                    float * v408;
                                    v408 = reinterpret_cast<float *>(&v1[69206016ull]);
                                    float * v410;
                                    v410 = reinterpret_cast<float *>(&v1[56623104ull]);
                                    float * v412;
                                    v412 = reinterpret_cast<float *>(&v1[0ull]);
                                    float * v414;
                                    v414 = reinterpret_cast<float *>(&v0[0ull]);
                                    float * v416;
                                    v416 = reinterpret_cast<float *>(&v2[0ull]);
                                    assert("Tensor range check" && 0 <= v397 && v397 < 4);
                                    int v418;
                                    v418 = 524288 * v397;
                                    float * v419;
                                    v419 = reinterpret_cast<float *>(&v1[50331648ull]);
                                    block_matmul_45(v419, v414, v418, v412);
                                    block_map_46(v410, v419);
                                    float * v421;
                                    v421 = reinterpret_cast<float *>(&v0[8388608ull]);
                                    float * v423;
                                    v423 = reinterpret_cast<float *>(&v2[8388608ull]);
                                    assert("Tensor range check" && 0 <= v397 && v397 < 4);
                                    int v425;
                                    v425 = 65536 * v397;
                                    float * v426;
                                    v426 = reinterpret_cast<float *>(&v1[62914560ull]);
                                    block_matmul_47(v426, v421, v425, v410);
                                    block_map_46(v408, v426);
                                    float * v428;
                                    v428 = reinterpret_cast<float *>(&v0[9437184ull]);
                                    float * v430;
                                    v430 = reinterpret_cast<float *>(&v2[9437184ull]);
                                    assert("Tensor range check" && 0 <= v397 && v397 < 4);
                                    float * v432;
                                    v432 = reinterpret_cast<float *>(&v1[75497472ull]);
                                    block_matmul_47(v432, v428, v425, v408);
                                    block_map_46(v406, v432);
                                    float * v434;
                                    v434 = reinterpret_cast<float *>(&v0[10485760ull]);
                                    float * v436;
                                    v436 = reinterpret_cast<float *>(&v2[10485760ull]);
                                    assert("Tensor range check" && 0 <= v397 && v397 < 4);
                                    float * v438;
                                    v438 = reinterpret_cast<float *>(&v1[88080384ull]);
                                    block_matmul_47(v438, v434, v425, v406);
                                    block_map_46(v404, v438);
                                    float * v440;
                                    v440 = reinterpret_cast<float *>(&v0[11534336ull]);
                                    float * v442;
                                    v442 = reinterpret_cast<float *>(&v2[11534336ull]);
                                    assert("Tensor range check" && 0 <= v397 && v397 < 4);
                                    float * v444;
                                    v444 = reinterpret_cast<float *>(&v1[100663296ull]);
                                    block_matmul_47(v444, v440, v425, v404);
                                    block_map_46(v402, v444);
                                    float * v446;
                                    v446 = reinterpret_cast<float *>(&v0[12582912ull]);
                                    float * v448;
                                    v448 = reinterpret_cast<float *>(&v2[12582912ull]);
                                    assert("Tensor range check" && 0 <= v397 && v397 < 4);
                                    int v450;
                                    v450 = 16384 * v397;
                                    float * v451;
                                    v451 = reinterpret_cast<float *>(&v1[113246208ull]);
                                    block_matmul_48(v451, v446, v450, v402);
                                    block_row_map_49(v399, v401, v451);
                                    int * v453;
                                    v453 = reinterpret_cast<int *>(&v0[12845056ull]);
                                    bool * v455;
                                    v455 = reinterpret_cast<bool *>(&v0[12845072ull]);
                                    float * v457;
                                    v457 = reinterpret_cast<float *>(&v0[12845088ull]);
                                    float * v459;
                                    v459 = reinterpret_cast<float *>(&v0[12845104ull]);
                                    double * v461;
                                    v461 = reinterpret_cast<double *>(&v1[121110528ull]);
                                    double * v463;
                                    v463 = reinterpret_cast<double *>(&v1[121503744ull]);
                                    v397 += 1 ;
                                }
                                __syncthreads();
                                int * v465;
                                v465 = reinterpret_cast<int *>(&v0[12845056ull]);
                                bool * v467;
                                v467 = reinterpret_cast<bool *>(&v0[12845072ull]);
                                float * v469;
                                v469 = reinterpret_cast<float *>(&v0[12845088ull]);
                                float * v471;
                                v471 = reinterpret_cast<float *>(&v0[12845104ull]);
                                int v473;
                                v473 = 0;
                                int v474;
                                v474 = 4;
                                int v475;
                                v475 = int_range_44(v474, v473, v180);
                                extern __shared__ unsigned char v476[];
                                int * v477;
                                v477 = reinterpret_cast<int *>(&v476[0ull]);
                                int v479;
                                v479 = threadIdx.x;
                                bool v480;
                                v480 = v479 == 0;
                                if (v480){
                                    v477[0] = v475;
                                } else {
                                }
                                __syncthreads();
                                int v481;
                                v481 = v477[0];
                                __syncthreads();
                                float * v482;
                                v482 = reinterpret_cast<float *>(&v1[114819072ull]);
                                assert("Tensor range check" && 0 <= v481 && v481 < 4);
                                int v484;
                                v484 = 393216 * v481;
                                int v485;
                                v485 = blockIdx.x;
                                assert("Tensor range check" && 0 <= v485 && v485 < 24);
                                int v486;
                                v486 = 16384 * v485;
                                int v487;
                                v487 = v486 + v484;
                                int v488;
                                v488 = threadIdx.x;
                                assert("Tensor range check" && 0 <= v488 && v488 < 256);
                                int v489;
                                v489 = 64 * v488;
                                int v490;
                                v490 = v489 + v487;
                                float * v491;
                                v491 = v482+v490;
                                int v493;
                                v493 = sizeof(float *);
                                unsigned long long v494;
                                v494 = (unsigned long long)v493;
                                unsigned long long v495;
                                v495 = 256ull * v494;
                                unsigned long long v496;
                                v496 = v495 + 16ull;
                                unsigned long long v497;
                                v497 = v496 - 1ull;
                                unsigned long long v498;
                                v498 = v497 % 16ull;
                                unsigned long long v499;
                                v499 = v497 - v498;
                                unsigned long long v500;
                                v500 = v499 + 1024ull;
                                unsigned long long v501;
                                v501 = v500 + 16ull;
                                unsigned long long v502;
                                v502 = v501 - 1ull;
                                unsigned long long v503;
                                v503 = v502 % 16ull;
                                unsigned long long v504;
                                v504 = v502 - v503;
                                unsigned long long v505;
                                v505 = v504 + 1024ull;
                                bool v506;
                                v506 = v505 <= 98304ull;
                                bool v507;
                                v507 = v506 == false;
                                if (v507){
                                    assert("The dynamic shared memory is insufficient to allocate the tensor." && v506);
                                } else {
                                }
                                extern __shared__ unsigned char v509[];
                                bool v510;
                                v510 = v505 <= v505;
                                bool v511;
                                v511 = v510 == false;
                                if (v511){
                                    assert("The length of the partition has to be less than or equal to the length of the base array." && v510);
                                } else {
                                }
                                float * * v513;
                                v513 = reinterpret_cast<float * *>(&v509[0ull]);
                                float * v515;
                                v515 = reinterpret_cast<float *>(&v509[v499]);
                                int * v517;
                                v517 = reinterpret_cast<int *>(&v509[v504]);
                                int v519;
                                v519 = threadIdx.x;
                                assert("Tensor range check" && 0 <= v519 && v519 < 256);
                                v513[v519] = v491;
                                __syncthreads();
                                bool v520;
                                v520 = 0 <= v519;
                                bool v521;
                                v521 = v520 == false;
                                if (v521){
                                    assert("The index needs to be zero or positive." && v520);
                                } else {
                                }
                                int v523;
                                v523 = v519 % 16;
                                int v524;
                                v524 = v519 / 16;
                                bool v525;
                                v525 = v524 < 16;
                                bool v526;
                                v526 = v525 == false;
                                if (v526){
                                    assert("The last element of the projection dimensions needs to be greater than the index remainder." && v525);
                                } else {
                                }
                                assert("Tensor range check" && 0 <= v524 && v524 < 16);
                                int v528;
                                v528 = 0;
                                while (while_method_12(v528)){
                                    bool v530;
                                    v530 = 0 <= v524;
                                    bool v531;
                                    v531 = v530 && v525;
                                    bool v532;
                                    v532 = v531 == false;
                                    if (v532){
                                        assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v531);
                                    } else {
                                    }
                                    bool v534;
                                    v534 = 0 <= v528;
                                    bool v536;
                                    if (v534){
                                        bool v535;
                                        v535 = v528 < 16;
                                        v536 = v535;
                                    } else {
                                        v536 = false;
                                    }
                                    bool v537;
                                    v537 = v536 == false;
                                    if (v537){
                                        assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v536);
                                    } else {
                                    }
                                    int v539;
                                    v539 = v528 * 16;
                                    int v540;
                                    v540 = v539 + v524;
                                    assert("Tensor range check" && 0 <= v528 && v528 < 16);
                                    int v541;
                                    v541 = 16 * v528;
                                    int v542;
                                    v542 = v541 + v524;
                                    float * v543;
                                    v543 = v513[v542];
                                    int v544;
                                    v544 = blockIdx.x;
                                    int v545;
                                    v545 = v544 * 256;
                                    int v546;
                                    v546 = v545 + v540;
                                    assert("Tensor range check" && 0 <= v523 && v523 < 16);
                                    int v547;
                                    v547 = 4 * v523;
                                    float v548[4];
                                    int v549[4];
                                    int v550;
                                    v550 = 0;
                                    while (while_method_6(v550)){
                                        assert("Tensor range check" && 0 <= v550 && v550 < 1);
                                        int v552;
                                        v552 = 4 * v550;
                                        assert("Tensor range check" && 0 <= v550 && v550 < 1);
                                        int v553;
                                        v553 = 64 * v550;
                                        int v554;
                                        v554 = v553 + v547;
                                        int4* v555;
                                        v555 = reinterpret_cast<int4*>(v543 + v554);
                                        int4* v556;
                                        v556 = reinterpret_cast<int4*>(v548 + v552);
                                        assert("Pointer alignment check" && reinterpret_cast<unsigned long long>(v555) % 16 == 0 && reinterpret_cast<unsigned long long>(v556) % 16 == 0);
                                        *v556 = *v555;
                                        v550 += 1 ;
                                    }
                                    int v557;
                                    v557 = 0;
                                    while (while_method_6(v557)){
                                        int v559;
                                        v559 = 0;
                                        while (while_method_3(v559)){
                                            bool v561;
                                            v561 = 0 <= v559;
                                            bool v563;
                                            if (v561){
                                                bool v562;
                                                v562 = v559 < 4;
                                                v563 = v562;
                                            } else {
                                                v563 = false;
                                            }
                                            bool v564;
                                            v564 = v563 == false;
                                            if (v564){
                                                assert("The indices should be inside the range of the dimension." && v563);
                                            } else {
                                            }
                                            bool v566;
                                            v566 = 0 <= v523;
                                            bool v568;
                                            if (v566){
                                                bool v567;
                                                v567 = v523 < 16;
                                                v568 = v567;
                                            } else {
                                                v568 = false;
                                            }
                                            bool v569;
                                            v569 = v568 == false;
                                            if (v569){
                                                assert("The indices should be inside the range of the dimension." && v568);
                                            } else {
                                            }
                                            int v571;
                                            v571 = v523 * 4;
                                            int v572;
                                            v572 = v559 + v571;
                                            bool v573;
                                            v573 = 0 <= v557;
                                            bool v575;
                                            if (v573){
                                                bool v574;
                                                v574 = v557 < 1;
                                                v575 = v574;
                                            } else {
                                                v575 = false;
                                            }
                                            bool v576;
                                            v576 = v575 == false;
                                            if (v576){
                                                assert("The indices should be inside the range of the dimension." && v575);
                                            } else {
                                            }
                                            int v578;
                                            v578 = v557 * 64;
                                            int v579;
                                            v579 = v572 + v578;
                                            assert("Tensor range check" && 0 <= v557 && v557 < 1);
                                            assert("Tensor range check" && 0 <= v559 && v559 < 4);
                                            int v580;
                                            v580 = 4 * v557;
                                            int v581;
                                            v581 = v580 + v559;
                                            v549[v581] = v579;
                                            v559 += 1 ;
                                        }
                                        v557 += 1 ;
                                    }
                                    float v582[4];
                                    float v583;
                                    v583 = 0.0f;
                                    int v584;
                                    v584 = 0;
                                    while (while_method_6(v584)){
                                        assert("Tensor range check" && 0 <= v584 && v584 < 1);
                                        int v586;
                                        v586 = 4 * v584;
                                        assert("Tensor range check" && 0 <= v584 && v584 < 1);
                                        float v587;
                                        v587 = 0.0f;
                                        int v588;
                                        v588 = 0;
                                        while (while_method_3(v588)){
                                            assert("Tensor range check" && 0 <= v588 && v588 < 4);
                                            int v590;
                                            v590 = v588 + v586;
                                            float v591;
                                            v591 = v548[v590];
                                            float v592;
                                            v592 = v587 + v591;
                                            v587 = v592;
                                            v588 += 1 ;
                                        }
                                        auto v593 = cooperative_groups::coalesced_threads();
                                        int v594;
                                        v594 = threadIdx.x;
                                        int v595;
                                        v595 = v594 / 16;
                                        auto v596 = cooperative_groups::labeled_partition(v593,v595);
                                        Closure2 v597{};
                                        float v598;
                                        v598 = cooperative_groups::inclusive_scan(v596, v587, v597);
                                        float v599;
                                        v599 = v596.shfl_up(v598,1);
                                        bool v600;
                                        v600 = v596.thread_rank() == 0;
                                        float v601;
                                        if (v600){
                                            v601 = 0.0f;
                                        } else {
                                            v601 = v599;
                                        }
                                        float v602;
                                        v602 = v596.shfl(v598,v596.num_threads()-1);
                                        float v603;
                                        v603 = v583 + v601;
                                        float v604;
                                        v604 = v603;
                                        int v605;
                                        v605 = 0;
                                        while (while_method_3(v605)){
                                            assert("Tensor range check" && 0 <= v605 && v605 < 4);
                                            int v607;
                                            v607 = v605 + v586;
                                            float v608;
                                            v608 = v548[v607];
                                            float v609;
                                            v609 = v604 + v608;
                                            assert("Tensor range check" && 0 <= v605 && v605 < 4);
                                            v582[v607] = v609;
                                            v604 = v609;
                                            v605 += 1 ;
                                        }
                                        float v610;
                                        v610 = v583 + v602;
                                        v583 = v610;
                                        v584 += 1 ;
                                    }
                                    float v611[4];
                                    bool v612[4];
                                    int v613;
                                    v613 = 0;
                                    while (while_method_6(v613)){
                                        int v615;
                                        v615 = 0;
                                        while (while_method_3(v615)){
                                            assert("Tensor range check" && 0 <= v613 && v613 < 1);
                                            assert("Tensor range check" && 0 <= v615 && v615 < 4);
                                            int v617;
                                            v617 = 4 * v613;
                                            int v618;
                                            v618 = v617 + v615;
                                            float v619;
                                            v619 = v582[v618];
                                            float v620;
                                            v620 = v548[v618];
                                            bool v621;
                                            v621 = v620 > 0.0f;
                                            assert("Tensor range check" && 0 <= v613 && v613 < 1);
                                            assert("Tensor range check" && 0 <= v615 && v615 < 4);
                                            v611[v618] = v619;
                                            v612[v618] = v621;
                                            v615 += 1 ;
                                        }
                                        v613 += 1 ;
                                    }
                                    float v622; bool v623;
                                    Tuple14 tmp144 = Tuple14{-1.0f / 0.0f, false};
                                    v622 = tmp144.v0; v623 = tmp144.v1;
                                    int v624;
                                    v624 = 0;
                                    while (while_method_6(v624)){
                                        int v626;
                                        v626 = 0;
                                        while (while_method_3(v626)){
                                            assert("Tensor range check" && 0 <= v624 && v624 < 1);
                                            assert("Tensor range check" && 0 <= v626 && v626 < 4);
                                            int v628;
                                            v628 = 4 * v624;
                                            int v629;
                                            v629 = v628 + v626;
                                            float v630;
                                            v630 = v611[v629];
                                            bool v631;
                                            v631 = v612[v629];
                                            float v638; bool v639;
                                            if (v623){
                                                if (v631){
                                                    bool v632;
                                                    v632 = v622 >= v630;
                                                    float v633;
                                                    if (v632){
                                                        v633 = v622;
                                                    } else {
                                                        v633 = v630;
                                                    }
                                                    v638 = v633; v639 = true;
                                                } else {
                                                    v638 = v622; v639 = v623;
                                                }
                                            } else {
                                                if (v631){
                                                    v638 = v630; v639 = v631;
                                                } else {
                                                    v638 = v622; v639 = v623;
                                                }
                                            }
                                            v622 = v638;
                                            v623 = v639;
                                            v626 += 1 ;
                                        }
                                        v624 += 1 ;
                                    }
                                    auto v640 = cooperative_groups::coalesced_threads();
                                    int v641;
                                    v641 = threadIdx.x;
                                    int v642;
                                    v642 = v641 / 16;
                                    auto v643 = cooperative_groups::labeled_partition(v640,v642);
                                    Closure3 v644{};
                                    float v645; bool v646;
                                    Tuple14 tmp145 = cooperative_groups::reduce(v643, Tuple14{v622, v623}, v644);
                                    v645 = tmp145.v0; v646 = tmp145.v1;
                                    bool v647;
                                    v647 = v646 == false;
                                    if (v647){
                                        int v648;
                                        v648 = threadIdx.x;
                                        int v649;
                                        v649 = blockIdx.x;
                                        int v650;
                                        v650 = v649 * 256;
                                        int v651;
                                        v651 = v648 + v650;
                                        cuda::counting_semaphore<cuda::thread_scope_system, 1> & v652 = console_lock;
                                        auto v653 = cooperative_groups::coalesced_threads();
                                        v652.acquire();
                                        int v654;
                                        v654 = 0;
                                        printf("{%s = %d; %s = %c","tid", v651, "x'", '[');
                                        int v655;
                                        v655 = 0;
                                        while (while_method_6(v655)){
                                            int v657;
                                            v657 = v654;
                                            bool v658;
                                            v658 = v657 >= 100;
                                            if (v658){
                                                printf("%s"," ...");
                                                break;
                                            } else {
                                            }
                                            bool v659;
                                            v659 = v655 == 0;
                                            bool v660;
                                            v660 = v659 != true;
                                            if (v660){
                                                printf("%s","; ");
                                            } else {
                                            }
                                            printf("%c",'[');
                                            int v661;
                                            v661 = 0;
                                            while (while_method_3(v661)){
                                                int v663;
                                                v663 = v654;
                                                bool v664;
                                                v664 = v663 >= 100;
                                                if (v664){
                                                    printf("%s"," ...");
                                                    break;
                                                } else {
                                                }
                                                bool v665;
                                                v665 = v661 == 0;
                                                bool v666;
                                                v666 = v665 != true;
                                                if (v666){
                                                    printf("%s","; ");
                                                } else {
                                                }
                                                int v667;
                                                v667 = v654 + 1;
                                                v654 = v667;
                                                int v668;
                                                v668 = v655 * 4;
                                                int v669;
                                                v669 = v668 + v661;
                                                float v670;
                                                v670 = v611[v669];
                                                bool v671;
                                                v671 = v612[v669];
                                                const char * v674;
                                                if (v671){
                                                    const char * v672;
                                                    v672 = "true";
                                                    v674 = v672;
                                                } else {
                                                    const char * v673;
                                                    v673 = "false";
                                                    v674 = v673;
                                                }
                                                printf("%f, %s",v670, v674);
                                                v661 += 1 ;
                                            }
                                            printf("%c",']');
                                            v655 += 1 ;
                                        }
                                        printf("%c",']');
                                        printf("}\n");
                                        v652.release();
                                        v653.sync() ;
                                    } else {
                                    }
                                    if (v647){
                                        assert("The local reduce must be true." && v646);
                                    } else {
                                    }
                                    float v710[4];
                                    int v711[4];
                                    int v712;
                                    v712 = 0;
                                    while (while_method_6(v712)){
                                        int v714;
                                        v714 = 0;
                                        while (while_method_3(v714)){
                                            assert("Tensor range check" && 0 <= v712 && v712 < 1);
                                            assert("Tensor range check" && 0 <= v714 && v714 < 4);
                                            int v716;
                                            v716 = 4 * v712;
                                            int v717;
                                            v717 = v716 + v714;
                                            int v718;
                                            v718 = v549[v717];
                                            float v719;
                                            v719 = curand_uniform(&v180);
                                            assert("Tensor range check" && 0 <= v712 && v712 < 1);
                                            assert("Tensor range check" && 0 <= v714 && v714 < 4);
                                            v710[v717] = v719;
                                            v711[v717] = v718;
                                            v714 += 1 ;
                                        }
                                        v712 += 1 ;
                                    }
                                    float v720; int v721;
                                    Tuple15 tmp146 = Tuple15{0.0f, 2147483647};
                                    v720 = tmp146.v0; v721 = tmp146.v1;
                                    int v722;
                                    v722 = 0;
                                    while (while_method_6(v722)){
                                        int v724;
                                        v724 = 0;
                                        while (while_method_3(v724)){
                                            assert("Tensor range check" && 0 <= v722 && v722 < 1);
                                            assert("Tensor range check" && 0 <= v724 && v724 < 4);
                                            int v726;
                                            v726 = 4 * v722;
                                            int v727;
                                            v727 = v726 + v724;
                                            float v728;
                                            v728 = v710[v727];
                                            int v729;
                                            v729 = v711[v727];
                                            bool v730;
                                            v730 = v721 < v729;
                                            float v731; int v732;
                                            if (v730){
                                                v731 = v720; v732 = v721;
                                            } else {
                                                v731 = v728; v732 = v729;
                                            }
                                            v720 = v731;
                                            v721 = v732;
                                            v724 += 1 ;
                                        }
                                        v722 += 1 ;
                                    }
                                    auto v733 = cooperative_groups::coalesced_threads();
                                    int v734;
                                    v734 = threadIdx.x;
                                    int v735;
                                    v735 = v734 / 16;
                                    auto v736 = cooperative_groups::labeled_partition(v733,v735);
                                    Closure4 v737{};
                                    float v738; int v739;
                                    Tuple15 tmp147 = cooperative_groups::reduce(v736, Tuple15{v720, v721}, v737);
                                    v738 = tmp147.v0; v739 = tmp147.v1;
                                    float v740;
                                    v740 = v645 * v738;
                                    int v741[4];
                                    bool v742[4];
                                    int v743;
                                    v743 = 0;
                                    while (while_method_6(v743)){
                                        int v745;
                                        v745 = 0;
                                        while (while_method_3(v745)){
                                            assert("Tensor range check" && 0 <= v743 && v743 < 1);
                                            assert("Tensor range check" && 0 <= v745 && v745 < 4);
                                            int v747;
                                            v747 = 4 * v743;
                                            int v748;
                                            v748 = v747 + v745;
                                            float v749;
                                            v749 = v611[v748];
                                            bool v750;
                                            v750 = v612[v748];
                                            int v751;
                                            v751 = v549[v748];
                                            int v754; bool v755;
                                            if (v750){
                                                float v752;
                                                v752 = v749 - v740;
                                                bool v753;
                                                v753 = v752 >= 0.0f;
                                                v754 = v751; v755 = v753;
                                            } else {
                                                v754 = 2147483647; v755 = false;
                                            }
                                            assert("Tensor range check" && 0 <= v743 && v743 < 1);
                                            assert("Tensor range check" && 0 <= v745 && v745 < 4);
                                            v741[v748] = v754;
                                            v742[v748] = v755;
                                            v745 += 1 ;
                                        }
                                        v743 += 1 ;
                                    }
                                    int v756; bool v757;
                                    Tuple16 tmp148 = Tuple16{2147483647, false};
                                    v756 = tmp148.v0; v757 = tmp148.v1;
                                    int v758;
                                    v758 = 0;
                                    while (while_method_6(v758)){
                                        int v760;
                                        v760 = 0;
                                        while (while_method_3(v760)){
                                            assert("Tensor range check" && 0 <= v758 && v758 < 1);
                                            assert("Tensor range check" && 0 <= v760 && v760 < 4);
                                            int v762;
                                            v762 = 4 * v758;
                                            int v763;
                                            v763 = v762 + v760;
                                            int v764;
                                            v764 = v741[v763];
                                            bool v765;
                                            v765 = v742[v763];
                                            int v772; bool v773;
                                            if (v757){
                                                if (v765){
                                                    bool v766;
                                                    v766 = v756 < v764;
                                                    int v767;
                                                    if (v766){
                                                        v767 = v756;
                                                    } else {
                                                        v767 = v764;
                                                    }
                                                    v772 = v767; v773 = true;
                                                } else {
                                                    v772 = v756; v773 = v757;
                                                }
                                            } else {
                                                if (v765){
                                                    v772 = v764; v773 = v765;
                                                } else {
                                                    v772 = v756; v773 = v757;
                                                }
                                            }
                                            v756 = v772;
                                            v757 = v773;
                                            v760 += 1 ;
                                        }
                                        v758 += 1 ;
                                    }
                                    auto v774 = cooperative_groups::coalesced_threads();
                                    int v775;
                                    v775 = threadIdx.x;
                                    int v776;
                                    v776 = v775 / 16;
                                    auto v777 = cooperative_groups::labeled_partition(v774,v776);
                                    Closure5 v778{};
                                    int v779; bool v780;
                                    Tuple16 tmp149 = cooperative_groups::reduce(v777, Tuple16{v756, v757}, v778);
                                    v779 = tmp149.v0; v780 = tmp149.v1;
                                    bool v781;
                                    v781 = v780 == false;
                                    if (v781){
                                        int v782;
                                        v782 = threadIdx.x;
                                        int v783;
                                        v783 = blockIdx.x;
                                        int v784;
                                        v784 = v783 * 256;
                                        int v785;
                                        v785 = v782 + v784;
                                        cuda::counting_semaphore<cuda::thread_scope_system, 1> & v786 = console_lock;
                                        auto v787 = cooperative_groups::coalesced_threads();
                                        v786.acquire();
                                        int v788;
                                        v788 = 0;
                                        printf("{%s = %d; %s = %c","tid", v785, "x'", '[');
                                        int v789;
                                        v789 = 0;
                                        while (while_method_6(v789)){
                                            int v791;
                                            v791 = v788;
                                            bool v792;
                                            v792 = v791 >= 100;
                                            if (v792){
                                                printf("%s"," ...");
                                                break;
                                            } else {
                                            }
                                            bool v793;
                                            v793 = v789 == 0;
                                            bool v794;
                                            v794 = v793 != true;
                                            if (v794){
                                                printf("%s","; ");
                                            } else {
                                            }
                                            printf("%c",'[');
                                            int v795;
                                            v795 = 0;
                                            while (while_method_3(v795)){
                                                int v797;
                                                v797 = v788;
                                                bool v798;
                                                v798 = v797 >= 100;
                                                if (v798){
                                                    printf("%s"," ...");
                                                    break;
                                                } else {
                                                }
                                                bool v799;
                                                v799 = v795 == 0;
                                                bool v800;
                                                v800 = v799 != true;
                                                if (v800){
                                                    printf("%s","; ");
                                                } else {
                                                }
                                                int v801;
                                                v801 = v788 + 1;
                                                v788 = v801;
                                                int v802;
                                                v802 = v789 * 4;
                                                int v803;
                                                v803 = v802 + v795;
                                                int v804;
                                                v804 = v741[v803];
                                                bool v805;
                                                v805 = v742[v803];
                                                const char * v808;
                                                if (v805){
                                                    const char * v806;
                                                    v806 = "true";
                                                    v808 = v806;
                                                } else {
                                                    const char * v807;
                                                    v807 = "false";
                                                    v808 = v807;
                                                }
                                                printf("%d, %s",v804, v808);
                                                v795 += 1 ;
                                            }
                                            printf("%c",']');
                                            v789 += 1 ;
                                        }
                                        printf("%c",']');
                                        printf("}\n");
                                        v786.release();
                                        v787.sync() ;
                                    } else {
                                    }
                                    if (v781){
                                        assert("The local reduce must be true." && v780);
                                    } else {
                                    }
                                    float v844; int v845;
                                    Tuple15 tmp150 = Tuple15{0.0f, 2147483647};
                                    v844 = tmp150.v0; v845 = tmp150.v1;
                                    int v846;
                                    v846 = 0;
                                    while (while_method_6(v846)){
                                        int v848;
                                        v848 = 0;
                                        while (while_method_3(v848)){
                                            assert("Tensor range check" && 0 <= v846 && v846 < 1);
                                            assert("Tensor range check" && 0 <= v848 && v848 < 4);
                                            int v850;
                                            v850 = 4 * v846;
                                            int v851;
                                            v851 = v850 + v848;
                                            float v852;
                                            v852 = v548[v851];
                                            int v853;
                                            v853 = v549[v851];
                                            bool v854;
                                            v854 = v845 == v779;
                                            float v858; int v859;
                                            if (v854){
                                                v858 = v844; v859 = v845;
                                            } else {
                                                bool v855;
                                                v855 = v853 == v779;
                                                if (v855){
                                                    v858 = v852; v859 = v853;
                                                } else {
                                                    v858 = v844; v859 = v845;
                                                }
                                            }
                                            v844 = v858;
                                            v845 = v859;
                                            v848 += 1 ;
                                        }
                                        v846 += 1 ;
                                    }
                                    auto v860 = cooperative_groups::coalesced_threads();
                                    int v861;
                                    v861 = threadIdx.x;
                                    int v862;
                                    v862 = v861 / 16;
                                    auto v863 = cooperative_groups::labeled_partition(v860,v862);
                                    Closure6 v864{v779};
                                    float v865; int v866;
                                    Tuple15 tmp151 = cooperative_groups::reduce(v863, Tuple15{v844, v845}, v864);
                                    v865 = tmp151.v0; v866 = tmp151.v1;
                                    bool v867;
                                    v867 = v866 == 2147483647;
                                    bool v868;
                                    v868 = v867 != true;
                                    bool v869;
                                    v869 = v868 == false;
                                    if (v869){
                                        assert("Expected a valid action id in get_prob." && v868);
                                    } else {
                                    }
                                    int v871;
                                    v871 = 0;
                                    while (while_method_6(v871)){
                                        assert("Tensor range check" && 0 <= v871 && v871 < 1);
                                        assert("Tensor range check" && 0 <= v871 && v871 < 1);
                                        v871 += 1 ;
                                    }
                                    assert("Tensor range check" && 0 <= v540 && v540 < 256);
                                    v515[v540] = v865;
                                    v517[v540] = v779;
                                    v528 += 1 ;
                                }
                                __syncthreads();
                                assert("Tensor range check" && 0 <= v519 && v519 < 256);
                                float v873;
                                v873 = v515[v519];
                                int v874;
                                v874 = v517[v519];
                                __syncthreads();
                                extern __shared__ unsigned char v875[];
                                float * v876;
                                v876 = reinterpret_cast<float *>(&v875[0ull]);
                                int * v878;
                                v878 = reinterpret_cast<int *>(&v875[16ull]);
                                int v880;
                                v880 = threadIdx.x;
                                bool v881;
                                v881 = v880 == 0;
                                if (v881){
                                    v876[0] = v873;
                                    v878[0] = v874;
                                } else {
                                }
                                __syncthreads();
                                float v882;
                                v882 = v876[0];
                                int v883;
                                v883 = v878[0];
                                __syncthreads();
                                double * v884;
                                v884 = reinterpret_cast<double *>(&v1[121110528ull]);
                                double * v886;
                                v886 = reinterpret_cast<double *>(&v1[121503744ull]);
                                int v888;
                                v888 = threadIdx.x;
                                int v889;
                                v889 = blockIdx.x;
                                int v890;
                                v890 = v889 * 256;
                                int v891;
                                v891 = v888 + v890;
                                int v892;
                                v892 = 0;
                                while (while_method_3(v892)){
                                    float * v894;
                                    v894 = reinterpret_cast<float *>(&v1[114819072ull]);
                                    int v896;
                                    v896 = blockIdx.x;
                                    int v897;
                                    v897 = threadIdx.x;
                                    assert("Tensor range check" && 0 <= v892 && v892 < 4);
                                    assert("Tensor range check" && 0 <= v896 && v896 < 24);
                                    assert("Tensor range check" && 0 <= v897 && v897 < 256);
                                    assert("Tensor range check" && 0 <= v883 && v883 < 64);
                                    int v898;
                                    v898 = 64 * v897;
                                    int v899;
                                    v899 = v898 + v883;
                                    int v900;
                                    v900 = 16384 * v896;
                                    int v901;
                                    v901 = v900 + v899;
                                    int v902;
                                    v902 = 393216 * v892;
                                    int v903;
                                    v903 = v902 + v901;
                                    float v904;
                                    v904 = v894[v903];
                                    double v905;
                                    v905 = (double)v882;
                                    double v906;
                                    v906 = log(v905);
                                    double v907;
                                    v907 = (double)v904;
                                    double v908;
                                    v908 = log(v907);
                                    assert("Tensor range check" && 0 <= v892 && v892 < 4);
                                    assert("Tensor range check" && 0 <= v891 && v891 < 6144);
                                    assert("Tensor range check" && 0 <= v168 && v168 < 2);
                                    int v909;
                                    v909 = 2 * v891;
                                    int v910;
                                    v910 = v909 + v168;
                                    int v911;
                                    v911 = 12288 * v892;
                                    int v912;
                                    v912 = v911 + v910;
                                    double v913;
                                    v913 = v884[v912];
                                    double v914;
                                    v914 = v886[v912];
                                    double v915;
                                    v915 = v908 + v913;
                                    double v916;
                                    v916 = v906 + v914;
                                    bool v917;
                                    v917 = isnan(v916);
                                    bool v918;
                                    v918 = v917 == false;
                                    bool v919;
                                    v919 = v918 == false;
                                    if (v919){
                                        assert("The sampling log probability shouldn't be nan." && v918);
                                    } else {
                                    }
                                    bool v921;
                                    v921 = isnan(v915);
                                    bool v922;
                                    v922 = v921 == false;
                                    bool v923;
                                    v923 = v922 == false;
                                    if (v923){
                                        assert("The policy log probability shouldn't be nan." && v922);
                                    } else {
                                    }
                                    assert("Tensor range check" && 0 <= v892 && v892 < 4);
                                    assert("Tensor range check" && 0 <= v891 && v891 < 6144);
                                    assert("Tensor range check" && 0 <= v168 && v168 < 2);
                                    v884[v912] = v915;
                                    v886[v912] = v916;
                                    v892 += 1 ;
                                }
                                bool v925;
                                v925 = 0 == v883;
                                Union10 v934;
                                if (v925){
                                    v934 = Union10{Union10_1{}};
                                } else {
                                    bool v927;
                                    v927 = 1 == v883;
                                    if (v927){
                                        v934 = Union10{Union10_0{}};
                                    } else {
                                        bool v929;
                                        v929 = 2 == v883;
                                        if (v929){
                                            v934 = Union10{Union10_2{1, 1}};
                                        } else {
                                            printf("%s\n", "Invalid output id in the NL Holdem model.");
                                            __trap();
                                        }
                                    }
                                }
                                switch (v934.tag) {
                                    case 0: { // AA_Call
                                        v1222 = Union1{Union1_1{}};
                                        break;
                                    }
                                    case 1: { // AA_Fold
                                        int v935;
                                        v935 = v164[0];
                                        int v937; int v938;
                                        Tuple4 tmp152 = Tuple4{1, v935};
                                        v937 = tmp152.v0; v938 = tmp152.v1;
                                        while (while_method_0(v937)){
                                            bool v940;
                                            v940 = 0 <= v937;
                                            bool v942;
                                            if (v940){
                                                bool v941;
                                                v941 = v937 < 2;
                                                v942 = v941;
                                            } else {
                                                v942 = false;
                                            }
                                            bool v943;
                                            v943 = v942 == false;
                                            if (v943){
                                                assert("Index must be in range." && v942);
                                            } else {
                                            }
                                            int v945;
                                            v945 = v164[v937];
                                            bool v947;
                                            v947 = v938 >= v945;
                                            int v948;
                                            if (v947){
                                                v948 = v938;
                                            } else {
                                                v948 = v945;
                                            }
                                            v938 = v948;
                                            v937 += 1 ;
                                        }
                                        bool v950;
                                        if (v170){
                                            bool v949;
                                            v949 = v168 < 2;
                                            v950 = v949;
                                        } else {
                                            v950 = false;
                                        }
                                        bool v951;
                                        v951 = v950 == false;
                                        if (v951){
                                            assert("Index must be in range." && v950);
                                        } else {
                                        }
                                        int v953;
                                        v953 = v164[v168];
                                        bool v955;
                                        v955 = v953 == v938;
                                        if (v955){
                                            v1222 = Union1{Union1_1{}};
                                        } else {
                                            v1222 = Union1{Union1_2{}};
                                        }
                                        break;
                                    }
                                    case 2: { // AA_Raise
                                        int v960 = v934.case2.v0; int v961 = v934.case2.v1;
                                        static_array<int,2> v962;
                                        int v964;
                                        v964 = 0;
                                        while (while_method_0(v964)){
                                            bool v966;
                                            v966 = 0 <= v964;
                                            bool v968;
                                            if (v966){
                                                bool v967;
                                                v967 = v964 < 2;
                                                v968 = v967;
                                            } else {
                                                v968 = false;
                                            }
                                            bool v969;
                                            v969 = v968 == false;
                                            if (v969){
                                                assert("Index must be in range." && v968);
                                            } else {
                                            }
                                            int v971;
                                            v971 = v166[v964];
                                            bool v974;
                                            if (v966){
                                                bool v973;
                                                v973 = v964 < 2;
                                                v974 = v973;
                                            } else {
                                                v974 = false;
                                            }
                                            bool v975;
                                            v975 = v974 == false;
                                            if (v975){
                                                assert("Index must be in range." && v974);
                                            } else {
                                            }
                                            int v977;
                                            v977 = v164[v964];
                                            int v979;
                                            v979 = v971 + v977;
                                            v962[v964] = v979;
                                            v964 += 1 ;
                                        }
                                        int v980;
                                        v980 = v164[0];
                                        int v982; int v983;
                                        Tuple4 tmp153 = Tuple4{1, v980};
                                        v982 = tmp153.v0; v983 = tmp153.v1;
                                        while (while_method_0(v982)){
                                            bool v985;
                                            v985 = 0 <= v982;
                                            bool v987;
                                            if (v985){
                                                bool v986;
                                                v986 = v982 < 2;
                                                v987 = v986;
                                            } else {
                                                v987 = false;
                                            }
                                            bool v988;
                                            v988 = v987 == false;
                                            if (v988){
                                                assert("Index must be in range." && v987);
                                            } else {
                                            }
                                            int v990;
                                            v990 = v164[v982];
                                            bool v992;
                                            v992 = v983 >= v990;
                                            int v993;
                                            if (v992){
                                                v993 = v983;
                                            } else {
                                                v993 = v990;
                                            }
                                            v983 = v993;
                                            v982 += 1 ;
                                        }
                                        bool v995;
                                        if (v170){
                                            bool v994;
                                            v994 = v168 < 2;
                                            v995 = v994;
                                        } else {
                                            v995 = false;
                                        }
                                        bool v996;
                                        v996 = v995 == false;
                                        if (v996){
                                            assert("Index must be in range." && v995);
                                        } else {
                                        }
                                        int v998;
                                        v998 = v962[v168];
                                        bool v1000;
                                        v1000 = v983 < v998;
                                        int v1001;
                                        if (v1000){
                                            v1001 = v983;
                                        } else {
                                            v1001 = v998;
                                        }
                                        static_array<int,2> v1002;
                                        int v1004;
                                        v1004 = 0;
                                        while (while_method_0(v1004)){
                                            bool v1006;
                                            v1006 = 0 <= v1004;
                                            bool v1008;
                                            if (v1006){
                                                bool v1007;
                                                v1007 = v1004 < 2;
                                                v1008 = v1007;
                                            } else {
                                                v1008 = false;
                                            }
                                            bool v1009;
                                            v1009 = v1008 == false;
                                            if (v1009){
                                                assert("Index must be in range." && v1008);
                                            } else {
                                            }
                                            int v1011;
                                            v1011 = v164[v1004];
                                            bool v1013;
                                            v1013 = v168 == v1004;
                                            int v1014;
                                            if (v1013){
                                                v1014 = v1001;
                                            } else {
                                                v1014 = v1011;
                                            }
                                            v1002[v1004] = v1014;
                                            v1004 += 1 ;
                                        }
                                        int v1015;
                                        v1015 = v1002[0];
                                        int v1017; int v1018;
                                        Tuple4 tmp154 = Tuple4{1, v1015};
                                        v1017 = tmp154.v0; v1018 = tmp154.v1;
                                        while (while_method_0(v1017)){
                                            bool v1020;
                                            v1020 = 0 <= v1017;
                                            bool v1022;
                                            if (v1020){
                                                bool v1021;
                                                v1021 = v1017 < 2;
                                                v1022 = v1021;
                                            } else {
                                                v1022 = false;
                                            }
                                            bool v1023;
                                            v1023 = v1022 == false;
                                            if (v1023){
                                                assert("Index must be in range." && v1022);
                                            } else {
                                            }
                                            int v1025;
                                            v1025 = v1002[v1017];
                                            int v1027;
                                            v1027 = v1018 + v1025;
                                            v1018 = v1027;
                                            v1017 += 1 ;
                                        }
                                        static_array<int,2> v1028;
                                        int v1030;
                                        v1030 = 0;
                                        while (while_method_0(v1030)){
                                            bool v1032;
                                            v1032 = 0 <= v1030;
                                            bool v1034;
                                            if (v1032){
                                                bool v1033;
                                                v1033 = v1030 < 2;
                                                v1034 = v1033;
                                            } else {
                                                v1034 = false;
                                            }
                                            bool v1035;
                                            v1035 = v1034 == false;
                                            if (v1035){
                                                assert("Index must be in range." && v1034);
                                            } else {
                                            }
                                            int v1037;
                                            v1037 = v962[v1030];
                                            bool v1040;
                                            if (v1032){
                                                bool v1039;
                                                v1039 = v1030 < 2;
                                                v1040 = v1039;
                                            } else {
                                                v1040 = false;
                                            }
                                            bool v1041;
                                            v1041 = v1040 == false;
                                            if (v1041){
                                                assert("Index must be in range." && v1040);
                                            } else {
                                            }
                                            int v1043;
                                            v1043 = v1002[v1030];
                                            int v1045;
                                            v1045 = v1037 - v1043;
                                            v1028[v1030] = v1045;
                                            v1030 += 1 ;
                                        }
                                        int v1046;
                                        v1046 = v960 * v1018;
                                        int v1047;
                                        v1047 = v1046 / v961;
                                        bool v1048;
                                        v1048 = v162 >= v1047;
                                        int v1049;
                                        if (v1048){
                                            v1049 = v162;
                                        } else {
                                            v1049 = v1047;
                                        }
                                        bool v1051;
                                        if (v170){
                                            bool v1050;
                                            v1050 = v168 < 2;
                                            v1051 = v1050;
                                        } else {
                                            v1051 = false;
                                        }
                                        bool v1052;
                                        v1052 = v1051 == false;
                                        if (v1052){
                                            assert("Index must be in range." && v1051);
                                        } else {
                                        }
                                        int v1054;
                                        v1054 = v1028[v168];
                                        bool v1056;
                                        v1056 = v1049 >= v1054;
                                        if (v1056){
                                            v1222 = Union1{Union1_0{}};
                                        } else {
                                            v1222 = Union1{Union1_3{v1049}};
                                        }
                                        break;
                                    }
                                    default: {
                                        assert("Invalid tag." && false); __trap();
                                    }
                                }
                                break;
                            }
                            case 2: { // Human
                                printf("%s\n", "Humans aren't allowed during training.");
                                __trap();
                                break;
                            }
                            case 3: { // Random
                                curandStatePhilox4_32_10_t & v1063 = v3.v5;
                                curandStatePhilox4_32_10_t & v1064 = v1063;
                                static_array<int,2> v1065;
                                int v1067;
                                v1067 = 0;
                                while (while_method_0(v1067)){
                                    bool v1069;
                                    v1069 = 0 <= v1067;
                                    bool v1071;
                                    if (v1069){
                                        bool v1070;
                                        v1070 = v1067 < 2;
                                        v1071 = v1070;
                                    } else {
                                        v1071 = false;
                                    }
                                    bool v1072;
                                    v1072 = v1071 == false;
                                    if (v1072){
                                        assert("Index must be in range." && v1071);
                                    } else {
                                    }
                                    int v1074;
                                    v1074 = v166[v1067];
                                    bool v1077;
                                    if (v1069){
                                        bool v1076;
                                        v1076 = v1067 < 2;
                                        v1077 = v1076;
                                    } else {
                                        v1077 = false;
                                    }
                                    bool v1078;
                                    v1078 = v1077 == false;
                                    if (v1078){
                                        assert("Index must be in range." && v1077);
                                    } else {
                                    }
                                    int v1080;
                                    v1080 = v164[v1067];
                                    int v1082;
                                    v1082 = v1074 + v1080;
                                    v1065[v1067] = v1082;
                                    v1067 += 1 ;
                                }
                                int v1083;
                                v1083 = v164[0];
                                int v1085; int v1086;
                                Tuple4 tmp155 = Tuple4{1, v1083};
                                v1085 = tmp155.v0; v1086 = tmp155.v1;
                                while (while_method_0(v1085)){
                                    bool v1088;
                                    v1088 = 0 <= v1085;
                                    bool v1090;
                                    if (v1088){
                                        bool v1089;
                                        v1089 = v1085 < 2;
                                        v1090 = v1089;
                                    } else {
                                        v1090 = false;
                                    }
                                    bool v1091;
                                    v1091 = v1090 == false;
                                    if (v1091){
                                        assert("Index must be in range." && v1090);
                                    } else {
                                    }
                                    int v1093;
                                    v1093 = v164[v1085];
                                    bool v1095;
                                    v1095 = v1086 >= v1093;
                                    int v1096;
                                    if (v1095){
                                        v1096 = v1086;
                                    } else {
                                        v1096 = v1093;
                                    }
                                    v1086 = v1096;
                                    v1085 += 1 ;
                                }
                                bool v1098;
                                if (v170){
                                    bool v1097;
                                    v1097 = v168 < 2;
                                    v1098 = v1097;
                                } else {
                                    v1098 = false;
                                }
                                bool v1099;
                                v1099 = v1098 == false;
                                if (v1099){
                                    assert("Index must be in range." && v1098);
                                } else {
                                }
                                int v1101;
                                v1101 = v1065[v168];
                                bool v1103;
                                v1103 = v1086 < v1101;
                                int v1104;
                                if (v1103){
                                    v1104 = v1086;
                                } else {
                                    v1104 = v1101;
                                }
                                static_array<int,2> v1105;
                                int v1107;
                                v1107 = 0;
                                while (while_method_0(v1107)){
                                    bool v1109;
                                    v1109 = 0 <= v1107;
                                    bool v1111;
                                    if (v1109){
                                        bool v1110;
                                        v1110 = v1107 < 2;
                                        v1111 = v1110;
                                    } else {
                                        v1111 = false;
                                    }
                                    bool v1112;
                                    v1112 = v1111 == false;
                                    if (v1112){
                                        assert("Index must be in range." && v1111);
                                    } else {
                                    }
                                    int v1114;
                                    v1114 = v164[v1107];
                                    bool v1116;
                                    v1116 = v168 == v1107;
                                    int v1117;
                                    if (v1116){
                                        v1117 = v1104;
                                    } else {
                                        v1117 = v1114;
                                    }
                                    v1105[v1107] = v1117;
                                    v1107 += 1 ;
                                }
                                int v1118;
                                v1118 = v1105[0];
                                int v1120; int v1121;
                                Tuple4 tmp156 = Tuple4{1, v1118};
                                v1120 = tmp156.v0; v1121 = tmp156.v1;
                                while (while_method_0(v1120)){
                                    bool v1123;
                                    v1123 = 0 <= v1120;
                                    bool v1125;
                                    if (v1123){
                                        bool v1124;
                                        v1124 = v1120 < 2;
                                        v1125 = v1124;
                                    } else {
                                        v1125 = false;
                                    }
                                    bool v1126;
                                    v1126 = v1125 == false;
                                    if (v1126){
                                        assert("Index must be in range." && v1125);
                                    } else {
                                    }
                                    int v1128;
                                    v1128 = v1105[v1120];
                                    int v1130;
                                    v1130 = v1121 + v1128;
                                    v1121 = v1130;
                                    v1120 += 1 ;
                                }
                                static_array<int,2> v1131;
                                int v1133;
                                v1133 = 0;
                                while (while_method_0(v1133)){
                                    bool v1135;
                                    v1135 = 0 <= v1133;
                                    bool v1137;
                                    if (v1135){
                                        bool v1136;
                                        v1136 = v1133 < 2;
                                        v1137 = v1136;
                                    } else {
                                        v1137 = false;
                                    }
                                    bool v1138;
                                    v1138 = v1137 == false;
                                    if (v1138){
                                        assert("Index must be in range." && v1137);
                                    } else {
                                    }
                                    int v1140;
                                    v1140 = v1065[v1133];
                                    bool v1143;
                                    if (v1135){
                                        bool v1142;
                                        v1142 = v1133 < 2;
                                        v1143 = v1142;
                                    } else {
                                        v1143 = false;
                                    }
                                    bool v1144;
                                    v1144 = v1143 == false;
                                    if (v1144){
                                        assert("Index must be in range." && v1143);
                                    } else {
                                    }
                                    int v1146;
                                    v1146 = v1105[v1133];
                                    int v1148;
                                    v1148 = v1140 - v1146;
                                    v1131[v1133] = v1148;
                                    v1133 += 1 ;
                                }
                                bool v1150;
                                if (v170){
                                    bool v1149;
                                    v1149 = v168 < 2;
                                    v1150 = v1149;
                                } else {
                                    v1150 = false;
                                }
                                bool v1151;
                                v1151 = v1150 == false;
                                if (v1151){
                                    assert("Index must be in range." && v1150);
                                } else {
                                }
                                int v1153;
                                v1153 = v164[v168];
                                bool v1155;
                                v1155 = v1153 < v1086;
                                float v1156;
                                if (v1155){
                                    v1156 = 1.0f;
                                } else {
                                    v1156 = 0.0f;
                                }
                                int v1157;
                                v1157 = v1121 / 3;
                                bool v1158;
                                v1158 = v162 <= v1157;
                                bool v1166;
                                if (v1158){
                                    bool v1160;
                                    if (v170){
                                        bool v1159;
                                        v1159 = v168 < 2;
                                        v1160 = v1159;
                                    } else {
                                        v1160 = false;
                                    }
                                    bool v1161;
                                    v1161 = v1160 == false;
                                    if (v1161){
                                        assert("Index must be in range." && v1160);
                                    } else {
                                    }
                                    int v1163;
                                    v1163 = v1131[v168];
                                    bool v1165;
                                    v1165 = v1157 < v1163;
                                    v1166 = v1165;
                                } else {
                                    v1166 = false;
                                }
                                float v1167;
                                if (v1166){
                                    v1167 = 1.0f;
                                } else {
                                    v1167 = 0.0f;
                                }
                                int v1168;
                                v1168 = v1121 / 2;
                                bool v1169;
                                v1169 = v162 <= v1168;
                                bool v1177;
                                if (v1169){
                                    bool v1171;
                                    if (v170){
                                        bool v1170;
                                        v1170 = v168 < 2;
                                        v1171 = v1170;
                                    } else {
                                        v1171 = false;
                                    }
                                    bool v1172;
                                    v1172 = v1171 == false;
                                    if (v1172){
                                        assert("Index must be in range." && v1171);
                                    } else {
                                    }
                                    int v1174;
                                    v1174 = v1131[v168];
                                    bool v1176;
                                    v1176 = v1168 < v1174;
                                    v1177 = v1176;
                                } else {
                                    v1177 = false;
                                }
                                float v1178;
                                if (v1177){
                                    v1178 = 1.0f;
                                } else {
                                    v1178 = 0.0f;
                                }
                                bool v1179;
                                v1179 = v162 <= v1121;
                                bool v1187;
                                if (v1179){
                                    bool v1181;
                                    if (v170){
                                        bool v1180;
                                        v1180 = v168 < 2;
                                        v1181 = v1180;
                                    } else {
                                        v1181 = false;
                                    }
                                    bool v1182;
                                    v1182 = v1181 == false;
                                    if (v1182){
                                        assert("Index must be in range." && v1181);
                                    } else {
                                    }
                                    int v1184;
                                    v1184 = v1131[v168];
                                    bool v1186;
                                    v1186 = v1121 < v1184;
                                    v1187 = v1186;
                                } else {
                                    v1187 = false;
                                }
                                float v1188;
                                if (v1187){
                                    v1188 = 1.0f;
                                } else {
                                    v1188 = 0.0f;
                                }
                                static_array<Tuple17,6> v1189;
                                Union1 v1191;
                                v1191 = Union1{Union1_2{}};
                                v1189[0] = Tuple17{v1191, v1156};
                                Union1 v1193;
                                v1193 = Union1{Union1_1{}};
                                v1189[1] = Tuple17{v1193, 4.0f};
                                Union1 v1195;
                                v1195 = Union1{Union1_3{v1157}};
                                v1189[2] = Tuple17{v1195, v1167};
                                Union1 v1197;
                                v1197 = Union1{Union1_3{v1168}};
                                v1189[3] = Tuple17{v1197, v1178};
                                Union1 v1199;
                                v1199 = Union1{Union1_3{v1121}};
                                v1189[4] = Tuple17{v1199, v1188};
                                Union1 v1201;
                                v1201 = Union1{Union1_0{}};
                                v1189[5] = Tuple17{v1201, 1.0f};
                                Union1 v1203;
                                v1203 = sample_discrete_50(v1189, v1064);
                                int v1204;
                                v1204 = sizeof(Union1);
                                unsigned long long v1205;
                                v1205 = (unsigned long long)v1204;
                                bool v1206;
                                v1206 = v1205 <= 98304ull;
                                bool v1207;
                                v1207 = v1206 == false;
                                if (v1207){
                                    assert("The dynamic shared memory is insufficient to allocate the tensor." && v1206);
                                } else {
                                }
                                extern __shared__ unsigned char v1209[];
                                bool v1210;
                                v1210 = v1205 <= v1205;
                                bool v1211;
                                v1211 = v1210 == false;
                                if (v1211){
                                    assert("The length of the partition has to be less than or equal to the length of the base array." && v1210);
                                } else {
                                }
                                Union1 * v1213;
                                v1213 = reinterpret_cast<Union1 *>(&v1209[0ull]);
                                int v1215;
                                v1215 = threadIdx.x;
                                bool v1216;
                                v1216 = v1215 == 0;
                                if (v1216){
                                    v1213[0] = v1203;
                                } else {
                                }
                                __syncthreads();
                                Union1 v1217;
                                v1217 = v1213[0];
                                __syncthreads();
                                v1222 = v1217;
                                break;
                            }
                            default: {
                                assert("Invalid tag." && false); __trap();
                            }
                        }
                        Union6 v1223;
                        v1223 = Union6{Union6_2{v168, v1222}};
                        v14.push(v1223);
                        v1374 = Union18{Union18_1{v162, v163, v164, v165, v166, v167, v1222}};
                        break;
                    }
                    case 5: { // G_Round'
                        int v1225 = v19.case5.v0; static_array<static_array<unsigned char,2>,2> v1226 = v19.case5.v1; static_array<int,2> v1227 = v19.case5.v2; int v1228 = v19.case5.v3; static_array<int,2> v1229 = v19.case5.v4; Union5 v1230 = v19.case5.v5; Union1 v1231 = v19.case5.v6;
                        int v1232;
                        v1232 = v1228 % 2;
                        Union6 v1233;
                        v1233 = Union6{Union6_2{v1232, v1231}};
                        v14.push(v1233);
                        v1374 = Union18{Union18_1{v1225, v1226, v1227, v1228, v1229, v1230, v1231}};
                        break;
                    }
                    case 6: { // G_Showdown
                        int v43 = v19.case6.v0; static_array<static_array<unsigned char,2>,2> v44 = v19.case6.v1; static_array<int,2> v45 = v19.case6.v2; int v46 = v19.case6.v3; static_array<int,2> v47 = v19.case6.v4; Union5 v48 = v19.case6.v5;
                        static_array<unsigned char,5> v51;
                        switch (v48.tag) {
                            case 2: { // River
                                static_array<unsigned char,5> v49 = v48.case2.v0;
                                v51 = v49;
                                break;
                            }
                            default: {
                                printf("%s\n", "Invalid street in showdown.");
                                __trap();
                            }
                        }
                        static_array<unsigned char,2> v52;
                        v52 = v44[0];
                        static_array<unsigned char,7> v54;
                        int v56;
                        v56 = 0;
                        while (while_method_0(v56)){
                            bool v58;
                            v58 = 0 <= v56;
                            bool v60;
                            if (v58){
                                bool v59;
                                v59 = v56 < 2;
                                v60 = v59;
                            } else {
                                v60 = false;
                            }
                            bool v61;
                            v61 = v60 == false;
                            if (v61){
                                assert("Index must be in range." && v60);
                            } else {
                            }
                            unsigned char v63;
                            v63 = v52[v56];
                            v54[v56] = v63;
                            v56 += 1 ;
                        }
                        int v65;
                        v65 = 0;
                        while (while_method_2(v65)){
                            bool v67;
                            v67 = 0 <= v65;
                            bool v69;
                            if (v67){
                                bool v68;
                                v68 = v65 < 5;
                                v69 = v68;
                            } else {
                                v69 = false;
                            }
                            bool v70;
                            v70 = v69 == false;
                            if (v70){
                                assert("Index must be in range." && v69);
                            } else {
                            }
                            unsigned char v72;
                            v72 = v51[v65];
                            int v74;
                            v74 = 2 + v65;
                            v54[v74] = v72;
                            v65 += 1 ;
                        }
                        static_array<unsigned char,5> v75; char v76;
                        Tuple0 tmp157 = score_54(v54);
                        v75 = tmp157.v0; v76 = tmp157.v1;
                        static_array<unsigned char,2> v77;
                        v77 = v44[1];
                        static_array<unsigned char,7> v79;
                        int v81;
                        v81 = 0;
                        while (while_method_0(v81)){
                            bool v83;
                            v83 = 0 <= v81;
                            bool v85;
                            if (v83){
                                bool v84;
                                v84 = v81 < 2;
                                v85 = v84;
                            } else {
                                v85 = false;
                            }
                            bool v86;
                            v86 = v85 == false;
                            if (v86){
                                assert("Index must be in range." && v85);
                            } else {
                            }
                            unsigned char v88;
                            v88 = v77[v81];
                            v79[v81] = v88;
                            v81 += 1 ;
                        }
                        int v90;
                        v90 = 0;
                        while (while_method_2(v90)){
                            bool v92;
                            v92 = 0 <= v90;
                            bool v94;
                            if (v92){
                                bool v93;
                                v93 = v90 < 5;
                                v94 = v93;
                            } else {
                                v94 = false;
                            }
                            bool v95;
                            v95 = v94 == false;
                            if (v95){
                                assert("Index must be in range." && v94);
                            } else {
                            }
                            unsigned char v97;
                            v97 = v51[v90];
                            int v99;
                            v99 = 2 + v90;
                            v79[v99] = v97;
                            v90 += 1 ;
                        }
                        static_array<unsigned char,5> v100; char v101;
                        Tuple0 tmp158 = score_54(v79);
                        v100 = tmp158.v0; v101 = tmp158.v1;
                        int v102;
                        v102 = v46 % 2;
                        bool v103;
                        v103 = 0 <= v102;
                        bool v105;
                        if (v103){
                            bool v104;
                            v104 = v102 < 2;
                            v105 = v104;
                        } else {
                            v105 = false;
                        }
                        bool v106;
                        v106 = v105 == false;
                        if (v106){
                            assert("Index must be in range." && v105);
                        } else {
                        }
                        int v108;
                        v108 = v45[v102];
                        bool v110;
                        v110 = v76 < v101;
                        Union11 v116;
                        if (v110){
                            v116 = Union11{Union11_2{}};
                        } else {
                            bool v112;
                            v112 = v76 > v101;
                            if (v112){
                                v116 = Union11{Union11_1{}};
                            } else {
                                v116 = Union11{Union11_0{}};
                            }
                        }
                        Union11 v144;
                        switch (v116.tag) {
                            case 0: { // Eq
                                Union11 v117;
                                v117 = Union11{Union11_0{}};
                                int v118;
                                v118 = 0;
                                while (while_method_2(v118)){
                                    bool v120;
                                    v120 = 0 <= v118;
                                    bool v122;
                                    if (v120){
                                        bool v121;
                                        v121 = v118 < 5;
                                        v122 = v121;
                                    } else {
                                        v122 = false;
                                    }
                                    bool v123;
                                    v123 = v122 == false;
                                    if (v123){
                                        assert("Index must be in range." && v122);
                                    } else {
                                    }
                                    unsigned char v125;
                                    v125 = v75[v118];
                                    bool v128;
                                    if (v120){
                                        bool v127;
                                        v127 = v118 < 5;
                                        v128 = v127;
                                    } else {
                                        v128 = false;
                                    }
                                    bool v129;
                                    v129 = v128 == false;
                                    if (v129){
                                        assert("Index must be in range." && v128);
                                    } else {
                                    }
                                    unsigned char v131;
                                    v131 = v100[v118];
                                    unsigned char v133;
                                    v133 = v125 / 4u;
                                    unsigned char v134;
                                    v134 = v131 / 4u;
                                    bool v135;
                                    v135 = v133 < v134;
                                    Union11 v141;
                                    if (v135){
                                        v141 = Union11{Union11_2{}};
                                    } else {
                                        bool v137;
                                        v137 = v133 > v134;
                                        if (v137){
                                            v141 = Union11{Union11_1{}};
                                        } else {
                                            v141 = Union11{Union11_0{}};
                                        }
                                    }
                                    bool v142;
                                    switch (v141.tag) {
                                        case 0: { // Eq
                                            v142 = true;
                                            break;
                                        }
                                        default: {
                                            v142 = false;
                                        }
                                    }
                                    bool v143;
                                    v143 = v142 == false;
                                    if (v143){
                                        v117 = v141;
                                        break;
                                    } else {
                                    }
                                    v118 += 1 ;
                                }
                                v144 = v117;
                                break;
                            }
                            default: {
                                v144 = v116;
                            }
                        }
                        int v149; int v150;
                        switch (v144.tag) {
                            case 0: { // Eq
                                v149 = 0; v150 = -1;
                                break;
                            }
                            case 1: { // Gt
                                v149 = v108; v150 = 0;
                                break;
                            }
                            case 2: { // Lt
                                v149 = v108; v150 = 1;
                                break;
                            }
                            default: {
                                assert("Invalid tag." && false); __trap();
                            }
                        }
                        int v151;
                        v151 = -v150;
                        bool v152;
                        v152 = v150 >= v151;
                        int v153;
                        if (v152){
                            v153 = v150;
                        } else {
                            v153 = v151;
                        }
                        float v154;
                        v154 = (float)v149;
                        static_array<float,2> & v155 = v3.v4;
                        v155[v153] = v154;
                        int v156;
                        v156 = v153 ^ 1;
                        float v157;
                        v157 = -v154;
                        v155[v156] = v157;
                        static_array<Tuple0,2> v158;
                        v158[0] = Tuple0{v75, v76};
                        v158[1] = Tuple0{v100, v101};
                        Union6 v160;
                        v160 = Union6{Union6_4{v149, v158, v150}};
                        v14.push(v160);
                        v1374 = Union18{Union18_0{}};
                        break;
                    }
                    case 7: { // G_Turn
                        int v1254 = v19.case7.v0; static_array<static_array<unsigned char,2>,2> v1255 = v19.case7.v1; static_array<int,2> v1256 = v19.case7.v2; int v1257 = v19.case7.v3; static_array<int,2> v1258 = v19.case7.v4; Union5 v1259 = v19.case7.v5;
                        curandStatePhilox4_32_10_t & v1260 = v3.v5;
                        curandStatePhilox4_32_10_t & v1261 = v1260;
                        static_array<unsigned char,1> v1262; unsigned long long v1263;
                        Tuple12 tmp159 = draw_cards_40(v1261, v15);
                        v1262 = tmp159.v0; v1263 = tmp159.v1;
                        v3.v0 = v1263;
                        static_array_list<unsigned char,5> v1264;
                        v1264 = get_community_cards_85(v1259, v1262);
                        Union6 v1265;
                        v1265 = Union6{Union6_0{v1264}};
                        v14.push(v1265);
                        Union5 v1290;
                        switch (v1259.tag) {
                            case 0: { // Flop
                                static_array<unsigned char,3> v1266 = v1259.case0.v0;
                                static_array<unsigned char,4> v1267;
                                int v1269;
                                v1269 = 0;
                                while (while_method_1(v1269)){
                                    bool v1271;
                                    v1271 = 0 <= v1269;
                                    bool v1273;
                                    if (v1271){
                                        bool v1272;
                                        v1272 = v1269 < 3;
                                        v1273 = v1272;
                                    } else {
                                        v1273 = false;
                                    }
                                    bool v1274;
                                    v1274 = v1273 == false;
                                    if (v1274){
                                        assert("Index must be in range." && v1273);
                                    } else {
                                    }
                                    unsigned char v1276;
                                    v1276 = v1266[v1269];
                                    v1267[v1269] = v1276;
                                    v1269 += 1 ;
                                }
                                int v1278;
                                v1278 = 0;
                                while (while_method_6(v1278)){
                                    bool v1280;
                                    v1280 = 0 <= v1278;
                                    bool v1282;
                                    if (v1280){
                                        bool v1281;
                                        v1281 = v1278 < 1;
                                        v1282 = v1281;
                                    } else {
                                        v1282 = false;
                                    }
                                    bool v1283;
                                    v1283 = v1282 == false;
                                    if (v1283){
                                        assert("Index must be in range." && v1282);
                                    } else {
                                    }
                                    unsigned char v1285;
                                    v1285 = v1262[v1278];
                                    int v1287;
                                    v1287 = 3 + v1278;
                                    v1267[v1287] = v1285;
                                    v1278 += 1 ;
                                }
                                v1290 = Union5{Union5_3{v1267}};
                                break;
                            }
                            default: {
                                printf("%s\n", "Invalid street in turn.");
                                __trap();
                            }
                        }
                        int v1291;
                        v1291 = 2;
                        int v1292;
                        v1292 = 0;
                        Union4 v1293;
                        v1293 = try_round_36(v1291, v1255, v1256, v1292, v1258, v1290);
                        v1374 = Union18{Union18_2{v1293}};
                        break;
                    }
                    default: {
                        assert("Invalid tag." && false); __trap();
                    }
                }
                switch (v1374.tag) {
                    case 0: { // T_none
                        v1723 = Union3{Union3_0{}};
                        break;
                    }
                    case 1: { // T_round
                        int v1378 = v1374.case1.v0; static_array<static_array<unsigned char,2>,2> v1379 = v1374.case1.v1; static_array<int,2> v1380 = v1374.case1.v2; int v1381 = v1374.case1.v3; static_array<int,2> v1382 = v1374.case1.v4; Union5 v1383 = v1374.case1.v5; Union1 v1384 = v1374.case1.v6;
                        int v1385;
                        v1385 = v1381 % 2;
                        Union4 v1716;
                        switch (v1384.tag) {
                            case 0: { // A_All_In
                                static_array<int,2> v1591;
                                int v1593;
                                v1593 = 0;
                                while (while_method_0(v1593)){
                                    bool v1595;
                                    v1595 = 0 <= v1593;
                                    bool v1597;
                                    if (v1595){
                                        bool v1596;
                                        v1596 = v1593 < 2;
                                        v1597 = v1596;
                                    } else {
                                        v1597 = false;
                                    }
                                    bool v1598;
                                    v1598 = v1597 == false;
                                    if (v1598){
                                        assert("Index must be in range." && v1597);
                                    } else {
                                    }
                                    int v1600;
                                    v1600 = v1382[v1593];
                                    bool v1603;
                                    if (v1595){
                                        bool v1602;
                                        v1602 = v1593 < 2;
                                        v1603 = v1602;
                                    } else {
                                        v1603 = false;
                                    }
                                    bool v1604;
                                    v1604 = v1603 == false;
                                    if (v1604){
                                        assert("Index must be in range." && v1603);
                                    } else {
                                    }
                                    int v1606;
                                    v1606 = v1380[v1593];
                                    int v1608;
                                    v1608 = v1600 + v1606;
                                    v1591[v1593] = v1608;
                                    v1593 += 1 ;
                                }
                                int v1609;
                                v1609 = v1380[0];
                                int v1611; int v1612;
                                Tuple4 tmp160 = Tuple4{1, v1609};
                                v1611 = tmp160.v0; v1612 = tmp160.v1;
                                while (while_method_0(v1611)){
                                    bool v1614;
                                    v1614 = 0 <= v1611;
                                    bool v1616;
                                    if (v1614){
                                        bool v1615;
                                        v1615 = v1611 < 2;
                                        v1616 = v1615;
                                    } else {
                                        v1616 = false;
                                    }
                                    bool v1617;
                                    v1617 = v1616 == false;
                                    if (v1617){
                                        assert("Index must be in range." && v1616);
                                    } else {
                                    }
                                    int v1619;
                                    v1619 = v1380[v1611];
                                    bool v1621;
                                    v1621 = v1612 >= v1619;
                                    int v1622;
                                    if (v1621){
                                        v1622 = v1612;
                                    } else {
                                        v1622 = v1619;
                                    }
                                    v1612 = v1622;
                                    v1611 += 1 ;
                                }
                                bool v1623;
                                v1623 = 0 <= v1385;
                                bool v1625;
                                if (v1623){
                                    bool v1624;
                                    v1624 = v1385 < 2;
                                    v1625 = v1624;
                                } else {
                                    v1625 = false;
                                }
                                bool v1626;
                                v1626 = v1625 == false;
                                if (v1626){
                                    assert("Index must be in range." && v1625);
                                } else {
                                }
                                int v1628;
                                v1628 = v1591[v1385];
                                bool v1630;
                                v1630 = v1612 < v1628;
                                int v1631;
                                if (v1630){
                                    v1631 = v1612;
                                } else {
                                    v1631 = v1628;
                                }
                                static_array<int,2> v1632;
                                int v1634;
                                v1634 = 0;
                                while (while_method_0(v1634)){
                                    bool v1636;
                                    v1636 = 0 <= v1634;
                                    bool v1638;
                                    if (v1636){
                                        bool v1637;
                                        v1637 = v1634 < 2;
                                        v1638 = v1637;
                                    } else {
                                        v1638 = false;
                                    }
                                    bool v1639;
                                    v1639 = v1638 == false;
                                    if (v1639){
                                        assert("Index must be in range." && v1638);
                                    } else {
                                    }
                                    int v1641;
                                    v1641 = v1380[v1634];
                                    bool v1643;
                                    v1643 = v1385 == v1634;
                                    int v1644;
                                    if (v1643){
                                        v1644 = v1631;
                                    } else {
                                        v1644 = v1641;
                                    }
                                    v1632[v1634] = v1644;
                                    v1634 += 1 ;
                                }
                                static_array<int,2> v1645;
                                int v1647;
                                v1647 = 0;
                                while (while_method_0(v1647)){
                                    bool v1649;
                                    v1649 = 0 <= v1647;
                                    bool v1651;
                                    if (v1649){
                                        bool v1650;
                                        v1650 = v1647 < 2;
                                        v1651 = v1650;
                                    } else {
                                        v1651 = false;
                                    }
                                    bool v1652;
                                    v1652 = v1651 == false;
                                    if (v1652){
                                        assert("Index must be in range." && v1651);
                                    } else {
                                    }
                                    int v1654;
                                    v1654 = v1591[v1647];
                                    bool v1657;
                                    if (v1649){
                                        bool v1656;
                                        v1656 = v1647 < 2;
                                        v1657 = v1656;
                                    } else {
                                        v1657 = false;
                                    }
                                    bool v1658;
                                    v1658 = v1657 == false;
                                    if (v1658){
                                        assert("Index must be in range." && v1657);
                                    } else {
                                    }
                                    int v1660;
                                    v1660 = v1632[v1647];
                                    int v1662;
                                    v1662 = v1654 - v1660;
                                    v1645[v1647] = v1662;
                                    v1647 += 1 ;
                                }
                                bool v1664;
                                if (v1623){
                                    bool v1663;
                                    v1663 = v1385 < 2;
                                    v1664 = v1663;
                                } else {
                                    v1664 = false;
                                }
                                bool v1665;
                                v1665 = v1664 == false;
                                if (v1665){
                                    assert("Index must be in range." && v1664);
                                } else {
                                }
                                int v1667;
                                v1667 = v1645[v1385];
                                int v1669;
                                v1669 = v1612 + v1667;
                                bool v1671;
                                if (v1623){
                                    bool v1670;
                                    v1670 = v1385 < 2;
                                    v1671 = v1670;
                                } else {
                                    v1671 = false;
                                }
                                bool v1672;
                                v1672 = v1671 == false;
                                if (v1672){
                                    assert("Index must be in range." && v1671);
                                } else {
                                }
                                int v1674;
                                v1674 = v1591[v1385];
                                bool v1676;
                                v1676 = v1669 < v1674;
                                int v1677;
                                if (v1676){
                                    v1677 = v1669;
                                } else {
                                    v1677 = v1674;
                                }
                                static_array<int,2> v1678;
                                int v1680;
                                v1680 = 0;
                                while (while_method_0(v1680)){
                                    bool v1682;
                                    v1682 = 0 <= v1680;
                                    bool v1684;
                                    if (v1682){
                                        bool v1683;
                                        v1683 = v1680 < 2;
                                        v1684 = v1683;
                                    } else {
                                        v1684 = false;
                                    }
                                    bool v1685;
                                    v1685 = v1684 == false;
                                    if (v1685){
                                        assert("Index must be in range." && v1684);
                                    } else {
                                    }
                                    int v1687;
                                    v1687 = v1380[v1680];
                                    bool v1689;
                                    v1689 = v1385 == v1680;
                                    int v1690;
                                    if (v1689){
                                        v1690 = v1677;
                                    } else {
                                        v1690 = v1687;
                                    }
                                    v1678[v1680] = v1690;
                                    v1680 += 1 ;
                                }
                                static_array<int,2> v1691;
                                int v1693;
                                v1693 = 0;
                                while (while_method_0(v1693)){
                                    bool v1695;
                                    v1695 = 0 <= v1693;
                                    bool v1697;
                                    if (v1695){
                                        bool v1696;
                                        v1696 = v1693 < 2;
                                        v1697 = v1696;
                                    } else {
                                        v1697 = false;
                                    }
                                    bool v1698;
                                    v1698 = v1697 == false;
                                    if (v1698){
                                        assert("Index must be in range." && v1697);
                                    } else {
                                    }
                                    int v1700;
                                    v1700 = v1591[v1693];
                                    bool v1703;
                                    if (v1695){
                                        bool v1702;
                                        v1702 = v1693 < 2;
                                        v1703 = v1702;
                                    } else {
                                        v1703 = false;
                                    }
                                    bool v1704;
                                    v1704 = v1703 == false;
                                    if (v1704){
                                        assert("Index must be in range." && v1703);
                                    } else {
                                    }
                                    int v1706;
                                    v1706 = v1678[v1693];
                                    int v1708;
                                    v1708 = v1700 - v1706;
                                    v1691[v1693] = v1708;
                                    v1693 += 1 ;
                                }
                                bool v1709;
                                v1709 = v1667 >= v1378;
                                int v1710;
                                if (v1709){
                                    v1710 = v1667;
                                } else {
                                    v1710 = v1378;
                                }
                                int v1711;
                                v1711 = v1381 + 1;
                                v1716 = try_round_36(v1710, v1379, v1678, v1711, v1691, v1383);
                                break;
                            }
                            case 1: { // A_Call
                                static_array<int,2> v1387;
                                int v1389;
                                v1389 = 0;
                                while (while_method_0(v1389)){
                                    bool v1391;
                                    v1391 = 0 <= v1389;
                                    bool v1393;
                                    if (v1391){
                                        bool v1392;
                                        v1392 = v1389 < 2;
                                        v1393 = v1392;
                                    } else {
                                        v1393 = false;
                                    }
                                    bool v1394;
                                    v1394 = v1393 == false;
                                    if (v1394){
                                        assert("Index must be in range." && v1393);
                                    } else {
                                    }
                                    int v1396;
                                    v1396 = v1382[v1389];
                                    bool v1399;
                                    if (v1391){
                                        bool v1398;
                                        v1398 = v1389 < 2;
                                        v1399 = v1398;
                                    } else {
                                        v1399 = false;
                                    }
                                    bool v1400;
                                    v1400 = v1399 == false;
                                    if (v1400){
                                        assert("Index must be in range." && v1399);
                                    } else {
                                    }
                                    int v1402;
                                    v1402 = v1380[v1389];
                                    int v1404;
                                    v1404 = v1396 + v1402;
                                    v1387[v1389] = v1404;
                                    v1389 += 1 ;
                                }
                                int v1405;
                                v1405 = v1380[0];
                                int v1407; int v1408;
                                Tuple4 tmp161 = Tuple4{1, v1405};
                                v1407 = tmp161.v0; v1408 = tmp161.v1;
                                while (while_method_0(v1407)){
                                    bool v1410;
                                    v1410 = 0 <= v1407;
                                    bool v1412;
                                    if (v1410){
                                        bool v1411;
                                        v1411 = v1407 < 2;
                                        v1412 = v1411;
                                    } else {
                                        v1412 = false;
                                    }
                                    bool v1413;
                                    v1413 = v1412 == false;
                                    if (v1413){
                                        assert("Index must be in range." && v1412);
                                    } else {
                                    }
                                    int v1415;
                                    v1415 = v1380[v1407];
                                    bool v1417;
                                    v1417 = v1408 >= v1415;
                                    int v1418;
                                    if (v1417){
                                        v1418 = v1408;
                                    } else {
                                        v1418 = v1415;
                                    }
                                    v1408 = v1418;
                                    v1407 += 1 ;
                                }
                                bool v1419;
                                v1419 = 0 <= v1385;
                                bool v1421;
                                if (v1419){
                                    bool v1420;
                                    v1420 = v1385 < 2;
                                    v1421 = v1420;
                                } else {
                                    v1421 = false;
                                }
                                bool v1422;
                                v1422 = v1421 == false;
                                if (v1422){
                                    assert("Index must be in range." && v1421);
                                } else {
                                }
                                int v1424;
                                v1424 = v1387[v1385];
                                bool v1426;
                                v1426 = v1408 < v1424;
                                int v1427;
                                if (v1426){
                                    v1427 = v1408;
                                } else {
                                    v1427 = v1424;
                                }
                                static_array<int,2> v1428;
                                int v1430;
                                v1430 = 0;
                                while (while_method_0(v1430)){
                                    bool v1432;
                                    v1432 = 0 <= v1430;
                                    bool v1434;
                                    if (v1432){
                                        bool v1433;
                                        v1433 = v1430 < 2;
                                        v1434 = v1433;
                                    } else {
                                        v1434 = false;
                                    }
                                    bool v1435;
                                    v1435 = v1434 == false;
                                    if (v1435){
                                        assert("Index must be in range." && v1434);
                                    } else {
                                    }
                                    int v1437;
                                    v1437 = v1380[v1430];
                                    bool v1439;
                                    v1439 = v1385 == v1430;
                                    int v1440;
                                    if (v1439){
                                        v1440 = v1427;
                                    } else {
                                        v1440 = v1437;
                                    }
                                    v1428[v1430] = v1440;
                                    v1430 += 1 ;
                                }
                                static_array<int,2> v1441;
                                int v1443;
                                v1443 = 0;
                                while (while_method_0(v1443)){
                                    bool v1445;
                                    v1445 = 0 <= v1443;
                                    bool v1447;
                                    if (v1445){
                                        bool v1446;
                                        v1446 = v1443 < 2;
                                        v1447 = v1446;
                                    } else {
                                        v1447 = false;
                                    }
                                    bool v1448;
                                    v1448 = v1447 == false;
                                    if (v1448){
                                        assert("Index must be in range." && v1447);
                                    } else {
                                    }
                                    int v1450;
                                    v1450 = v1387[v1443];
                                    bool v1453;
                                    if (v1445){
                                        bool v1452;
                                        v1452 = v1443 < 2;
                                        v1453 = v1452;
                                    } else {
                                        v1453 = false;
                                    }
                                    bool v1454;
                                    v1454 = v1453 == false;
                                    if (v1454){
                                        assert("Index must be in range." && v1453);
                                    } else {
                                    }
                                    int v1456;
                                    v1456 = v1428[v1443];
                                    int v1458;
                                    v1458 = v1450 - v1456;
                                    v1441[v1443] = v1458;
                                    v1443 += 1 ;
                                }
                                bool v1459;
                                v1459 = v1385 < 2;
                                if (v1459){
                                    int v1460;
                                    v1460 = v1381 + 1;
                                    v1716 = try_round_36(v1378, v1379, v1428, v1460, v1441, v1383);
                                } else {
                                    v1716 = go_next_street_38(v1378, v1379, v1428, v1381, v1441, v1383);
                                }
                                break;
                            }
                            case 2: { // A_Fold
                                v1716 = Union4{Union4_1{v1378, v1379, v1380, v1381, v1382, v1383}};
                                break;
                            }
                            case 3: { // A_Raise
                                int v1464 = v1384.case3.v0;
                                bool v1465;
                                v1465 = v1378 <= v1464;
                                bool v1466;
                                v1466 = v1465 == false;
                                if (v1466){
                                    assert("The raise amount must match the minimum." && v1465);
                                } else {
                                }
                                static_array<int,2> v1468;
                                int v1470;
                                v1470 = 0;
                                while (while_method_0(v1470)){
                                    bool v1472;
                                    v1472 = 0 <= v1470;
                                    bool v1474;
                                    if (v1472){
                                        bool v1473;
                                        v1473 = v1470 < 2;
                                        v1474 = v1473;
                                    } else {
                                        v1474 = false;
                                    }
                                    bool v1475;
                                    v1475 = v1474 == false;
                                    if (v1475){
                                        assert("Index must be in range." && v1474);
                                    } else {
                                    }
                                    int v1477;
                                    v1477 = v1382[v1470];
                                    bool v1480;
                                    if (v1472){
                                        bool v1479;
                                        v1479 = v1470 < 2;
                                        v1480 = v1479;
                                    } else {
                                        v1480 = false;
                                    }
                                    bool v1481;
                                    v1481 = v1480 == false;
                                    if (v1481){
                                        assert("Index must be in range." && v1480);
                                    } else {
                                    }
                                    int v1483;
                                    v1483 = v1380[v1470];
                                    int v1485;
                                    v1485 = v1477 + v1483;
                                    v1468[v1470] = v1485;
                                    v1470 += 1 ;
                                }
                                int v1486;
                                v1486 = v1380[0];
                                int v1488; int v1489;
                                Tuple4 tmp162 = Tuple4{1, v1486};
                                v1488 = tmp162.v0; v1489 = tmp162.v1;
                                while (while_method_0(v1488)){
                                    bool v1491;
                                    v1491 = 0 <= v1488;
                                    bool v1493;
                                    if (v1491){
                                        bool v1492;
                                        v1492 = v1488 < 2;
                                        v1493 = v1492;
                                    } else {
                                        v1493 = false;
                                    }
                                    bool v1494;
                                    v1494 = v1493 == false;
                                    if (v1494){
                                        assert("Index must be in range." && v1493);
                                    } else {
                                    }
                                    int v1496;
                                    v1496 = v1380[v1488];
                                    bool v1498;
                                    v1498 = v1489 >= v1496;
                                    int v1499;
                                    if (v1498){
                                        v1499 = v1489;
                                    } else {
                                        v1499 = v1496;
                                    }
                                    v1489 = v1499;
                                    v1488 += 1 ;
                                }
                                bool v1500;
                                v1500 = 0 <= v1385;
                                bool v1502;
                                if (v1500){
                                    bool v1501;
                                    v1501 = v1385 < 2;
                                    v1502 = v1501;
                                } else {
                                    v1502 = false;
                                }
                                bool v1503;
                                v1503 = v1502 == false;
                                if (v1503){
                                    assert("Index must be in range." && v1502);
                                } else {
                                }
                                int v1505;
                                v1505 = v1468[v1385];
                                bool v1507;
                                v1507 = v1489 < v1505;
                                int v1508;
                                if (v1507){
                                    v1508 = v1489;
                                } else {
                                    v1508 = v1505;
                                }
                                static_array<int,2> v1509;
                                int v1511;
                                v1511 = 0;
                                while (while_method_0(v1511)){
                                    bool v1513;
                                    v1513 = 0 <= v1511;
                                    bool v1515;
                                    if (v1513){
                                        bool v1514;
                                        v1514 = v1511 < 2;
                                        v1515 = v1514;
                                    } else {
                                        v1515 = false;
                                    }
                                    bool v1516;
                                    v1516 = v1515 == false;
                                    if (v1516){
                                        assert("Index must be in range." && v1515);
                                    } else {
                                    }
                                    int v1518;
                                    v1518 = v1380[v1511];
                                    bool v1520;
                                    v1520 = v1385 == v1511;
                                    int v1521;
                                    if (v1520){
                                        v1521 = v1508;
                                    } else {
                                        v1521 = v1518;
                                    }
                                    v1509[v1511] = v1521;
                                    v1511 += 1 ;
                                }
                                static_array<int,2> v1522;
                                int v1524;
                                v1524 = 0;
                                while (while_method_0(v1524)){
                                    bool v1526;
                                    v1526 = 0 <= v1524;
                                    bool v1528;
                                    if (v1526){
                                        bool v1527;
                                        v1527 = v1524 < 2;
                                        v1528 = v1527;
                                    } else {
                                        v1528 = false;
                                    }
                                    bool v1529;
                                    v1529 = v1528 == false;
                                    if (v1529){
                                        assert("Index must be in range." && v1528);
                                    } else {
                                    }
                                    int v1531;
                                    v1531 = v1468[v1524];
                                    bool v1534;
                                    if (v1526){
                                        bool v1533;
                                        v1533 = v1524 < 2;
                                        v1534 = v1533;
                                    } else {
                                        v1534 = false;
                                    }
                                    bool v1535;
                                    v1535 = v1534 == false;
                                    if (v1535){
                                        assert("Index must be in range." && v1534);
                                    } else {
                                    }
                                    int v1537;
                                    v1537 = v1509[v1524];
                                    int v1539;
                                    v1539 = v1531 - v1537;
                                    v1522[v1524] = v1539;
                                    v1524 += 1 ;
                                }
                                bool v1541;
                                if (v1500){
                                    bool v1540;
                                    v1540 = v1385 < 2;
                                    v1541 = v1540;
                                } else {
                                    v1541 = false;
                                }
                                bool v1542;
                                v1542 = v1541 == false;
                                if (v1542){
                                    assert("Index must be in range." && v1541);
                                } else {
                                }
                                int v1544;
                                v1544 = v1522[v1385];
                                bool v1546;
                                v1546 = v1464 < v1544;
                                bool v1547;
                                v1547 = v1546 == false;
                                if (v1547){
                                    assert("The raise amount must be less than the stack size after calling." && v1546);
                                } else {
                                }
                                int v1549;
                                v1549 = v1489 + v1464;
                                bool v1551;
                                if (v1500){
                                    bool v1550;
                                    v1550 = v1385 < 2;
                                    v1551 = v1550;
                                } else {
                                    v1551 = false;
                                }
                                bool v1552;
                                v1552 = v1551 == false;
                                if (v1552){
                                    assert("Index must be in range." && v1551);
                                } else {
                                }
                                int v1554;
                                v1554 = v1468[v1385];
                                bool v1556;
                                v1556 = v1549 < v1554;
                                int v1557;
                                if (v1556){
                                    v1557 = v1549;
                                } else {
                                    v1557 = v1554;
                                }
                                static_array<int,2> v1558;
                                int v1560;
                                v1560 = 0;
                                while (while_method_0(v1560)){
                                    bool v1562;
                                    v1562 = 0 <= v1560;
                                    bool v1564;
                                    if (v1562){
                                        bool v1563;
                                        v1563 = v1560 < 2;
                                        v1564 = v1563;
                                    } else {
                                        v1564 = false;
                                    }
                                    bool v1565;
                                    v1565 = v1564 == false;
                                    if (v1565){
                                        assert("Index must be in range." && v1564);
                                    } else {
                                    }
                                    int v1567;
                                    v1567 = v1380[v1560];
                                    bool v1569;
                                    v1569 = v1385 == v1560;
                                    int v1570;
                                    if (v1569){
                                        v1570 = v1557;
                                    } else {
                                        v1570 = v1567;
                                    }
                                    v1558[v1560] = v1570;
                                    v1560 += 1 ;
                                }
                                static_array<int,2> v1571;
                                int v1573;
                                v1573 = 0;
                                while (while_method_0(v1573)){
                                    bool v1575;
                                    v1575 = 0 <= v1573;
                                    bool v1577;
                                    if (v1575){
                                        bool v1576;
                                        v1576 = v1573 < 2;
                                        v1577 = v1576;
                                    } else {
                                        v1577 = false;
                                    }
                                    bool v1578;
                                    v1578 = v1577 == false;
                                    if (v1578){
                                        assert("Index must be in range." && v1577);
                                    } else {
                                    }
                                    int v1580;
                                    v1580 = v1468[v1573];
                                    bool v1583;
                                    if (v1575){
                                        bool v1582;
                                        v1582 = v1573 < 2;
                                        v1583 = v1582;
                                    } else {
                                        v1583 = false;
                                    }
                                    bool v1584;
                                    v1584 = v1583 == false;
                                    if (v1584){
                                        assert("Index must be in range." && v1583);
                                    } else {
                                    }
                                    int v1586;
                                    v1586 = v1558[v1573];
                                    int v1588;
                                    v1588 = v1580 - v1586;
                                    v1571[v1573] = v1588;
                                    v1573 += 1 ;
                                }
                                int v1589;
                                v1589 = v1381 + 1;
                                v1716 = try_round_36(v1464, v1379, v1558, v1589, v1571, v1383);
                                break;
                            }
                            default: {
                                assert("Invalid tag." && false); __trap();
                            }
                        }
                        v1723 = Union3{Union3_1{v1716}};
                        break;
                    }
                    case 2: { // T_some
                        Union4 v1376 = v1374.case2.v0;
                        v1723 = Union3{Union3_1{v1376}};
                        break;
                    }
                    default: {
                        assert("Invalid tag." && false); __trap();
                    }
                }
                break;
            }
            default: {
                assert("Invalid tag." && false); __trap();
            }
        }
        v17 = v1723;
    }
    return ;
}
extern "C" __global__ void entry0(unsigned char * v0, unsigned char * v1, unsigned char * v2, unsigned char * v3, unsigned char * v4) {
    Union0 v5;
    v5 = f_0(v1);
    unsigned long long v6; Union3 v7; static_array_list<Union6,128> v8; static_array<Union2,2> v9; Union7 v10;
    Tuple1 tmp15 = f_6(v0);
    v6 = tmp15.v0; v7 = tmp15.v1; v8 = tmp15.v2; v9 = tmp15.v3; v10 = tmp15.v4;
    unsigned long long v11;
    v11 = clock64();
    int v12;
    v12 = threadIdx.x;
    int v13;
    v13 = blockIdx.x;
    int v14;
    v14 = v13 * 256;
    int v15;
    v15 = v12 + v14;
    unsigned long long v16;
    v16 = (unsigned long long)v15;
    curandStatePhilox4_32_10_t v17;
    curand_init(v11,v16,0ull,&v17);
    curandStatePhilox4_32_10_t & v18 = v17;
    StackMut0 v19{v6, v7, v8, v9, v18, v10};
    Union3 v56;
    switch (v5.tag) {
        case 0: { // ActionSelected
            Union1 v34 = v5.case0.v0;
            Union3 & v35 = v19.v1;
            switch (v35.tag) {
                case 0: { // None
                    printf("%s\n", "The game hasn't been started in ActionSelected.");
                    __trap();
                    break;
                }
                case 1: { // Some
                    Union4 v36 = v35.case1.v0;
                    switch (v36.tag) {
                        case 4: { // G_Round
                            int v37 = v36.case4.v0; static_array<static_array<unsigned char,2>,2> v38 = v36.case4.v1; static_array<int,2> v39 = v36.case4.v2; int v40 = v36.case4.v3; static_array<int,2> v41 = v36.case4.v4; Union5 v42 = v36.case4.v5;
                            Union4 v43;
                            v43 = Union4{Union4_5{v37, v38, v39, v40, v41, v42, v34}};
                            v56 = Union3{Union3_1{v43}};
                            break;
                        }
                        default: {
                            printf("%s\n", "Unexpected game node in ActionSelected.");
                            __trap();
                        }
                    }
                    break;
                }
                default: {
                    assert("Invalid tag." && false); __trap();
                }
            }
            break;
        }
        case 1: { // PlayerChanged
            static_array<Union2,2> v32 = v5.case1.v0;
            v19.v3 = v32;
            v56 = Union3{Union3_0{}};
            break;
        }
        case 2: { // StartGame
            static_array<Union2,2> v20;
            Union2 v22;
            v22 = Union2{Union2_1{}};
            v20[0] = v22;
            Union2 v24;
            v24 = Union2{Union2_2{}};
            v20[1] = v24;
            static_array_list<Union6,128> v26;
            v26 = static_array_list<Union6,128>{};
            Union7 v28;
            v28 = Union7{Union7_0{}};
            v19.v5 = v28;
            Union3 v29;
            v29 = Union3{Union3_0{}};
            v19.v1 = v29;
            v19.v0 = 4503599627370495ull;
            v19.v2 = v26;
            Union4 v30;
            v30 = Union4{Union4_2{}};
            v56 = Union3{Union3_1{v30}};
            break;
        }
        case 3: { // StartTrainingVsCallingMachine
            printf("%s\n", "Training is not supported in the `event_loop_play` function.");
            __trap();
            break;
        }
        case 4: { // StartTrainingVsSelf
            printf("%s\n", "Training is not supported in the `event_loop_play` function.");
            __trap();
            break;
        }
        default: {
            assert("Invalid tag." && false); __trap();
        }
    }
    switch (v56.tag) {
        case 0: { // None
            break;
        }
        case 1: { // Some
            Union4 v57 = v56.case1.v0;
            play_loop_31(v2, v3, v4, v19, v57);
            break;
        }
        default: {
            assert("Invalid tag." && false); __trap();
        }
    }
    int v58;
    v58 = threadIdx.x;
    int v59;
    v59 = blockIdx.x;
    int v60;
    v60 = v59 * 256;
    int v61;
    v61 = v58 + v60;
    bool v62;
    v62 = v61 == 0;
    if (v62){
        Union7 & v63 = v19.v5;
        static_array<Union2,2> & v64 = v19.v3;
        static_array_list<Union6,128> & v65 = v19.v2;
        Union3 & v66 = v19.v1;
        unsigned long long & v67 = v19.v0;
        return f_55(v0, v67, v66, v65, v64, v63);
    } else {
        return ;
    }
}
extern "C" __global__ void entry1(unsigned char * v0, unsigned char * v1, unsigned char * v2, float * v3, float * v4, float * v5) {
    auto v6 = cooperative_groups::this_grid();
    unsigned long long v7;
    v7 = clock64();
    int v8;
    v8 = threadIdx.x;
    int v9;
    v9 = blockIdx.x;
    int v10;
    v10 = v9 * 256;
    int v11;
    v11 = v8 + v10;
    unsigned long long v12;
    v12 = (unsigned long long)v11;
    curandStatePhilox4_32_10_t v13;
    curand_init(v7,v12,0ull,&v13);
    static_array<Union2,2> v14;
    Union2 v16;
    v16 = Union2{Union2_3{}};
    v14[0] = v16;
    Union2 v18;
    v18 = Union2{Union2_3{}};
    v14[1] = v18;
    static_array_list<Union6,128> v20;
    v20 = static_array_list<Union6,128>{};
    static_array<float,2> v22;
    v22[0] = 0.0f;
    v22[1] = 0.0f;
    cooperative_groups::grid_group & v24 = v6;
    curandStatePhilox4_32_10_t & v25 = v13;
    StackMut1 v26{4503599627370495ull, v24, v20, v14, v22, v25};
    int v27;
    v27 = 0;
    while (while_method_23(v27)){
        int v29;
        v29 = 0;
        while (while_method_24(v29)){
            int v31;
            v31 = 0;
            while (while_method_0(v31)){
                Union4 v33;
                v33 = Union4{Union4_2{}};
                method_83(v0, v1, v2, v26, v31, v33);
                static_array<float,2> & v34 = v26.v4;
                bool v35;
                v35 = 0 <= v31;
                bool v37;
                if (v35){
                    bool v36;
                    v36 = v31 < 2;
                    v37 = v36;
                } else {
                    v37 = false;
                }
                bool v38;
                v38 = v37 == false;
                if (v38){
                    assert("Index must be in range." && v37);
                } else {
                }
                float v40;
                v40 = v34[v31];
                double * v42;
                v42 = reinterpret_cast<double *>(&v1[121110528ull]);
                double * v44;
                v44 = reinterpret_cast<double *>(&v1[121503744ull]);
                int v46;
                v46 = threadIdx.x;
                int v47;
                v47 = blockIdx.x;
                int v48;
                v48 = v47 * 256;
                int v49;
                v49 = v46 + v48;
                assert("Tensor range check" && 0 <= v49 && v49 < 6144);
                int v50;
                v50 = 2 * v49;
                int * v51;
                v51 = reinterpret_cast<int *>(&v0[12845056ull]);
                bool * v53;
                v53 = reinterpret_cast<bool *>(&v0[12845072ull]);
                float * v55;
                v55 = reinterpret_cast<float *>(&v0[12845088ull]);
                float * v57;
                v57 = reinterpret_cast<float *>(&v0[12845104ull]);
                double v59[2];
                int v60;
                v60 = 0;
                while (while_method_0(v60)){
                    int v62; double v63;
                    Tuple23 tmp106 = Tuple23{0, 0.0};
                    v62 = tmp106.v0; v63 = tmp106.v1;
                    while (while_method_3(v62)){
                        assert("Tensor range check" && 0 <= v62 && v62 < 4);
                        bool v65;
                        v65 = v53[v62];
                        bool v66;
                        v66 = v65 == false;
                        double v74;
                        if (v66){
                            v74 = 0.0;
                        } else {
                            assert("Tensor range check" && 0 <= v62 && v62 < 4);
                            assert("Tensor range check" && 0 <= v60 && v60 < 2);
                            int v67;
                            v67 = v60 + v50;
                            int v68;
                            v68 = 12288 * v62;
                            int v69;
                            v69 = v68 + v67;
                            double v70;
                            v70 = v42[v69];
                            double v71;
                            v71 = v44[v69];
                            double v72;
                            v72 = v70 - v71;
                            double v73;
                            v73 = exp(v72);
                            v74 = v73;
                        }
                        double v75;
                        v75 = v63 + v74;
                        v63 = v75;
                        v62 += 1 ;
                    }
                    assert("Tensor range check" && 0 <= v60 && v60 < 2);
                    v59[v60] = v63;
                    v60 += 1 ;
                }
                double v76;
                v76 = 1.0;
                int v77;
                v77 = 0;
                while (while_method_0(v77)){
                    assert("Tensor range check" && 0 <= v77 && v77 < 2);
                    double v79;
                    v79 = v59[v77];
                    double v80;
                    v80 = v76 * v79;
                    v76 = v80;
                    v77 += 1 ;
                }
                double v81[8];
                int v82;
                v82 = 0;
                while (while_method_3(v82)){
                    int v84;
                    v84 = 0;
                    while (while_method_0(v84)){
                        bool v86;
                        v86 = v76 == 0.0;
                        bool v87;
                        v87 = v86 != true;
                        double v98;
                        if (v87){
                            assert("Tensor range check" && 0 <= v84 && v84 < 2);
                            double v88;
                            v88 = v59[v84];
                            double v89;
                            v89 = v76 / v88;
                            assert("Tensor range check" && 0 <= v82 && v82 < 4);
                            assert("Tensor range check" && 0 <= v84 && v84 < 2);
                            int v90;
                            v90 = v84 + v50;
                            int v91;
                            v91 = 12288 * v82;
                            int v92;
                            v92 = v91 + v90;
                            double v93;
                            v93 = v42[v92];
                            double v94;
                            v94 = v44[v92];
                            double v95;
                            v95 = v93 - v94;
                            double v96;
                            v96 = exp(v95);
                            double v97;
                            v97 = v89 * v96;
                            v98 = v97;
                        } else {
                            v98 = 0.0;
                        }
                        bool v99;
                        v99 = isnan(v98);
                        bool v100;
                        v100 = v99 == false;
                        bool v101;
                        v101 = v100 == false;
                        if (v101){
                            assert("The path probability after integration should not be a nan in integrate_rewards_." && v100);
                        } else {
                        }
                        assert("Tensor range check" && 0 <= v82 && v82 < 4);
                        assert("Tensor range check" && 0 <= v84 && v84 < 2);
                        int v103;
                        v103 = 2 * v82;
                        int v104;
                        v104 = v103 + v84;
                        v81[v104] = v98;
                        v84 += 1 ;
                    }
                    v82 += 1 ;
                }
                int v105;
                v105 = 0;
                while (while_method_3(v105)){
                    assert("Tensor range check" && 0 <= v105 && v105 < 4);
                    assert("Tensor range check" && 0 <= v31 && v31 < 2);
                    int v107;
                    v107 = 2 * v105;
                    int v108;
                    v108 = v107 + v31;
                    double v109;
                    v109 = v81[v108];
                    float v110;
                    v110 = (float)v109;
                    float v111;
                    v111 = v40 * v110;
                    assert("Tensor range check" && 0 <= v105 && v105 < 4);
                    assert("Tensor range check" && 0 <= v27 && v27 < 2048);
                    int v112;
                    v112 = 2048 * v105;
                    int v113;
                    v113 = v112 + v27;
                    float * v114;
                    v114 = v3+v113;
                    float * v116;
                    v116 = v4+v113;
                    float v118;
                    v118 = atomicAdd(v114,v111);
                    float v119;
                    v119 = atomicAdd(v116,v110);
                    v105 += 1 ;
                }
                static_array<float,2> & v120 = v26.v4;
                float * v121;
                v121 = reinterpret_cast<float *>(&v1[114819072ull]);
                int * v123;
                v123 = reinterpret_cast<int *>(&v0[12845056ull]);
                bool * v125;
                v125 = reinterpret_cast<bool *>(&v0[12845072ull]);
                float * v127;
                v127 = reinterpret_cast<float *>(&v0[12845088ull]);
                float * v129;
                v129 = reinterpret_cast<float *>(&v0[12845104ull]);
                double * v131;
                v131 = reinterpret_cast<double *>(&v1[121110528ull]);
                double * v133;
                v133 = reinterpret_cast<double *>(&v1[121503744ull]);
                int v135;
                v135 = threadIdx.x;
                int v136;
                v136 = blockIdx.x;
                int v137;
                v137 = v136 * 256;
                int v138;
                v138 = v135 + v137;
                assert("Tensor range check" && 0 <= v138 && v138 < 6144);
                int v139;
                v139 = 2 * v138;
                double * v140;
                v140 = v131+v139;
                double * v142;
                v142 = v133+v139;
                float v144[2];
                int v145;
                v145 = 0;
                while (while_method_0(v145)){
                    bool v147;
                    v147 = 0 <= v145;
                    bool v149;
                    if (v147){
                        bool v148;
                        v148 = v145 < 2;
                        v149 = v148;
                    } else {
                        v149 = false;
                    }
                    bool v150;
                    v150 = v149 == false;
                    if (v150){
                        assert("Index must be in range." && v149);
                    } else {
                    }
                    float v152;
                    v152 = v120[v145];
                    assert("Tensor range check" && 0 <= v145 && v145 < 2);
                    v144[v145] = v152;
                    v145 += 1 ;
                }
                double v154[2];
                int v155;
                v155 = 0;
                while (while_method_0(v155)){
                    int v157; double v158;
                    Tuple23 tmp107 = Tuple23{0, 0.0};
                    v157 = tmp107.v0; v158 = tmp107.v1;
                    while (while_method_3(v157)){
                        assert("Tensor range check" && 0 <= v157 && v157 < 4);
                        bool v160;
                        v160 = v125[v157];
                        bool v161;
                        v161 = v160 == false;
                        double v168;
                        if (v161){
                            v168 = 0.0;
                        } else {
                            assert("Tensor range check" && 0 <= v157 && v157 < 4);
                            assert("Tensor range check" && 0 <= v155 && v155 < 2);
                            int v162;
                            v162 = 12288 * v157;
                            int v163;
                            v163 = v162 + v155;
                            double v164;
                            v164 = v140[v163];
                            double v165;
                            v165 = v142[v163];
                            double v166;
                            v166 = v164 - v165;
                            double v167;
                            v167 = exp(v166);
                            v168 = v167;
                        }
                        double v169;
                        v169 = v158 + v168;
                        v158 = v169;
                        v157 += 1 ;
                    }
                    assert("Tensor range check" && 0 <= v155 && v155 < 2);
                    v154[v155] = v158;
                    v155 += 1 ;
                }
                double v170;
                v170 = 1.0;
                int v171;
                v171 = 0;
                while (while_method_0(v171)){
                    assert("Tensor range check" && 0 <= v171 && v171 < 2);
                    double v173;
                    v173 = v154[v171];
                    double v174;
                    v174 = v170 * v173;
                    v170 = v174;
                    v171 += 1 ;
                }
                double v175[8];
                int v176;
                v176 = 0;
                while (while_method_3(v176)){
                    int v178;
                    v178 = 0;
                    while (while_method_0(v178)){
                        bool v180;
                        v180 = v170 == 0.0;
                        bool v181;
                        v181 = v180 != true;
                        double v191;
                        if (v181){
                            assert("Tensor range check" && 0 <= v178 && v178 < 2);
                            double v182;
                            v182 = v154[v178];
                            double v183;
                            v183 = v170 / v182;
                            assert("Tensor range check" && 0 <= v176 && v176 < 4);
                            assert("Tensor range check" && 0 <= v178 && v178 < 2);
                            int v184;
                            v184 = 12288 * v176;
                            int v185;
                            v185 = v184 + v178;
                            double v186;
                            v186 = v140[v185];
                            double v187;
                            v187 = v142[v185];
                            double v188;
                            v188 = v186 - v187;
                            double v189;
                            v189 = exp(v188);
                            double v190;
                            v190 = v183 * v189;
                            v191 = v190;
                        } else {
                            v191 = 0.0;
                        }
                        bool v192;
                        v192 = isnan(v191);
                        bool v193;
                        v193 = v192 == false;
                        bool v194;
                        v194 = v193 == false;
                        if (v194){
                            assert("The path probability after integration should not be a nan in integrate_rewards_." && v193);
                        } else {
                        }
                        assert("Tensor range check" && 0 <= v176 && v176 < 4);
                        assert("Tensor range check" && 0 <= v178 && v178 < 2);
                        int v196;
                        v196 = 2 * v176;
                        int v197;
                        v197 = v196 + v178;
                        v175[v197] = v191;
                        v178 += 1 ;
                    }
                    v176 += 1 ;
                }
                float v198[4];
                float v199[4];
                int v200;
                v200 = 0;
                while (while_method_3(v200)){
                    int v202; float v203; double v204;
                    Tuple24 tmp108 = Tuple24{0, 0.0f, 0.0};
                    v202 = tmp108.v0; v203 = tmp108.v1; v204 = tmp108.v2;
                    while (while_method_0(v202)){
                        assert("Tensor range check" && 0 <= v200 && v200 < 4);
                        assert("Tensor range check" && 0 <= v202 && v202 < 2);
                        int v206;
                        v206 = 2 * v200;
                        int v207;
                        v207 = v206 + v202;
                        double v208;
                        v208 = v175[v207];
                        assert("Tensor range check" && 0 <= v202 && v202 < 2);
                        float v209;
                        v209 = v144[v202];
                        float v210;
                        v210 = (float)v208;
                        float v211;
                        v211 = v210 * v209;
                        float v212;
                        v212 = v203 + v211;
                        double v213;
                        v213 = v204 + v208;
                        v203 = v212;
                        v204 = v213;
                        v202 += 1 ;
                    }
                    float v214;
                    v214 = (float)v204;
                    assert("Tensor range check" && 0 <= v200 && v200 < 4);
                    v198[v200] = v203;
                    v199[v200] = v214;
                    v200 += 1 ;
                }
                int v215;
                v215 = 0;
                while (while_method_3(v215)){
                    assert("Tensor range check" && 0 <= v215 && v215 < 4);
                    float v217;
                    v217 = v198[v215];
                    float v218;
                    v218 = v199[v215];
                    bool v219;
                    v219 = isnan(v218);
                    bool v220;
                    v220 = v219 == false;
                    bool v221;
                    v221 = v220 == false;
                    if (v221){
                        assert("The path probability after integration should not be a nan in calculate updates." && v220);
                    } else {
                    }
                    float v223;
                    v223 = v217 * v218;
                    assert("Tensor range check" && 0 <= v215 && v215 < 4);
                    float * v224;
                    v224 = v127+v215;
                    float * v226;
                    v226 = v129+v215;
                    float v228;
                    v228 = atomicAdd(v224,v223);
                    float v229;
                    v229 = atomicAdd(v226,v218);
                    v215 += 1 ;
                }
                int v230;
                v230 = threadIdx.x;
                int v231;
                v231 = blockIdx.x;
                int v232;
                v232 = v231 * 256;
                int v233;
                v233 = v230 + v232;
                int v234;
                v234 = 0;
                while (while_method_3(v234)){
                    assert("Tensor range check" && 0 <= v234 && v234 < 4);
                    int v236;
                    v236 = 12288 * v234;
                    assert("Tensor range check" && 0 <= v233 && v233 < 6144);
                    int v237;
                    v237 = 2 * v233;
                    int v238;
                    v238 = v237 + v236;
                    double * v239;
                    v239 = v131+v238;
                    double * v241;
                    v241 = v133+v238;
                    double * v243;
                    v243 = v131+v238;
                    double * v245;
                    v245 = v133+v238;
                    int v247;
                    v247 = sizeof(double *);
                    unsigned long long v248;
                    v248 = (unsigned long long)v247;
                    unsigned long long v249;
                    v249 = 256ull * v248;
                    unsigned long long v250;
                    v250 = v249 + 16ull;
                    unsigned long long v251;
                    v251 = v250 - 1ull;
                    unsigned long long v252;
                    v252 = v251 % 16ull;
                    unsigned long long v253;
                    v253 = v251 - v252;
                    unsigned long long v254;
                    v254 = v253 + v249;
                    unsigned long long v255;
                    v255 = v254 + 16ull;
                    unsigned long long v256;
                    v256 = v255 - 1ull;
                    unsigned long long v257;
                    v257 = v256 % 16ull;
                    unsigned long long v258;
                    v258 = v256 - v257;
                    unsigned long long v259;
                    v259 = v258 + v249;
                    unsigned long long v260;
                    v260 = v259 + 16ull;
                    unsigned long long v261;
                    v261 = v260 - 1ull;
                    unsigned long long v262;
                    v262 = v261 % 16ull;
                    unsigned long long v263;
                    v263 = v261 - v262;
                    unsigned long long v264;
                    v264 = v263 + v249;
                    bool v265;
                    v265 = v264 <= 98304ull;
                    bool v266;
                    v266 = v265 == false;
                    if (v266){
                        assert("The dynamic shared memory is insufficient to allocate the tensor." && v265);
                    } else {
                    }
                    extern __shared__ unsigned char v268[];
                    bool v269;
                    v269 = v264 <= v264;
                    bool v270;
                    v270 = v269 == false;
                    if (v270){
                        assert("The length of the partition has to be less than or equal to the length of the base array." && v269);
                    } else {
                    }
                    double * * v272;
                    v272 = reinterpret_cast<double * *>(&v268[0ull]);
                    double * * v274;
                    v274 = reinterpret_cast<double * *>(&v268[v253]);
                    double * * v276;
                    v276 = reinterpret_cast<double * *>(&v268[v258]);
                    double * * v278;
                    v278 = reinterpret_cast<double * *>(&v268[v263]);
                    int v280;
                    v280 = threadIdx.x;
                    assert("Tensor range check" && 0 <= v280 && v280 < 256);
                    v272[v280] = v239;
                    v274[v280] = v241;
                    v276[v280] = v243;
                    v278[v280] = v245;
                    __syncthreads();
                    bool v281;
                    v281 = 0 <= v280;
                    bool v282;
                    v282 = v281 == false;
                    if (v282){
                        assert("The index needs to be zero or positive." && v281);
                    } else {
                    }
                    int v284;
                    v284 = v280 % 1;
                    bool v285;
                    v285 = v280 < 256;
                    bool v286;
                    v286 = v285 == false;
                    if (v286){
                        assert("The last element of the projection dimensions needs to be greater than the index remainder." && v285);
                    } else {
                    }
                    assert("Tensor range check" && 0 <= v280 && v280 < 256);
                    int v288;
                    v288 = 0;
                    while (while_method_6(v288)){
                        bool v290;
                        v290 = v281 && v285;
                        bool v291;
                        v291 = v290 == false;
                        if (v291){
                            assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v290);
                        } else {
                        }
                        bool v293;
                        v293 = 0 <= v288;
                        bool v295;
                        if (v293){
                            bool v294;
                            v294 = v288 < 1;
                            v295 = v294;
                        } else {
                            v295 = false;
                        }
                        bool v296;
                        v296 = v295 == false;
                        if (v296){
                            assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v295);
                        } else {
                        }
                        int v298;
                        v298 = v288 * 256;
                        int v299;
                        v299 = v298 + v280;
                        assert("Tensor range check" && 0 <= v288 && v288 < 1);
                        int v300;
                        v300 = 256 * v288;
                        int v301;
                        v301 = v300 + v280;
                        double * v302;
                        v302 = v272[v301];
                        double * v303;
                        v303 = v274[v301];
                        double * v304;
                        v304 = v276[v301];
                        double * v305;
                        v305 = v278[v301];
                        int v306;
                        v306 = blockIdx.x;
                        int v307;
                        v307 = v306 * 256;
                        int v308;
                        v308 = v307 + v299;
                        assert("Tensor range check" && 0 <= v284 && v284 < 1);
                        int v309;
                        v309 = 2 * v284;
                        double v310[2];
                        double v311[2];
                        int v312[2];
                        int v313;
                        v313 = 0;
                        while (while_method_6(v313)){
                            assert("Tensor range check" && 0 <= v313 && v313 < 1);
                            int v315;
                            v315 = 2 * v313;
                            assert("Tensor range check" && 0 <= v313 && v313 < 1);
                            int v316;
                            v316 = v315 + v309;
                            int4* v317;
                            v317 = reinterpret_cast<int4*>(v302 + v316);
                            int4* v318;
                            v318 = reinterpret_cast<int4*>(v310 + v315);
                            assert("Pointer alignment check" && reinterpret_cast<unsigned long long>(v317) % 16 == 0 && reinterpret_cast<unsigned long long>(v318) % 16 == 0);
                            *v318 = *v317;
                            int4* v319;
                            v319 = reinterpret_cast<int4*>(v303 + v316);
                            int4* v320;
                            v320 = reinterpret_cast<int4*>(v311 + v315);
                            assert("Pointer alignment check" && reinterpret_cast<unsigned long long>(v319) % 16 == 0 && reinterpret_cast<unsigned long long>(v320) % 16 == 0);
                            *v320 = *v319;
                            v313 += 1 ;
                        }
                        int v321;
                        v321 = 0;
                        while (while_method_6(v321)){
                            int v323;
                            v323 = 0;
                            while (while_method_0(v323)){
                                bool v325;
                                v325 = 0 <= v323;
                                bool v327;
                                if (v325){
                                    bool v326;
                                    v326 = v323 < 2;
                                    v327 = v326;
                                } else {
                                    v327 = false;
                                }
                                bool v328;
                                v328 = v327 == false;
                                if (v328){
                                    assert("The indices should be inside the range of the dimension." && v327);
                                } else {
                                }
                                bool v330;
                                v330 = 0 <= v284;
                                bool v332;
                                if (v330){
                                    bool v331;
                                    v331 = v284 < 1;
                                    v332 = v331;
                                } else {
                                    v332 = false;
                                }
                                bool v333;
                                v333 = v332 == false;
                                if (v333){
                                    assert("The indices should be inside the range of the dimension." && v332);
                                } else {
                                }
                                int v335;
                                v335 = v284 * 2;
                                int v336;
                                v336 = v323 + v335;
                                bool v337;
                                v337 = 0 <= v321;
                                bool v339;
                                if (v337){
                                    bool v338;
                                    v338 = v321 < 1;
                                    v339 = v338;
                                } else {
                                    v339 = false;
                                }
                                bool v340;
                                v340 = v339 == false;
                                if (v340){
                                    assert("The indices should be inside the range of the dimension." && v339);
                                } else {
                                }
                                int v342;
                                v342 = v321 * 2;
                                int v343;
                                v343 = v336 + v342;
                                assert("Tensor range check" && 0 <= v321 && v321 < 1);
                                assert("Tensor range check" && 0 <= v323 && v323 < 2);
                                int v344;
                                v344 = 2 * v321;
                                int v345;
                                v345 = v344 + v323;
                                v312[v345] = v343;
                                v323 += 1 ;
                            }
                            v321 += 1 ;
                        }
                        double v346[2];
                        double v347[2];
                        int v348;
                        v348 = 0;
                        while (while_method_6(v348)){
                            int v350;
                            v350 = 0;
                            while (while_method_0(v350)){
                                assert("Tensor range check" && 0 <= v348 && v348 < 1);
                                assert("Tensor range check" && 0 <= v350 && v350 < 2);
                                int v352;
                                v352 = 2 * v348;
                                int v353;
                                v353 = v352 + v350;
                                double v354;
                                v354 = v310[v353];
                                double v355;
                                v355 = v311[v353];
                                assert("Tensor range check" && 0 <= v348 && v348 < 1);
                                assert("Tensor range check" && 0 <= v350 && v350 < 2);
                                v346[v353] = 0.0;
                                v347[v353] = 0.0;
                                v350 += 1 ;
                            }
                            v348 += 1 ;
                        }
                        int v356;
                        v356 = 0;
                        while (while_method_6(v356)){
                            assert("Tensor range check" && 0 <= v356 && v356 < 1);
                            int v358;
                            v358 = 2 * v356;
                            int v359;
                            v359 = v358 + v309;
                            assert("Tensor range check" && 0 <= v356 && v356 < 1);
                            int4* v360;
                            v360 = reinterpret_cast<int4*>(v346 + v358);
                            int4* v361;
                            v361 = reinterpret_cast<int4*>(v304 + v359);
                            assert("Pointer alignment check" && reinterpret_cast<unsigned long long>(v360) % 16 == 0 && reinterpret_cast<unsigned long long>(v361) % 16 == 0);
                            *v361 = *v360;
                            int4* v362;
                            v362 = reinterpret_cast<int4*>(v347 + v358);
                            int4* v363;
                            v363 = reinterpret_cast<int4*>(v305 + v359);
                            assert("Pointer alignment check" && reinterpret_cast<unsigned long long>(v362) % 16 == 0 && reinterpret_cast<unsigned long long>(v363) % 16 == 0);
                            *v363 = *v362;
                            v356 += 1 ;
                        }
                        assert("Tensor range check" && 0 <= v299 && v299 < 256);
                        v288 += 1 ;
                    }
                    __syncthreads();
                    assert("Tensor range check" && 0 <= v280 && v280 < 256);
                    __syncthreads();
                    v234 += 1 ;
                }
                v31 += 1 ;
            }
            v29 += 1 ;
        }
        cooperative_groups::grid_group & v364 = v26.v1;
        cooperative_groups::grid_group & v365 = v364;
        curandStatePhilox4_32_10_t & v366 = v26.v5;
        curandStatePhilox4_32_10_t & v367 = v366;
        float * v368;
        v368 = reinterpret_cast<float *>(&v0[0ull]);
        float * v370;
        v370 = reinterpret_cast<float *>(&v2[0ull]);
        float * v372;
        v372 = reinterpret_cast<float *>(&v0[8388608ull]);
        float * v374;
        v374 = reinterpret_cast<float *>(&v2[8388608ull]);
        float * v376;
        v376 = reinterpret_cast<float *>(&v0[9437184ull]);
        float * v378;
        v378 = reinterpret_cast<float *>(&v2[9437184ull]);
        float * v380;
        v380 = reinterpret_cast<float *>(&v0[10485760ull]);
        float * v382;
        v382 = reinterpret_cast<float *>(&v2[10485760ull]);
        float * v384;
        v384 = reinterpret_cast<float *>(&v0[11534336ull]);
        float * v386;
        v386 = reinterpret_cast<float *>(&v2[11534336ull]);
        float * v388;
        v388 = reinterpret_cast<float *>(&v0[12582912ull]);
        float * v390;
        v390 = reinterpret_cast<float *>(&v2[12582912ull]);
        float * v392;
        v392 = reinterpret_cast<float *>(&v1[114819072ull]);
        int * v394;
        v394 = reinterpret_cast<int *>(&v0[12845056ull]);
        bool * v396;
        v396 = reinterpret_cast<bool *>(&v0[12845072ull]);
        float * v398;
        v398 = reinterpret_cast<float *>(&v0[12845088ull]);
        float * v400;
        v400 = reinterpret_cast<float *>(&v0[12845104ull]);
        double * v402;
        v402 = reinterpret_cast<double *>(&v1[121110528ull]);
        double * v404;
        v404 = reinterpret_cast<double *>(&v1[121503744ull]);
        v365.sync() ;
        int v406;
        v406 = threadIdx.x;
        int v407;
        v407 = blockIdx.x;
        int v408;
        v408 = v407 * 256;
        int v409;
        v409 = v406 + v408;
        bool v410;
        v410 = v409 == 0;
        if (v410){
            int v411;
            v411 = 0;
            int v412;
            v412 = 4;
            int v413;
            v413 = int_range_44(v412, v411, v367);
            v394[0] = v413;
        } else {
        }
        __syncwarp();
        float v414[4];
        int v415;
        v415 = 0;
        while (while_method_3(v415)){
            assert("Tensor range check" && 0 <= v415 && v415 < 4);
            float v417;
            v417 = v398[v415];
            float v418;
            v418 = v400[v415];
            bool v419;
            v419 = v418 == 0.0f;
            bool v420;
            v420 = v419 != true;
            float v422;
            if (v420){
                float v421;
                v421 = v417 / v418;
                v422 = v421;
            } else {
                v422 = 0.0f;
            }
            assert("Tensor range check" && 0 <= v415 && v415 < 4);
            v414[v415] = v422;
            v415 += 1 ;
        }
        float v423;
        v423 = 0.0f;
        int v424;
        v424 = 0;
        while (while_method_3(v424)){
            assert("Tensor range check" && 0 <= v424 && v424 < 4);
            float v426;
            v426 = v414[v424];
            float v427;
            v427 = v423 + v426;
            v423 = v427;
            v424 += 1 ;
        }
        float v428;
        v428 = v423 / 4.0f;
        int v429;
        v429 = 0;
        while (while_method_3(v429)){
            assert("Tensor range check" && 0 <= v429 && v429 < 4);
            v398[v429] = 0.0f;
            v400[v429] = 0.0f;
            v429 += 1 ;
        }
        bool v431[4];
        int v432;
        v432 = 0;
        while (while_method_3(v432)){
            assert("Tensor range check" && 0 <= v432 && v432 < 4);
            float v434;
            v434 = v414[v432];
            bool v435;
            v435 = v434 >= v428;
            assert("Tensor range check" && 0 <= v432 && v432 < 4);
            v431[v432] = v435;
            v432 += 1 ;
        }
        int v436;
        v436 = 0;
        while (while_method_3(v436)){
            assert("Tensor range check" && 0 <= v436 && v436 < 4);
            bool v438;
            v438 = v431[v436];
            assert("Tensor range check" && 0 <= v436 && v436 < 4);
            v396[v436] = v438;
            v436 += 1 ;
        }
        extern __shared__ unsigned char v439[];
        float * v440;
        v440 = reinterpret_cast<float *>(&v439[0ull]);
        int v442;
        v442 = blockIdx.x;
        int v443;
        v443 = v442;
        while (while_method_26(v443)){
            bool v445;
            v445 = 0 <= v443;
            bool v446;
            v446 = v445 == false;
            if (v446){
                assert("The index needs to be zero or positive." && v445);
            } else {
            }
            int v448;
            v448 = v443 % 1024;
            int v449;
            v449 = v443 / 1024;
            bool v450;
            v450 = v449 < 1;
            bool v451;
            v451 = v450 == false;
            if (v451){
                assert("The last element of the projection dimensions needs to be greater than the index remainder." && v450);
            } else {
            }
            assert("Tensor range check" && 0 <= v449 && v449 < 1);
            assert("Tensor range check" && 0 <= v448 && v448 < 1024);
            int v453;
            v453 = 512 * v448;
            int v454;
            v454 = 2097152 * v449;
            int v455;
            v455 = v454 + v453;
            int v456;
            v456 = 2048 * v448;
            int v457;
            v457 = 4 * v449;
            int v458;
            v458 = v457 + v456;
            int v459;
            v459 = threadIdx.x;
            int v460;
            v460 = v459;
            while (while_method_23(v460)){
                bool v462;
                v462 = 0 <= v460;
                bool v463;
                v463 = v462 == false;
                if (v463){
                    assert("The index needs to be zero or positive." && v462);
                } else {
                }
                int v465;
                v465 = v460 % 512;
                int v466;
                v466 = v460 / 512;
                bool v467;
                v467 = v466 < 4;
                bool v468;
                v468 = v467 == false;
                if (v468){
                    assert("The last element of the projection dimensions needs to be greater than the index remainder." && v467);
                } else {
                }
                assert("Tensor range check" && 0 <= v466 && v466 < 4);
                assert("Tensor range check" && 0 <= v465 && v465 < 512);
                int v470;
                v470 = v465 + v455;
                int v471;
                v471 = 524288 * v466;
                int v472;
                v472 = v471 + v470;
                float v473;
                v473 = v368[v472];
                assert("Tensor range check" && 0 <= v466 && v466 < 4);
                assert("Tensor range check" && 0 <= v465 && v465 < 512);
                int v474;
                v474 = 513 * v466;
                int v475;
                v475 = v474 + v465;
                v440[v475] = v473;
                v460 += 256 ;
            }
            __syncthreads();
            int v476;
            v476 = threadIdx.x;
            int v477;
            v477 = v476;
            while (while_method_23(v477)){
                bool v479;
                v479 = 0 <= v477;
                bool v480;
                v480 = v479 == false;
                if (v480){
                    assert("The index needs to be zero or positive." && v479);
                } else {
                }
                int v482;
                v482 = v477 % 4;
                int v483;
                v483 = v477 / 4;
                bool v484;
                v484 = v483 < 512;
                bool v485;
                v485 = v484 == false;
                if (v485){
                    assert("The last element of the projection dimensions needs to be greater than the index remainder." && v484);
                } else {
                }
                assert("Tensor range check" && 0 <= v483 && v483 < 512);
                assert("Tensor range check" && 0 <= v482 && v482 < 4);
                int v487;
                v487 = 513 * v482;
                int v488;
                v488 = v483 + v487;
                float v489;
                v489 = v440[v488];
                assert("Tensor range check" && 0 <= v483 && v483 < 512);
                assert("Tensor range check" && 0 <= v482 && v482 < 4);
                int v490;
                v490 = v482 + v458;
                int v491;
                v491 = 4 * v483;
                int v492;
                v492 = v491 + v490;
                v370[v492] = v489;
                v477 += 256 ;
            }
            __syncthreads();
            v443 += 24 ;
        }
        extern __shared__ unsigned char v493[];
        float * v494;
        v494 = reinterpret_cast<float *>(&v493[0ull]);
        int v496;
        v496 = blockIdx.x;
        int v497;
        v497 = v496;
        while (while_method_27(v497)){
            bool v499;
            v499 = 0 <= v497;
            bool v500;
            v500 = v499 == false;
            if (v500){
                assert("The index needs to be zero or positive." && v499);
            } else {
            }
            int v502;
            v502 = v497 % 128;
            int v503;
            v503 = v497 / 128;
            bool v504;
            v504 = v503 < 1;
            bool v505;
            v505 = v504 == false;
            if (v505){
                assert("The last element of the projection dimensions needs to be greater than the index remainder." && v504);
            } else {
            }
            assert("Tensor range check" && 0 <= v503 && v503 < 1);
            assert("Tensor range check" && 0 <= v502 && v502 < 128);
            int v507;
            v507 = 512 * v502;
            int v508;
            v508 = 262144 * v503;
            int v509;
            v509 = v508 + v507;
            int v510;
            v510 = 2048 * v502;
            int v511;
            v511 = 4 * v503;
            int v512;
            v512 = v511 + v510;
            int v513;
            v513 = threadIdx.x;
            int v514;
            v514 = v513;
            while (while_method_23(v514)){
                bool v516;
                v516 = 0 <= v514;
                bool v517;
                v517 = v516 == false;
                if (v517){
                    assert("The index needs to be zero or positive." && v516);
                } else {
                }
                int v519;
                v519 = v514 % 512;
                int v520;
                v520 = v514 / 512;
                bool v521;
                v521 = v520 < 4;
                bool v522;
                v522 = v521 == false;
                if (v522){
                    assert("The last element of the projection dimensions needs to be greater than the index remainder." && v521);
                } else {
                }
                assert("Tensor range check" && 0 <= v520 && v520 < 4);
                assert("Tensor range check" && 0 <= v519 && v519 < 512);
                int v524;
                v524 = v519 + v509;
                int v525;
                v525 = 65536 * v520;
                int v526;
                v526 = v525 + v524;
                float v527;
                v527 = v372[v526];
                assert("Tensor range check" && 0 <= v520 && v520 < 4);
                assert("Tensor range check" && 0 <= v519 && v519 < 512);
                int v528;
                v528 = 513 * v520;
                int v529;
                v529 = v528 + v519;
                v494[v529] = v527;
                v514 += 256 ;
            }
            __syncthreads();
            int v530;
            v530 = threadIdx.x;
            int v531;
            v531 = v530;
            while (while_method_23(v531)){
                bool v533;
                v533 = 0 <= v531;
                bool v534;
                v534 = v533 == false;
                if (v534){
                    assert("The index needs to be zero or positive." && v533);
                } else {
                }
                int v536;
                v536 = v531 % 4;
                int v537;
                v537 = v531 / 4;
                bool v538;
                v538 = v537 < 512;
                bool v539;
                v539 = v538 == false;
                if (v539){
                    assert("The last element of the projection dimensions needs to be greater than the index remainder." && v538);
                } else {
                }
                assert("Tensor range check" && 0 <= v537 && v537 < 512);
                assert("Tensor range check" && 0 <= v536 && v536 < 4);
                int v541;
                v541 = 513 * v536;
                int v542;
                v542 = v537 + v541;
                float v543;
                v543 = v494[v542];
                assert("Tensor range check" && 0 <= v537 && v537 < 512);
                assert("Tensor range check" && 0 <= v536 && v536 < 4);
                int v544;
                v544 = v536 + v512;
                int v545;
                v545 = 4 * v537;
                int v546;
                v546 = v545 + v544;
                v374[v546] = v543;
                v531 += 256 ;
            }
            __syncthreads();
            v497 += 24 ;
        }
        extern __shared__ unsigned char v547[];
        float * v548;
        v548 = reinterpret_cast<float *>(&v547[0ull]);
        int v550;
        v550 = blockIdx.x;
        int v551;
        v551 = v550;
        while (while_method_27(v551)){
            bool v553;
            v553 = 0 <= v551;
            bool v554;
            v554 = v553 == false;
            if (v554){
                assert("The index needs to be zero or positive." && v553);
            } else {
            }
            int v556;
            v556 = v551 % 128;
            int v557;
            v557 = v551 / 128;
            bool v558;
            v558 = v557 < 1;
            bool v559;
            v559 = v558 == false;
            if (v559){
                assert("The last element of the projection dimensions needs to be greater than the index remainder." && v558);
            } else {
            }
            assert("Tensor range check" && 0 <= v557 && v557 < 1);
            assert("Tensor range check" && 0 <= v556 && v556 < 128);
            int v561;
            v561 = 512 * v556;
            int v562;
            v562 = 262144 * v557;
            int v563;
            v563 = v562 + v561;
            int v564;
            v564 = 2048 * v556;
            int v565;
            v565 = 4 * v557;
            int v566;
            v566 = v565 + v564;
            int v567;
            v567 = threadIdx.x;
            int v568;
            v568 = v567;
            while (while_method_23(v568)){
                bool v570;
                v570 = 0 <= v568;
                bool v571;
                v571 = v570 == false;
                if (v571){
                    assert("The index needs to be zero or positive." && v570);
                } else {
                }
                int v573;
                v573 = v568 % 512;
                int v574;
                v574 = v568 / 512;
                bool v575;
                v575 = v574 < 4;
                bool v576;
                v576 = v575 == false;
                if (v576){
                    assert("The last element of the projection dimensions needs to be greater than the index remainder." && v575);
                } else {
                }
                assert("Tensor range check" && 0 <= v574 && v574 < 4);
                assert("Tensor range check" && 0 <= v573 && v573 < 512);
                int v578;
                v578 = v573 + v563;
                int v579;
                v579 = 65536 * v574;
                int v580;
                v580 = v579 + v578;
                float v581;
                v581 = v376[v580];
                assert("Tensor range check" && 0 <= v574 && v574 < 4);
                assert("Tensor range check" && 0 <= v573 && v573 < 512);
                int v582;
                v582 = 513 * v574;
                int v583;
                v583 = v582 + v573;
                v548[v583] = v581;
                v568 += 256 ;
            }
            __syncthreads();
            int v584;
            v584 = threadIdx.x;
            int v585;
            v585 = v584;
            while (while_method_23(v585)){
                bool v587;
                v587 = 0 <= v585;
                bool v588;
                v588 = v587 == false;
                if (v588){
                    assert("The index needs to be zero or positive." && v587);
                } else {
                }
                int v590;
                v590 = v585 % 4;
                int v591;
                v591 = v585 / 4;
                bool v592;
                v592 = v591 < 512;
                bool v593;
                v593 = v592 == false;
                if (v593){
                    assert("The last element of the projection dimensions needs to be greater than the index remainder." && v592);
                } else {
                }
                assert("Tensor range check" && 0 <= v591 && v591 < 512);
                assert("Tensor range check" && 0 <= v590 && v590 < 4);
                int v595;
                v595 = 513 * v590;
                int v596;
                v596 = v591 + v595;
                float v597;
                v597 = v548[v596];
                assert("Tensor range check" && 0 <= v591 && v591 < 512);
                assert("Tensor range check" && 0 <= v590 && v590 < 4);
                int v598;
                v598 = v590 + v566;
                int v599;
                v599 = 4 * v591;
                int v600;
                v600 = v599 + v598;
                v378[v600] = v597;
                v585 += 256 ;
            }
            __syncthreads();
            v551 += 24 ;
        }
        extern __shared__ unsigned char v601[];
        float * v602;
        v602 = reinterpret_cast<float *>(&v601[0ull]);
        int v604;
        v604 = blockIdx.x;
        int v605;
        v605 = v604;
        while (while_method_27(v605)){
            bool v607;
            v607 = 0 <= v605;
            bool v608;
            v608 = v607 == false;
            if (v608){
                assert("The index needs to be zero or positive." && v607);
            } else {
            }
            int v610;
            v610 = v605 % 128;
            int v611;
            v611 = v605 / 128;
            bool v612;
            v612 = v611 < 1;
            bool v613;
            v613 = v612 == false;
            if (v613){
                assert("The last element of the projection dimensions needs to be greater than the index remainder." && v612);
            } else {
            }
            assert("Tensor range check" && 0 <= v611 && v611 < 1);
            assert("Tensor range check" && 0 <= v610 && v610 < 128);
            int v615;
            v615 = 512 * v610;
            int v616;
            v616 = 262144 * v611;
            int v617;
            v617 = v616 + v615;
            int v618;
            v618 = 2048 * v610;
            int v619;
            v619 = 4 * v611;
            int v620;
            v620 = v619 + v618;
            int v621;
            v621 = threadIdx.x;
            int v622;
            v622 = v621;
            while (while_method_23(v622)){
                bool v624;
                v624 = 0 <= v622;
                bool v625;
                v625 = v624 == false;
                if (v625){
                    assert("The index needs to be zero or positive." && v624);
                } else {
                }
                int v627;
                v627 = v622 % 512;
                int v628;
                v628 = v622 / 512;
                bool v629;
                v629 = v628 < 4;
                bool v630;
                v630 = v629 == false;
                if (v630){
                    assert("The last element of the projection dimensions needs to be greater than the index remainder." && v629);
                } else {
                }
                assert("Tensor range check" && 0 <= v628 && v628 < 4);
                assert("Tensor range check" && 0 <= v627 && v627 < 512);
                int v632;
                v632 = v627 + v617;
                int v633;
                v633 = 65536 * v628;
                int v634;
                v634 = v633 + v632;
                float v635;
                v635 = v380[v634];
                assert("Tensor range check" && 0 <= v628 && v628 < 4);
                assert("Tensor range check" && 0 <= v627 && v627 < 512);
                int v636;
                v636 = 513 * v628;
                int v637;
                v637 = v636 + v627;
                v602[v637] = v635;
                v622 += 256 ;
            }
            __syncthreads();
            int v638;
            v638 = threadIdx.x;
            int v639;
            v639 = v638;
            while (while_method_23(v639)){
                bool v641;
                v641 = 0 <= v639;
                bool v642;
                v642 = v641 == false;
                if (v642){
                    assert("The index needs to be zero or positive." && v641);
                } else {
                }
                int v644;
                v644 = v639 % 4;
                int v645;
                v645 = v639 / 4;
                bool v646;
                v646 = v645 < 512;
                bool v647;
                v647 = v646 == false;
                if (v647){
                    assert("The last element of the projection dimensions needs to be greater than the index remainder." && v646);
                } else {
                }
                assert("Tensor range check" && 0 <= v645 && v645 < 512);
                assert("Tensor range check" && 0 <= v644 && v644 < 4);
                int v649;
                v649 = 513 * v644;
                int v650;
                v650 = v645 + v649;
                float v651;
                v651 = v602[v650];
                assert("Tensor range check" && 0 <= v645 && v645 < 512);
                assert("Tensor range check" && 0 <= v644 && v644 < 4);
                int v652;
                v652 = v644 + v620;
                int v653;
                v653 = 4 * v645;
                int v654;
                v654 = v653 + v652;
                v382[v654] = v651;
                v639 += 256 ;
            }
            __syncthreads();
            v605 += 24 ;
        }
        extern __shared__ unsigned char v655[];
        float * v656;
        v656 = reinterpret_cast<float *>(&v655[0ull]);
        int v658;
        v658 = blockIdx.x;
        int v659;
        v659 = v658;
        while (while_method_27(v659)){
            bool v661;
            v661 = 0 <= v659;
            bool v662;
            v662 = v661 == false;
            if (v662){
                assert("The index needs to be zero or positive." && v661);
            } else {
            }
            int v664;
            v664 = v659 % 128;
            int v665;
            v665 = v659 / 128;
            bool v666;
            v666 = v665 < 1;
            bool v667;
            v667 = v666 == false;
            if (v667){
                assert("The last element of the projection dimensions needs to be greater than the index remainder." && v666);
            } else {
            }
            assert("Tensor range check" && 0 <= v665 && v665 < 1);
            assert("Tensor range check" && 0 <= v664 && v664 < 128);
            int v669;
            v669 = 512 * v664;
            int v670;
            v670 = 262144 * v665;
            int v671;
            v671 = v670 + v669;
            int v672;
            v672 = 2048 * v664;
            int v673;
            v673 = 4 * v665;
            int v674;
            v674 = v673 + v672;
            int v675;
            v675 = threadIdx.x;
            int v676;
            v676 = v675;
            while (while_method_23(v676)){
                bool v678;
                v678 = 0 <= v676;
                bool v679;
                v679 = v678 == false;
                if (v679){
                    assert("The index needs to be zero or positive." && v678);
                } else {
                }
                int v681;
                v681 = v676 % 512;
                int v682;
                v682 = v676 / 512;
                bool v683;
                v683 = v682 < 4;
                bool v684;
                v684 = v683 == false;
                if (v684){
                    assert("The last element of the projection dimensions needs to be greater than the index remainder." && v683);
                } else {
                }
                assert("Tensor range check" && 0 <= v682 && v682 < 4);
                assert("Tensor range check" && 0 <= v681 && v681 < 512);
                int v686;
                v686 = v681 + v671;
                int v687;
                v687 = 65536 * v682;
                int v688;
                v688 = v687 + v686;
                float v689;
                v689 = v384[v688];
                assert("Tensor range check" && 0 <= v682 && v682 < 4);
                assert("Tensor range check" && 0 <= v681 && v681 < 512);
                int v690;
                v690 = 513 * v682;
                int v691;
                v691 = v690 + v681;
                v656[v691] = v689;
                v676 += 256 ;
            }
            __syncthreads();
            int v692;
            v692 = threadIdx.x;
            int v693;
            v693 = v692;
            while (while_method_23(v693)){
                bool v695;
                v695 = 0 <= v693;
                bool v696;
                v696 = v695 == false;
                if (v696){
                    assert("The index needs to be zero or positive." && v695);
                } else {
                }
                int v698;
                v698 = v693 % 4;
                int v699;
                v699 = v693 / 4;
                bool v700;
                v700 = v699 < 512;
                bool v701;
                v701 = v700 == false;
                if (v701){
                    assert("The last element of the projection dimensions needs to be greater than the index remainder." && v700);
                } else {
                }
                assert("Tensor range check" && 0 <= v699 && v699 < 512);
                assert("Tensor range check" && 0 <= v698 && v698 < 4);
                int v703;
                v703 = 513 * v698;
                int v704;
                v704 = v699 + v703;
                float v705;
                v705 = v656[v704];
                assert("Tensor range check" && 0 <= v699 && v699 < 512);
                assert("Tensor range check" && 0 <= v698 && v698 < 4);
                int v706;
                v706 = v698 + v674;
                int v707;
                v707 = 4 * v699;
                int v708;
                v708 = v707 + v706;
                v386[v708] = v705;
                v693 += 256 ;
            }
            __syncthreads();
            v659 += 24 ;
        }
        extern __shared__ unsigned char v709[];
        float * v710;
        v710 = reinterpret_cast<float *>(&v709[0ull]);
        int v712;
        v712 = blockIdx.x;
        int v713;
        v713 = v712;
        while (while_method_24(v713)){
            bool v715;
            v715 = 0 <= v713;
            bool v716;
            v716 = v715 == false;
            if (v716){
                assert("The index needs to be zero or positive." && v715);
            } else {
            }
            int v718;
            v718 = v713 % 32;
            int v719;
            v719 = v713 / 32;
            bool v720;
            v720 = v719 < 1;
            bool v721;
            v721 = v720 == false;
            if (v721){
                assert("The last element of the projection dimensions needs to be greater than the index remainder." && v720);
            } else {
            }
            assert("Tensor range check" && 0 <= v719 && v719 < 1);
            assert("Tensor range check" && 0 <= v718 && v718 < 32);
            int v723;
            v723 = 512 * v718;
            int v724;
            v724 = 65536 * v719;
            int v725;
            v725 = v724 + v723;
            int v726;
            v726 = 2048 * v718;
            int v727;
            v727 = 4 * v719;
            int v728;
            v728 = v727 + v726;
            int v729;
            v729 = threadIdx.x;
            int v730;
            v730 = v729;
            while (while_method_23(v730)){
                bool v732;
                v732 = 0 <= v730;
                bool v733;
                v733 = v732 == false;
                if (v733){
                    assert("The index needs to be zero or positive." && v732);
                } else {
                }
                int v735;
                v735 = v730 % 512;
                int v736;
                v736 = v730 / 512;
                bool v737;
                v737 = v736 < 4;
                bool v738;
                v738 = v737 == false;
                if (v738){
                    assert("The last element of the projection dimensions needs to be greater than the index remainder." && v737);
                } else {
                }
                assert("Tensor range check" && 0 <= v736 && v736 < 4);
                assert("Tensor range check" && 0 <= v735 && v735 < 512);
                int v740;
                v740 = v735 + v725;
                int v741;
                v741 = 16384 * v736;
                int v742;
                v742 = v741 + v740;
                float v743;
                v743 = v388[v742];
                assert("Tensor range check" && 0 <= v736 && v736 < 4);
                assert("Tensor range check" && 0 <= v735 && v735 < 512);
                int v744;
                v744 = 513 * v736;
                int v745;
                v745 = v744 + v735;
                v710[v745] = v743;
                v730 += 256 ;
            }
            __syncthreads();
            int v746;
            v746 = threadIdx.x;
            int v747;
            v747 = v746;
            while (while_method_23(v747)){
                bool v749;
                v749 = 0 <= v747;
                bool v750;
                v750 = v749 == false;
                if (v750){
                    assert("The index needs to be zero or positive." && v749);
                } else {
                }
                int v752;
                v752 = v747 % 4;
                int v753;
                v753 = v747 / 4;
                bool v754;
                v754 = v753 < 512;
                bool v755;
                v755 = v754 == false;
                if (v755){
                    assert("The last element of the projection dimensions needs to be greater than the index remainder." && v754);
                } else {
                }
                assert("Tensor range check" && 0 <= v753 && v753 < 512);
                assert("Tensor range check" && 0 <= v752 && v752 < 4);
                int v757;
                v757 = 513 * v752;
                int v758;
                v758 = v753 + v757;
                float v759;
                v759 = v710[v758];
                assert("Tensor range check" && 0 <= v753 && v753 < 512);
                assert("Tensor range check" && 0 <= v752 && v752 < 4);
                int v760;
                v760 = v752 + v728;
                int v761;
                v761 = 4 * v753;
                int v762;
                v762 = v761 + v760;
                v390[v762] = v759;
                v747 += 256 ;
            }
            __syncthreads();
            v713 += 24 ;
        }
        v365.sync() ;
        int v763;
        v763 = threadIdx.x;
        bool v764;
        v764 = 0 <= v763;
        bool v765;
        v765 = v764 == false;
        if (v765){
            assert("The index needs to be zero or positive." && v764);
        } else {
        }
        int v767;
        v767 = v763 % 1;
        int v768;
        v768 = v763 % 256;
        int v769;
        v769 = v763 / 256;
        bool v770;
        v770 = v769 < 1;
        bool v771;
        v771 = v770 == false;
        if (v771){
            assert("The last element of the projection dimensions needs to be greater than the index remainder." && v770);
        } else {
        }
        assert("Tensor range check" && 0 <= v769 && v769 < 1);
        assert("Tensor range check" && 0 <= v768 && v768 < 256);
        assert("Tensor range check" && 0 <= v767 && v767 < 1);
        int v773;
        v773 = 4 * v767;
        int v774;
        v774 = 4 * v768;
        int v775;
        v775 = v774 + v773;
        int v776;
        v776 = 8192 * v769;
        int v777;
        v777 = v776 + v775;
        assert("Tensor range check" && 0 <= v769 && v769 < 1);
        assert("Tensor range check" && 0 <= v768 && v768 < 256);
        assert("Tensor range check" && 0 <= v767 && v767 < 1);
        int v778;
        v778 = blockIdx.x;
        int v779;
        v779 = v778;
        while (while_method_23(v779)){
            bool v781;
            v781 = 0 <= v779;
            bool v782;
            v782 = v781 == false;
            if (v782){
                assert("The index needs to be zero or positive." && v781);
            } else {
            }
            int v784;
            v784 = v779 % 8;
            int v785;
            v785 = v779 / 8;
            bool v786;
            v786 = v785 < 256;
            bool v787;
            v787 = v786 == false;
            if (v787){
                assert("The last element of the projection dimensions needs to be greater than the index remainder." && v786);
            } else {
            }
            assert("Tensor range check" && 0 <= v785 && v785 < 256);
            assert("Tensor range check" && 0 <= v784 && v784 < 8);
            int v789;
            v789 = 1024 * v784;
            int v790;
            v790 = v789 + v777;
            int v791;
            v791 = 8192 * v785;
            int v792;
            v792 = v791 + v790;
            float v793[4];
            int v794[4];
            int v795;
            v795 = 0;
            while (while_method_6(v795)){
                assert("Tensor range check" && 0 <= v795 && v795 < 1);
                int v797;
                v797 = 4 * v795;
                assert("Tensor range check" && 0 <= v795 && v795 < 1);
                int v798;
                v798 = v797 + v792;
                int4* v799;
                v799 = reinterpret_cast<int4*>(v370 + v798);
                int4* v800;
                v800 = reinterpret_cast<int4*>(v793 + v797);
                assert("Pointer alignment check" && reinterpret_cast<unsigned long long>(v799) % 16 == 0 && reinterpret_cast<unsigned long long>(v800) % 16 == 0);
                *v800 = *v799;
                v795 += 1 ;
            }
            int v801;
            v801 = 0;
            while (while_method_6(v801)){
                int v803;
                v803 = 0;
                while (while_method_3(v803)){
                    bool v805;
                    v805 = 0 <= v803;
                    bool v807;
                    if (v805){
                        bool v806;
                        v806 = v803 < 4;
                        v807 = v806;
                    } else {
                        v807 = false;
                    }
                    bool v808;
                    v808 = v807 == false;
                    if (v808){
                        assert("The indices should be inside the range of the dimension." && v807);
                    } else {
                    }
                    bool v810;
                    v810 = 0 <= v767;
                    bool v812;
                    if (v810){
                        bool v811;
                        v811 = v767 < 1;
                        v812 = v811;
                    } else {
                        v812 = false;
                    }
                    bool v813;
                    v813 = v812 == false;
                    if (v813){
                        assert("The indices should be inside the range of the dimension." && v812);
                    } else {
                    }
                    int v815;
                    v815 = v767 * 4;
                    int v816;
                    v816 = v803 + v815;
                    bool v817;
                    v817 = 0 <= v801;
                    bool v819;
                    if (v817){
                        bool v818;
                        v818 = v801 < 1;
                        v819 = v818;
                    } else {
                        v819 = false;
                    }
                    bool v820;
                    v820 = v819 == false;
                    if (v820){
                        assert("The indices should be inside the range of the dimension." && v819);
                    } else {
                    }
                    int v822;
                    v822 = v801 * 4;
                    int v823;
                    v823 = v816 + v822;
                    assert("Tensor range check" && 0 <= v801 && v801 < 1);
                    assert("Tensor range check" && 0 <= v803 && v803 < 4);
                    int v824;
                    v824 = 4 * v801;
                    int v825;
                    v825 = v824 + v803;
                    v794[v825] = v823;
                    v803 += 1 ;
                }
                v801 += 1 ;
            }
            bool v826;
            v826 = 0 <= v769;
            bool v827;
            v827 = v826 && v770;
            bool v828;
            v828 = v827 == false;
            if (v828){
                assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v827);
            } else {
            }
            bool v830;
            v830 = 0 <= v768;
            bool v832;
            if (v830){
                bool v831;
                v831 = v768 < 256;
                v832 = v831;
            } else {
                v832 = false;
            }
            bool v833;
            v833 = v832 == false;
            if (v833){
                assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v832);
            } else {
            }
            bool v835;
            v835 = 0 <= v785;
            bool v836;
            v836 = v835 && v786;
            bool v837;
            v837 = v836 == false;
            if (v837){
                assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v836);
            } else {
            }
            bool v839;
            v839 = 0 <= v784;
            bool v841;
            if (v839){
                bool v840;
                v840 = v784 < 8;
                v841 = v840;
            } else {
                v841 = false;
            }
            bool v842;
            v842 = v841 == false;
            if (v842){
                assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v841);
            } else {
            }
            int v844;
            v844 = v784 * 256;
            int v845;
            v845 = v785 + v769;
            int v846;
            v846 = v844 + v768;
            bool v847[4];
            int v848;
            v848 = 0;
            while (while_method_6(v848)){
                int v850;
                v850 = 0;
                while (while_method_3(v850)){
                    assert("Tensor range check" && 0 <= v848 && v848 < 1);
                    assert("Tensor range check" && 0 <= v850 && v850 < 4);
                    int v852;
                    v852 = 4 * v848;
                    int v853;
                    v853 = v852 + v850;
                    int v854;
                    v854 = v794[v853];
                    assert("Tensor range check" && 0 <= v854 && v854 < 4);
                    bool v855;
                    v855 = v396[v854];
                    assert("Tensor range check" && 0 <= v848 && v848 < 1);
                    assert("Tensor range check" && 0 <= v850 && v850 < 4);
                    v847[v853] = v855;
                    v850 += 1 ;
                }
                v848 += 1 ;
            }
            int v856[4];
            int v857;
            v857 = 0;
            while (while_method_6(v857)){
                int v859;
                v859 = 0;
                while (while_method_3(v859)){
                    assert("Tensor range check" && 0 <= v857 && v857 < 1);
                    assert("Tensor range check" && 0 <= v859 && v859 < 4);
                    int v861;
                    v861 = 4 * v857;
                    int v862;
                    v862 = v861 + v859;
                    bool v863;
                    v863 = v847[v862];
                    int v864;
                    if (v863){
                        v864 = 1;
                    } else {
                        v864 = 0;
                    }
                    assert("Tensor range check" && 0 <= v857 && v857 < 1);
                    assert("Tensor range check" && 0 <= v859 && v859 < 4);
                    v856[v862] = v864;
                    v859 += 1 ;
                }
                v857 += 1 ;
            }
            int v865;
            v865 = 0;
            int v866;
            v866 = 0;
            while (while_method_6(v866)){
                int v868;
                v868 = 0;
                while (while_method_3(v868)){
                    assert("Tensor range check" && 0 <= v866 && v866 < 1);
                    assert("Tensor range check" && 0 <= v868 && v868 < 4);
                    int v870;
                    v870 = 4 * v866;
                    int v871;
                    v871 = v870 + v868;
                    int v872;
                    v872 = v856[v871];
                    int v873;
                    v873 = v865 + v872;
                    v865 = v873;
                    v868 += 1 ;
                }
                v866 += 1 ;
            }
            auto v874 = cooperative_groups::coalesced_threads();
            int v875;
            v875 = threadIdx.x;
            auto v876 = cooperative_groups::labeled_partition(v874,v875);
            Closure1 v877{};
            int v878;
            v878 = cooperative_groups::reduce(v876, v865, v877);
            float v879;
            v879 = (float)v878;
            float v880[4];
            int v881;
            v881 = 0;
            while (while_method_6(v881)){
                int v883;
                v883 = 0;
                while (while_method_3(v883)){
                    assert("Tensor range check" && 0 <= v881 && v881 < 1);
                    assert("Tensor range check" && 0 <= v883 && v883 < 4);
                    int v885;
                    v885 = 4 * v881;
                    int v886;
                    v886 = v885 + v883;
                    float v887;
                    v887 = v793[v886];
                    bool v888;
                    v888 = v847[v886];
                    float v889;
                    if (v888){
                        v889 = v887;
                    } else {
                        v889 = 0.0f;
                    }
                    assert("Tensor range check" && 0 <= v881 && v881 < 1);
                    assert("Tensor range check" && 0 <= v883 && v883 < 4);
                    v880[v886] = v889;
                    v883 += 1 ;
                }
                v881 += 1 ;
            }
            float v890;
            v890 = 0.0f;
            int v891;
            v891 = 0;
            while (while_method_6(v891)){
                int v893;
                v893 = 0;
                while (while_method_3(v893)){
                    assert("Tensor range check" && 0 <= v891 && v891 < 1);
                    assert("Tensor range check" && 0 <= v893 && v893 < 4);
                    int v895;
                    v895 = 4 * v891;
                    int v896;
                    v896 = v895 + v893;
                    float v897;
                    v897 = v880[v896];
                    float v898;
                    v898 = v890 + v897;
                    v890 = v898;
                    v893 += 1 ;
                }
                v891 += 1 ;
            }
            auto v899 = cooperative_groups::coalesced_threads();
            int v900;
            v900 = threadIdx.x;
            auto v901 = cooperative_groups::labeled_partition(v899,v900);
            Closure0 v902{};
            float v903;
            v903 = cooperative_groups::reduce(v901, v890, v902);
            float v904;
            v904 = v903 / v879;
            float v905[4];
            int v906;
            v906 = 0;
            while (while_method_6(v906)){
                int v908;
                v908 = 0;
                while (while_method_3(v908)){
                    assert("Tensor range check" && 0 <= v906 && v906 < 1);
                    assert("Tensor range check" && 0 <= v908 && v908 < 4);
                    int v910;
                    v910 = 4 * v906;
                    int v911;
                    v911 = v910 + v908;
                    float v912;
                    v912 = v793[v911];
                    float v913;
                    v913 = v912 - v904;
                    float v914;
                    v914 = v913 * v913;
                    assert("Tensor range check" && 0 <= v906 && v906 < 1);
                    assert("Tensor range check" && 0 <= v908 && v908 < 4);
                    v905[v911] = v914;
                    v908 += 1 ;
                }
                v906 += 1 ;
            }
            float v915[4];
            int v916;
            v916 = 0;
            while (while_method_6(v916)){
                int v918;
                v918 = 0;
                while (while_method_3(v918)){
                    assert("Tensor range check" && 0 <= v916 && v916 < 1);
                    assert("Tensor range check" && 0 <= v918 && v918 < 4);
                    int v920;
                    v920 = 4 * v916;
                    int v921;
                    v921 = v920 + v918;
                    float v922;
                    v922 = v905[v921];
                    bool v923;
                    v923 = v847[v921];
                    float v924;
                    if (v923){
                        v924 = v922;
                    } else {
                        v924 = 0.0f;
                    }
                    assert("Tensor range check" && 0 <= v916 && v916 < 1);
                    assert("Tensor range check" && 0 <= v918 && v918 < 4);
                    v915[v921] = v924;
                    v918 += 1 ;
                }
                v916 += 1 ;
            }
            float v925;
            v925 = 0.0f;
            int v926;
            v926 = 0;
            while (while_method_6(v926)){
                int v928;
                v928 = 0;
                while (while_method_3(v928)){
                    assert("Tensor range check" && 0 <= v926 && v926 < 1);
                    assert("Tensor range check" && 0 <= v928 && v928 < 4);
                    int v930;
                    v930 = 4 * v926;
                    int v931;
                    v931 = v930 + v928;
                    float v932;
                    v932 = v915[v931];
                    float v933;
                    v933 = v925 + v932;
                    v925 = v933;
                    v928 += 1 ;
                }
                v926 += 1 ;
            }
            auto v934 = cooperative_groups::coalesced_threads();
            int v935;
            v935 = threadIdx.x;
            auto v936 = cooperative_groups::labeled_partition(v934,v935);
            float v937;
            v937 = cooperative_groups::reduce(v936, v925, v902);
            float v938;
            v938 = v937 / v879;
            float v939;
            v939 = sqrt(v938);
            bool v940;
            v940 = v879 > 1.0f;
            float v944;
            if (v940){
                float v941;
                v941 = v939 * v879;
                float v942;
                v942 = v879 - 1.0f;
                float v943;
                v943 = v941 / v942;
                v944 = v943;
            } else {
                v944 = 0.0f;
            }
            float v945[4];
            int v946;
            v946 = 0;
            while (while_method_6(v946)){
                int v948;
                v948 = 0;
                while (while_method_3(v948)){
                    assert("Tensor range check" && 0 <= v946 && v946 < 1);
                    assert("Tensor range check" && 0 <= v948 && v948 < 4);
                    int v950;
                    v950 = 4 * v946;
                    int v951;
                    v951 = v950 + v948;
                    float v952;
                    v952 = v793[v951];
                    bool v953;
                    v953 = v847[v951];
                    float v954;
                    v954 = curand_normal(&v367);
                    bool v955;
                    v955 = v944 >= 0.1f;
                    float v956;
                    if (v955){
                        v956 = v944;
                    } else {
                        v956 = 0.1f;
                    }
                    float v957;
                    v957 = v954 * v956;
                    float v958;
                    v958 = v957 + v904;
                    float v959;
                    if (v953){
                        v959 = v952;
                    } else {
                        v959 = v958;
                    }
                    assert("Tensor range check" && 0 <= v946 && v946 < 1);
                    assert("Tensor range check" && 0 <= v948 && v948 < 4);
                    v945[v951] = v959;
                    v948 += 1 ;
                }
                v946 += 1 ;
            }
            assert("Tensor range check" && 0 <= v785 && v785 < 256);
            assert("Tensor range check" && 0 <= v784 && v784 < 8);
            int v960;
            v960 = 0;
            while (while_method_6(v960)){
                assert("Tensor range check" && 0 <= v960 && v960 < 1);
                int v962;
                v962 = 4 * v960;
                int v963;
                v963 = v962 + v792;
                assert("Tensor range check" && 0 <= v960 && v960 < 1);
                int4* v964;
                v964 = reinterpret_cast<int4*>(v945 + v962);
                int4* v965;
                v965 = reinterpret_cast<int4*>(v370 + v963);
                assert("Pointer alignment check" && reinterpret_cast<unsigned long long>(v964) % 16 == 0 && reinterpret_cast<unsigned long long>(v965) % 16 == 0);
                *v965 = *v964;
                v960 += 1 ;
            }
            v779 += 24 ;
        }
        int v966;
        v966 = threadIdx.x;
        bool v967;
        v967 = 0 <= v966;
        bool v968;
        v968 = v967 == false;
        if (v968){
            assert("The index needs to be zero or positive." && v967);
        } else {
        }
        int v970;
        v970 = v966 % 1;
        int v971;
        v971 = v966 % 256;
        int v972;
        v972 = v966 / 256;
        bool v973;
        v973 = v972 < 1;
        bool v974;
        v974 = v973 == false;
        if (v974){
            assert("The last element of the projection dimensions needs to be greater than the index remainder." && v973);
        } else {
        }
        assert("Tensor range check" && 0 <= v972 && v972 < 1);
        assert("Tensor range check" && 0 <= v971 && v971 < 256);
        assert("Tensor range check" && 0 <= v970 && v970 < 1);
        int v976;
        v976 = 4 * v970;
        int v977;
        v977 = 4 * v971;
        int v978;
        v978 = v977 + v976;
        int v979;
        v979 = 1024 * v972;
        int v980;
        v980 = v979 + v978;
        assert("Tensor range check" && 0 <= v972 && v972 < 1);
        assert("Tensor range check" && 0 <= v971 && v971 < 256);
        assert("Tensor range check" && 0 <= v970 && v970 < 1);
        int v981;
        v981 = blockIdx.x;
        int v982;
        v982 = v981;
        while (while_method_28(v982)){
            bool v984;
            v984 = 0 <= v982;
            bool v985;
            v985 = v984 == false;
            if (v985){
                assert("The index needs to be zero or positive." && v984);
            } else {
            }
            int v987;
            v987 = v982 % 1;
            bool v988;
            v988 = v982 < 256;
            bool v989;
            v989 = v988 == false;
            if (v989){
                assert("The last element of the projection dimensions needs to be greater than the index remainder." && v988);
            } else {
            }
            assert("Tensor range check" && 0 <= v982 && v982 < 256);
            assert("Tensor range check" && 0 <= v987 && v987 < 1);
            int v991;
            v991 = 1024 * v987;
            int v992;
            v992 = v991 + v980;
            int v993;
            v993 = 1024 * v982;
            int v994;
            v994 = v993 + v992;
            float v995[4];
            int v996[4];
            int v997;
            v997 = 0;
            while (while_method_6(v997)){
                assert("Tensor range check" && 0 <= v997 && v997 < 1);
                int v999;
                v999 = 4 * v997;
                assert("Tensor range check" && 0 <= v997 && v997 < 1);
                int v1000;
                v1000 = v999 + v994;
                int4* v1001;
                v1001 = reinterpret_cast<int4*>(v374 + v1000);
                int4* v1002;
                v1002 = reinterpret_cast<int4*>(v995 + v999);
                assert("Pointer alignment check" && reinterpret_cast<unsigned long long>(v1001) % 16 == 0 && reinterpret_cast<unsigned long long>(v1002) % 16 == 0);
                *v1002 = *v1001;
                v997 += 1 ;
            }
            int v1003;
            v1003 = 0;
            while (while_method_6(v1003)){
                int v1005;
                v1005 = 0;
                while (while_method_3(v1005)){
                    bool v1007;
                    v1007 = 0 <= v1005;
                    bool v1009;
                    if (v1007){
                        bool v1008;
                        v1008 = v1005 < 4;
                        v1009 = v1008;
                    } else {
                        v1009 = false;
                    }
                    bool v1010;
                    v1010 = v1009 == false;
                    if (v1010){
                        assert("The indices should be inside the range of the dimension." && v1009);
                    } else {
                    }
                    bool v1012;
                    v1012 = 0 <= v970;
                    bool v1014;
                    if (v1012){
                        bool v1013;
                        v1013 = v970 < 1;
                        v1014 = v1013;
                    } else {
                        v1014 = false;
                    }
                    bool v1015;
                    v1015 = v1014 == false;
                    if (v1015){
                        assert("The indices should be inside the range of the dimension." && v1014);
                    } else {
                    }
                    int v1017;
                    v1017 = v970 * 4;
                    int v1018;
                    v1018 = v1005 + v1017;
                    bool v1019;
                    v1019 = 0 <= v1003;
                    bool v1021;
                    if (v1019){
                        bool v1020;
                        v1020 = v1003 < 1;
                        v1021 = v1020;
                    } else {
                        v1021 = false;
                    }
                    bool v1022;
                    v1022 = v1021 == false;
                    if (v1022){
                        assert("The indices should be inside the range of the dimension." && v1021);
                    } else {
                    }
                    int v1024;
                    v1024 = v1003 * 4;
                    int v1025;
                    v1025 = v1018 + v1024;
                    assert("Tensor range check" && 0 <= v1003 && v1003 < 1);
                    assert("Tensor range check" && 0 <= v1005 && v1005 < 4);
                    int v1026;
                    v1026 = 4 * v1003;
                    int v1027;
                    v1027 = v1026 + v1005;
                    v996[v1027] = v1025;
                    v1005 += 1 ;
                }
                v1003 += 1 ;
            }
            bool v1028;
            v1028 = 0 <= v972;
            bool v1029;
            v1029 = v1028 && v973;
            bool v1030;
            v1030 = v1029 == false;
            if (v1030){
                assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v1029);
            } else {
            }
            bool v1032;
            v1032 = 0 <= v971;
            bool v1034;
            if (v1032){
                bool v1033;
                v1033 = v971 < 256;
                v1034 = v1033;
            } else {
                v1034 = false;
            }
            bool v1035;
            v1035 = v1034 == false;
            if (v1035){
                assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v1034);
            } else {
            }
            bool v1037;
            v1037 = v984 && v988;
            bool v1038;
            v1038 = v1037 == false;
            if (v1038){
                assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v1037);
            } else {
            }
            bool v1040;
            v1040 = 0 <= v987;
            bool v1042;
            if (v1040){
                bool v1041;
                v1041 = v987 < 1;
                v1042 = v1041;
            } else {
                v1042 = false;
            }
            bool v1043;
            v1043 = v1042 == false;
            if (v1043){
                assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v1042);
            } else {
            }
            int v1045;
            v1045 = v987 * 256;
            int v1046;
            v1046 = v982 + v972;
            int v1047;
            v1047 = v1045 + v971;
            bool v1048[4];
            int v1049;
            v1049 = 0;
            while (while_method_6(v1049)){
                int v1051;
                v1051 = 0;
                while (while_method_3(v1051)){
                    assert("Tensor range check" && 0 <= v1049 && v1049 < 1);
                    assert("Tensor range check" && 0 <= v1051 && v1051 < 4);
                    int v1053;
                    v1053 = 4 * v1049;
                    int v1054;
                    v1054 = v1053 + v1051;
                    int v1055;
                    v1055 = v996[v1054];
                    assert("Tensor range check" && 0 <= v1055 && v1055 < 4);
                    bool v1056;
                    v1056 = v396[v1055];
                    assert("Tensor range check" && 0 <= v1049 && v1049 < 1);
                    assert("Tensor range check" && 0 <= v1051 && v1051 < 4);
                    v1048[v1054] = v1056;
                    v1051 += 1 ;
                }
                v1049 += 1 ;
            }
            int v1057[4];
            int v1058;
            v1058 = 0;
            while (while_method_6(v1058)){
                int v1060;
                v1060 = 0;
                while (while_method_3(v1060)){
                    assert("Tensor range check" && 0 <= v1058 && v1058 < 1);
                    assert("Tensor range check" && 0 <= v1060 && v1060 < 4);
                    int v1062;
                    v1062 = 4 * v1058;
                    int v1063;
                    v1063 = v1062 + v1060;
                    bool v1064;
                    v1064 = v1048[v1063];
                    int v1065;
                    if (v1064){
                        v1065 = 1;
                    } else {
                        v1065 = 0;
                    }
                    assert("Tensor range check" && 0 <= v1058 && v1058 < 1);
                    assert("Tensor range check" && 0 <= v1060 && v1060 < 4);
                    v1057[v1063] = v1065;
                    v1060 += 1 ;
                }
                v1058 += 1 ;
            }
            int v1066;
            v1066 = 0;
            int v1067;
            v1067 = 0;
            while (while_method_6(v1067)){
                int v1069;
                v1069 = 0;
                while (while_method_3(v1069)){
                    assert("Tensor range check" && 0 <= v1067 && v1067 < 1);
                    assert("Tensor range check" && 0 <= v1069 && v1069 < 4);
                    int v1071;
                    v1071 = 4 * v1067;
                    int v1072;
                    v1072 = v1071 + v1069;
                    int v1073;
                    v1073 = v1057[v1072];
                    int v1074;
                    v1074 = v1066 + v1073;
                    v1066 = v1074;
                    v1069 += 1 ;
                }
                v1067 += 1 ;
            }
            auto v1075 = cooperative_groups::coalesced_threads();
            int v1076;
            v1076 = threadIdx.x;
            auto v1077 = cooperative_groups::labeled_partition(v1075,v1076);
            Closure1 v1078{};
            int v1079;
            v1079 = cooperative_groups::reduce(v1077, v1066, v1078);
            float v1080;
            v1080 = (float)v1079;
            float v1081[4];
            int v1082;
            v1082 = 0;
            while (while_method_6(v1082)){
                int v1084;
                v1084 = 0;
                while (while_method_3(v1084)){
                    assert("Tensor range check" && 0 <= v1082 && v1082 < 1);
                    assert("Tensor range check" && 0 <= v1084 && v1084 < 4);
                    int v1086;
                    v1086 = 4 * v1082;
                    int v1087;
                    v1087 = v1086 + v1084;
                    float v1088;
                    v1088 = v995[v1087];
                    bool v1089;
                    v1089 = v1048[v1087];
                    float v1090;
                    if (v1089){
                        v1090 = v1088;
                    } else {
                        v1090 = 0.0f;
                    }
                    assert("Tensor range check" && 0 <= v1082 && v1082 < 1);
                    assert("Tensor range check" && 0 <= v1084 && v1084 < 4);
                    v1081[v1087] = v1090;
                    v1084 += 1 ;
                }
                v1082 += 1 ;
            }
            float v1091;
            v1091 = 0.0f;
            int v1092;
            v1092 = 0;
            while (while_method_6(v1092)){
                int v1094;
                v1094 = 0;
                while (while_method_3(v1094)){
                    assert("Tensor range check" && 0 <= v1092 && v1092 < 1);
                    assert("Tensor range check" && 0 <= v1094 && v1094 < 4);
                    int v1096;
                    v1096 = 4 * v1092;
                    int v1097;
                    v1097 = v1096 + v1094;
                    float v1098;
                    v1098 = v1081[v1097];
                    float v1099;
                    v1099 = v1091 + v1098;
                    v1091 = v1099;
                    v1094 += 1 ;
                }
                v1092 += 1 ;
            }
            auto v1100 = cooperative_groups::coalesced_threads();
            int v1101;
            v1101 = threadIdx.x;
            auto v1102 = cooperative_groups::labeled_partition(v1100,v1101);
            Closure0 v1103{};
            float v1104;
            v1104 = cooperative_groups::reduce(v1102, v1091, v1103);
            float v1105;
            v1105 = v1104 / v1080;
            float v1106[4];
            int v1107;
            v1107 = 0;
            while (while_method_6(v1107)){
                int v1109;
                v1109 = 0;
                while (while_method_3(v1109)){
                    assert("Tensor range check" && 0 <= v1107 && v1107 < 1);
                    assert("Tensor range check" && 0 <= v1109 && v1109 < 4);
                    int v1111;
                    v1111 = 4 * v1107;
                    int v1112;
                    v1112 = v1111 + v1109;
                    float v1113;
                    v1113 = v995[v1112];
                    float v1114;
                    v1114 = v1113 - v1105;
                    float v1115;
                    v1115 = v1114 * v1114;
                    assert("Tensor range check" && 0 <= v1107 && v1107 < 1);
                    assert("Tensor range check" && 0 <= v1109 && v1109 < 4);
                    v1106[v1112] = v1115;
                    v1109 += 1 ;
                }
                v1107 += 1 ;
            }
            float v1116[4];
            int v1117;
            v1117 = 0;
            while (while_method_6(v1117)){
                int v1119;
                v1119 = 0;
                while (while_method_3(v1119)){
                    assert("Tensor range check" && 0 <= v1117 && v1117 < 1);
                    assert("Tensor range check" && 0 <= v1119 && v1119 < 4);
                    int v1121;
                    v1121 = 4 * v1117;
                    int v1122;
                    v1122 = v1121 + v1119;
                    float v1123;
                    v1123 = v1106[v1122];
                    bool v1124;
                    v1124 = v1048[v1122];
                    float v1125;
                    if (v1124){
                        v1125 = v1123;
                    } else {
                        v1125 = 0.0f;
                    }
                    assert("Tensor range check" && 0 <= v1117 && v1117 < 1);
                    assert("Tensor range check" && 0 <= v1119 && v1119 < 4);
                    v1116[v1122] = v1125;
                    v1119 += 1 ;
                }
                v1117 += 1 ;
            }
            float v1126;
            v1126 = 0.0f;
            int v1127;
            v1127 = 0;
            while (while_method_6(v1127)){
                int v1129;
                v1129 = 0;
                while (while_method_3(v1129)){
                    assert("Tensor range check" && 0 <= v1127 && v1127 < 1);
                    assert("Tensor range check" && 0 <= v1129 && v1129 < 4);
                    int v1131;
                    v1131 = 4 * v1127;
                    int v1132;
                    v1132 = v1131 + v1129;
                    float v1133;
                    v1133 = v1116[v1132];
                    float v1134;
                    v1134 = v1126 + v1133;
                    v1126 = v1134;
                    v1129 += 1 ;
                }
                v1127 += 1 ;
            }
            auto v1135 = cooperative_groups::coalesced_threads();
            int v1136;
            v1136 = threadIdx.x;
            auto v1137 = cooperative_groups::labeled_partition(v1135,v1136);
            float v1138;
            v1138 = cooperative_groups::reduce(v1137, v1126, v1103);
            float v1139;
            v1139 = v1138 / v1080;
            float v1140;
            v1140 = sqrt(v1139);
            bool v1141;
            v1141 = v1080 > 1.0f;
            float v1145;
            if (v1141){
                float v1142;
                v1142 = v1140 * v1080;
                float v1143;
                v1143 = v1080 - 1.0f;
                float v1144;
                v1144 = v1142 / v1143;
                v1145 = v1144;
            } else {
                v1145 = 0.0f;
            }
            float v1146[4];
            int v1147;
            v1147 = 0;
            while (while_method_6(v1147)){
                int v1149;
                v1149 = 0;
                while (while_method_3(v1149)){
                    assert("Tensor range check" && 0 <= v1147 && v1147 < 1);
                    assert("Tensor range check" && 0 <= v1149 && v1149 < 4);
                    int v1151;
                    v1151 = 4 * v1147;
                    int v1152;
                    v1152 = v1151 + v1149;
                    float v1153;
                    v1153 = v995[v1152];
                    bool v1154;
                    v1154 = v1048[v1152];
                    float v1155;
                    v1155 = curand_normal(&v367);
                    bool v1156;
                    v1156 = v1145 >= 0.1f;
                    float v1157;
                    if (v1156){
                        v1157 = v1145;
                    } else {
                        v1157 = 0.1f;
                    }
                    float v1158;
                    v1158 = v1155 * v1157;
                    float v1159;
                    v1159 = v1158 + v1105;
                    float v1160;
                    if (v1154){
                        v1160 = v1153;
                    } else {
                        v1160 = v1159;
                    }
                    assert("Tensor range check" && 0 <= v1147 && v1147 < 1);
                    assert("Tensor range check" && 0 <= v1149 && v1149 < 4);
                    v1146[v1152] = v1160;
                    v1149 += 1 ;
                }
                v1147 += 1 ;
            }
            assert("Tensor range check" && 0 <= v982 && v982 < 256);
            assert("Tensor range check" && 0 <= v987 && v987 < 1);
            int v1161;
            v1161 = 0;
            while (while_method_6(v1161)){
                assert("Tensor range check" && 0 <= v1161 && v1161 < 1);
                int v1163;
                v1163 = 4 * v1161;
                int v1164;
                v1164 = v1163 + v994;
                assert("Tensor range check" && 0 <= v1161 && v1161 < 1);
                int4* v1165;
                v1165 = reinterpret_cast<int4*>(v1146 + v1163);
                int4* v1166;
                v1166 = reinterpret_cast<int4*>(v374 + v1164);
                assert("Pointer alignment check" && reinterpret_cast<unsigned long long>(v1165) % 16 == 0 && reinterpret_cast<unsigned long long>(v1166) % 16 == 0);
                *v1166 = *v1165;
                v1161 += 1 ;
            }
            v982 += 24 ;
        }
        int v1167;
        v1167 = threadIdx.x;
        bool v1168;
        v1168 = 0 <= v1167;
        bool v1169;
        v1169 = v1168 == false;
        if (v1169){
            assert("The index needs to be zero or positive." && v1168);
        } else {
        }
        int v1171;
        v1171 = v1167 % 1;
        int v1172;
        v1172 = v1167 % 256;
        int v1173;
        v1173 = v1167 / 256;
        bool v1174;
        v1174 = v1173 < 1;
        bool v1175;
        v1175 = v1174 == false;
        if (v1175){
            assert("The last element of the projection dimensions needs to be greater than the index remainder." && v1174);
        } else {
        }
        assert("Tensor range check" && 0 <= v1173 && v1173 < 1);
        assert("Tensor range check" && 0 <= v1172 && v1172 < 256);
        assert("Tensor range check" && 0 <= v1171 && v1171 < 1);
        int v1177;
        v1177 = 4 * v1171;
        int v1178;
        v1178 = 4 * v1172;
        int v1179;
        v1179 = v1178 + v1177;
        int v1180;
        v1180 = 1024 * v1173;
        int v1181;
        v1181 = v1180 + v1179;
        assert("Tensor range check" && 0 <= v1173 && v1173 < 1);
        assert("Tensor range check" && 0 <= v1172 && v1172 < 256);
        assert("Tensor range check" && 0 <= v1171 && v1171 < 1);
        int v1182;
        v1182 = blockIdx.x;
        int v1183;
        v1183 = v1182;
        while (while_method_28(v1183)){
            bool v1185;
            v1185 = 0 <= v1183;
            bool v1186;
            v1186 = v1185 == false;
            if (v1186){
                assert("The index needs to be zero or positive." && v1185);
            } else {
            }
            int v1188;
            v1188 = v1183 % 1;
            bool v1189;
            v1189 = v1183 < 256;
            bool v1190;
            v1190 = v1189 == false;
            if (v1190){
                assert("The last element of the projection dimensions needs to be greater than the index remainder." && v1189);
            } else {
            }
            assert("Tensor range check" && 0 <= v1183 && v1183 < 256);
            assert("Tensor range check" && 0 <= v1188 && v1188 < 1);
            int v1192;
            v1192 = 1024 * v1188;
            int v1193;
            v1193 = v1192 + v1181;
            int v1194;
            v1194 = 1024 * v1183;
            int v1195;
            v1195 = v1194 + v1193;
            float v1196[4];
            int v1197[4];
            int v1198;
            v1198 = 0;
            while (while_method_6(v1198)){
                assert("Tensor range check" && 0 <= v1198 && v1198 < 1);
                int v1200;
                v1200 = 4 * v1198;
                assert("Tensor range check" && 0 <= v1198 && v1198 < 1);
                int v1201;
                v1201 = v1200 + v1195;
                int4* v1202;
                v1202 = reinterpret_cast<int4*>(v378 + v1201);
                int4* v1203;
                v1203 = reinterpret_cast<int4*>(v1196 + v1200);
                assert("Pointer alignment check" && reinterpret_cast<unsigned long long>(v1202) % 16 == 0 && reinterpret_cast<unsigned long long>(v1203) % 16 == 0);
                *v1203 = *v1202;
                v1198 += 1 ;
            }
            int v1204;
            v1204 = 0;
            while (while_method_6(v1204)){
                int v1206;
                v1206 = 0;
                while (while_method_3(v1206)){
                    bool v1208;
                    v1208 = 0 <= v1206;
                    bool v1210;
                    if (v1208){
                        bool v1209;
                        v1209 = v1206 < 4;
                        v1210 = v1209;
                    } else {
                        v1210 = false;
                    }
                    bool v1211;
                    v1211 = v1210 == false;
                    if (v1211){
                        assert("The indices should be inside the range of the dimension." && v1210);
                    } else {
                    }
                    bool v1213;
                    v1213 = 0 <= v1171;
                    bool v1215;
                    if (v1213){
                        bool v1214;
                        v1214 = v1171 < 1;
                        v1215 = v1214;
                    } else {
                        v1215 = false;
                    }
                    bool v1216;
                    v1216 = v1215 == false;
                    if (v1216){
                        assert("The indices should be inside the range of the dimension." && v1215);
                    } else {
                    }
                    int v1218;
                    v1218 = v1171 * 4;
                    int v1219;
                    v1219 = v1206 + v1218;
                    bool v1220;
                    v1220 = 0 <= v1204;
                    bool v1222;
                    if (v1220){
                        bool v1221;
                        v1221 = v1204 < 1;
                        v1222 = v1221;
                    } else {
                        v1222 = false;
                    }
                    bool v1223;
                    v1223 = v1222 == false;
                    if (v1223){
                        assert("The indices should be inside the range of the dimension." && v1222);
                    } else {
                    }
                    int v1225;
                    v1225 = v1204 * 4;
                    int v1226;
                    v1226 = v1219 + v1225;
                    assert("Tensor range check" && 0 <= v1204 && v1204 < 1);
                    assert("Tensor range check" && 0 <= v1206 && v1206 < 4);
                    int v1227;
                    v1227 = 4 * v1204;
                    int v1228;
                    v1228 = v1227 + v1206;
                    v1197[v1228] = v1226;
                    v1206 += 1 ;
                }
                v1204 += 1 ;
            }
            bool v1229;
            v1229 = 0 <= v1173;
            bool v1230;
            v1230 = v1229 && v1174;
            bool v1231;
            v1231 = v1230 == false;
            if (v1231){
                assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v1230);
            } else {
            }
            bool v1233;
            v1233 = 0 <= v1172;
            bool v1235;
            if (v1233){
                bool v1234;
                v1234 = v1172 < 256;
                v1235 = v1234;
            } else {
                v1235 = false;
            }
            bool v1236;
            v1236 = v1235 == false;
            if (v1236){
                assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v1235);
            } else {
            }
            bool v1238;
            v1238 = v1185 && v1189;
            bool v1239;
            v1239 = v1238 == false;
            if (v1239){
                assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v1238);
            } else {
            }
            bool v1241;
            v1241 = 0 <= v1188;
            bool v1243;
            if (v1241){
                bool v1242;
                v1242 = v1188 < 1;
                v1243 = v1242;
            } else {
                v1243 = false;
            }
            bool v1244;
            v1244 = v1243 == false;
            if (v1244){
                assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v1243);
            } else {
            }
            int v1246;
            v1246 = v1188 * 256;
            int v1247;
            v1247 = v1183 + v1173;
            int v1248;
            v1248 = v1246 + v1172;
            bool v1249[4];
            int v1250;
            v1250 = 0;
            while (while_method_6(v1250)){
                int v1252;
                v1252 = 0;
                while (while_method_3(v1252)){
                    assert("Tensor range check" && 0 <= v1250 && v1250 < 1);
                    assert("Tensor range check" && 0 <= v1252 && v1252 < 4);
                    int v1254;
                    v1254 = 4 * v1250;
                    int v1255;
                    v1255 = v1254 + v1252;
                    int v1256;
                    v1256 = v1197[v1255];
                    assert("Tensor range check" && 0 <= v1256 && v1256 < 4);
                    bool v1257;
                    v1257 = v396[v1256];
                    assert("Tensor range check" && 0 <= v1250 && v1250 < 1);
                    assert("Tensor range check" && 0 <= v1252 && v1252 < 4);
                    v1249[v1255] = v1257;
                    v1252 += 1 ;
                }
                v1250 += 1 ;
            }
            int v1258[4];
            int v1259;
            v1259 = 0;
            while (while_method_6(v1259)){
                int v1261;
                v1261 = 0;
                while (while_method_3(v1261)){
                    assert("Tensor range check" && 0 <= v1259 && v1259 < 1);
                    assert("Tensor range check" && 0 <= v1261 && v1261 < 4);
                    int v1263;
                    v1263 = 4 * v1259;
                    int v1264;
                    v1264 = v1263 + v1261;
                    bool v1265;
                    v1265 = v1249[v1264];
                    int v1266;
                    if (v1265){
                        v1266 = 1;
                    } else {
                        v1266 = 0;
                    }
                    assert("Tensor range check" && 0 <= v1259 && v1259 < 1);
                    assert("Tensor range check" && 0 <= v1261 && v1261 < 4);
                    v1258[v1264] = v1266;
                    v1261 += 1 ;
                }
                v1259 += 1 ;
            }
            int v1267;
            v1267 = 0;
            int v1268;
            v1268 = 0;
            while (while_method_6(v1268)){
                int v1270;
                v1270 = 0;
                while (while_method_3(v1270)){
                    assert("Tensor range check" && 0 <= v1268 && v1268 < 1);
                    assert("Tensor range check" && 0 <= v1270 && v1270 < 4);
                    int v1272;
                    v1272 = 4 * v1268;
                    int v1273;
                    v1273 = v1272 + v1270;
                    int v1274;
                    v1274 = v1258[v1273];
                    int v1275;
                    v1275 = v1267 + v1274;
                    v1267 = v1275;
                    v1270 += 1 ;
                }
                v1268 += 1 ;
            }
            auto v1276 = cooperative_groups::coalesced_threads();
            int v1277;
            v1277 = threadIdx.x;
            auto v1278 = cooperative_groups::labeled_partition(v1276,v1277);
            Closure1 v1279{};
            int v1280;
            v1280 = cooperative_groups::reduce(v1278, v1267, v1279);
            float v1281;
            v1281 = (float)v1280;
            float v1282[4];
            int v1283;
            v1283 = 0;
            while (while_method_6(v1283)){
                int v1285;
                v1285 = 0;
                while (while_method_3(v1285)){
                    assert("Tensor range check" && 0 <= v1283 && v1283 < 1);
                    assert("Tensor range check" && 0 <= v1285 && v1285 < 4);
                    int v1287;
                    v1287 = 4 * v1283;
                    int v1288;
                    v1288 = v1287 + v1285;
                    float v1289;
                    v1289 = v1196[v1288];
                    bool v1290;
                    v1290 = v1249[v1288];
                    float v1291;
                    if (v1290){
                        v1291 = v1289;
                    } else {
                        v1291 = 0.0f;
                    }
                    assert("Tensor range check" && 0 <= v1283 && v1283 < 1);
                    assert("Tensor range check" && 0 <= v1285 && v1285 < 4);
                    v1282[v1288] = v1291;
                    v1285 += 1 ;
                }
                v1283 += 1 ;
            }
            float v1292;
            v1292 = 0.0f;
            int v1293;
            v1293 = 0;
            while (while_method_6(v1293)){
                int v1295;
                v1295 = 0;
                while (while_method_3(v1295)){
                    assert("Tensor range check" && 0 <= v1293 && v1293 < 1);
                    assert("Tensor range check" && 0 <= v1295 && v1295 < 4);
                    int v1297;
                    v1297 = 4 * v1293;
                    int v1298;
                    v1298 = v1297 + v1295;
                    float v1299;
                    v1299 = v1282[v1298];
                    float v1300;
                    v1300 = v1292 + v1299;
                    v1292 = v1300;
                    v1295 += 1 ;
                }
                v1293 += 1 ;
            }
            auto v1301 = cooperative_groups::coalesced_threads();
            int v1302;
            v1302 = threadIdx.x;
            auto v1303 = cooperative_groups::labeled_partition(v1301,v1302);
            Closure0 v1304{};
            float v1305;
            v1305 = cooperative_groups::reduce(v1303, v1292, v1304);
            float v1306;
            v1306 = v1305 / v1281;
            float v1307[4];
            int v1308;
            v1308 = 0;
            while (while_method_6(v1308)){
                int v1310;
                v1310 = 0;
                while (while_method_3(v1310)){
                    assert("Tensor range check" && 0 <= v1308 && v1308 < 1);
                    assert("Tensor range check" && 0 <= v1310 && v1310 < 4);
                    int v1312;
                    v1312 = 4 * v1308;
                    int v1313;
                    v1313 = v1312 + v1310;
                    float v1314;
                    v1314 = v1196[v1313];
                    float v1315;
                    v1315 = v1314 - v1306;
                    float v1316;
                    v1316 = v1315 * v1315;
                    assert("Tensor range check" && 0 <= v1308 && v1308 < 1);
                    assert("Tensor range check" && 0 <= v1310 && v1310 < 4);
                    v1307[v1313] = v1316;
                    v1310 += 1 ;
                }
                v1308 += 1 ;
            }
            float v1317[4];
            int v1318;
            v1318 = 0;
            while (while_method_6(v1318)){
                int v1320;
                v1320 = 0;
                while (while_method_3(v1320)){
                    assert("Tensor range check" && 0 <= v1318 && v1318 < 1);
                    assert("Tensor range check" && 0 <= v1320 && v1320 < 4);
                    int v1322;
                    v1322 = 4 * v1318;
                    int v1323;
                    v1323 = v1322 + v1320;
                    float v1324;
                    v1324 = v1307[v1323];
                    bool v1325;
                    v1325 = v1249[v1323];
                    float v1326;
                    if (v1325){
                        v1326 = v1324;
                    } else {
                        v1326 = 0.0f;
                    }
                    assert("Tensor range check" && 0 <= v1318 && v1318 < 1);
                    assert("Tensor range check" && 0 <= v1320 && v1320 < 4);
                    v1317[v1323] = v1326;
                    v1320 += 1 ;
                }
                v1318 += 1 ;
            }
            float v1327;
            v1327 = 0.0f;
            int v1328;
            v1328 = 0;
            while (while_method_6(v1328)){
                int v1330;
                v1330 = 0;
                while (while_method_3(v1330)){
                    assert("Tensor range check" && 0 <= v1328 && v1328 < 1);
                    assert("Tensor range check" && 0 <= v1330 && v1330 < 4);
                    int v1332;
                    v1332 = 4 * v1328;
                    int v1333;
                    v1333 = v1332 + v1330;
                    float v1334;
                    v1334 = v1317[v1333];
                    float v1335;
                    v1335 = v1327 + v1334;
                    v1327 = v1335;
                    v1330 += 1 ;
                }
                v1328 += 1 ;
            }
            auto v1336 = cooperative_groups::coalesced_threads();
            int v1337;
            v1337 = threadIdx.x;
            auto v1338 = cooperative_groups::labeled_partition(v1336,v1337);
            float v1339;
            v1339 = cooperative_groups::reduce(v1338, v1327, v1304);
            float v1340;
            v1340 = v1339 / v1281;
            float v1341;
            v1341 = sqrt(v1340);
            bool v1342;
            v1342 = v1281 > 1.0f;
            float v1346;
            if (v1342){
                float v1343;
                v1343 = v1341 * v1281;
                float v1344;
                v1344 = v1281 - 1.0f;
                float v1345;
                v1345 = v1343 / v1344;
                v1346 = v1345;
            } else {
                v1346 = 0.0f;
            }
            float v1347[4];
            int v1348;
            v1348 = 0;
            while (while_method_6(v1348)){
                int v1350;
                v1350 = 0;
                while (while_method_3(v1350)){
                    assert("Tensor range check" && 0 <= v1348 && v1348 < 1);
                    assert("Tensor range check" && 0 <= v1350 && v1350 < 4);
                    int v1352;
                    v1352 = 4 * v1348;
                    int v1353;
                    v1353 = v1352 + v1350;
                    float v1354;
                    v1354 = v1196[v1353];
                    bool v1355;
                    v1355 = v1249[v1353];
                    float v1356;
                    v1356 = curand_normal(&v367);
                    bool v1357;
                    v1357 = v1346 >= 0.1f;
                    float v1358;
                    if (v1357){
                        v1358 = v1346;
                    } else {
                        v1358 = 0.1f;
                    }
                    float v1359;
                    v1359 = v1356 * v1358;
                    float v1360;
                    v1360 = v1359 + v1306;
                    float v1361;
                    if (v1355){
                        v1361 = v1354;
                    } else {
                        v1361 = v1360;
                    }
                    assert("Tensor range check" && 0 <= v1348 && v1348 < 1);
                    assert("Tensor range check" && 0 <= v1350 && v1350 < 4);
                    v1347[v1353] = v1361;
                    v1350 += 1 ;
                }
                v1348 += 1 ;
            }
            assert("Tensor range check" && 0 <= v1183 && v1183 < 256);
            assert("Tensor range check" && 0 <= v1188 && v1188 < 1);
            int v1362;
            v1362 = 0;
            while (while_method_6(v1362)){
                assert("Tensor range check" && 0 <= v1362 && v1362 < 1);
                int v1364;
                v1364 = 4 * v1362;
                int v1365;
                v1365 = v1364 + v1195;
                assert("Tensor range check" && 0 <= v1362 && v1362 < 1);
                int4* v1366;
                v1366 = reinterpret_cast<int4*>(v1347 + v1364);
                int4* v1367;
                v1367 = reinterpret_cast<int4*>(v378 + v1365);
                assert("Pointer alignment check" && reinterpret_cast<unsigned long long>(v1366) % 16 == 0 && reinterpret_cast<unsigned long long>(v1367) % 16 == 0);
                *v1367 = *v1366;
                v1362 += 1 ;
            }
            v1183 += 24 ;
        }
        int v1368;
        v1368 = threadIdx.x;
        bool v1369;
        v1369 = 0 <= v1368;
        bool v1370;
        v1370 = v1369 == false;
        if (v1370){
            assert("The index needs to be zero or positive." && v1369);
        } else {
        }
        int v1372;
        v1372 = v1368 % 1;
        int v1373;
        v1373 = v1368 % 256;
        int v1374;
        v1374 = v1368 / 256;
        bool v1375;
        v1375 = v1374 < 1;
        bool v1376;
        v1376 = v1375 == false;
        if (v1376){
            assert("The last element of the projection dimensions needs to be greater than the index remainder." && v1375);
        } else {
        }
        assert("Tensor range check" && 0 <= v1374 && v1374 < 1);
        assert("Tensor range check" && 0 <= v1373 && v1373 < 256);
        assert("Tensor range check" && 0 <= v1372 && v1372 < 1);
        int v1378;
        v1378 = 4 * v1372;
        int v1379;
        v1379 = 4 * v1373;
        int v1380;
        v1380 = v1379 + v1378;
        int v1381;
        v1381 = 1024 * v1374;
        int v1382;
        v1382 = v1381 + v1380;
        assert("Tensor range check" && 0 <= v1374 && v1374 < 1);
        assert("Tensor range check" && 0 <= v1373 && v1373 < 256);
        assert("Tensor range check" && 0 <= v1372 && v1372 < 1);
        int v1383;
        v1383 = blockIdx.x;
        int v1384;
        v1384 = v1383;
        while (while_method_28(v1384)){
            bool v1386;
            v1386 = 0 <= v1384;
            bool v1387;
            v1387 = v1386 == false;
            if (v1387){
                assert("The index needs to be zero or positive." && v1386);
            } else {
            }
            int v1389;
            v1389 = v1384 % 1;
            bool v1390;
            v1390 = v1384 < 256;
            bool v1391;
            v1391 = v1390 == false;
            if (v1391){
                assert("The last element of the projection dimensions needs to be greater than the index remainder." && v1390);
            } else {
            }
            assert("Tensor range check" && 0 <= v1384 && v1384 < 256);
            assert("Tensor range check" && 0 <= v1389 && v1389 < 1);
            int v1393;
            v1393 = 1024 * v1389;
            int v1394;
            v1394 = v1393 + v1382;
            int v1395;
            v1395 = 1024 * v1384;
            int v1396;
            v1396 = v1395 + v1394;
            float v1397[4];
            int v1398[4];
            int v1399;
            v1399 = 0;
            while (while_method_6(v1399)){
                assert("Tensor range check" && 0 <= v1399 && v1399 < 1);
                int v1401;
                v1401 = 4 * v1399;
                assert("Tensor range check" && 0 <= v1399 && v1399 < 1);
                int v1402;
                v1402 = v1401 + v1396;
                int4* v1403;
                v1403 = reinterpret_cast<int4*>(v382 + v1402);
                int4* v1404;
                v1404 = reinterpret_cast<int4*>(v1397 + v1401);
                assert("Pointer alignment check" && reinterpret_cast<unsigned long long>(v1403) % 16 == 0 && reinterpret_cast<unsigned long long>(v1404) % 16 == 0);
                *v1404 = *v1403;
                v1399 += 1 ;
            }
            int v1405;
            v1405 = 0;
            while (while_method_6(v1405)){
                int v1407;
                v1407 = 0;
                while (while_method_3(v1407)){
                    bool v1409;
                    v1409 = 0 <= v1407;
                    bool v1411;
                    if (v1409){
                        bool v1410;
                        v1410 = v1407 < 4;
                        v1411 = v1410;
                    } else {
                        v1411 = false;
                    }
                    bool v1412;
                    v1412 = v1411 == false;
                    if (v1412){
                        assert("The indices should be inside the range of the dimension." && v1411);
                    } else {
                    }
                    bool v1414;
                    v1414 = 0 <= v1372;
                    bool v1416;
                    if (v1414){
                        bool v1415;
                        v1415 = v1372 < 1;
                        v1416 = v1415;
                    } else {
                        v1416 = false;
                    }
                    bool v1417;
                    v1417 = v1416 == false;
                    if (v1417){
                        assert("The indices should be inside the range of the dimension." && v1416);
                    } else {
                    }
                    int v1419;
                    v1419 = v1372 * 4;
                    int v1420;
                    v1420 = v1407 + v1419;
                    bool v1421;
                    v1421 = 0 <= v1405;
                    bool v1423;
                    if (v1421){
                        bool v1422;
                        v1422 = v1405 < 1;
                        v1423 = v1422;
                    } else {
                        v1423 = false;
                    }
                    bool v1424;
                    v1424 = v1423 == false;
                    if (v1424){
                        assert("The indices should be inside the range of the dimension." && v1423);
                    } else {
                    }
                    int v1426;
                    v1426 = v1405 * 4;
                    int v1427;
                    v1427 = v1420 + v1426;
                    assert("Tensor range check" && 0 <= v1405 && v1405 < 1);
                    assert("Tensor range check" && 0 <= v1407 && v1407 < 4);
                    int v1428;
                    v1428 = 4 * v1405;
                    int v1429;
                    v1429 = v1428 + v1407;
                    v1398[v1429] = v1427;
                    v1407 += 1 ;
                }
                v1405 += 1 ;
            }
            bool v1430;
            v1430 = 0 <= v1374;
            bool v1431;
            v1431 = v1430 && v1375;
            bool v1432;
            v1432 = v1431 == false;
            if (v1432){
                assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v1431);
            } else {
            }
            bool v1434;
            v1434 = 0 <= v1373;
            bool v1436;
            if (v1434){
                bool v1435;
                v1435 = v1373 < 256;
                v1436 = v1435;
            } else {
                v1436 = false;
            }
            bool v1437;
            v1437 = v1436 == false;
            if (v1437){
                assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v1436);
            } else {
            }
            bool v1439;
            v1439 = v1386 && v1390;
            bool v1440;
            v1440 = v1439 == false;
            if (v1440){
                assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v1439);
            } else {
            }
            bool v1442;
            v1442 = 0 <= v1389;
            bool v1444;
            if (v1442){
                bool v1443;
                v1443 = v1389 < 1;
                v1444 = v1443;
            } else {
                v1444 = false;
            }
            bool v1445;
            v1445 = v1444 == false;
            if (v1445){
                assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v1444);
            } else {
            }
            int v1447;
            v1447 = v1389 * 256;
            int v1448;
            v1448 = v1384 + v1374;
            int v1449;
            v1449 = v1447 + v1373;
            bool v1450[4];
            int v1451;
            v1451 = 0;
            while (while_method_6(v1451)){
                int v1453;
                v1453 = 0;
                while (while_method_3(v1453)){
                    assert("Tensor range check" && 0 <= v1451 && v1451 < 1);
                    assert("Tensor range check" && 0 <= v1453 && v1453 < 4);
                    int v1455;
                    v1455 = 4 * v1451;
                    int v1456;
                    v1456 = v1455 + v1453;
                    int v1457;
                    v1457 = v1398[v1456];
                    assert("Tensor range check" && 0 <= v1457 && v1457 < 4);
                    bool v1458;
                    v1458 = v396[v1457];
                    assert("Tensor range check" && 0 <= v1451 && v1451 < 1);
                    assert("Tensor range check" && 0 <= v1453 && v1453 < 4);
                    v1450[v1456] = v1458;
                    v1453 += 1 ;
                }
                v1451 += 1 ;
            }
            int v1459[4];
            int v1460;
            v1460 = 0;
            while (while_method_6(v1460)){
                int v1462;
                v1462 = 0;
                while (while_method_3(v1462)){
                    assert("Tensor range check" && 0 <= v1460 && v1460 < 1);
                    assert("Tensor range check" && 0 <= v1462 && v1462 < 4);
                    int v1464;
                    v1464 = 4 * v1460;
                    int v1465;
                    v1465 = v1464 + v1462;
                    bool v1466;
                    v1466 = v1450[v1465];
                    int v1467;
                    if (v1466){
                        v1467 = 1;
                    } else {
                        v1467 = 0;
                    }
                    assert("Tensor range check" && 0 <= v1460 && v1460 < 1);
                    assert("Tensor range check" && 0 <= v1462 && v1462 < 4);
                    v1459[v1465] = v1467;
                    v1462 += 1 ;
                }
                v1460 += 1 ;
            }
            int v1468;
            v1468 = 0;
            int v1469;
            v1469 = 0;
            while (while_method_6(v1469)){
                int v1471;
                v1471 = 0;
                while (while_method_3(v1471)){
                    assert("Tensor range check" && 0 <= v1469 && v1469 < 1);
                    assert("Tensor range check" && 0 <= v1471 && v1471 < 4);
                    int v1473;
                    v1473 = 4 * v1469;
                    int v1474;
                    v1474 = v1473 + v1471;
                    int v1475;
                    v1475 = v1459[v1474];
                    int v1476;
                    v1476 = v1468 + v1475;
                    v1468 = v1476;
                    v1471 += 1 ;
                }
                v1469 += 1 ;
            }
            auto v1477 = cooperative_groups::coalesced_threads();
            int v1478;
            v1478 = threadIdx.x;
            auto v1479 = cooperative_groups::labeled_partition(v1477,v1478);
            Closure1 v1480{};
            int v1481;
            v1481 = cooperative_groups::reduce(v1479, v1468, v1480);
            float v1482;
            v1482 = (float)v1481;
            float v1483[4];
            int v1484;
            v1484 = 0;
            while (while_method_6(v1484)){
                int v1486;
                v1486 = 0;
                while (while_method_3(v1486)){
                    assert("Tensor range check" && 0 <= v1484 && v1484 < 1);
                    assert("Tensor range check" && 0 <= v1486 && v1486 < 4);
                    int v1488;
                    v1488 = 4 * v1484;
                    int v1489;
                    v1489 = v1488 + v1486;
                    float v1490;
                    v1490 = v1397[v1489];
                    bool v1491;
                    v1491 = v1450[v1489];
                    float v1492;
                    if (v1491){
                        v1492 = v1490;
                    } else {
                        v1492 = 0.0f;
                    }
                    assert("Tensor range check" && 0 <= v1484 && v1484 < 1);
                    assert("Tensor range check" && 0 <= v1486 && v1486 < 4);
                    v1483[v1489] = v1492;
                    v1486 += 1 ;
                }
                v1484 += 1 ;
            }
            float v1493;
            v1493 = 0.0f;
            int v1494;
            v1494 = 0;
            while (while_method_6(v1494)){
                int v1496;
                v1496 = 0;
                while (while_method_3(v1496)){
                    assert("Tensor range check" && 0 <= v1494 && v1494 < 1);
                    assert("Tensor range check" && 0 <= v1496 && v1496 < 4);
                    int v1498;
                    v1498 = 4 * v1494;
                    int v1499;
                    v1499 = v1498 + v1496;
                    float v1500;
                    v1500 = v1483[v1499];
                    float v1501;
                    v1501 = v1493 + v1500;
                    v1493 = v1501;
                    v1496 += 1 ;
                }
                v1494 += 1 ;
            }
            auto v1502 = cooperative_groups::coalesced_threads();
            int v1503;
            v1503 = threadIdx.x;
            auto v1504 = cooperative_groups::labeled_partition(v1502,v1503);
            Closure0 v1505{};
            float v1506;
            v1506 = cooperative_groups::reduce(v1504, v1493, v1505);
            float v1507;
            v1507 = v1506 / v1482;
            float v1508[4];
            int v1509;
            v1509 = 0;
            while (while_method_6(v1509)){
                int v1511;
                v1511 = 0;
                while (while_method_3(v1511)){
                    assert("Tensor range check" && 0 <= v1509 && v1509 < 1);
                    assert("Tensor range check" && 0 <= v1511 && v1511 < 4);
                    int v1513;
                    v1513 = 4 * v1509;
                    int v1514;
                    v1514 = v1513 + v1511;
                    float v1515;
                    v1515 = v1397[v1514];
                    float v1516;
                    v1516 = v1515 - v1507;
                    float v1517;
                    v1517 = v1516 * v1516;
                    assert("Tensor range check" && 0 <= v1509 && v1509 < 1);
                    assert("Tensor range check" && 0 <= v1511 && v1511 < 4);
                    v1508[v1514] = v1517;
                    v1511 += 1 ;
                }
                v1509 += 1 ;
            }
            float v1518[4];
            int v1519;
            v1519 = 0;
            while (while_method_6(v1519)){
                int v1521;
                v1521 = 0;
                while (while_method_3(v1521)){
                    assert("Tensor range check" && 0 <= v1519 && v1519 < 1);
                    assert("Tensor range check" && 0 <= v1521 && v1521 < 4);
                    int v1523;
                    v1523 = 4 * v1519;
                    int v1524;
                    v1524 = v1523 + v1521;
                    float v1525;
                    v1525 = v1508[v1524];
                    bool v1526;
                    v1526 = v1450[v1524];
                    float v1527;
                    if (v1526){
                        v1527 = v1525;
                    } else {
                        v1527 = 0.0f;
                    }
                    assert("Tensor range check" && 0 <= v1519 && v1519 < 1);
                    assert("Tensor range check" && 0 <= v1521 && v1521 < 4);
                    v1518[v1524] = v1527;
                    v1521 += 1 ;
                }
                v1519 += 1 ;
            }
            float v1528;
            v1528 = 0.0f;
            int v1529;
            v1529 = 0;
            while (while_method_6(v1529)){
                int v1531;
                v1531 = 0;
                while (while_method_3(v1531)){
                    assert("Tensor range check" && 0 <= v1529 && v1529 < 1);
                    assert("Tensor range check" && 0 <= v1531 && v1531 < 4);
                    int v1533;
                    v1533 = 4 * v1529;
                    int v1534;
                    v1534 = v1533 + v1531;
                    float v1535;
                    v1535 = v1518[v1534];
                    float v1536;
                    v1536 = v1528 + v1535;
                    v1528 = v1536;
                    v1531 += 1 ;
                }
                v1529 += 1 ;
            }
            auto v1537 = cooperative_groups::coalesced_threads();
            int v1538;
            v1538 = threadIdx.x;
            auto v1539 = cooperative_groups::labeled_partition(v1537,v1538);
            float v1540;
            v1540 = cooperative_groups::reduce(v1539, v1528, v1505);
            float v1541;
            v1541 = v1540 / v1482;
            float v1542;
            v1542 = sqrt(v1541);
            bool v1543;
            v1543 = v1482 > 1.0f;
            float v1547;
            if (v1543){
                float v1544;
                v1544 = v1542 * v1482;
                float v1545;
                v1545 = v1482 - 1.0f;
                float v1546;
                v1546 = v1544 / v1545;
                v1547 = v1546;
            } else {
                v1547 = 0.0f;
            }
            float v1548[4];
            int v1549;
            v1549 = 0;
            while (while_method_6(v1549)){
                int v1551;
                v1551 = 0;
                while (while_method_3(v1551)){
                    assert("Tensor range check" && 0 <= v1549 && v1549 < 1);
                    assert("Tensor range check" && 0 <= v1551 && v1551 < 4);
                    int v1553;
                    v1553 = 4 * v1549;
                    int v1554;
                    v1554 = v1553 + v1551;
                    float v1555;
                    v1555 = v1397[v1554];
                    bool v1556;
                    v1556 = v1450[v1554];
                    float v1557;
                    v1557 = curand_normal(&v367);
                    bool v1558;
                    v1558 = v1547 >= 0.1f;
                    float v1559;
                    if (v1558){
                        v1559 = v1547;
                    } else {
                        v1559 = 0.1f;
                    }
                    float v1560;
                    v1560 = v1557 * v1559;
                    float v1561;
                    v1561 = v1560 + v1507;
                    float v1562;
                    if (v1556){
                        v1562 = v1555;
                    } else {
                        v1562 = v1561;
                    }
                    assert("Tensor range check" && 0 <= v1549 && v1549 < 1);
                    assert("Tensor range check" && 0 <= v1551 && v1551 < 4);
                    v1548[v1554] = v1562;
                    v1551 += 1 ;
                }
                v1549 += 1 ;
            }
            assert("Tensor range check" && 0 <= v1384 && v1384 < 256);
            assert("Tensor range check" && 0 <= v1389 && v1389 < 1);
            int v1563;
            v1563 = 0;
            while (while_method_6(v1563)){
                assert("Tensor range check" && 0 <= v1563 && v1563 < 1);
                int v1565;
                v1565 = 4 * v1563;
                int v1566;
                v1566 = v1565 + v1396;
                assert("Tensor range check" && 0 <= v1563 && v1563 < 1);
                int4* v1567;
                v1567 = reinterpret_cast<int4*>(v1548 + v1565);
                int4* v1568;
                v1568 = reinterpret_cast<int4*>(v382 + v1566);
                assert("Pointer alignment check" && reinterpret_cast<unsigned long long>(v1567) % 16 == 0 && reinterpret_cast<unsigned long long>(v1568) % 16 == 0);
                *v1568 = *v1567;
                v1563 += 1 ;
            }
            v1384 += 24 ;
        }
        int v1569;
        v1569 = threadIdx.x;
        bool v1570;
        v1570 = 0 <= v1569;
        bool v1571;
        v1571 = v1570 == false;
        if (v1571){
            assert("The index needs to be zero or positive." && v1570);
        } else {
        }
        int v1573;
        v1573 = v1569 % 1;
        int v1574;
        v1574 = v1569 % 256;
        int v1575;
        v1575 = v1569 / 256;
        bool v1576;
        v1576 = v1575 < 1;
        bool v1577;
        v1577 = v1576 == false;
        if (v1577){
            assert("The last element of the projection dimensions needs to be greater than the index remainder." && v1576);
        } else {
        }
        assert("Tensor range check" && 0 <= v1575 && v1575 < 1);
        assert("Tensor range check" && 0 <= v1574 && v1574 < 256);
        assert("Tensor range check" && 0 <= v1573 && v1573 < 1);
        int v1579;
        v1579 = 4 * v1573;
        int v1580;
        v1580 = 4 * v1574;
        int v1581;
        v1581 = v1580 + v1579;
        int v1582;
        v1582 = 1024 * v1575;
        int v1583;
        v1583 = v1582 + v1581;
        assert("Tensor range check" && 0 <= v1575 && v1575 < 1);
        assert("Tensor range check" && 0 <= v1574 && v1574 < 256);
        assert("Tensor range check" && 0 <= v1573 && v1573 < 1);
        int v1584;
        v1584 = blockIdx.x;
        int v1585;
        v1585 = v1584;
        while (while_method_28(v1585)){
            bool v1587;
            v1587 = 0 <= v1585;
            bool v1588;
            v1588 = v1587 == false;
            if (v1588){
                assert("The index needs to be zero or positive." && v1587);
            } else {
            }
            int v1590;
            v1590 = v1585 % 1;
            bool v1591;
            v1591 = v1585 < 256;
            bool v1592;
            v1592 = v1591 == false;
            if (v1592){
                assert("The last element of the projection dimensions needs to be greater than the index remainder." && v1591);
            } else {
            }
            assert("Tensor range check" && 0 <= v1585 && v1585 < 256);
            assert("Tensor range check" && 0 <= v1590 && v1590 < 1);
            int v1594;
            v1594 = 1024 * v1590;
            int v1595;
            v1595 = v1594 + v1583;
            int v1596;
            v1596 = 1024 * v1585;
            int v1597;
            v1597 = v1596 + v1595;
            float v1598[4];
            int v1599[4];
            int v1600;
            v1600 = 0;
            while (while_method_6(v1600)){
                assert("Tensor range check" && 0 <= v1600 && v1600 < 1);
                int v1602;
                v1602 = 4 * v1600;
                assert("Tensor range check" && 0 <= v1600 && v1600 < 1);
                int v1603;
                v1603 = v1602 + v1597;
                int4* v1604;
                v1604 = reinterpret_cast<int4*>(v386 + v1603);
                int4* v1605;
                v1605 = reinterpret_cast<int4*>(v1598 + v1602);
                assert("Pointer alignment check" && reinterpret_cast<unsigned long long>(v1604) % 16 == 0 && reinterpret_cast<unsigned long long>(v1605) % 16 == 0);
                *v1605 = *v1604;
                v1600 += 1 ;
            }
            int v1606;
            v1606 = 0;
            while (while_method_6(v1606)){
                int v1608;
                v1608 = 0;
                while (while_method_3(v1608)){
                    bool v1610;
                    v1610 = 0 <= v1608;
                    bool v1612;
                    if (v1610){
                        bool v1611;
                        v1611 = v1608 < 4;
                        v1612 = v1611;
                    } else {
                        v1612 = false;
                    }
                    bool v1613;
                    v1613 = v1612 == false;
                    if (v1613){
                        assert("The indices should be inside the range of the dimension." && v1612);
                    } else {
                    }
                    bool v1615;
                    v1615 = 0 <= v1573;
                    bool v1617;
                    if (v1615){
                        bool v1616;
                        v1616 = v1573 < 1;
                        v1617 = v1616;
                    } else {
                        v1617 = false;
                    }
                    bool v1618;
                    v1618 = v1617 == false;
                    if (v1618){
                        assert("The indices should be inside the range of the dimension." && v1617);
                    } else {
                    }
                    int v1620;
                    v1620 = v1573 * 4;
                    int v1621;
                    v1621 = v1608 + v1620;
                    bool v1622;
                    v1622 = 0 <= v1606;
                    bool v1624;
                    if (v1622){
                        bool v1623;
                        v1623 = v1606 < 1;
                        v1624 = v1623;
                    } else {
                        v1624 = false;
                    }
                    bool v1625;
                    v1625 = v1624 == false;
                    if (v1625){
                        assert("The indices should be inside the range of the dimension." && v1624);
                    } else {
                    }
                    int v1627;
                    v1627 = v1606 * 4;
                    int v1628;
                    v1628 = v1621 + v1627;
                    assert("Tensor range check" && 0 <= v1606 && v1606 < 1);
                    assert("Tensor range check" && 0 <= v1608 && v1608 < 4);
                    int v1629;
                    v1629 = 4 * v1606;
                    int v1630;
                    v1630 = v1629 + v1608;
                    v1599[v1630] = v1628;
                    v1608 += 1 ;
                }
                v1606 += 1 ;
            }
            bool v1631;
            v1631 = 0 <= v1575;
            bool v1632;
            v1632 = v1631 && v1576;
            bool v1633;
            v1633 = v1632 == false;
            if (v1633){
                assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v1632);
            } else {
            }
            bool v1635;
            v1635 = 0 <= v1574;
            bool v1637;
            if (v1635){
                bool v1636;
                v1636 = v1574 < 256;
                v1637 = v1636;
            } else {
                v1637 = false;
            }
            bool v1638;
            v1638 = v1637 == false;
            if (v1638){
                assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v1637);
            } else {
            }
            bool v1640;
            v1640 = v1587 && v1591;
            bool v1641;
            v1641 = v1640 == false;
            if (v1641){
                assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v1640);
            } else {
            }
            bool v1643;
            v1643 = 0 <= v1590;
            bool v1645;
            if (v1643){
                bool v1644;
                v1644 = v1590 < 1;
                v1645 = v1644;
            } else {
                v1645 = false;
            }
            bool v1646;
            v1646 = v1645 == false;
            if (v1646){
                assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v1645);
            } else {
            }
            int v1648;
            v1648 = v1590 * 256;
            int v1649;
            v1649 = v1585 + v1575;
            int v1650;
            v1650 = v1648 + v1574;
            bool v1651[4];
            int v1652;
            v1652 = 0;
            while (while_method_6(v1652)){
                int v1654;
                v1654 = 0;
                while (while_method_3(v1654)){
                    assert("Tensor range check" && 0 <= v1652 && v1652 < 1);
                    assert("Tensor range check" && 0 <= v1654 && v1654 < 4);
                    int v1656;
                    v1656 = 4 * v1652;
                    int v1657;
                    v1657 = v1656 + v1654;
                    int v1658;
                    v1658 = v1599[v1657];
                    assert("Tensor range check" && 0 <= v1658 && v1658 < 4);
                    bool v1659;
                    v1659 = v396[v1658];
                    assert("Tensor range check" && 0 <= v1652 && v1652 < 1);
                    assert("Tensor range check" && 0 <= v1654 && v1654 < 4);
                    v1651[v1657] = v1659;
                    v1654 += 1 ;
                }
                v1652 += 1 ;
            }
            int v1660[4];
            int v1661;
            v1661 = 0;
            while (while_method_6(v1661)){
                int v1663;
                v1663 = 0;
                while (while_method_3(v1663)){
                    assert("Tensor range check" && 0 <= v1661 && v1661 < 1);
                    assert("Tensor range check" && 0 <= v1663 && v1663 < 4);
                    int v1665;
                    v1665 = 4 * v1661;
                    int v1666;
                    v1666 = v1665 + v1663;
                    bool v1667;
                    v1667 = v1651[v1666];
                    int v1668;
                    if (v1667){
                        v1668 = 1;
                    } else {
                        v1668 = 0;
                    }
                    assert("Tensor range check" && 0 <= v1661 && v1661 < 1);
                    assert("Tensor range check" && 0 <= v1663 && v1663 < 4);
                    v1660[v1666] = v1668;
                    v1663 += 1 ;
                }
                v1661 += 1 ;
            }
            int v1669;
            v1669 = 0;
            int v1670;
            v1670 = 0;
            while (while_method_6(v1670)){
                int v1672;
                v1672 = 0;
                while (while_method_3(v1672)){
                    assert("Tensor range check" && 0 <= v1670 && v1670 < 1);
                    assert("Tensor range check" && 0 <= v1672 && v1672 < 4);
                    int v1674;
                    v1674 = 4 * v1670;
                    int v1675;
                    v1675 = v1674 + v1672;
                    int v1676;
                    v1676 = v1660[v1675];
                    int v1677;
                    v1677 = v1669 + v1676;
                    v1669 = v1677;
                    v1672 += 1 ;
                }
                v1670 += 1 ;
            }
            auto v1678 = cooperative_groups::coalesced_threads();
            int v1679;
            v1679 = threadIdx.x;
            auto v1680 = cooperative_groups::labeled_partition(v1678,v1679);
            Closure1 v1681{};
            int v1682;
            v1682 = cooperative_groups::reduce(v1680, v1669, v1681);
            float v1683;
            v1683 = (float)v1682;
            float v1684[4];
            int v1685;
            v1685 = 0;
            while (while_method_6(v1685)){
                int v1687;
                v1687 = 0;
                while (while_method_3(v1687)){
                    assert("Tensor range check" && 0 <= v1685 && v1685 < 1);
                    assert("Tensor range check" && 0 <= v1687 && v1687 < 4);
                    int v1689;
                    v1689 = 4 * v1685;
                    int v1690;
                    v1690 = v1689 + v1687;
                    float v1691;
                    v1691 = v1598[v1690];
                    bool v1692;
                    v1692 = v1651[v1690];
                    float v1693;
                    if (v1692){
                        v1693 = v1691;
                    } else {
                        v1693 = 0.0f;
                    }
                    assert("Tensor range check" && 0 <= v1685 && v1685 < 1);
                    assert("Tensor range check" && 0 <= v1687 && v1687 < 4);
                    v1684[v1690] = v1693;
                    v1687 += 1 ;
                }
                v1685 += 1 ;
            }
            float v1694;
            v1694 = 0.0f;
            int v1695;
            v1695 = 0;
            while (while_method_6(v1695)){
                int v1697;
                v1697 = 0;
                while (while_method_3(v1697)){
                    assert("Tensor range check" && 0 <= v1695 && v1695 < 1);
                    assert("Tensor range check" && 0 <= v1697 && v1697 < 4);
                    int v1699;
                    v1699 = 4 * v1695;
                    int v1700;
                    v1700 = v1699 + v1697;
                    float v1701;
                    v1701 = v1684[v1700];
                    float v1702;
                    v1702 = v1694 + v1701;
                    v1694 = v1702;
                    v1697 += 1 ;
                }
                v1695 += 1 ;
            }
            auto v1703 = cooperative_groups::coalesced_threads();
            int v1704;
            v1704 = threadIdx.x;
            auto v1705 = cooperative_groups::labeled_partition(v1703,v1704);
            Closure0 v1706{};
            float v1707;
            v1707 = cooperative_groups::reduce(v1705, v1694, v1706);
            float v1708;
            v1708 = v1707 / v1683;
            float v1709[4];
            int v1710;
            v1710 = 0;
            while (while_method_6(v1710)){
                int v1712;
                v1712 = 0;
                while (while_method_3(v1712)){
                    assert("Tensor range check" && 0 <= v1710 && v1710 < 1);
                    assert("Tensor range check" && 0 <= v1712 && v1712 < 4);
                    int v1714;
                    v1714 = 4 * v1710;
                    int v1715;
                    v1715 = v1714 + v1712;
                    float v1716;
                    v1716 = v1598[v1715];
                    float v1717;
                    v1717 = v1716 - v1708;
                    float v1718;
                    v1718 = v1717 * v1717;
                    assert("Tensor range check" && 0 <= v1710 && v1710 < 1);
                    assert("Tensor range check" && 0 <= v1712 && v1712 < 4);
                    v1709[v1715] = v1718;
                    v1712 += 1 ;
                }
                v1710 += 1 ;
            }
            float v1719[4];
            int v1720;
            v1720 = 0;
            while (while_method_6(v1720)){
                int v1722;
                v1722 = 0;
                while (while_method_3(v1722)){
                    assert("Tensor range check" && 0 <= v1720 && v1720 < 1);
                    assert("Tensor range check" && 0 <= v1722 && v1722 < 4);
                    int v1724;
                    v1724 = 4 * v1720;
                    int v1725;
                    v1725 = v1724 + v1722;
                    float v1726;
                    v1726 = v1709[v1725];
                    bool v1727;
                    v1727 = v1651[v1725];
                    float v1728;
                    if (v1727){
                        v1728 = v1726;
                    } else {
                        v1728 = 0.0f;
                    }
                    assert("Tensor range check" && 0 <= v1720 && v1720 < 1);
                    assert("Tensor range check" && 0 <= v1722 && v1722 < 4);
                    v1719[v1725] = v1728;
                    v1722 += 1 ;
                }
                v1720 += 1 ;
            }
            float v1729;
            v1729 = 0.0f;
            int v1730;
            v1730 = 0;
            while (while_method_6(v1730)){
                int v1732;
                v1732 = 0;
                while (while_method_3(v1732)){
                    assert("Tensor range check" && 0 <= v1730 && v1730 < 1);
                    assert("Tensor range check" && 0 <= v1732 && v1732 < 4);
                    int v1734;
                    v1734 = 4 * v1730;
                    int v1735;
                    v1735 = v1734 + v1732;
                    float v1736;
                    v1736 = v1719[v1735];
                    float v1737;
                    v1737 = v1729 + v1736;
                    v1729 = v1737;
                    v1732 += 1 ;
                }
                v1730 += 1 ;
            }
            auto v1738 = cooperative_groups::coalesced_threads();
            int v1739;
            v1739 = threadIdx.x;
            auto v1740 = cooperative_groups::labeled_partition(v1738,v1739);
            float v1741;
            v1741 = cooperative_groups::reduce(v1740, v1729, v1706);
            float v1742;
            v1742 = v1741 / v1683;
            float v1743;
            v1743 = sqrt(v1742);
            bool v1744;
            v1744 = v1683 > 1.0f;
            float v1748;
            if (v1744){
                float v1745;
                v1745 = v1743 * v1683;
                float v1746;
                v1746 = v1683 - 1.0f;
                float v1747;
                v1747 = v1745 / v1746;
                v1748 = v1747;
            } else {
                v1748 = 0.0f;
            }
            float v1749[4];
            int v1750;
            v1750 = 0;
            while (while_method_6(v1750)){
                int v1752;
                v1752 = 0;
                while (while_method_3(v1752)){
                    assert("Tensor range check" && 0 <= v1750 && v1750 < 1);
                    assert("Tensor range check" && 0 <= v1752 && v1752 < 4);
                    int v1754;
                    v1754 = 4 * v1750;
                    int v1755;
                    v1755 = v1754 + v1752;
                    float v1756;
                    v1756 = v1598[v1755];
                    bool v1757;
                    v1757 = v1651[v1755];
                    float v1758;
                    v1758 = curand_normal(&v367);
                    bool v1759;
                    v1759 = v1748 >= 0.1f;
                    float v1760;
                    if (v1759){
                        v1760 = v1748;
                    } else {
                        v1760 = 0.1f;
                    }
                    float v1761;
                    v1761 = v1758 * v1760;
                    float v1762;
                    v1762 = v1761 + v1708;
                    float v1763;
                    if (v1757){
                        v1763 = v1756;
                    } else {
                        v1763 = v1762;
                    }
                    assert("Tensor range check" && 0 <= v1750 && v1750 < 1);
                    assert("Tensor range check" && 0 <= v1752 && v1752 < 4);
                    v1749[v1755] = v1763;
                    v1752 += 1 ;
                }
                v1750 += 1 ;
            }
            assert("Tensor range check" && 0 <= v1585 && v1585 < 256);
            assert("Tensor range check" && 0 <= v1590 && v1590 < 1);
            int v1764;
            v1764 = 0;
            while (while_method_6(v1764)){
                assert("Tensor range check" && 0 <= v1764 && v1764 < 1);
                int v1766;
                v1766 = 4 * v1764;
                int v1767;
                v1767 = v1766 + v1597;
                assert("Tensor range check" && 0 <= v1764 && v1764 < 1);
                int4* v1768;
                v1768 = reinterpret_cast<int4*>(v1749 + v1766);
                int4* v1769;
                v1769 = reinterpret_cast<int4*>(v386 + v1767);
                assert("Pointer alignment check" && reinterpret_cast<unsigned long long>(v1768) % 16 == 0 && reinterpret_cast<unsigned long long>(v1769) % 16 == 0);
                *v1769 = *v1768;
                v1764 += 1 ;
            }
            v1585 += 24 ;
        }
        int v1770;
        v1770 = threadIdx.x;
        bool v1771;
        v1771 = 0 <= v1770;
        bool v1772;
        v1772 = v1771 == false;
        if (v1772){
            assert("The index needs to be zero or positive." && v1771);
        } else {
        }
        int v1774;
        v1774 = v1770 % 1;
        int v1775;
        v1775 = v1770 % 256;
        int v1776;
        v1776 = v1770 / 256;
        bool v1777;
        v1777 = v1776 < 1;
        bool v1778;
        v1778 = v1777 == false;
        if (v1778){
            assert("The last element of the projection dimensions needs to be greater than the index remainder." && v1777);
        } else {
        }
        assert("Tensor range check" && 0 <= v1776 && v1776 < 1);
        assert("Tensor range check" && 0 <= v1775 && v1775 < 256);
        assert("Tensor range check" && 0 <= v1774 && v1774 < 1);
        int v1780;
        v1780 = 4 * v1774;
        int v1781;
        v1781 = 4 * v1775;
        int v1782;
        v1782 = v1781 + v1780;
        int v1783;
        v1783 = 1024 * v1776;
        int v1784;
        v1784 = v1783 + v1782;
        assert("Tensor range check" && 0 <= v1776 && v1776 < 1);
        assert("Tensor range check" && 0 <= v1775 && v1775 < 256);
        assert("Tensor range check" && 0 <= v1774 && v1774 < 1);
        int v1785;
        v1785 = blockIdx.x;
        int v1786;
        v1786 = v1785;
        while (while_method_29(v1786)){
            bool v1788;
            v1788 = 0 <= v1786;
            bool v1789;
            v1789 = v1788 == false;
            if (v1789){
                assert("The index needs to be zero or positive." && v1788);
            } else {
            }
            int v1791;
            v1791 = v1786 % 1;
            bool v1792;
            v1792 = v1786 < 64;
            bool v1793;
            v1793 = v1792 == false;
            if (v1793){
                assert("The last element of the projection dimensions needs to be greater than the index remainder." && v1792);
            } else {
            }
            assert("Tensor range check" && 0 <= v1786 && v1786 < 64);
            assert("Tensor range check" && 0 <= v1791 && v1791 < 1);
            int v1795;
            v1795 = 1024 * v1791;
            int v1796;
            v1796 = v1795 + v1784;
            int v1797;
            v1797 = 1024 * v1786;
            int v1798;
            v1798 = v1797 + v1796;
            float v1799[4];
            int v1800[4];
            int v1801;
            v1801 = 0;
            while (while_method_6(v1801)){
                assert("Tensor range check" && 0 <= v1801 && v1801 < 1);
                int v1803;
                v1803 = 4 * v1801;
                assert("Tensor range check" && 0 <= v1801 && v1801 < 1);
                int v1804;
                v1804 = v1803 + v1798;
                int4* v1805;
                v1805 = reinterpret_cast<int4*>(v390 + v1804);
                int4* v1806;
                v1806 = reinterpret_cast<int4*>(v1799 + v1803);
                assert("Pointer alignment check" && reinterpret_cast<unsigned long long>(v1805) % 16 == 0 && reinterpret_cast<unsigned long long>(v1806) % 16 == 0);
                *v1806 = *v1805;
                v1801 += 1 ;
            }
            int v1807;
            v1807 = 0;
            while (while_method_6(v1807)){
                int v1809;
                v1809 = 0;
                while (while_method_3(v1809)){
                    bool v1811;
                    v1811 = 0 <= v1809;
                    bool v1813;
                    if (v1811){
                        bool v1812;
                        v1812 = v1809 < 4;
                        v1813 = v1812;
                    } else {
                        v1813 = false;
                    }
                    bool v1814;
                    v1814 = v1813 == false;
                    if (v1814){
                        assert("The indices should be inside the range of the dimension." && v1813);
                    } else {
                    }
                    bool v1816;
                    v1816 = 0 <= v1774;
                    bool v1818;
                    if (v1816){
                        bool v1817;
                        v1817 = v1774 < 1;
                        v1818 = v1817;
                    } else {
                        v1818 = false;
                    }
                    bool v1819;
                    v1819 = v1818 == false;
                    if (v1819){
                        assert("The indices should be inside the range of the dimension." && v1818);
                    } else {
                    }
                    int v1821;
                    v1821 = v1774 * 4;
                    int v1822;
                    v1822 = v1809 + v1821;
                    bool v1823;
                    v1823 = 0 <= v1807;
                    bool v1825;
                    if (v1823){
                        bool v1824;
                        v1824 = v1807 < 1;
                        v1825 = v1824;
                    } else {
                        v1825 = false;
                    }
                    bool v1826;
                    v1826 = v1825 == false;
                    if (v1826){
                        assert("The indices should be inside the range of the dimension." && v1825);
                    } else {
                    }
                    int v1828;
                    v1828 = v1807 * 4;
                    int v1829;
                    v1829 = v1822 + v1828;
                    assert("Tensor range check" && 0 <= v1807 && v1807 < 1);
                    assert("Tensor range check" && 0 <= v1809 && v1809 < 4);
                    int v1830;
                    v1830 = 4 * v1807;
                    int v1831;
                    v1831 = v1830 + v1809;
                    v1800[v1831] = v1829;
                    v1809 += 1 ;
                }
                v1807 += 1 ;
            }
            bool v1832;
            v1832 = 0 <= v1776;
            bool v1833;
            v1833 = v1832 && v1777;
            bool v1834;
            v1834 = v1833 == false;
            if (v1834){
                assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v1833);
            } else {
            }
            bool v1836;
            v1836 = 0 <= v1775;
            bool v1838;
            if (v1836){
                bool v1837;
                v1837 = v1775 < 256;
                v1838 = v1837;
            } else {
                v1838 = false;
            }
            bool v1839;
            v1839 = v1838 == false;
            if (v1839){
                assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v1838);
            } else {
            }
            bool v1841;
            v1841 = v1788 && v1792;
            bool v1842;
            v1842 = v1841 == false;
            if (v1842){
                assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v1841);
            } else {
            }
            bool v1844;
            v1844 = 0 <= v1791;
            bool v1846;
            if (v1844){
                bool v1845;
                v1845 = v1791 < 1;
                v1846 = v1845;
            } else {
                v1846 = false;
            }
            bool v1847;
            v1847 = v1846 == false;
            if (v1847){
                assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v1846);
            } else {
            }
            int v1849;
            v1849 = v1791 * 256;
            int v1850;
            v1850 = v1786 + v1776;
            int v1851;
            v1851 = v1849 + v1775;
            bool v1852[4];
            int v1853;
            v1853 = 0;
            while (while_method_6(v1853)){
                int v1855;
                v1855 = 0;
                while (while_method_3(v1855)){
                    assert("Tensor range check" && 0 <= v1853 && v1853 < 1);
                    assert("Tensor range check" && 0 <= v1855 && v1855 < 4);
                    int v1857;
                    v1857 = 4 * v1853;
                    int v1858;
                    v1858 = v1857 + v1855;
                    int v1859;
                    v1859 = v1800[v1858];
                    assert("Tensor range check" && 0 <= v1859 && v1859 < 4);
                    bool v1860;
                    v1860 = v396[v1859];
                    assert("Tensor range check" && 0 <= v1853 && v1853 < 1);
                    assert("Tensor range check" && 0 <= v1855 && v1855 < 4);
                    v1852[v1858] = v1860;
                    v1855 += 1 ;
                }
                v1853 += 1 ;
            }
            int v1861[4];
            int v1862;
            v1862 = 0;
            while (while_method_6(v1862)){
                int v1864;
                v1864 = 0;
                while (while_method_3(v1864)){
                    assert("Tensor range check" && 0 <= v1862 && v1862 < 1);
                    assert("Tensor range check" && 0 <= v1864 && v1864 < 4);
                    int v1866;
                    v1866 = 4 * v1862;
                    int v1867;
                    v1867 = v1866 + v1864;
                    bool v1868;
                    v1868 = v1852[v1867];
                    int v1869;
                    if (v1868){
                        v1869 = 1;
                    } else {
                        v1869 = 0;
                    }
                    assert("Tensor range check" && 0 <= v1862 && v1862 < 1);
                    assert("Tensor range check" && 0 <= v1864 && v1864 < 4);
                    v1861[v1867] = v1869;
                    v1864 += 1 ;
                }
                v1862 += 1 ;
            }
            int v1870;
            v1870 = 0;
            int v1871;
            v1871 = 0;
            while (while_method_6(v1871)){
                int v1873;
                v1873 = 0;
                while (while_method_3(v1873)){
                    assert("Tensor range check" && 0 <= v1871 && v1871 < 1);
                    assert("Tensor range check" && 0 <= v1873 && v1873 < 4);
                    int v1875;
                    v1875 = 4 * v1871;
                    int v1876;
                    v1876 = v1875 + v1873;
                    int v1877;
                    v1877 = v1861[v1876];
                    int v1878;
                    v1878 = v1870 + v1877;
                    v1870 = v1878;
                    v1873 += 1 ;
                }
                v1871 += 1 ;
            }
            auto v1879 = cooperative_groups::coalesced_threads();
            int v1880;
            v1880 = threadIdx.x;
            auto v1881 = cooperative_groups::labeled_partition(v1879,v1880);
            Closure1 v1882{};
            int v1883;
            v1883 = cooperative_groups::reduce(v1881, v1870, v1882);
            float v1884;
            v1884 = (float)v1883;
            float v1885[4];
            int v1886;
            v1886 = 0;
            while (while_method_6(v1886)){
                int v1888;
                v1888 = 0;
                while (while_method_3(v1888)){
                    assert("Tensor range check" && 0 <= v1886 && v1886 < 1);
                    assert("Tensor range check" && 0 <= v1888 && v1888 < 4);
                    int v1890;
                    v1890 = 4 * v1886;
                    int v1891;
                    v1891 = v1890 + v1888;
                    float v1892;
                    v1892 = v1799[v1891];
                    bool v1893;
                    v1893 = v1852[v1891];
                    float v1894;
                    if (v1893){
                        v1894 = v1892;
                    } else {
                        v1894 = 0.0f;
                    }
                    assert("Tensor range check" && 0 <= v1886 && v1886 < 1);
                    assert("Tensor range check" && 0 <= v1888 && v1888 < 4);
                    v1885[v1891] = v1894;
                    v1888 += 1 ;
                }
                v1886 += 1 ;
            }
            float v1895;
            v1895 = 0.0f;
            int v1896;
            v1896 = 0;
            while (while_method_6(v1896)){
                int v1898;
                v1898 = 0;
                while (while_method_3(v1898)){
                    assert("Tensor range check" && 0 <= v1896 && v1896 < 1);
                    assert("Tensor range check" && 0 <= v1898 && v1898 < 4);
                    int v1900;
                    v1900 = 4 * v1896;
                    int v1901;
                    v1901 = v1900 + v1898;
                    float v1902;
                    v1902 = v1885[v1901];
                    float v1903;
                    v1903 = v1895 + v1902;
                    v1895 = v1903;
                    v1898 += 1 ;
                }
                v1896 += 1 ;
            }
            auto v1904 = cooperative_groups::coalesced_threads();
            int v1905;
            v1905 = threadIdx.x;
            auto v1906 = cooperative_groups::labeled_partition(v1904,v1905);
            Closure0 v1907{};
            float v1908;
            v1908 = cooperative_groups::reduce(v1906, v1895, v1907);
            float v1909;
            v1909 = v1908 / v1884;
            float v1910[4];
            int v1911;
            v1911 = 0;
            while (while_method_6(v1911)){
                int v1913;
                v1913 = 0;
                while (while_method_3(v1913)){
                    assert("Tensor range check" && 0 <= v1911 && v1911 < 1);
                    assert("Tensor range check" && 0 <= v1913 && v1913 < 4);
                    int v1915;
                    v1915 = 4 * v1911;
                    int v1916;
                    v1916 = v1915 + v1913;
                    float v1917;
                    v1917 = v1799[v1916];
                    float v1918;
                    v1918 = v1917 - v1909;
                    float v1919;
                    v1919 = v1918 * v1918;
                    assert("Tensor range check" && 0 <= v1911 && v1911 < 1);
                    assert("Tensor range check" && 0 <= v1913 && v1913 < 4);
                    v1910[v1916] = v1919;
                    v1913 += 1 ;
                }
                v1911 += 1 ;
            }
            float v1920[4];
            int v1921;
            v1921 = 0;
            while (while_method_6(v1921)){
                int v1923;
                v1923 = 0;
                while (while_method_3(v1923)){
                    assert("Tensor range check" && 0 <= v1921 && v1921 < 1);
                    assert("Tensor range check" && 0 <= v1923 && v1923 < 4);
                    int v1925;
                    v1925 = 4 * v1921;
                    int v1926;
                    v1926 = v1925 + v1923;
                    float v1927;
                    v1927 = v1910[v1926];
                    bool v1928;
                    v1928 = v1852[v1926];
                    float v1929;
                    if (v1928){
                        v1929 = v1927;
                    } else {
                        v1929 = 0.0f;
                    }
                    assert("Tensor range check" && 0 <= v1921 && v1921 < 1);
                    assert("Tensor range check" && 0 <= v1923 && v1923 < 4);
                    v1920[v1926] = v1929;
                    v1923 += 1 ;
                }
                v1921 += 1 ;
            }
            float v1930;
            v1930 = 0.0f;
            int v1931;
            v1931 = 0;
            while (while_method_6(v1931)){
                int v1933;
                v1933 = 0;
                while (while_method_3(v1933)){
                    assert("Tensor range check" && 0 <= v1931 && v1931 < 1);
                    assert("Tensor range check" && 0 <= v1933 && v1933 < 4);
                    int v1935;
                    v1935 = 4 * v1931;
                    int v1936;
                    v1936 = v1935 + v1933;
                    float v1937;
                    v1937 = v1920[v1936];
                    float v1938;
                    v1938 = v1930 + v1937;
                    v1930 = v1938;
                    v1933 += 1 ;
                }
                v1931 += 1 ;
            }
            auto v1939 = cooperative_groups::coalesced_threads();
            int v1940;
            v1940 = threadIdx.x;
            auto v1941 = cooperative_groups::labeled_partition(v1939,v1940);
            float v1942;
            v1942 = cooperative_groups::reduce(v1941, v1930, v1907);
            float v1943;
            v1943 = v1942 / v1884;
            float v1944;
            v1944 = sqrt(v1943);
            bool v1945;
            v1945 = v1884 > 1.0f;
            float v1949;
            if (v1945){
                float v1946;
                v1946 = v1944 * v1884;
                float v1947;
                v1947 = v1884 - 1.0f;
                float v1948;
                v1948 = v1946 / v1947;
                v1949 = v1948;
            } else {
                v1949 = 0.0f;
            }
            float v1950[4];
            int v1951;
            v1951 = 0;
            while (while_method_6(v1951)){
                int v1953;
                v1953 = 0;
                while (while_method_3(v1953)){
                    assert("Tensor range check" && 0 <= v1951 && v1951 < 1);
                    assert("Tensor range check" && 0 <= v1953 && v1953 < 4);
                    int v1955;
                    v1955 = 4 * v1951;
                    int v1956;
                    v1956 = v1955 + v1953;
                    float v1957;
                    v1957 = v1799[v1956];
                    bool v1958;
                    v1958 = v1852[v1956];
                    float v1959;
                    v1959 = curand_normal(&v367);
                    bool v1960;
                    v1960 = v1949 >= 0.1f;
                    float v1961;
                    if (v1960){
                        v1961 = v1949;
                    } else {
                        v1961 = 0.1f;
                    }
                    float v1962;
                    v1962 = v1959 * v1961;
                    float v1963;
                    v1963 = v1962 + v1909;
                    float v1964;
                    if (v1958){
                        v1964 = v1957;
                    } else {
                        v1964 = v1963;
                    }
                    assert("Tensor range check" && 0 <= v1951 && v1951 < 1);
                    assert("Tensor range check" && 0 <= v1953 && v1953 < 4);
                    v1950[v1956] = v1964;
                    v1953 += 1 ;
                }
                v1951 += 1 ;
            }
            assert("Tensor range check" && 0 <= v1786 && v1786 < 64);
            assert("Tensor range check" && 0 <= v1791 && v1791 < 1);
            int v1965;
            v1965 = 0;
            while (while_method_6(v1965)){
                assert("Tensor range check" && 0 <= v1965 && v1965 < 1);
                int v1967;
                v1967 = 4 * v1965;
                int v1968;
                v1968 = v1967 + v1798;
                assert("Tensor range check" && 0 <= v1965 && v1965 < 1);
                int4* v1969;
                v1969 = reinterpret_cast<int4*>(v1950 + v1967);
                int4* v1970;
                v1970 = reinterpret_cast<int4*>(v390 + v1968);
                assert("Pointer alignment check" && reinterpret_cast<unsigned long long>(v1969) % 16 == 0 && reinterpret_cast<unsigned long long>(v1970) % 16 == 0);
                *v1970 = *v1969;
                v1965 += 1 ;
            }
            v1786 += 24 ;
        }
        v365.sync() ;
        static float v1971[524288];
        int v1972;
        v1972 = threadIdx.x;
        int v1973;
        v1973 = blockIdx.x;
        int v1974;
        v1974 = v1973 * 256;
        int v1975;
        v1975 = v1972 + v1974;
        int v1976;
        v1976 = v1975 / 32;
        int v1977;
        v1977 = v1976;
        while (while_method_7(v1977)){
            bool v1979;
            v1979 = 0 <= v1977;
            bool v1980;
            v1980 = v1979 == false;
            if (v1980){
                assert("The index needs to be zero or positive." && v1979);
            } else {
            }
            int v1982;
            v1982 = v1977 % 2048;
            int v1983;
            v1983 = v1977 / 2048;
            bool v1984;
            v1984 = v1983 < 256;
            bool v1985;
            v1985 = v1984 == false;
            if (v1985){
                assert("The last element of the projection dimensions needs to be greater than the index remainder." && v1984);
            } else {
            }
            assert("Tensor range check" && 0 <= v1983 && v1983 < 256);
            assert("Tensor range check" && 0 <= v1982 && v1982 < 2048);
            int v1987;
            v1987 = 4 * v1982;
            int v1988;
            v1988 = 8192 * v1983;
            int v1989;
            v1989 = v1988 + v1987;
            float v1990;
            v1990 = 0.0f;
            int v1991;
            v1991 = threadIdx.x;
            int v1992;
            v1992 = v1991 % 32;
            int v1993;
            v1993 = v1992;
            while (while_method_6(v1993)){
                bool v1995;
                v1995 = 0 <= v1993;
                bool v1996;
                v1996 = v1995 == false;
                if (v1996){
                    assert("The index needs to be zero or positive." && v1995);
                } else {
                }
                bool v1998;
                v1998 = v1993 < 1;
                bool v1999;
                v1999 = v1998 == false;
                if (v1999){
                    assert("The last element of the projection dimensions needs to be greater than the index remainder." && v1998);
                } else {
                }
                assert("Tensor range check" && 0 <= v1993 && v1993 < 1);
                int v2001;
                v2001 = 4 * v1993;
                int v2002;
                v2002 = v2001 + v1989;
                float v2003[4];
                int4* v2004;
                v2004 = reinterpret_cast<int4*>(v370 + v2002);
                int4* v2005;
                v2005 = reinterpret_cast<int4*>(v2003 + 0);
                assert("Pointer alignment check" && reinterpret_cast<unsigned long long>(v2004) % 16 == 0 && reinterpret_cast<unsigned long long>(v2005) % 16 == 0);
                *v2005 = *v2004;
                int v2006;
                v2006 = 0;
                while (while_method_3(v2006)){
                    assert("Tensor range check" && 0 <= v2006 && v2006 < 4);
                    float v2008;
                    v2008 = v2003[v2006];
                    float v2009;
                    v2009 = v2008 * v2008;
                    float v2010;
                    v2010 = v1990 + v2009;
                    v1990 = v2010;
                    v2006 += 1 ;
                }
                v1993 += 32 ;
            }
            __syncwarp();
            auto v2011 = cooperative_groups::coalesced_threads();
            Closure0 v2012{};
            float v2013;
            v2013 = cooperative_groups::reduce(v2011, v1990, v2012);
            float v2014;
            v2014 = sqrt(v2013);
            assert("Tensor range check" && 0 <= v1983 && v1983 < 256);
            assert("Tensor range check" && 0 <= v1982 && v1982 < 2048);
            int v2015;
            v2015 = 2048 * v1983;
            int v2016;
            v2016 = v2015 + v1982;
            v1971[v2016] = v2014;
            v1977 += 192 ;
        }
        __syncthreads();
        v365.sync() ;
        float v2017;
        v2017 = 0.0f;
        int v2018;
        v2018 = threadIdx.x;
        int v2019;
        v2019 = blockIdx.x;
        int v2020;
        v2020 = v2019 * 256;
        int v2021;
        v2021 = v2018 + v2020;
        int v2022;
        v2022 = v2021;
        while (while_method_30(v2022)){
            bool v2024;
            v2024 = 0 <= v2022;
            bool v2025;
            v2025 = v2024 == false;
            if (v2025){
                assert("The index needs to be zero or positive." && v2024);
            } else {
            }
            int v2027;
            v2027 = v2022 % 512;
            int v2028;
            v2028 = v2022 / 512;
            bool v2029;
            v2029 = v2028 < 256;
            bool v2030;
            v2030 = v2029 == false;
            if (v2030){
                assert("The last element of the projection dimensions needs to be greater than the index remainder." && v2029);
            } else {
            }
            assert("Tensor range check" && 0 <= v2028 && v2028 < 256);
            assert("Tensor range check" && 0 <= v2027 && v2027 < 512);
            int v2032;
            v2032 = 4 * v2027;
            int v2033;
            v2033 = 2048 * v2028;
            int v2034;
            v2034 = v2033 + v2032;
            float v2035[4];
            int4* v2036;
            v2036 = reinterpret_cast<int4*>(v1971 + v2034);
            int4* v2037;
            v2037 = reinterpret_cast<int4*>(v2035 + 0);
            assert("Pointer alignment check" && reinterpret_cast<unsigned long long>(v2036) % 16 == 0 && reinterpret_cast<unsigned long long>(v2037) % 16 == 0);
            *v2037 = *v2036;
            int v2038; float v2039;
            Tuple25 tmp109 = Tuple25{0, v2017};
            v2038 = tmp109.v0; v2039 = tmp109.v1;
            while (while_method_3(v2038)){
                assert("Tensor range check" && 0 <= v2038 && v2038 < 4);
                float v2041;
                v2041 = v2035[v2038];
                bool v2042;
                v2042 = v2039 >= v2041;
                float v2043;
                if (v2042){
                    v2043 = v2039;
                } else {
                    v2043 = v2041;
                }
                v2039 = v2043;
                v2038 += 1 ;
            }
            v2017 = v2039;
            v2022 += 6144 ;
        }
        __syncwarp();
        auto v2044 = cooperative_groups::coalesced_threads();
        Closure7 v2045{};
        float v2046;
        v2046 = cooperative_groups::reduce(v2044, v2017, v2045);
        int v2047;
        v2047 = threadIdx.x;
        int v2048;
        v2048 = v2047 / 32;
        extern __shared__ unsigned char v2049[];
        float * v2050;
        v2050 = reinterpret_cast<float *>(&v2049[0ull]);
        assert("Tensor range check" && 0 <= v2048 && v2048 < 8);
        v2050[v2048] = v2046;
        __syncthreads();
        int v2052;
        v2052 = threadIdx.x;
        int v2053;
        v2053 = v2052 % 32;
        bool v2054;
        v2054 = v2053 < 8;
        float v2056;
        if (v2054){
            assert("Tensor range check" && 0 <= v2053 && v2053 < 8);
            float v2055;
            v2055 = v2050[v2053];
            v2056 = v2055;
        } else {
            v2056 = 0.0f;
        }
        __syncthreads();
        auto v2057 = cooperative_groups::coalesced_threads();
        float v2058;
        v2058 = cooperative_groups::reduce(v2057, v2056, v2045);
        int v2059;
        v2059 = blockIdx.x;
        static float v2060[24];
        assert("Tensor range check" && 0 <= v2059 && v2059 < 24);
        v2060[v2059] = v2058;
        v365.sync() ;
        float v2061;
        v2061 = 0.0f;
        int v2062;
        v2062 = threadIdx.x;
        int v2063;
        v2063 = v2062 % 32;
        int v2064;
        v2064 = v2063;
        while (while_method_31(v2064)){
            bool v2066;
            v2066 = 0 <= v2064;
            bool v2067;
            v2067 = v2066 == false;
            if (v2067){
                assert("The index needs to be zero or positive." && v2066);
            } else {
            }
            bool v2069;
            v2069 = v2064 < 24;
            bool v2070;
            v2070 = v2069 == false;
            if (v2070){
                assert("The last element of the projection dimensions needs to be greater than the index remainder." && v2069);
            } else {
            }
            assert("Tensor range check" && 0 <= v2064 && v2064 < 24);
            float v2072;
            v2072 = v2060[v2064];
            bool v2073;
            v2073 = v2061 >= v2072;
            float v2074;
            if (v2073){
                v2074 = v2061;
            } else {
                v2074 = v2072;
            }
            v2061 = v2074;
            v2064 += 32 ;
        }
        __syncwarp();
        auto v2075 = cooperative_groups::coalesced_threads();
        float v2076;
        v2076 = cooperative_groups::reduce(v2075, v2061, v2045);
        int v2077;
        v2077 = threadIdx.x;
        int v2078;
        v2078 = blockIdx.x;
        int v2079;
        v2079 = v2078 * 256;
        int v2080;
        v2080 = v2077 + v2079;
        bool v2081;
        v2081 = v2080 == 0;
        if (v2081){
            cuda::counting_semaphore<cuda::thread_scope_system, 1> & v2082 = console_lock;
            auto v2083 = cooperative_groups::coalesced_threads();
            v2082.acquire();
            printf("{%s = %f}\n","max_norm", v2076);
            v2082.release();
            v2083.sync() ;
        } else {
        }
        __syncwarp();
        static float v2086[65536];
        int v2087;
        v2087 = threadIdx.x;
        int v2088;
        v2088 = blockIdx.x;
        int v2089;
        v2089 = v2088 * 256;
        int v2090;
        v2090 = v2087 + v2089;
        int v2091;
        v2091 = v2090 / 32;
        int v2092;
        v2092 = v2091;
        while (while_method_32(v2092)){
            bool v2094;
            v2094 = 0 <= v2092;
            bool v2095;
            v2095 = v2094 == false;
            if (v2095){
                assert("The index needs to be zero or positive." && v2094);
            } else {
            }
            int v2097;
            v2097 = v2092 % 256;
            int v2098;
            v2098 = v2092 / 256;
            bool v2099;
            v2099 = v2098 < 256;
            bool v2100;
            v2100 = v2099 == false;
            if (v2100){
                assert("The last element of the projection dimensions needs to be greater than the index remainder." && v2099);
            } else {
            }
            assert("Tensor range check" && 0 <= v2098 && v2098 < 256);
            assert("Tensor range check" && 0 <= v2097 && v2097 < 256);
            int v2102;
            v2102 = 4 * v2097;
            int v2103;
            v2103 = 1024 * v2098;
            int v2104;
            v2104 = v2103 + v2102;
            float v2105;
            v2105 = 0.0f;
            int v2106;
            v2106 = threadIdx.x;
            int v2107;
            v2107 = v2106 % 32;
            int v2108;
            v2108 = v2107;
            while (while_method_6(v2108)){
                bool v2110;
                v2110 = 0 <= v2108;
                bool v2111;
                v2111 = v2110 == false;
                if (v2111){
                    assert("The index needs to be zero or positive." && v2110);
                } else {
                }
                bool v2113;
                v2113 = v2108 < 1;
                bool v2114;
                v2114 = v2113 == false;
                if (v2114){
                    assert("The last element of the projection dimensions needs to be greater than the index remainder." && v2113);
                } else {
                }
                assert("Tensor range check" && 0 <= v2108 && v2108 < 1);
                int v2116;
                v2116 = 4 * v2108;
                int v2117;
                v2117 = v2116 + v2104;
                float v2118[4];
                int4* v2119;
                v2119 = reinterpret_cast<int4*>(v374 + v2117);
                int4* v2120;
                v2120 = reinterpret_cast<int4*>(v2118 + 0);
                assert("Pointer alignment check" && reinterpret_cast<unsigned long long>(v2119) % 16 == 0 && reinterpret_cast<unsigned long long>(v2120) % 16 == 0);
                *v2120 = *v2119;
                int v2121;
                v2121 = 0;
                while (while_method_3(v2121)){
                    assert("Tensor range check" && 0 <= v2121 && v2121 < 4);
                    float v2123;
                    v2123 = v2118[v2121];
                    float v2124;
                    v2124 = v2123 * v2123;
                    float v2125;
                    v2125 = v2105 + v2124;
                    v2105 = v2125;
                    v2121 += 1 ;
                }
                v2108 += 32 ;
            }
            __syncwarp();
            auto v2126 = cooperative_groups::coalesced_threads();
            Closure0 v2127{};
            float v2128;
            v2128 = cooperative_groups::reduce(v2126, v2105, v2127);
            float v2129;
            v2129 = sqrt(v2128);
            assert("Tensor range check" && 0 <= v2098 && v2098 < 256);
            assert("Tensor range check" && 0 <= v2097 && v2097 < 256);
            int v2130;
            v2130 = 256 * v2098;
            int v2131;
            v2131 = v2130 + v2097;
            v2086[v2131] = v2129;
            v2092 += 192 ;
        }
        __syncthreads();
        v365.sync() ;
        float v2132;
        v2132 = 0.0f;
        int v2133;
        v2133 = threadIdx.x;
        int v2134;
        v2134 = blockIdx.x;
        int v2135;
        v2135 = v2134 * 256;
        int v2136;
        v2136 = v2133 + v2135;
        int v2137;
        v2137 = v2136;
        while (while_method_13(v2137)){
            bool v2139;
            v2139 = 0 <= v2137;
            bool v2140;
            v2140 = v2139 == false;
            if (v2140){
                assert("The index needs to be zero or positive." && v2139);
            } else {
            }
            int v2142;
            v2142 = v2137 % 64;
            int v2143;
            v2143 = v2137 / 64;
            bool v2144;
            v2144 = v2143 < 256;
            bool v2145;
            v2145 = v2144 == false;
            if (v2145){
                assert("The last element of the projection dimensions needs to be greater than the index remainder." && v2144);
            } else {
            }
            assert("Tensor range check" && 0 <= v2143 && v2143 < 256);
            assert("Tensor range check" && 0 <= v2142 && v2142 < 64);
            int v2147;
            v2147 = 4 * v2142;
            int v2148;
            v2148 = 256 * v2143;
            int v2149;
            v2149 = v2148 + v2147;
            float v2150[4];
            int4* v2151;
            v2151 = reinterpret_cast<int4*>(v2086 + v2149);
            int4* v2152;
            v2152 = reinterpret_cast<int4*>(v2150 + 0);
            assert("Pointer alignment check" && reinterpret_cast<unsigned long long>(v2151) % 16 == 0 && reinterpret_cast<unsigned long long>(v2152) % 16 == 0);
            *v2152 = *v2151;
            int v2153; float v2154;
            Tuple25 tmp110 = Tuple25{0, v2132};
            v2153 = tmp110.v0; v2154 = tmp110.v1;
            while (while_method_3(v2153)){
                assert("Tensor range check" && 0 <= v2153 && v2153 < 4);
                float v2156;
                v2156 = v2150[v2153];
                bool v2157;
                v2157 = v2154 >= v2156;
                float v2158;
                if (v2157){
                    v2158 = v2154;
                } else {
                    v2158 = v2156;
                }
                v2154 = v2158;
                v2153 += 1 ;
            }
            v2132 = v2154;
            v2137 += 6144 ;
        }
        __syncwarp();
        auto v2159 = cooperative_groups::coalesced_threads();
        float v2160;
        v2160 = cooperative_groups::reduce(v2159, v2132, v2045);
        int v2161;
        v2161 = threadIdx.x;
        int v2162;
        v2162 = v2161 / 32;
        extern __shared__ unsigned char v2163[];
        float * v2164;
        v2164 = reinterpret_cast<float *>(&v2163[0ull]);
        assert("Tensor range check" && 0 <= v2162 && v2162 < 8);
        v2164[v2162] = v2160;
        __syncthreads();
        int v2166;
        v2166 = threadIdx.x;
        int v2167;
        v2167 = v2166 % 32;
        bool v2168;
        v2168 = v2167 < 8;
        float v2170;
        if (v2168){
            assert("Tensor range check" && 0 <= v2167 && v2167 < 8);
            float v2169;
            v2169 = v2164[v2167];
            v2170 = v2169;
        } else {
            v2170 = 0.0f;
        }
        __syncthreads();
        auto v2171 = cooperative_groups::coalesced_threads();
        float v2172;
        v2172 = cooperative_groups::reduce(v2171, v2170, v2045);
        int v2173;
        v2173 = blockIdx.x;
        static float v2174[24];
        assert("Tensor range check" && 0 <= v2173 && v2173 < 24);
        v2174[v2173] = v2172;
        v365.sync() ;
        float v2175;
        v2175 = 0.0f;
        int v2176;
        v2176 = threadIdx.x;
        int v2177;
        v2177 = v2176 % 32;
        int v2178;
        v2178 = v2177;
        while (while_method_31(v2178)){
            bool v2180;
            v2180 = 0 <= v2178;
            bool v2181;
            v2181 = v2180 == false;
            if (v2181){
                assert("The index needs to be zero or positive." && v2180);
            } else {
            }
            bool v2183;
            v2183 = v2178 < 24;
            bool v2184;
            v2184 = v2183 == false;
            if (v2184){
                assert("The last element of the projection dimensions needs to be greater than the index remainder." && v2183);
            } else {
            }
            assert("Tensor range check" && 0 <= v2178 && v2178 < 24);
            float v2186;
            v2186 = v2174[v2178];
            bool v2187;
            v2187 = v2175 >= v2186;
            float v2188;
            if (v2187){
                v2188 = v2175;
            } else {
                v2188 = v2186;
            }
            v2175 = v2188;
            v2178 += 32 ;
        }
        __syncwarp();
        auto v2189 = cooperative_groups::coalesced_threads();
        float v2190;
        v2190 = cooperative_groups::reduce(v2189, v2175, v2045);
        int v2191;
        v2191 = threadIdx.x;
        int v2192;
        v2192 = blockIdx.x;
        int v2193;
        v2193 = v2192 * 256;
        int v2194;
        v2194 = v2191 + v2193;
        bool v2195;
        v2195 = v2194 == 0;
        if (v2195){
            cuda::counting_semaphore<cuda::thread_scope_system, 1> & v2196 = console_lock;
            auto v2197 = cooperative_groups::coalesced_threads();
            v2196.acquire();
            printf("{%s = %f}\n","max_norm", v2190);
            v2196.release();
            v2197.sync() ;
        } else {
        }
        __syncwarp();
        static float v2200[65536];
        int v2201;
        v2201 = threadIdx.x;
        int v2202;
        v2202 = blockIdx.x;
        int v2203;
        v2203 = v2202 * 256;
        int v2204;
        v2204 = v2201 + v2203;
        int v2205;
        v2205 = v2204 / 32;
        int v2206;
        v2206 = v2205;
        while (while_method_32(v2206)){
            bool v2208;
            v2208 = 0 <= v2206;
            bool v2209;
            v2209 = v2208 == false;
            if (v2209){
                assert("The index needs to be zero or positive." && v2208);
            } else {
            }
            int v2211;
            v2211 = v2206 % 256;
            int v2212;
            v2212 = v2206 / 256;
            bool v2213;
            v2213 = v2212 < 256;
            bool v2214;
            v2214 = v2213 == false;
            if (v2214){
                assert("The last element of the projection dimensions needs to be greater than the index remainder." && v2213);
            } else {
            }
            assert("Tensor range check" && 0 <= v2212 && v2212 < 256);
            assert("Tensor range check" && 0 <= v2211 && v2211 < 256);
            int v2216;
            v2216 = 4 * v2211;
            int v2217;
            v2217 = 1024 * v2212;
            int v2218;
            v2218 = v2217 + v2216;
            float v2219;
            v2219 = 0.0f;
            int v2220;
            v2220 = threadIdx.x;
            int v2221;
            v2221 = v2220 % 32;
            int v2222;
            v2222 = v2221;
            while (while_method_6(v2222)){
                bool v2224;
                v2224 = 0 <= v2222;
                bool v2225;
                v2225 = v2224 == false;
                if (v2225){
                    assert("The index needs to be zero or positive." && v2224);
                } else {
                }
                bool v2227;
                v2227 = v2222 < 1;
                bool v2228;
                v2228 = v2227 == false;
                if (v2228){
                    assert("The last element of the projection dimensions needs to be greater than the index remainder." && v2227);
                } else {
                }
                assert("Tensor range check" && 0 <= v2222 && v2222 < 1);
                int v2230;
                v2230 = 4 * v2222;
                int v2231;
                v2231 = v2230 + v2218;
                float v2232[4];
                int4* v2233;
                v2233 = reinterpret_cast<int4*>(v378 + v2231);
                int4* v2234;
                v2234 = reinterpret_cast<int4*>(v2232 + 0);
                assert("Pointer alignment check" && reinterpret_cast<unsigned long long>(v2233) % 16 == 0 && reinterpret_cast<unsigned long long>(v2234) % 16 == 0);
                *v2234 = *v2233;
                int v2235;
                v2235 = 0;
                while (while_method_3(v2235)){
                    assert("Tensor range check" && 0 <= v2235 && v2235 < 4);
                    float v2237;
                    v2237 = v2232[v2235];
                    float v2238;
                    v2238 = v2237 * v2237;
                    float v2239;
                    v2239 = v2219 + v2238;
                    v2219 = v2239;
                    v2235 += 1 ;
                }
                v2222 += 32 ;
            }
            __syncwarp();
            auto v2240 = cooperative_groups::coalesced_threads();
            Closure0 v2241{};
            float v2242;
            v2242 = cooperative_groups::reduce(v2240, v2219, v2241);
            float v2243;
            v2243 = sqrt(v2242);
            assert("Tensor range check" && 0 <= v2212 && v2212 < 256);
            assert("Tensor range check" && 0 <= v2211 && v2211 < 256);
            int v2244;
            v2244 = 256 * v2212;
            int v2245;
            v2245 = v2244 + v2211;
            v2200[v2245] = v2243;
            v2206 += 192 ;
        }
        __syncthreads();
        v365.sync() ;
        float v2246;
        v2246 = 0.0f;
        int v2247;
        v2247 = threadIdx.x;
        int v2248;
        v2248 = blockIdx.x;
        int v2249;
        v2249 = v2248 * 256;
        int v2250;
        v2250 = v2247 + v2249;
        int v2251;
        v2251 = v2250;
        while (while_method_13(v2251)){
            bool v2253;
            v2253 = 0 <= v2251;
            bool v2254;
            v2254 = v2253 == false;
            if (v2254){
                assert("The index needs to be zero or positive." && v2253);
            } else {
            }
            int v2256;
            v2256 = v2251 % 64;
            int v2257;
            v2257 = v2251 / 64;
            bool v2258;
            v2258 = v2257 < 256;
            bool v2259;
            v2259 = v2258 == false;
            if (v2259){
                assert("The last element of the projection dimensions needs to be greater than the index remainder." && v2258);
            } else {
            }
            assert("Tensor range check" && 0 <= v2257 && v2257 < 256);
            assert("Tensor range check" && 0 <= v2256 && v2256 < 64);
            int v2261;
            v2261 = 4 * v2256;
            int v2262;
            v2262 = 256 * v2257;
            int v2263;
            v2263 = v2262 + v2261;
            float v2264[4];
            int4* v2265;
            v2265 = reinterpret_cast<int4*>(v2200 + v2263);
            int4* v2266;
            v2266 = reinterpret_cast<int4*>(v2264 + 0);
            assert("Pointer alignment check" && reinterpret_cast<unsigned long long>(v2265) % 16 == 0 && reinterpret_cast<unsigned long long>(v2266) % 16 == 0);
            *v2266 = *v2265;
            int v2267; float v2268;
            Tuple25 tmp111 = Tuple25{0, v2246};
            v2267 = tmp111.v0; v2268 = tmp111.v1;
            while (while_method_3(v2267)){
                assert("Tensor range check" && 0 <= v2267 && v2267 < 4);
                float v2270;
                v2270 = v2264[v2267];
                bool v2271;
                v2271 = v2268 >= v2270;
                float v2272;
                if (v2271){
                    v2272 = v2268;
                } else {
                    v2272 = v2270;
                }
                v2268 = v2272;
                v2267 += 1 ;
            }
            v2246 = v2268;
            v2251 += 6144 ;
        }
        __syncwarp();
        auto v2273 = cooperative_groups::coalesced_threads();
        float v2274;
        v2274 = cooperative_groups::reduce(v2273, v2246, v2045);
        int v2275;
        v2275 = threadIdx.x;
        int v2276;
        v2276 = v2275 / 32;
        extern __shared__ unsigned char v2277[];
        float * v2278;
        v2278 = reinterpret_cast<float *>(&v2277[0ull]);
        assert("Tensor range check" && 0 <= v2276 && v2276 < 8);
        v2278[v2276] = v2274;
        __syncthreads();
        int v2280;
        v2280 = threadIdx.x;
        int v2281;
        v2281 = v2280 % 32;
        bool v2282;
        v2282 = v2281 < 8;
        float v2284;
        if (v2282){
            assert("Tensor range check" && 0 <= v2281 && v2281 < 8);
            float v2283;
            v2283 = v2278[v2281];
            v2284 = v2283;
        } else {
            v2284 = 0.0f;
        }
        __syncthreads();
        auto v2285 = cooperative_groups::coalesced_threads();
        float v2286;
        v2286 = cooperative_groups::reduce(v2285, v2284, v2045);
        int v2287;
        v2287 = blockIdx.x;
        static float v2288[24];
        assert("Tensor range check" && 0 <= v2287 && v2287 < 24);
        v2288[v2287] = v2286;
        v365.sync() ;
        float v2289;
        v2289 = 0.0f;
        int v2290;
        v2290 = threadIdx.x;
        int v2291;
        v2291 = v2290 % 32;
        int v2292;
        v2292 = v2291;
        while (while_method_31(v2292)){
            bool v2294;
            v2294 = 0 <= v2292;
            bool v2295;
            v2295 = v2294 == false;
            if (v2295){
                assert("The index needs to be zero or positive." && v2294);
            } else {
            }
            bool v2297;
            v2297 = v2292 < 24;
            bool v2298;
            v2298 = v2297 == false;
            if (v2298){
                assert("The last element of the projection dimensions needs to be greater than the index remainder." && v2297);
            } else {
            }
            assert("Tensor range check" && 0 <= v2292 && v2292 < 24);
            float v2300;
            v2300 = v2288[v2292];
            bool v2301;
            v2301 = v2289 >= v2300;
            float v2302;
            if (v2301){
                v2302 = v2289;
            } else {
                v2302 = v2300;
            }
            v2289 = v2302;
            v2292 += 32 ;
        }
        __syncwarp();
        auto v2303 = cooperative_groups::coalesced_threads();
        float v2304;
        v2304 = cooperative_groups::reduce(v2303, v2289, v2045);
        int v2305;
        v2305 = threadIdx.x;
        int v2306;
        v2306 = blockIdx.x;
        int v2307;
        v2307 = v2306 * 256;
        int v2308;
        v2308 = v2305 + v2307;
        bool v2309;
        v2309 = v2308 == 0;
        if (v2309){
            cuda::counting_semaphore<cuda::thread_scope_system, 1> & v2310 = console_lock;
            auto v2311 = cooperative_groups::coalesced_threads();
            v2310.acquire();
            printf("{%s = %f}\n","max_norm", v2304);
            v2310.release();
            v2311.sync() ;
        } else {
        }
        __syncwarp();
        static float v2314[65536];
        int v2315;
        v2315 = threadIdx.x;
        int v2316;
        v2316 = blockIdx.x;
        int v2317;
        v2317 = v2316 * 256;
        int v2318;
        v2318 = v2315 + v2317;
        int v2319;
        v2319 = v2318 / 32;
        int v2320;
        v2320 = v2319;
        while (while_method_32(v2320)){
            bool v2322;
            v2322 = 0 <= v2320;
            bool v2323;
            v2323 = v2322 == false;
            if (v2323){
                assert("The index needs to be zero or positive." && v2322);
            } else {
            }
            int v2325;
            v2325 = v2320 % 256;
            int v2326;
            v2326 = v2320 / 256;
            bool v2327;
            v2327 = v2326 < 256;
            bool v2328;
            v2328 = v2327 == false;
            if (v2328){
                assert("The last element of the projection dimensions needs to be greater than the index remainder." && v2327);
            } else {
            }
            assert("Tensor range check" && 0 <= v2326 && v2326 < 256);
            assert("Tensor range check" && 0 <= v2325 && v2325 < 256);
            int v2330;
            v2330 = 4 * v2325;
            int v2331;
            v2331 = 1024 * v2326;
            int v2332;
            v2332 = v2331 + v2330;
            float v2333;
            v2333 = 0.0f;
            int v2334;
            v2334 = threadIdx.x;
            int v2335;
            v2335 = v2334 % 32;
            int v2336;
            v2336 = v2335;
            while (while_method_6(v2336)){
                bool v2338;
                v2338 = 0 <= v2336;
                bool v2339;
                v2339 = v2338 == false;
                if (v2339){
                    assert("The index needs to be zero or positive." && v2338);
                } else {
                }
                bool v2341;
                v2341 = v2336 < 1;
                bool v2342;
                v2342 = v2341 == false;
                if (v2342){
                    assert("The last element of the projection dimensions needs to be greater than the index remainder." && v2341);
                } else {
                }
                assert("Tensor range check" && 0 <= v2336 && v2336 < 1);
                int v2344;
                v2344 = 4 * v2336;
                int v2345;
                v2345 = v2344 + v2332;
                float v2346[4];
                int4* v2347;
                v2347 = reinterpret_cast<int4*>(v382 + v2345);
                int4* v2348;
                v2348 = reinterpret_cast<int4*>(v2346 + 0);
                assert("Pointer alignment check" && reinterpret_cast<unsigned long long>(v2347) % 16 == 0 && reinterpret_cast<unsigned long long>(v2348) % 16 == 0);
                *v2348 = *v2347;
                int v2349;
                v2349 = 0;
                while (while_method_3(v2349)){
                    assert("Tensor range check" && 0 <= v2349 && v2349 < 4);
                    float v2351;
                    v2351 = v2346[v2349];
                    float v2352;
                    v2352 = v2351 * v2351;
                    float v2353;
                    v2353 = v2333 + v2352;
                    v2333 = v2353;
                    v2349 += 1 ;
                }
                v2336 += 32 ;
            }
            __syncwarp();
            auto v2354 = cooperative_groups::coalesced_threads();
            Closure0 v2355{};
            float v2356;
            v2356 = cooperative_groups::reduce(v2354, v2333, v2355);
            float v2357;
            v2357 = sqrt(v2356);
            assert("Tensor range check" && 0 <= v2326 && v2326 < 256);
            assert("Tensor range check" && 0 <= v2325 && v2325 < 256);
            int v2358;
            v2358 = 256 * v2326;
            int v2359;
            v2359 = v2358 + v2325;
            v2314[v2359] = v2357;
            v2320 += 192 ;
        }
        __syncthreads();
        v365.sync() ;
        float v2360;
        v2360 = 0.0f;
        int v2361;
        v2361 = threadIdx.x;
        int v2362;
        v2362 = blockIdx.x;
        int v2363;
        v2363 = v2362 * 256;
        int v2364;
        v2364 = v2361 + v2363;
        int v2365;
        v2365 = v2364;
        while (while_method_13(v2365)){
            bool v2367;
            v2367 = 0 <= v2365;
            bool v2368;
            v2368 = v2367 == false;
            if (v2368){
                assert("The index needs to be zero or positive." && v2367);
            } else {
            }
            int v2370;
            v2370 = v2365 % 64;
            int v2371;
            v2371 = v2365 / 64;
            bool v2372;
            v2372 = v2371 < 256;
            bool v2373;
            v2373 = v2372 == false;
            if (v2373){
                assert("The last element of the projection dimensions needs to be greater than the index remainder." && v2372);
            } else {
            }
            assert("Tensor range check" && 0 <= v2371 && v2371 < 256);
            assert("Tensor range check" && 0 <= v2370 && v2370 < 64);
            int v2375;
            v2375 = 4 * v2370;
            int v2376;
            v2376 = 256 * v2371;
            int v2377;
            v2377 = v2376 + v2375;
            float v2378[4];
            int4* v2379;
            v2379 = reinterpret_cast<int4*>(v2314 + v2377);
            int4* v2380;
            v2380 = reinterpret_cast<int4*>(v2378 + 0);
            assert("Pointer alignment check" && reinterpret_cast<unsigned long long>(v2379) % 16 == 0 && reinterpret_cast<unsigned long long>(v2380) % 16 == 0);
            *v2380 = *v2379;
            int v2381; float v2382;
            Tuple25 tmp112 = Tuple25{0, v2360};
            v2381 = tmp112.v0; v2382 = tmp112.v1;
            while (while_method_3(v2381)){
                assert("Tensor range check" && 0 <= v2381 && v2381 < 4);
                float v2384;
                v2384 = v2378[v2381];
                bool v2385;
                v2385 = v2382 >= v2384;
                float v2386;
                if (v2385){
                    v2386 = v2382;
                } else {
                    v2386 = v2384;
                }
                v2382 = v2386;
                v2381 += 1 ;
            }
            v2360 = v2382;
            v2365 += 6144 ;
        }
        __syncwarp();
        auto v2387 = cooperative_groups::coalesced_threads();
        float v2388;
        v2388 = cooperative_groups::reduce(v2387, v2360, v2045);
        int v2389;
        v2389 = threadIdx.x;
        int v2390;
        v2390 = v2389 / 32;
        extern __shared__ unsigned char v2391[];
        float * v2392;
        v2392 = reinterpret_cast<float *>(&v2391[0ull]);
        assert("Tensor range check" && 0 <= v2390 && v2390 < 8);
        v2392[v2390] = v2388;
        __syncthreads();
        int v2394;
        v2394 = threadIdx.x;
        int v2395;
        v2395 = v2394 % 32;
        bool v2396;
        v2396 = v2395 < 8;
        float v2398;
        if (v2396){
            assert("Tensor range check" && 0 <= v2395 && v2395 < 8);
            float v2397;
            v2397 = v2392[v2395];
            v2398 = v2397;
        } else {
            v2398 = 0.0f;
        }
        __syncthreads();
        auto v2399 = cooperative_groups::coalesced_threads();
        float v2400;
        v2400 = cooperative_groups::reduce(v2399, v2398, v2045);
        int v2401;
        v2401 = blockIdx.x;
        static float v2402[24];
        assert("Tensor range check" && 0 <= v2401 && v2401 < 24);
        v2402[v2401] = v2400;
        v365.sync() ;
        float v2403;
        v2403 = 0.0f;
        int v2404;
        v2404 = threadIdx.x;
        int v2405;
        v2405 = v2404 % 32;
        int v2406;
        v2406 = v2405;
        while (while_method_31(v2406)){
            bool v2408;
            v2408 = 0 <= v2406;
            bool v2409;
            v2409 = v2408 == false;
            if (v2409){
                assert("The index needs to be zero or positive." && v2408);
            } else {
            }
            bool v2411;
            v2411 = v2406 < 24;
            bool v2412;
            v2412 = v2411 == false;
            if (v2412){
                assert("The last element of the projection dimensions needs to be greater than the index remainder." && v2411);
            } else {
            }
            assert("Tensor range check" && 0 <= v2406 && v2406 < 24);
            float v2414;
            v2414 = v2402[v2406];
            bool v2415;
            v2415 = v2403 >= v2414;
            float v2416;
            if (v2415){
                v2416 = v2403;
            } else {
                v2416 = v2414;
            }
            v2403 = v2416;
            v2406 += 32 ;
        }
        __syncwarp();
        auto v2417 = cooperative_groups::coalesced_threads();
        float v2418;
        v2418 = cooperative_groups::reduce(v2417, v2403, v2045);
        int v2419;
        v2419 = threadIdx.x;
        int v2420;
        v2420 = blockIdx.x;
        int v2421;
        v2421 = v2420 * 256;
        int v2422;
        v2422 = v2419 + v2421;
        bool v2423;
        v2423 = v2422 == 0;
        if (v2423){
            cuda::counting_semaphore<cuda::thread_scope_system, 1> & v2424 = console_lock;
            auto v2425 = cooperative_groups::coalesced_threads();
            v2424.acquire();
            printf("{%s = %f}\n","max_norm", v2418);
            v2424.release();
            v2425.sync() ;
        } else {
        }
        __syncwarp();
        static float v2428[65536];
        int v2429;
        v2429 = threadIdx.x;
        int v2430;
        v2430 = blockIdx.x;
        int v2431;
        v2431 = v2430 * 256;
        int v2432;
        v2432 = v2429 + v2431;
        int v2433;
        v2433 = v2432 / 32;
        int v2434;
        v2434 = v2433;
        while (while_method_32(v2434)){
            bool v2436;
            v2436 = 0 <= v2434;
            bool v2437;
            v2437 = v2436 == false;
            if (v2437){
                assert("The index needs to be zero or positive." && v2436);
            } else {
            }
            int v2439;
            v2439 = v2434 % 256;
            int v2440;
            v2440 = v2434 / 256;
            bool v2441;
            v2441 = v2440 < 256;
            bool v2442;
            v2442 = v2441 == false;
            if (v2442){
                assert("The last element of the projection dimensions needs to be greater than the index remainder." && v2441);
            } else {
            }
            assert("Tensor range check" && 0 <= v2440 && v2440 < 256);
            assert("Tensor range check" && 0 <= v2439 && v2439 < 256);
            int v2444;
            v2444 = 4 * v2439;
            int v2445;
            v2445 = 1024 * v2440;
            int v2446;
            v2446 = v2445 + v2444;
            float v2447;
            v2447 = 0.0f;
            int v2448;
            v2448 = threadIdx.x;
            int v2449;
            v2449 = v2448 % 32;
            int v2450;
            v2450 = v2449;
            while (while_method_6(v2450)){
                bool v2452;
                v2452 = 0 <= v2450;
                bool v2453;
                v2453 = v2452 == false;
                if (v2453){
                    assert("The index needs to be zero or positive." && v2452);
                } else {
                }
                bool v2455;
                v2455 = v2450 < 1;
                bool v2456;
                v2456 = v2455 == false;
                if (v2456){
                    assert("The last element of the projection dimensions needs to be greater than the index remainder." && v2455);
                } else {
                }
                assert("Tensor range check" && 0 <= v2450 && v2450 < 1);
                int v2458;
                v2458 = 4 * v2450;
                int v2459;
                v2459 = v2458 + v2446;
                float v2460[4];
                int4* v2461;
                v2461 = reinterpret_cast<int4*>(v386 + v2459);
                int4* v2462;
                v2462 = reinterpret_cast<int4*>(v2460 + 0);
                assert("Pointer alignment check" && reinterpret_cast<unsigned long long>(v2461) % 16 == 0 && reinterpret_cast<unsigned long long>(v2462) % 16 == 0);
                *v2462 = *v2461;
                int v2463;
                v2463 = 0;
                while (while_method_3(v2463)){
                    assert("Tensor range check" && 0 <= v2463 && v2463 < 4);
                    float v2465;
                    v2465 = v2460[v2463];
                    float v2466;
                    v2466 = v2465 * v2465;
                    float v2467;
                    v2467 = v2447 + v2466;
                    v2447 = v2467;
                    v2463 += 1 ;
                }
                v2450 += 32 ;
            }
            __syncwarp();
            auto v2468 = cooperative_groups::coalesced_threads();
            Closure0 v2469{};
            float v2470;
            v2470 = cooperative_groups::reduce(v2468, v2447, v2469);
            float v2471;
            v2471 = sqrt(v2470);
            assert("Tensor range check" && 0 <= v2440 && v2440 < 256);
            assert("Tensor range check" && 0 <= v2439 && v2439 < 256);
            int v2472;
            v2472 = 256 * v2440;
            int v2473;
            v2473 = v2472 + v2439;
            v2428[v2473] = v2471;
            v2434 += 192 ;
        }
        __syncthreads();
        v365.sync() ;
        float v2474;
        v2474 = 0.0f;
        int v2475;
        v2475 = threadIdx.x;
        int v2476;
        v2476 = blockIdx.x;
        int v2477;
        v2477 = v2476 * 256;
        int v2478;
        v2478 = v2475 + v2477;
        int v2479;
        v2479 = v2478;
        while (while_method_13(v2479)){
            bool v2481;
            v2481 = 0 <= v2479;
            bool v2482;
            v2482 = v2481 == false;
            if (v2482){
                assert("The index needs to be zero or positive." && v2481);
            } else {
            }
            int v2484;
            v2484 = v2479 % 64;
            int v2485;
            v2485 = v2479 / 64;
            bool v2486;
            v2486 = v2485 < 256;
            bool v2487;
            v2487 = v2486 == false;
            if (v2487){
                assert("The last element of the projection dimensions needs to be greater than the index remainder." && v2486);
            } else {
            }
            assert("Tensor range check" && 0 <= v2485 && v2485 < 256);
            assert("Tensor range check" && 0 <= v2484 && v2484 < 64);
            int v2489;
            v2489 = 4 * v2484;
            int v2490;
            v2490 = 256 * v2485;
            int v2491;
            v2491 = v2490 + v2489;
            float v2492[4];
            int4* v2493;
            v2493 = reinterpret_cast<int4*>(v2428 + v2491);
            int4* v2494;
            v2494 = reinterpret_cast<int4*>(v2492 + 0);
            assert("Pointer alignment check" && reinterpret_cast<unsigned long long>(v2493) % 16 == 0 && reinterpret_cast<unsigned long long>(v2494) % 16 == 0);
            *v2494 = *v2493;
            int v2495; float v2496;
            Tuple25 tmp113 = Tuple25{0, v2474};
            v2495 = tmp113.v0; v2496 = tmp113.v1;
            while (while_method_3(v2495)){
                assert("Tensor range check" && 0 <= v2495 && v2495 < 4);
                float v2498;
                v2498 = v2492[v2495];
                bool v2499;
                v2499 = v2496 >= v2498;
                float v2500;
                if (v2499){
                    v2500 = v2496;
                } else {
                    v2500 = v2498;
                }
                v2496 = v2500;
                v2495 += 1 ;
            }
            v2474 = v2496;
            v2479 += 6144 ;
        }
        __syncwarp();
        auto v2501 = cooperative_groups::coalesced_threads();
        float v2502;
        v2502 = cooperative_groups::reduce(v2501, v2474, v2045);
        int v2503;
        v2503 = threadIdx.x;
        int v2504;
        v2504 = v2503 / 32;
        extern __shared__ unsigned char v2505[];
        float * v2506;
        v2506 = reinterpret_cast<float *>(&v2505[0ull]);
        assert("Tensor range check" && 0 <= v2504 && v2504 < 8);
        v2506[v2504] = v2502;
        __syncthreads();
        int v2508;
        v2508 = threadIdx.x;
        int v2509;
        v2509 = v2508 % 32;
        bool v2510;
        v2510 = v2509 < 8;
        float v2512;
        if (v2510){
            assert("Tensor range check" && 0 <= v2509 && v2509 < 8);
            float v2511;
            v2511 = v2506[v2509];
            v2512 = v2511;
        } else {
            v2512 = 0.0f;
        }
        __syncthreads();
        auto v2513 = cooperative_groups::coalesced_threads();
        float v2514;
        v2514 = cooperative_groups::reduce(v2513, v2512, v2045);
        int v2515;
        v2515 = blockIdx.x;
        static float v2516[24];
        assert("Tensor range check" && 0 <= v2515 && v2515 < 24);
        v2516[v2515] = v2514;
        v365.sync() ;
        float v2517;
        v2517 = 0.0f;
        int v2518;
        v2518 = threadIdx.x;
        int v2519;
        v2519 = v2518 % 32;
        int v2520;
        v2520 = v2519;
        while (while_method_31(v2520)){
            bool v2522;
            v2522 = 0 <= v2520;
            bool v2523;
            v2523 = v2522 == false;
            if (v2523){
                assert("The index needs to be zero or positive." && v2522);
            } else {
            }
            bool v2525;
            v2525 = v2520 < 24;
            bool v2526;
            v2526 = v2525 == false;
            if (v2526){
                assert("The last element of the projection dimensions needs to be greater than the index remainder." && v2525);
            } else {
            }
            assert("Tensor range check" && 0 <= v2520 && v2520 < 24);
            float v2528;
            v2528 = v2516[v2520];
            bool v2529;
            v2529 = v2517 >= v2528;
            float v2530;
            if (v2529){
                v2530 = v2517;
            } else {
                v2530 = v2528;
            }
            v2517 = v2530;
            v2520 += 32 ;
        }
        __syncwarp();
        auto v2531 = cooperative_groups::coalesced_threads();
        float v2532;
        v2532 = cooperative_groups::reduce(v2531, v2517, v2045);
        int v2533;
        v2533 = threadIdx.x;
        int v2534;
        v2534 = blockIdx.x;
        int v2535;
        v2535 = v2534 * 256;
        int v2536;
        v2536 = v2533 + v2535;
        bool v2537;
        v2537 = v2536 == 0;
        if (v2537){
            cuda::counting_semaphore<cuda::thread_scope_system, 1> & v2538 = console_lock;
            auto v2539 = cooperative_groups::coalesced_threads();
            v2538.acquire();
            printf("{%s = %f}\n","max_norm", v2532);
            v2538.release();
            v2539.sync() ;
        } else {
        }
        __syncwarp();
        static float v2542[16384];
        int v2543;
        v2543 = threadIdx.x;
        int v2544;
        v2544 = blockIdx.x;
        int v2545;
        v2545 = v2544 * 256;
        int v2546;
        v2546 = v2543 + v2545;
        int v2547;
        v2547 = v2546 / 32;
        int v2548;
        v2548 = v2547;
        while (while_method_13(v2548)){
            bool v2550;
            v2550 = 0 <= v2548;
            bool v2551;
            v2551 = v2550 == false;
            if (v2551){
                assert("The index needs to be zero or positive." && v2550);
            } else {
            }
            int v2553;
            v2553 = v2548 % 256;
            int v2554;
            v2554 = v2548 / 256;
            bool v2555;
            v2555 = v2554 < 64;
            bool v2556;
            v2556 = v2555 == false;
            if (v2556){
                assert("The last element of the projection dimensions needs to be greater than the index remainder." && v2555);
            } else {
            }
            assert("Tensor range check" && 0 <= v2554 && v2554 < 64);
            assert("Tensor range check" && 0 <= v2553 && v2553 < 256);
            int v2558;
            v2558 = 4 * v2553;
            int v2559;
            v2559 = 1024 * v2554;
            int v2560;
            v2560 = v2559 + v2558;
            float v2561;
            v2561 = 0.0f;
            int v2562;
            v2562 = threadIdx.x;
            int v2563;
            v2563 = v2562 % 32;
            int v2564;
            v2564 = v2563;
            while (while_method_6(v2564)){
                bool v2566;
                v2566 = 0 <= v2564;
                bool v2567;
                v2567 = v2566 == false;
                if (v2567){
                    assert("The index needs to be zero or positive." && v2566);
                } else {
                }
                bool v2569;
                v2569 = v2564 < 1;
                bool v2570;
                v2570 = v2569 == false;
                if (v2570){
                    assert("The last element of the projection dimensions needs to be greater than the index remainder." && v2569);
                } else {
                }
                assert("Tensor range check" && 0 <= v2564 && v2564 < 1);
                int v2572;
                v2572 = 4 * v2564;
                int v2573;
                v2573 = v2572 + v2560;
                float v2574[4];
                int4* v2575;
                v2575 = reinterpret_cast<int4*>(v390 + v2573);
                int4* v2576;
                v2576 = reinterpret_cast<int4*>(v2574 + 0);
                assert("Pointer alignment check" && reinterpret_cast<unsigned long long>(v2575) % 16 == 0 && reinterpret_cast<unsigned long long>(v2576) % 16 == 0);
                *v2576 = *v2575;
                int v2577;
                v2577 = 0;
                while (while_method_3(v2577)){
                    assert("Tensor range check" && 0 <= v2577 && v2577 < 4);
                    float v2579;
                    v2579 = v2574[v2577];
                    float v2580;
                    v2580 = v2579 * v2579;
                    float v2581;
                    v2581 = v2561 + v2580;
                    v2561 = v2581;
                    v2577 += 1 ;
                }
                v2564 += 32 ;
            }
            __syncwarp();
            auto v2582 = cooperative_groups::coalesced_threads();
            Closure0 v2583{};
            float v2584;
            v2584 = cooperative_groups::reduce(v2582, v2561, v2583);
            float v2585;
            v2585 = sqrt(v2584);
            assert("Tensor range check" && 0 <= v2554 && v2554 < 64);
            assert("Tensor range check" && 0 <= v2553 && v2553 < 256);
            int v2586;
            v2586 = 256 * v2554;
            int v2587;
            v2587 = v2586 + v2553;
            v2542[v2587] = v2585;
            v2548 += 192 ;
        }
        __syncthreads();
        v365.sync() ;
        float v2588;
        v2588 = 0.0f;
        int v2589;
        v2589 = threadIdx.x;
        int v2590;
        v2590 = blockIdx.x;
        int v2591;
        v2591 = v2590 * 256;
        int v2592;
        v2592 = v2589 + v2591;
        int v2593;
        v2593 = v2592;
        while (while_method_33(v2593)){
            bool v2595;
            v2595 = 0 <= v2593;
            bool v2596;
            v2596 = v2595 == false;
            if (v2596){
                assert("The index needs to be zero or positive." && v2595);
            } else {
            }
            int v2598;
            v2598 = v2593 % 64;
            int v2599;
            v2599 = v2593 / 64;
            bool v2600;
            v2600 = v2599 < 64;
            bool v2601;
            v2601 = v2600 == false;
            if (v2601){
                assert("The last element of the projection dimensions needs to be greater than the index remainder." && v2600);
            } else {
            }
            assert("Tensor range check" && 0 <= v2599 && v2599 < 64);
            assert("Tensor range check" && 0 <= v2598 && v2598 < 64);
            int v2603;
            v2603 = 4 * v2598;
            int v2604;
            v2604 = 256 * v2599;
            int v2605;
            v2605 = v2604 + v2603;
            float v2606[4];
            int4* v2607;
            v2607 = reinterpret_cast<int4*>(v2542 + v2605);
            int4* v2608;
            v2608 = reinterpret_cast<int4*>(v2606 + 0);
            assert("Pointer alignment check" && reinterpret_cast<unsigned long long>(v2607) % 16 == 0 && reinterpret_cast<unsigned long long>(v2608) % 16 == 0);
            *v2608 = *v2607;
            int v2609; float v2610;
            Tuple25 tmp114 = Tuple25{0, v2588};
            v2609 = tmp114.v0; v2610 = tmp114.v1;
            while (while_method_3(v2609)){
                assert("Tensor range check" && 0 <= v2609 && v2609 < 4);
                float v2612;
                v2612 = v2606[v2609];
                bool v2613;
                v2613 = v2610 >= v2612;
                float v2614;
                if (v2613){
                    v2614 = v2610;
                } else {
                    v2614 = v2612;
                }
                v2610 = v2614;
                v2609 += 1 ;
            }
            v2588 = v2610;
            v2593 += 6144 ;
        }
        __syncwarp();
        auto v2615 = cooperative_groups::coalesced_threads();
        float v2616;
        v2616 = cooperative_groups::reduce(v2615, v2588, v2045);
        int v2617;
        v2617 = threadIdx.x;
        int v2618;
        v2618 = v2617 / 32;
        extern __shared__ unsigned char v2619[];
        float * v2620;
        v2620 = reinterpret_cast<float *>(&v2619[0ull]);
        assert("Tensor range check" && 0 <= v2618 && v2618 < 8);
        v2620[v2618] = v2616;
        __syncthreads();
        int v2622;
        v2622 = threadIdx.x;
        int v2623;
        v2623 = v2622 % 32;
        bool v2624;
        v2624 = v2623 < 8;
        float v2626;
        if (v2624){
            assert("Tensor range check" && 0 <= v2623 && v2623 < 8);
            float v2625;
            v2625 = v2620[v2623];
            v2626 = v2625;
        } else {
            v2626 = 0.0f;
        }
        __syncthreads();
        auto v2627 = cooperative_groups::coalesced_threads();
        float v2628;
        v2628 = cooperative_groups::reduce(v2627, v2626, v2045);
        int v2629;
        v2629 = blockIdx.x;
        static float v2630[24];
        assert("Tensor range check" && 0 <= v2629 && v2629 < 24);
        v2630[v2629] = v2628;
        v365.sync() ;
        float v2631;
        v2631 = 0.0f;
        int v2632;
        v2632 = threadIdx.x;
        int v2633;
        v2633 = v2632 % 32;
        int v2634;
        v2634 = v2633;
        while (while_method_31(v2634)){
            bool v2636;
            v2636 = 0 <= v2634;
            bool v2637;
            v2637 = v2636 == false;
            if (v2637){
                assert("The index needs to be zero or positive." && v2636);
            } else {
            }
            bool v2639;
            v2639 = v2634 < 24;
            bool v2640;
            v2640 = v2639 == false;
            if (v2640){
                assert("The last element of the projection dimensions needs to be greater than the index remainder." && v2639);
            } else {
            }
            assert("Tensor range check" && 0 <= v2634 && v2634 < 24);
            float v2642;
            v2642 = v2630[v2634];
            bool v2643;
            v2643 = v2631 >= v2642;
            float v2644;
            if (v2643){
                v2644 = v2631;
            } else {
                v2644 = v2642;
            }
            v2631 = v2644;
            v2634 += 32 ;
        }
        __syncwarp();
        auto v2645 = cooperative_groups::coalesced_threads();
        float v2646;
        v2646 = cooperative_groups::reduce(v2645, v2631, v2045);
        int v2647;
        v2647 = threadIdx.x;
        int v2648;
        v2648 = blockIdx.x;
        int v2649;
        v2649 = v2648 * 256;
        int v2650;
        v2650 = v2647 + v2649;
        bool v2651;
        v2651 = v2650 == 0;
        if (v2651){
            cuda::counting_semaphore<cuda::thread_scope_system, 1> & v2652 = console_lock;
            auto v2653 = cooperative_groups::coalesced_threads();
            v2652.acquire();
            printf("{%s = %f}\n","max_norm", v2646);
            v2652.release();
            v2653.sync() ;
        } else {
        }
        __syncwarp();
        extern __shared__ unsigned char v2656[];
        float * v2657;
        v2657 = reinterpret_cast<float *>(&v2656[0ull]);
        int v2659;
        v2659 = blockIdx.x;
        int v2660;
        v2660 = v2659;
        while (while_method_26(v2660)){
            bool v2662;
            v2662 = 0 <= v2660;
            bool v2663;
            v2663 = v2662 == false;
            if (v2663){
                assert("The index needs to be zero or positive." && v2662);
            } else {
            }
            int v2665;
            v2665 = v2660 % 1;
            bool v2666;
            v2666 = v2660 < 1024;
            bool v2667;
            v2667 = v2666 == false;
            if (v2667){
                assert("The last element of the projection dimensions needs to be greater than the index remainder." && v2666);
            } else {
            }
            assert("Tensor range check" && 0 <= v2660 && v2660 < 1024);
            assert("Tensor range check" && 0 <= v2665 && v2665 < 1);
            int v2669;
            v2669 = 4 * v2665;
            int v2670;
            v2670 = 2048 * v2660;
            int v2671;
            v2671 = v2670 + v2669;
            int v2672;
            v2672 = 2097152 * v2665;
            int v2673;
            v2673 = 512 * v2660;
            int v2674;
            v2674 = v2673 + v2672;
            int v2675;
            v2675 = threadIdx.x;
            int v2676;
            v2676 = v2675;
            while (while_method_23(v2676)){
                bool v2678;
                v2678 = 0 <= v2676;
                bool v2679;
                v2679 = v2678 == false;
                if (v2679){
                    assert("The index needs to be zero or positive." && v2678);
                } else {
                }
                int v2681;
                v2681 = v2676 % 4;
                int v2682;
                v2682 = v2676 / 4;
                bool v2683;
                v2683 = v2682 < 512;
                bool v2684;
                v2684 = v2683 == false;
                if (v2684){
                    assert("The last element of the projection dimensions needs to be greater than the index remainder." && v2683);
                } else {
                }
                assert("Tensor range check" && 0 <= v2682 && v2682 < 512);
                assert("Tensor range check" && 0 <= v2681 && v2681 < 4);
                int v2686;
                v2686 = v2681 + v2671;
                int v2687;
                v2687 = 4 * v2682;
                int v2688;
                v2688 = v2687 + v2686;
                float v2689;
                v2689 = v370[v2688];
                assert("Tensor range check" && 0 <= v2682 && v2682 < 512);
                assert("Tensor range check" && 0 <= v2681 && v2681 < 4);
                int v2690;
                v2690 = 33 * v2682;
                int v2691;
                v2691 = v2690 + v2681;
                v2657[v2691] = v2689;
                v2676 += 256 ;
            }
            __syncthreads();
            int v2692;
            v2692 = threadIdx.x;
            int v2693;
            v2693 = v2692;
            while (while_method_23(v2693)){
                bool v2695;
                v2695 = 0 <= v2693;
                bool v2696;
                v2696 = v2695 == false;
                if (v2696){
                    assert("The index needs to be zero or positive." && v2695);
                } else {
                }
                int v2698;
                v2698 = v2693 % 512;
                int v2699;
                v2699 = v2693 / 512;
                bool v2700;
                v2700 = v2699 < 4;
                bool v2701;
                v2701 = v2700 == false;
                if (v2701){
                    assert("The last element of the projection dimensions needs to be greater than the index remainder." && v2700);
                } else {
                }
                assert("Tensor range check" && 0 <= v2699 && v2699 < 4);
                assert("Tensor range check" && 0 <= v2698 && v2698 < 512);
                int v2703;
                v2703 = 33 * v2698;
                int v2704;
                v2704 = v2699 + v2703;
                float v2705;
                v2705 = v2657[v2704];
                assert("Tensor range check" && 0 <= v2699 && v2699 < 4);
                assert("Tensor range check" && 0 <= v2698 && v2698 < 512);
                int v2706;
                v2706 = v2698 + v2674;
                int v2707;
                v2707 = 524288 * v2699;
                int v2708;
                v2708 = v2707 + v2706;
                v368[v2708] = v2705;
                v2693 += 256 ;
            }
            __syncthreads();
            v2660 += 24 ;
        }
        extern __shared__ unsigned char v2709[];
        float * v2710;
        v2710 = reinterpret_cast<float *>(&v2709[0ull]);
        int v2712;
        v2712 = blockIdx.x;
        int v2713;
        v2713 = v2712;
        while (while_method_27(v2713)){
            bool v2715;
            v2715 = 0 <= v2713;
            bool v2716;
            v2716 = v2715 == false;
            if (v2716){
                assert("The index needs to be zero or positive." && v2715);
            } else {
            }
            int v2718;
            v2718 = v2713 % 1;
            bool v2719;
            v2719 = v2713 < 128;
            bool v2720;
            v2720 = v2719 == false;
            if (v2720){
                assert("The last element of the projection dimensions needs to be greater than the index remainder." && v2719);
            } else {
            }
            assert("Tensor range check" && 0 <= v2713 && v2713 < 128);
            assert("Tensor range check" && 0 <= v2718 && v2718 < 1);
            int v2722;
            v2722 = 4 * v2718;
            int v2723;
            v2723 = 2048 * v2713;
            int v2724;
            v2724 = v2723 + v2722;
            int v2725;
            v2725 = 262144 * v2718;
            int v2726;
            v2726 = 512 * v2713;
            int v2727;
            v2727 = v2726 + v2725;
            int v2728;
            v2728 = threadIdx.x;
            int v2729;
            v2729 = v2728;
            while (while_method_23(v2729)){
                bool v2731;
                v2731 = 0 <= v2729;
                bool v2732;
                v2732 = v2731 == false;
                if (v2732){
                    assert("The index needs to be zero or positive." && v2731);
                } else {
                }
                int v2734;
                v2734 = v2729 % 4;
                int v2735;
                v2735 = v2729 / 4;
                bool v2736;
                v2736 = v2735 < 512;
                bool v2737;
                v2737 = v2736 == false;
                if (v2737){
                    assert("The last element of the projection dimensions needs to be greater than the index remainder." && v2736);
                } else {
                }
                assert("Tensor range check" && 0 <= v2735 && v2735 < 512);
                assert("Tensor range check" && 0 <= v2734 && v2734 < 4);
                int v2739;
                v2739 = v2734 + v2724;
                int v2740;
                v2740 = 4 * v2735;
                int v2741;
                v2741 = v2740 + v2739;
                float v2742;
                v2742 = v374[v2741];
                assert("Tensor range check" && 0 <= v2735 && v2735 < 512);
                assert("Tensor range check" && 0 <= v2734 && v2734 < 4);
                int v2743;
                v2743 = 33 * v2735;
                int v2744;
                v2744 = v2743 + v2734;
                v2710[v2744] = v2742;
                v2729 += 256 ;
            }
            __syncthreads();
            int v2745;
            v2745 = threadIdx.x;
            int v2746;
            v2746 = v2745;
            while (while_method_23(v2746)){
                bool v2748;
                v2748 = 0 <= v2746;
                bool v2749;
                v2749 = v2748 == false;
                if (v2749){
                    assert("The index needs to be zero or positive." && v2748);
                } else {
                }
                int v2751;
                v2751 = v2746 % 512;
                int v2752;
                v2752 = v2746 / 512;
                bool v2753;
                v2753 = v2752 < 4;
                bool v2754;
                v2754 = v2753 == false;
                if (v2754){
                    assert("The last element of the projection dimensions needs to be greater than the index remainder." && v2753);
                } else {
                }
                assert("Tensor range check" && 0 <= v2752 && v2752 < 4);
                assert("Tensor range check" && 0 <= v2751 && v2751 < 512);
                int v2756;
                v2756 = 33 * v2751;
                int v2757;
                v2757 = v2752 + v2756;
                float v2758;
                v2758 = v2710[v2757];
                assert("Tensor range check" && 0 <= v2752 && v2752 < 4);
                assert("Tensor range check" && 0 <= v2751 && v2751 < 512);
                int v2759;
                v2759 = v2751 + v2727;
                int v2760;
                v2760 = 65536 * v2752;
                int v2761;
                v2761 = v2760 + v2759;
                v372[v2761] = v2758;
                v2746 += 256 ;
            }
            __syncthreads();
            v2713 += 24 ;
        }
        extern __shared__ unsigned char v2762[];
        float * v2763;
        v2763 = reinterpret_cast<float *>(&v2762[0ull]);
        int v2765;
        v2765 = blockIdx.x;
        int v2766;
        v2766 = v2765;
        while (while_method_27(v2766)){
            bool v2768;
            v2768 = 0 <= v2766;
            bool v2769;
            v2769 = v2768 == false;
            if (v2769){
                assert("The index needs to be zero or positive." && v2768);
            } else {
            }
            int v2771;
            v2771 = v2766 % 1;
            bool v2772;
            v2772 = v2766 < 128;
            bool v2773;
            v2773 = v2772 == false;
            if (v2773){
                assert("The last element of the projection dimensions needs to be greater than the index remainder." && v2772);
            } else {
            }
            assert("Tensor range check" && 0 <= v2766 && v2766 < 128);
            assert("Tensor range check" && 0 <= v2771 && v2771 < 1);
            int v2775;
            v2775 = 4 * v2771;
            int v2776;
            v2776 = 2048 * v2766;
            int v2777;
            v2777 = v2776 + v2775;
            int v2778;
            v2778 = 262144 * v2771;
            int v2779;
            v2779 = 512 * v2766;
            int v2780;
            v2780 = v2779 + v2778;
            int v2781;
            v2781 = threadIdx.x;
            int v2782;
            v2782 = v2781;
            while (while_method_23(v2782)){
                bool v2784;
                v2784 = 0 <= v2782;
                bool v2785;
                v2785 = v2784 == false;
                if (v2785){
                    assert("The index needs to be zero or positive." && v2784);
                } else {
                }
                int v2787;
                v2787 = v2782 % 4;
                int v2788;
                v2788 = v2782 / 4;
                bool v2789;
                v2789 = v2788 < 512;
                bool v2790;
                v2790 = v2789 == false;
                if (v2790){
                    assert("The last element of the projection dimensions needs to be greater than the index remainder." && v2789);
                } else {
                }
                assert("Tensor range check" && 0 <= v2788 && v2788 < 512);
                assert("Tensor range check" && 0 <= v2787 && v2787 < 4);
                int v2792;
                v2792 = v2787 + v2777;
                int v2793;
                v2793 = 4 * v2788;
                int v2794;
                v2794 = v2793 + v2792;
                float v2795;
                v2795 = v378[v2794];
                assert("Tensor range check" && 0 <= v2788 && v2788 < 512);
                assert("Tensor range check" && 0 <= v2787 && v2787 < 4);
                int v2796;
                v2796 = 33 * v2788;
                int v2797;
                v2797 = v2796 + v2787;
                v2763[v2797] = v2795;
                v2782 += 256 ;
            }
            __syncthreads();
            int v2798;
            v2798 = threadIdx.x;
            int v2799;
            v2799 = v2798;
            while (while_method_23(v2799)){
                bool v2801;
                v2801 = 0 <= v2799;
                bool v2802;
                v2802 = v2801 == false;
                if (v2802){
                    assert("The index needs to be zero or positive." && v2801);
                } else {
                }
                int v2804;
                v2804 = v2799 % 512;
                int v2805;
                v2805 = v2799 / 512;
                bool v2806;
                v2806 = v2805 < 4;
                bool v2807;
                v2807 = v2806 == false;
                if (v2807){
                    assert("The last element of the projection dimensions needs to be greater than the index remainder." && v2806);
                } else {
                }
                assert("Tensor range check" && 0 <= v2805 && v2805 < 4);
                assert("Tensor range check" && 0 <= v2804 && v2804 < 512);
                int v2809;
                v2809 = 33 * v2804;
                int v2810;
                v2810 = v2805 + v2809;
                float v2811;
                v2811 = v2763[v2810];
                assert("Tensor range check" && 0 <= v2805 && v2805 < 4);
                assert("Tensor range check" && 0 <= v2804 && v2804 < 512);
                int v2812;
                v2812 = v2804 + v2780;
                int v2813;
                v2813 = 65536 * v2805;
                int v2814;
                v2814 = v2813 + v2812;
                v376[v2814] = v2811;
                v2799 += 256 ;
            }
            __syncthreads();
            v2766 += 24 ;
        }
        extern __shared__ unsigned char v2815[];
        float * v2816;
        v2816 = reinterpret_cast<float *>(&v2815[0ull]);
        int v2818;
        v2818 = blockIdx.x;
        int v2819;
        v2819 = v2818;
        while (while_method_27(v2819)){
            bool v2821;
            v2821 = 0 <= v2819;
            bool v2822;
            v2822 = v2821 == false;
            if (v2822){
                assert("The index needs to be zero or positive." && v2821);
            } else {
            }
            int v2824;
            v2824 = v2819 % 1;
            bool v2825;
            v2825 = v2819 < 128;
            bool v2826;
            v2826 = v2825 == false;
            if (v2826){
                assert("The last element of the projection dimensions needs to be greater than the index remainder." && v2825);
            } else {
            }
            assert("Tensor range check" && 0 <= v2819 && v2819 < 128);
            assert("Tensor range check" && 0 <= v2824 && v2824 < 1);
            int v2828;
            v2828 = 4 * v2824;
            int v2829;
            v2829 = 2048 * v2819;
            int v2830;
            v2830 = v2829 + v2828;
            int v2831;
            v2831 = 262144 * v2824;
            int v2832;
            v2832 = 512 * v2819;
            int v2833;
            v2833 = v2832 + v2831;
            int v2834;
            v2834 = threadIdx.x;
            int v2835;
            v2835 = v2834;
            while (while_method_23(v2835)){
                bool v2837;
                v2837 = 0 <= v2835;
                bool v2838;
                v2838 = v2837 == false;
                if (v2838){
                    assert("The index needs to be zero or positive." && v2837);
                } else {
                }
                int v2840;
                v2840 = v2835 % 4;
                int v2841;
                v2841 = v2835 / 4;
                bool v2842;
                v2842 = v2841 < 512;
                bool v2843;
                v2843 = v2842 == false;
                if (v2843){
                    assert("The last element of the projection dimensions needs to be greater than the index remainder." && v2842);
                } else {
                }
                assert("Tensor range check" && 0 <= v2841 && v2841 < 512);
                assert("Tensor range check" && 0 <= v2840 && v2840 < 4);
                int v2845;
                v2845 = v2840 + v2830;
                int v2846;
                v2846 = 4 * v2841;
                int v2847;
                v2847 = v2846 + v2845;
                float v2848;
                v2848 = v382[v2847];
                assert("Tensor range check" && 0 <= v2841 && v2841 < 512);
                assert("Tensor range check" && 0 <= v2840 && v2840 < 4);
                int v2849;
                v2849 = 33 * v2841;
                int v2850;
                v2850 = v2849 + v2840;
                v2816[v2850] = v2848;
                v2835 += 256 ;
            }
            __syncthreads();
            int v2851;
            v2851 = threadIdx.x;
            int v2852;
            v2852 = v2851;
            while (while_method_23(v2852)){
                bool v2854;
                v2854 = 0 <= v2852;
                bool v2855;
                v2855 = v2854 == false;
                if (v2855){
                    assert("The index needs to be zero or positive." && v2854);
                } else {
                }
                int v2857;
                v2857 = v2852 % 512;
                int v2858;
                v2858 = v2852 / 512;
                bool v2859;
                v2859 = v2858 < 4;
                bool v2860;
                v2860 = v2859 == false;
                if (v2860){
                    assert("The last element of the projection dimensions needs to be greater than the index remainder." && v2859);
                } else {
                }
                assert("Tensor range check" && 0 <= v2858 && v2858 < 4);
                assert("Tensor range check" && 0 <= v2857 && v2857 < 512);
                int v2862;
                v2862 = 33 * v2857;
                int v2863;
                v2863 = v2858 + v2862;
                float v2864;
                v2864 = v2816[v2863];
                assert("Tensor range check" && 0 <= v2858 && v2858 < 4);
                assert("Tensor range check" && 0 <= v2857 && v2857 < 512);
                int v2865;
                v2865 = v2857 + v2833;
                int v2866;
                v2866 = 65536 * v2858;
                int v2867;
                v2867 = v2866 + v2865;
                v380[v2867] = v2864;
                v2852 += 256 ;
            }
            __syncthreads();
            v2819 += 24 ;
        }
        extern __shared__ unsigned char v2868[];
        float * v2869;
        v2869 = reinterpret_cast<float *>(&v2868[0ull]);
        int v2871;
        v2871 = blockIdx.x;
        int v2872;
        v2872 = v2871;
        while (while_method_27(v2872)){
            bool v2874;
            v2874 = 0 <= v2872;
            bool v2875;
            v2875 = v2874 == false;
            if (v2875){
                assert("The index needs to be zero or positive." && v2874);
            } else {
            }
            int v2877;
            v2877 = v2872 % 1;
            bool v2878;
            v2878 = v2872 < 128;
            bool v2879;
            v2879 = v2878 == false;
            if (v2879){
                assert("The last element of the projection dimensions needs to be greater than the index remainder." && v2878);
            } else {
            }
            assert("Tensor range check" && 0 <= v2872 && v2872 < 128);
            assert("Tensor range check" && 0 <= v2877 && v2877 < 1);
            int v2881;
            v2881 = 4 * v2877;
            int v2882;
            v2882 = 2048 * v2872;
            int v2883;
            v2883 = v2882 + v2881;
            int v2884;
            v2884 = 262144 * v2877;
            int v2885;
            v2885 = 512 * v2872;
            int v2886;
            v2886 = v2885 + v2884;
            int v2887;
            v2887 = threadIdx.x;
            int v2888;
            v2888 = v2887;
            while (while_method_23(v2888)){
                bool v2890;
                v2890 = 0 <= v2888;
                bool v2891;
                v2891 = v2890 == false;
                if (v2891){
                    assert("The index needs to be zero or positive." && v2890);
                } else {
                }
                int v2893;
                v2893 = v2888 % 4;
                int v2894;
                v2894 = v2888 / 4;
                bool v2895;
                v2895 = v2894 < 512;
                bool v2896;
                v2896 = v2895 == false;
                if (v2896){
                    assert("The last element of the projection dimensions needs to be greater than the index remainder." && v2895);
                } else {
                }
                assert("Tensor range check" && 0 <= v2894 && v2894 < 512);
                assert("Tensor range check" && 0 <= v2893 && v2893 < 4);
                int v2898;
                v2898 = v2893 + v2883;
                int v2899;
                v2899 = 4 * v2894;
                int v2900;
                v2900 = v2899 + v2898;
                float v2901;
                v2901 = v386[v2900];
                assert("Tensor range check" && 0 <= v2894 && v2894 < 512);
                assert("Tensor range check" && 0 <= v2893 && v2893 < 4);
                int v2902;
                v2902 = 33 * v2894;
                int v2903;
                v2903 = v2902 + v2893;
                v2869[v2903] = v2901;
                v2888 += 256 ;
            }
            __syncthreads();
            int v2904;
            v2904 = threadIdx.x;
            int v2905;
            v2905 = v2904;
            while (while_method_23(v2905)){
                bool v2907;
                v2907 = 0 <= v2905;
                bool v2908;
                v2908 = v2907 == false;
                if (v2908){
                    assert("The index needs to be zero or positive." && v2907);
                } else {
                }
                int v2910;
                v2910 = v2905 % 512;
                int v2911;
                v2911 = v2905 / 512;
                bool v2912;
                v2912 = v2911 < 4;
                bool v2913;
                v2913 = v2912 == false;
                if (v2913){
                    assert("The last element of the projection dimensions needs to be greater than the index remainder." && v2912);
                } else {
                }
                assert("Tensor range check" && 0 <= v2911 && v2911 < 4);
                assert("Tensor range check" && 0 <= v2910 && v2910 < 512);
                int v2915;
                v2915 = 33 * v2910;
                int v2916;
                v2916 = v2911 + v2915;
                float v2917;
                v2917 = v2869[v2916];
                assert("Tensor range check" && 0 <= v2911 && v2911 < 4);
                assert("Tensor range check" && 0 <= v2910 && v2910 < 512);
                int v2918;
                v2918 = v2910 + v2886;
                int v2919;
                v2919 = 65536 * v2911;
                int v2920;
                v2920 = v2919 + v2918;
                v384[v2920] = v2917;
                v2905 += 256 ;
            }
            __syncthreads();
            v2872 += 24 ;
        }
        extern __shared__ unsigned char v2921[];
        float * v2922;
        v2922 = reinterpret_cast<float *>(&v2921[0ull]);
        int v2924;
        v2924 = blockIdx.x;
        int v2925;
        v2925 = v2924;
        while (while_method_24(v2925)){
            bool v2927;
            v2927 = 0 <= v2925;
            bool v2928;
            v2928 = v2927 == false;
            if (v2928){
                assert("The index needs to be zero or positive." && v2927);
            } else {
            }
            int v2930;
            v2930 = v2925 % 1;
            bool v2931;
            v2931 = v2925 < 32;
            bool v2932;
            v2932 = v2931 == false;
            if (v2932){
                assert("The last element of the projection dimensions needs to be greater than the index remainder." && v2931);
            } else {
            }
            assert("Tensor range check" && 0 <= v2925 && v2925 < 32);
            assert("Tensor range check" && 0 <= v2930 && v2930 < 1);
            int v2934;
            v2934 = 4 * v2930;
            int v2935;
            v2935 = 2048 * v2925;
            int v2936;
            v2936 = v2935 + v2934;
            int v2937;
            v2937 = 65536 * v2930;
            int v2938;
            v2938 = 512 * v2925;
            int v2939;
            v2939 = v2938 + v2937;
            int v2940;
            v2940 = threadIdx.x;
            int v2941;
            v2941 = v2940;
            while (while_method_23(v2941)){
                bool v2943;
                v2943 = 0 <= v2941;
                bool v2944;
                v2944 = v2943 == false;
                if (v2944){
                    assert("The index needs to be zero or positive." && v2943);
                } else {
                }
                int v2946;
                v2946 = v2941 % 4;
                int v2947;
                v2947 = v2941 / 4;
                bool v2948;
                v2948 = v2947 < 512;
                bool v2949;
                v2949 = v2948 == false;
                if (v2949){
                    assert("The last element of the projection dimensions needs to be greater than the index remainder." && v2948);
                } else {
                }
                assert("Tensor range check" && 0 <= v2947 && v2947 < 512);
                assert("Tensor range check" && 0 <= v2946 && v2946 < 4);
                int v2951;
                v2951 = v2946 + v2936;
                int v2952;
                v2952 = 4 * v2947;
                int v2953;
                v2953 = v2952 + v2951;
                float v2954;
                v2954 = v390[v2953];
                assert("Tensor range check" && 0 <= v2947 && v2947 < 512);
                assert("Tensor range check" && 0 <= v2946 && v2946 < 4);
                int v2955;
                v2955 = 33 * v2947;
                int v2956;
                v2956 = v2955 + v2946;
                v2922[v2956] = v2954;
                v2941 += 256 ;
            }
            __syncthreads();
            int v2957;
            v2957 = threadIdx.x;
            int v2958;
            v2958 = v2957;
            while (while_method_23(v2958)){
                bool v2960;
                v2960 = 0 <= v2958;
                bool v2961;
                v2961 = v2960 == false;
                if (v2961){
                    assert("The index needs to be zero or positive." && v2960);
                } else {
                }
                int v2963;
                v2963 = v2958 % 512;
                int v2964;
                v2964 = v2958 / 512;
                bool v2965;
                v2965 = v2964 < 4;
                bool v2966;
                v2966 = v2965 == false;
                if (v2966){
                    assert("The last element of the projection dimensions needs to be greater than the index remainder." && v2965);
                } else {
                }
                assert("Tensor range check" && 0 <= v2964 && v2964 < 4);
                assert("Tensor range check" && 0 <= v2963 && v2963 < 512);
                int v2968;
                v2968 = 33 * v2963;
                int v2969;
                v2969 = v2964 + v2968;
                float v2970;
                v2970 = v2922[v2969];
                assert("Tensor range check" && 0 <= v2964 && v2964 < 4);
                assert("Tensor range check" && 0 <= v2963 && v2963 < 512);
                int v2971;
                v2971 = v2963 + v2939;
                int v2972;
                v2972 = 16384 * v2964;
                int v2973;
                v2973 = v2972 + v2971;
                v388[v2973] = v2970;
                v2958 += 256 ;
            }
            __syncthreads();
            v2925 += 24 ;
        }
        v365.sync() ;
        v27 += 1 ;
    }
    cooperative_groups::grid_group & v2974 = v26.v1;
    cooperative_groups::grid_group & v2975 = v2974;
    int v2976;
    v2976 = threadIdx.x;
    int v2977;
    v2977 = blockIdx.x;
    int v2978;
    v2978 = v2977 * 256;
    int v2979;
    v2979 = v2976 + v2978;
    int v2980;
    v2980 = v2979;
    while (while_method_23(v2980)){
        bool v2982;
        v2982 = 0 <= v2980;
        bool v2983;
        v2983 = v2982 == false;
        if (v2983){
            assert("The index needs to be zero or positive." && v2982);
        } else {
        }
        int v2985;
        v2985 = v2980 % 512;
        int v2986;
        v2986 = v2980 / 512;
        bool v2987;
        v2987 = v2986 < 4;
        bool v2988;
        v2988 = v2987 == false;
        if (v2988){
            assert("The last element of the projection dimensions needs to be greater than the index remainder." && v2987);
        } else {
        }
        assert("Tensor range check" && 0 <= v2986 && v2986 < 4);
        assert("Tensor range check" && 0 <= v2985 && v2985 < 512);
        int v2990;
        v2990 = 4 * v2985;
        int v2991;
        v2991 = 2048 * v2986;
        int v2992;
        v2992 = v2991 + v2990;
        assert("Tensor range check" && 0 <= v2986 && v2986 < 4);
        assert("Tensor range check" && 0 <= v2985 && v2985 < 512);
        float v2993[4];
        float v2994[4];
        float v2995[4];
        int4* v2996;
        v2996 = reinterpret_cast<int4*>(v3 + v2992);
        int4* v2997;
        v2997 = reinterpret_cast<int4*>(v2993 + 0);
        assert("Pointer alignment check" && reinterpret_cast<unsigned long long>(v2996) % 16 == 0 && reinterpret_cast<unsigned long long>(v2997) % 16 == 0);
        *v2997 = *v2996;
        int4* v2998;
        v2998 = reinterpret_cast<int4*>(v4 + v2992);
        int4* v2999;
        v2999 = reinterpret_cast<int4*>(v2994 + 0);
        assert("Pointer alignment check" && reinterpret_cast<unsigned long long>(v2998) % 16 == 0 && reinterpret_cast<unsigned long long>(v2999) % 16 == 0);
        *v2999 = *v2998;
        // Pushing the loop unrolling to: 0
        int v3000;
        v3000 = 0;
        #pragma unroll
        while (while_method_3(v3000)){
            assert("Tensor range check" && 0 <= v3000 && v3000 < 4);
            float v3002;
            v3002 = v2993[v3000];
            float v3003;
            v3003 = v2994[v3000];
            bool v3004;
            v3004 = v3003 == 0.0f;
            bool v3005;
            v3005 = v3004 != true;
            float v3007;
            if (v3005){
                float v3006;
                v3006 = v3002 / v3003;
                v3007 = v3006;
            } else {
                v3007 = 0.0f;
            }
            assert("Tensor range check" && 0 <= v3000 && v3000 < 4);
            v2995[v3000] = v3007;
            v3000 += 1 ;
        }
        // Poping the loop unrolling to: 0
        int4* v3008;
        v3008 = reinterpret_cast<int4*>(v2995 + 0);
        int4* v3009;
        v3009 = reinterpret_cast<int4*>(v5 + v2992);
        assert("Pointer alignment check" && reinterpret_cast<unsigned long long>(v3008) % 16 == 0 && reinterpret_cast<unsigned long long>(v3009) % 16 == 0);
        *v3009 = *v3008;
        v2980 += 6144 ;
    }
    v2975.sync() ;
    return ;
}
extern "C" __global__ void entry2(unsigned char * v0, unsigned char * v1, unsigned char * v2, float * v3, float * v4, float * v5) {
    auto v6 = cooperative_groups::this_grid();
    unsigned long long v7;
    v7 = clock64();
    int v8;
    v8 = threadIdx.x;
    int v9;
    v9 = blockIdx.x;
    int v10;
    v10 = v9 * 256;
    int v11;
    v11 = v8 + v10;
    unsigned long long v12;
    v12 = (unsigned long long)v11;
    curandStatePhilox4_32_10_t v13;
    curand_init(v7,v12,0ull,&v13);
    static_array<Union2,2> v14;
    Union2 v16;
    v16 = Union2{Union2_3{}};
    v14[0] = v16;
    Union2 v18;
    v18 = Union2{Union2_3{}};
    v14[1] = v18;
    static_array_list<Union6,128> v20;
    v20 = static_array_list<Union6,128>{};
    static_array<float,2> v22;
    v22[0] = 0.0f;
    v22[1] = 0.0f;
    cooperative_groups::grid_group & v24 = v6;
    curandStatePhilox4_32_10_t & v25 = v13;
    StackMut1 v26{4503599627370495ull, v24, v20, v14, v22, v25};
    int v27;
    v27 = 0;
    while (while_method_23(v27)){
        int v29;
        v29 = 0;
        while (while_method_24(v29)){
            Union4 v31;
            v31 = Union4{Union4_2{}};
            method_86(v0, v1, v2, v26, v31);
            static_array<float,2> & v32 = v26.v4;
            float * v33;
            v33 = reinterpret_cast<float *>(&v1[114819072ull]);
            int * v35;
            v35 = reinterpret_cast<int *>(&v0[12845056ull]);
            bool * v37;
            v37 = reinterpret_cast<bool *>(&v0[12845072ull]);
            float * v39;
            v39 = reinterpret_cast<float *>(&v0[12845088ull]);
            float * v41;
            v41 = reinterpret_cast<float *>(&v0[12845104ull]);
            double * v43;
            v43 = reinterpret_cast<double *>(&v1[121110528ull]);
            double * v45;
            v45 = reinterpret_cast<double *>(&v1[121503744ull]);
            int v47;
            v47 = threadIdx.x;
            int v48;
            v48 = blockIdx.x;
            int v49;
            v49 = v48 * 256;
            int v50;
            v50 = v47 + v49;
            assert("Tensor range check" && 0 <= v50 && v50 < 6144);
            int v51;
            v51 = 2 * v50;
            double * v52;
            v52 = v43+v51;
            double * v54;
            v54 = v45+v51;
            float v56[2];
            int v57;
            v57 = 0;
            while (while_method_0(v57)){
                bool v59;
                v59 = 0 <= v57;
                bool v61;
                if (v59){
                    bool v60;
                    v60 = v57 < 2;
                    v61 = v60;
                } else {
                    v61 = false;
                }
                bool v62;
                v62 = v61 == false;
                if (v62){
                    assert("Index must be in range." && v61);
                } else {
                }
                float v64;
                v64 = v32[v57];
                assert("Tensor range check" && 0 <= v57 && v57 < 2);
                v56[v57] = v64;
                v57 += 1 ;
            }
            double v66[2];
            int v67;
            v67 = 0;
            while (while_method_0(v67)){
                int v69; double v70;
                Tuple23 tmp138 = Tuple23{0, 0.0};
                v69 = tmp138.v0; v70 = tmp138.v1;
                while (while_method_3(v69)){
                    assert("Tensor range check" && 0 <= v69 && v69 < 4);
                    bool v72;
                    v72 = v37[v69];
                    bool v73;
                    v73 = v72 == false;
                    double v80;
                    if (v73){
                        v80 = 0.0;
                    } else {
                        assert("Tensor range check" && 0 <= v69 && v69 < 4);
                        assert("Tensor range check" && 0 <= v67 && v67 < 2);
                        int v74;
                        v74 = 12288 * v69;
                        int v75;
                        v75 = v74 + v67;
                        double v76;
                        v76 = v52[v75];
                        double v77;
                        v77 = v54[v75];
                        double v78;
                        v78 = v76 - v77;
                        double v79;
                        v79 = exp(v78);
                        v80 = v79;
                    }
                    double v81;
                    v81 = v70 + v80;
                    v70 = v81;
                    v69 += 1 ;
                }
                assert("Tensor range check" && 0 <= v67 && v67 < 2);
                v66[v67] = v70;
                v67 += 1 ;
            }
            double v82;
            v82 = 1.0;
            int v83;
            v83 = 0;
            while (while_method_0(v83)){
                assert("Tensor range check" && 0 <= v83 && v83 < 2);
                double v85;
                v85 = v66[v83];
                double v86;
                v86 = v82 * v85;
                v82 = v86;
                v83 += 1 ;
            }
            double v87[8];
            int v88;
            v88 = 0;
            while (while_method_3(v88)){
                int v90;
                v90 = 0;
                while (while_method_0(v90)){
                    bool v92;
                    v92 = v82 == 0.0;
                    bool v93;
                    v93 = v92 != true;
                    double v103;
                    if (v93){
                        assert("Tensor range check" && 0 <= v90 && v90 < 2);
                        double v94;
                        v94 = v66[v90];
                        double v95;
                        v95 = v82 / v94;
                        assert("Tensor range check" && 0 <= v88 && v88 < 4);
                        assert("Tensor range check" && 0 <= v90 && v90 < 2);
                        int v96;
                        v96 = 12288 * v88;
                        int v97;
                        v97 = v96 + v90;
                        double v98;
                        v98 = v52[v97];
                        double v99;
                        v99 = v54[v97];
                        double v100;
                        v100 = v98 - v99;
                        double v101;
                        v101 = exp(v100);
                        double v102;
                        v102 = v95 * v101;
                        v103 = v102;
                    } else {
                        v103 = 0.0;
                    }
                    bool v104;
                    v104 = isnan(v103);
                    bool v105;
                    v105 = v104 == false;
                    bool v106;
                    v106 = v105 == false;
                    if (v106){
                        assert("The path probability after integration should not be a nan in integrate_rewards_." && v105);
                    } else {
                    }
                    assert("Tensor range check" && 0 <= v88 && v88 < 4);
                    assert("Tensor range check" && 0 <= v90 && v90 < 2);
                    int v108;
                    v108 = 2 * v88;
                    int v109;
                    v109 = v108 + v90;
                    v87[v109] = v103;
                    v90 += 1 ;
                }
                v88 += 1 ;
            }
            float v110[4];
            float v111[4];
            int v112;
            v112 = 0;
            while (while_method_3(v112)){
                int v114; float v115; double v116;
                Tuple24 tmp139 = Tuple24{0, 0.0f, 0.0};
                v114 = tmp139.v0; v115 = tmp139.v1; v116 = tmp139.v2;
                while (while_method_0(v114)){
                    assert("Tensor range check" && 0 <= v112 && v112 < 4);
                    assert("Tensor range check" && 0 <= v114 && v114 < 2);
                    int v118;
                    v118 = 2 * v112;
                    int v119;
                    v119 = v118 + v114;
                    double v120;
                    v120 = v87[v119];
                    assert("Tensor range check" && 0 <= v114 && v114 < 2);
                    float v121;
                    v121 = v56[v114];
                    float v122;
                    v122 = (float)v120;
                    float v123;
                    v123 = v122 * v121;
                    float v124;
                    v124 = v115 + v123;
                    double v125;
                    v125 = v116 + v120;
                    v115 = v124;
                    v116 = v125;
                    v114 += 1 ;
                }
                float v126;
                v126 = (float)v116;
                assert("Tensor range check" && 0 <= v112 && v112 < 4);
                v110[v112] = v115;
                v111[v112] = v126;
                v112 += 1 ;
            }
            int v127;
            v127 = 0;
            while (while_method_3(v127)){
                assert("Tensor range check" && 0 <= v127 && v127 < 4);
                float v129;
                v129 = v110[v127];
                float v130;
                v130 = v111[v127];
                bool v131;
                v131 = isnan(v130);
                bool v132;
                v132 = v131 == false;
                bool v133;
                v133 = v132 == false;
                if (v133){
                    assert("The path probability after integration should not be a nan in calculate updates." && v132);
                } else {
                }
                float v135;
                v135 = v129 * v130;
                assert("Tensor range check" && 0 <= v127 && v127 < 4);
                float * v136;
                v136 = v39+v127;
                float * v138;
                v138 = v41+v127;
                float v140;
                v140 = atomicAdd(v136,v135);
                float v141;
                v141 = atomicAdd(v138,v130);
                v127 += 1 ;
            }
            int v142;
            v142 = threadIdx.x;
            int v143;
            v143 = blockIdx.x;
            int v144;
            v144 = v143 * 256;
            int v145;
            v145 = v142 + v144;
            int v146;
            v146 = 0;
            while (while_method_3(v146)){
                assert("Tensor range check" && 0 <= v146 && v146 < 4);
                int v148;
                v148 = 12288 * v146;
                assert("Tensor range check" && 0 <= v145 && v145 < 6144);
                int v149;
                v149 = 2 * v145;
                int v150;
                v150 = v149 + v148;
                double * v151;
                v151 = v43+v150;
                double * v153;
                v153 = v45+v150;
                double * v155;
                v155 = v43+v150;
                double * v157;
                v157 = v45+v150;
                int v159;
                v159 = sizeof(double *);
                unsigned long long v160;
                v160 = (unsigned long long)v159;
                unsigned long long v161;
                v161 = 256ull * v160;
                unsigned long long v162;
                v162 = v161 + 16ull;
                unsigned long long v163;
                v163 = v162 - 1ull;
                unsigned long long v164;
                v164 = v163 % 16ull;
                unsigned long long v165;
                v165 = v163 - v164;
                unsigned long long v166;
                v166 = v165 + v161;
                unsigned long long v167;
                v167 = v166 + 16ull;
                unsigned long long v168;
                v168 = v167 - 1ull;
                unsigned long long v169;
                v169 = v168 % 16ull;
                unsigned long long v170;
                v170 = v168 - v169;
                unsigned long long v171;
                v171 = v170 + v161;
                unsigned long long v172;
                v172 = v171 + 16ull;
                unsigned long long v173;
                v173 = v172 - 1ull;
                unsigned long long v174;
                v174 = v173 % 16ull;
                unsigned long long v175;
                v175 = v173 - v174;
                unsigned long long v176;
                v176 = v175 + v161;
                bool v177;
                v177 = v176 <= 98304ull;
                bool v178;
                v178 = v177 == false;
                if (v178){
                    assert("The dynamic shared memory is insufficient to allocate the tensor." && v177);
                } else {
                }
                extern __shared__ unsigned char v180[];
                bool v181;
                v181 = v176 <= v176;
                bool v182;
                v182 = v181 == false;
                if (v182){
                    assert("The length of the partition has to be less than or equal to the length of the base array." && v181);
                } else {
                }
                double * * v184;
                v184 = reinterpret_cast<double * *>(&v180[0ull]);
                double * * v186;
                v186 = reinterpret_cast<double * *>(&v180[v165]);
                double * * v188;
                v188 = reinterpret_cast<double * *>(&v180[v170]);
                double * * v190;
                v190 = reinterpret_cast<double * *>(&v180[v175]);
                int v192;
                v192 = threadIdx.x;
                assert("Tensor range check" && 0 <= v192 && v192 < 256);
                v184[v192] = v151;
                v186[v192] = v153;
                v188[v192] = v155;
                v190[v192] = v157;
                __syncthreads();
                bool v193;
                v193 = 0 <= v192;
                bool v194;
                v194 = v193 == false;
                if (v194){
                    assert("The index needs to be zero or positive." && v193);
                } else {
                }
                int v196;
                v196 = v192 % 1;
                bool v197;
                v197 = v192 < 256;
                bool v198;
                v198 = v197 == false;
                if (v198){
                    assert("The last element of the projection dimensions needs to be greater than the index remainder." && v197);
                } else {
                }
                assert("Tensor range check" && 0 <= v192 && v192 < 256);
                int v200;
                v200 = 0;
                while (while_method_6(v200)){
                    bool v202;
                    v202 = v193 && v197;
                    bool v203;
                    v203 = v202 == false;
                    if (v203){
                        assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v202);
                    } else {
                    }
                    bool v205;
                    v205 = 0 <= v200;
                    bool v207;
                    if (v205){
                        bool v206;
                        v206 = v200 < 1;
                        v207 = v206;
                    } else {
                        v207 = false;
                    }
                    bool v208;
                    v208 = v207 == false;
                    if (v208){
                        assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v207);
                    } else {
                    }
                    int v210;
                    v210 = v200 * 256;
                    int v211;
                    v211 = v210 + v192;
                    assert("Tensor range check" && 0 <= v200 && v200 < 1);
                    int v212;
                    v212 = 256 * v200;
                    int v213;
                    v213 = v212 + v192;
                    double * v214;
                    v214 = v184[v213];
                    double * v215;
                    v215 = v186[v213];
                    double * v216;
                    v216 = v188[v213];
                    double * v217;
                    v217 = v190[v213];
                    int v218;
                    v218 = blockIdx.x;
                    int v219;
                    v219 = v218 * 256;
                    int v220;
                    v220 = v219 + v211;
                    assert("Tensor range check" && 0 <= v196 && v196 < 1);
                    int v221;
                    v221 = 2 * v196;
                    double v222[2];
                    double v223[2];
                    int v224[2];
                    int v225;
                    v225 = 0;
                    while (while_method_6(v225)){
                        assert("Tensor range check" && 0 <= v225 && v225 < 1);
                        int v227;
                        v227 = 2 * v225;
                        assert("Tensor range check" && 0 <= v225 && v225 < 1);
                        int v228;
                        v228 = v227 + v221;
                        int4* v229;
                        v229 = reinterpret_cast<int4*>(v214 + v228);
                        int4* v230;
                        v230 = reinterpret_cast<int4*>(v222 + v227);
                        assert("Pointer alignment check" && reinterpret_cast<unsigned long long>(v229) % 16 == 0 && reinterpret_cast<unsigned long long>(v230) % 16 == 0);
                        *v230 = *v229;
                        int4* v231;
                        v231 = reinterpret_cast<int4*>(v215 + v228);
                        int4* v232;
                        v232 = reinterpret_cast<int4*>(v223 + v227);
                        assert("Pointer alignment check" && reinterpret_cast<unsigned long long>(v231) % 16 == 0 && reinterpret_cast<unsigned long long>(v232) % 16 == 0);
                        *v232 = *v231;
                        v225 += 1 ;
                    }
                    int v233;
                    v233 = 0;
                    while (while_method_6(v233)){
                        int v235;
                        v235 = 0;
                        while (while_method_0(v235)){
                            bool v237;
                            v237 = 0 <= v235;
                            bool v239;
                            if (v237){
                                bool v238;
                                v238 = v235 < 2;
                                v239 = v238;
                            } else {
                                v239 = false;
                            }
                            bool v240;
                            v240 = v239 == false;
                            if (v240){
                                assert("The indices should be inside the range of the dimension." && v239);
                            } else {
                            }
                            bool v242;
                            v242 = 0 <= v196;
                            bool v244;
                            if (v242){
                                bool v243;
                                v243 = v196 < 1;
                                v244 = v243;
                            } else {
                                v244 = false;
                            }
                            bool v245;
                            v245 = v244 == false;
                            if (v245){
                                assert("The indices should be inside the range of the dimension." && v244);
                            } else {
                            }
                            int v247;
                            v247 = v196 * 2;
                            int v248;
                            v248 = v235 + v247;
                            bool v249;
                            v249 = 0 <= v233;
                            bool v251;
                            if (v249){
                                bool v250;
                                v250 = v233 < 1;
                                v251 = v250;
                            } else {
                                v251 = false;
                            }
                            bool v252;
                            v252 = v251 == false;
                            if (v252){
                                assert("The indices should be inside the range of the dimension." && v251);
                            } else {
                            }
                            int v254;
                            v254 = v233 * 2;
                            int v255;
                            v255 = v248 + v254;
                            assert("Tensor range check" && 0 <= v233 && v233 < 1);
                            assert("Tensor range check" && 0 <= v235 && v235 < 2);
                            int v256;
                            v256 = 2 * v233;
                            int v257;
                            v257 = v256 + v235;
                            v224[v257] = v255;
                            v235 += 1 ;
                        }
                        v233 += 1 ;
                    }
                    double v258[2];
                    double v259[2];
                    int v260;
                    v260 = 0;
                    while (while_method_6(v260)){
                        int v262;
                        v262 = 0;
                        while (while_method_0(v262)){
                            assert("Tensor range check" && 0 <= v260 && v260 < 1);
                            assert("Tensor range check" && 0 <= v262 && v262 < 2);
                            int v264;
                            v264 = 2 * v260;
                            int v265;
                            v265 = v264 + v262;
                            double v266;
                            v266 = v222[v265];
                            double v267;
                            v267 = v223[v265];
                            assert("Tensor range check" && 0 <= v260 && v260 < 1);
                            assert("Tensor range check" && 0 <= v262 && v262 < 2);
                            v258[v265] = 0.0;
                            v259[v265] = 0.0;
                            v262 += 1 ;
                        }
                        v260 += 1 ;
                    }
                    int v268;
                    v268 = 0;
                    while (while_method_6(v268)){
                        assert("Tensor range check" && 0 <= v268 && v268 < 1);
                        int v270;
                        v270 = 2 * v268;
                        int v271;
                        v271 = v270 + v221;
                        assert("Tensor range check" && 0 <= v268 && v268 < 1);
                        int4* v272;
                        v272 = reinterpret_cast<int4*>(v258 + v270);
                        int4* v273;
                        v273 = reinterpret_cast<int4*>(v216 + v271);
                        assert("Pointer alignment check" && reinterpret_cast<unsigned long long>(v272) % 16 == 0 && reinterpret_cast<unsigned long long>(v273) % 16 == 0);
                        *v273 = *v272;
                        int4* v274;
                        v274 = reinterpret_cast<int4*>(v259 + v270);
                        int4* v275;
                        v275 = reinterpret_cast<int4*>(v217 + v271);
                        assert("Pointer alignment check" && reinterpret_cast<unsigned long long>(v274) % 16 == 0 && reinterpret_cast<unsigned long long>(v275) % 16 == 0);
                        *v275 = *v274;
                        v268 += 1 ;
                    }
                    assert("Tensor range check" && 0 <= v211 && v211 < 256);
                    v200 += 1 ;
                }
                __syncthreads();
                assert("Tensor range check" && 0 <= v192 && v192 < 256);
                __syncthreads();
                v146 += 1 ;
            }
            Union4 v276;
            v276 = Union4{Union4_2{}};
            method_87(v0, v1, v2, v26, v276);
            double * v277;
            v277 = reinterpret_cast<double *>(&v1[121110528ull]);
            double * v279;
            v279 = reinterpret_cast<double *>(&v1[121503744ull]);
            int v281;
            v281 = threadIdx.x;
            int v282;
            v282 = blockIdx.x;
            int v283;
            v283 = v282 * 256;
            int v284;
            v284 = v281 + v283;
            assert("Tensor range check" && 0 <= v284 && v284 < 6144);
            int v285;
            v285 = 2 * v284;
            static_array<float,2> & v286 = v26.v4;
            float v287[2];
            int v288;
            v288 = 0;
            while (while_method_0(v288)){
                bool v290;
                v290 = 0 <= v288;
                bool v292;
                if (v290){
                    bool v291;
                    v291 = v288 < 2;
                    v292 = v291;
                } else {
                    v292 = false;
                }
                bool v293;
                v293 = v292 == false;
                if (v293){
                    assert("Index must be in range." && v292);
                } else {
                }
                float v295;
                v295 = v286[v288];
                assert("Tensor range check" && 0 <= v288 && v288 < 2);
                v287[v288] = v295;
                v288 += 1 ;
            }
            int * v297;
            v297 = reinterpret_cast<int *>(&v0[12845056ull]);
            bool * v299;
            v299 = reinterpret_cast<bool *>(&v0[12845072ull]);
            float * v301;
            v301 = reinterpret_cast<float *>(&v0[12845088ull]);
            float * v303;
            v303 = reinterpret_cast<float *>(&v0[12845104ull]);
            double v305[2];
            int v306;
            v306 = 0;
            while (while_method_0(v306)){
                int v308; double v309;
                Tuple23 tmp163 = Tuple23{0, 0.0};
                v308 = tmp163.v0; v309 = tmp163.v1;
                while (while_method_3(v308)){
                    assert("Tensor range check" && 0 <= v308 && v308 < 4);
                    bool v311;
                    v311 = v299[v308];
                    bool v312;
                    v312 = v311 == false;
                    double v320;
                    if (v312){
                        v320 = 0.0;
                    } else {
                        assert("Tensor range check" && 0 <= v308 && v308 < 4);
                        assert("Tensor range check" && 0 <= v306 && v306 < 2);
                        int v313;
                        v313 = v306 + v285;
                        int v314;
                        v314 = 12288 * v308;
                        int v315;
                        v315 = v314 + v313;
                        double v316;
                        v316 = v277[v315];
                        double v317;
                        v317 = v279[v315];
                        double v318;
                        v318 = v316 - v317;
                        double v319;
                        v319 = exp(v318);
                        v320 = v319;
                    }
                    double v321;
                    v321 = v309 + v320;
                    v309 = v321;
                    v308 += 1 ;
                }
                assert("Tensor range check" && 0 <= v306 && v306 < 2);
                v305[v306] = v309;
                v306 += 1 ;
            }
            double v322;
            v322 = 1.0;
            int v323;
            v323 = 0;
            while (while_method_0(v323)){
                assert("Tensor range check" && 0 <= v323 && v323 < 2);
                double v325;
                v325 = v305[v323];
                double v326;
                v326 = v322 * v325;
                v322 = v326;
                v323 += 1 ;
            }
            double v327[8];
            int v328;
            v328 = 0;
            while (while_method_3(v328)){
                int v330;
                v330 = 0;
                while (while_method_0(v330)){
                    bool v332;
                    v332 = v322 == 0.0;
                    bool v333;
                    v333 = v332 != true;
                    double v344;
                    if (v333){
                        assert("Tensor range check" && 0 <= v330 && v330 < 2);
                        double v334;
                        v334 = v305[v330];
                        double v335;
                        v335 = v322 / v334;
                        assert("Tensor range check" && 0 <= v328 && v328 < 4);
                        assert("Tensor range check" && 0 <= v330 && v330 < 2);
                        int v336;
                        v336 = v330 + v285;
                        int v337;
                        v337 = 12288 * v328;
                        int v338;
                        v338 = v337 + v336;
                        double v339;
                        v339 = v277[v338];
                        double v340;
                        v340 = v279[v338];
                        double v341;
                        v341 = v339 - v340;
                        double v342;
                        v342 = exp(v341);
                        double v343;
                        v343 = v335 * v342;
                        v344 = v343;
                    } else {
                        v344 = 0.0;
                    }
                    bool v345;
                    v345 = isnan(v344);
                    bool v346;
                    v346 = v345 == false;
                    bool v347;
                    v347 = v346 == false;
                    if (v347){
                        assert("The path probability after integration should not be a nan in integrate_rewards_." && v346);
                    } else {
                    }
                    assert("Tensor range check" && 0 <= v328 && v328 < 4);
                    assert("Tensor range check" && 0 <= v330 && v330 < 2);
                    int v349;
                    v349 = 2 * v328;
                    int v350;
                    v350 = v349 + v330;
                    v327[v350] = v344;
                    v330 += 1 ;
                }
                v328 += 1 ;
            }
            float v351[4];
            float v352[4];
            int v353;
            v353 = 0;
            while (while_method_3(v353)){
                int v355; float v356; double v357;
                Tuple24 tmp164 = Tuple24{0, 0.0f, 0.0};
                v355 = tmp164.v0; v356 = tmp164.v1; v357 = tmp164.v2;
                while (while_method_0(v355)){
                    assert("Tensor range check" && 0 <= v353 && v353 < 4);
                    assert("Tensor range check" && 0 <= v355 && v355 < 2);
                    int v359;
                    v359 = 2 * v353;
                    int v360;
                    v360 = v359 + v355;
                    double v361;
                    v361 = v327[v360];
                    assert("Tensor range check" && 0 <= v355 && v355 < 2);
                    float v362;
                    v362 = v287[v355];
                    float v363;
                    v363 = (float)v361;
                    float v364;
                    v364 = v363 * v362;
                    float v365;
                    v365 = v356 + v364;
                    double v366;
                    v366 = v357 + v361;
                    v356 = v365;
                    v357 = v366;
                    v355 += 1 ;
                }
                float v367;
                v367 = (float)v357;
                assert("Tensor range check" && 0 <= v353 && v353 < 4);
                v351[v353] = v356;
                v352[v353] = v367;
                v353 += 1 ;
            }
            int v368;
            v368 = 0;
            while (while_method_3(v368)){
                assert("Tensor range check" && 0 <= v368 && v368 < 4);
                float v370;
                v370 = v351[v368];
                float v371;
                v371 = v352[v368];
                assert("Tensor range check" && 0 <= v368 && v368 < 4);
                assert("Tensor range check" && 0 <= v27 && v27 < 2048);
                int v372;
                v372 = 2048 * v368;
                int v373;
                v373 = v372 + v27;
                float * v374;
                v374 = v3+v373;
                float * v376;
                v376 = v4+v373;
                float v378;
                v378 = atomicAdd(v374,v370);
                float v379;
                v379 = atomicAdd(v376,v371);
                v368 += 1 ;
            }
            double * v380;
            v380 = reinterpret_cast<double *>(&v1[121110528ull]);
            double * v382;
            v382 = reinterpret_cast<double *>(&v1[121503744ull]);
            int v384;
            v384 = threadIdx.x;
            int v385;
            v385 = blockIdx.x;
            int v386;
            v386 = v385 * 256;
            int v387;
            v387 = v384 + v386;
            int v388;
            v388 = 0;
            while (while_method_3(v388)){
                assert("Tensor range check" && 0 <= v388 && v388 < 4);
                int v390;
                v390 = 12288 * v388;
                assert("Tensor range check" && 0 <= v387 && v387 < 6144);
                int v391;
                v391 = 2 * v387;
                int v392;
                v392 = v391 + v390;
                double * v393;
                v393 = v380+v392;
                double * v395;
                v395 = v382+v392;
                double * v397;
                v397 = v380+v392;
                double * v399;
                v399 = v382+v392;
                int v401;
                v401 = sizeof(double *);
                unsigned long long v402;
                v402 = (unsigned long long)v401;
                unsigned long long v403;
                v403 = 256ull * v402;
                unsigned long long v404;
                v404 = v403 + 16ull;
                unsigned long long v405;
                v405 = v404 - 1ull;
                unsigned long long v406;
                v406 = v405 % 16ull;
                unsigned long long v407;
                v407 = v405 - v406;
                unsigned long long v408;
                v408 = v407 + v403;
                unsigned long long v409;
                v409 = v408 + 16ull;
                unsigned long long v410;
                v410 = v409 - 1ull;
                unsigned long long v411;
                v411 = v410 % 16ull;
                unsigned long long v412;
                v412 = v410 - v411;
                unsigned long long v413;
                v413 = v412 + v403;
                unsigned long long v414;
                v414 = v413 + 16ull;
                unsigned long long v415;
                v415 = v414 - 1ull;
                unsigned long long v416;
                v416 = v415 % 16ull;
                unsigned long long v417;
                v417 = v415 - v416;
                unsigned long long v418;
                v418 = v417 + v403;
                bool v419;
                v419 = v418 <= 98304ull;
                bool v420;
                v420 = v419 == false;
                if (v420){
                    assert("The dynamic shared memory is insufficient to allocate the tensor." && v419);
                } else {
                }
                extern __shared__ unsigned char v422[];
                bool v423;
                v423 = v418 <= v418;
                bool v424;
                v424 = v423 == false;
                if (v424){
                    assert("The length of the partition has to be less than or equal to the length of the base array." && v423);
                } else {
                }
                double * * v426;
                v426 = reinterpret_cast<double * *>(&v422[0ull]);
                double * * v428;
                v428 = reinterpret_cast<double * *>(&v422[v407]);
                double * * v430;
                v430 = reinterpret_cast<double * *>(&v422[v412]);
                double * * v432;
                v432 = reinterpret_cast<double * *>(&v422[v417]);
                int v434;
                v434 = threadIdx.x;
                assert("Tensor range check" && 0 <= v434 && v434 < 256);
                v426[v434] = v393;
                v428[v434] = v395;
                v430[v434] = v397;
                v432[v434] = v399;
                __syncthreads();
                bool v435;
                v435 = 0 <= v434;
                bool v436;
                v436 = v435 == false;
                if (v436){
                    assert("The index needs to be zero or positive." && v435);
                } else {
                }
                int v438;
                v438 = v434 % 1;
                bool v439;
                v439 = v434 < 256;
                bool v440;
                v440 = v439 == false;
                if (v440){
                    assert("The last element of the projection dimensions needs to be greater than the index remainder." && v439);
                } else {
                }
                assert("Tensor range check" && 0 <= v434 && v434 < 256);
                int v442;
                v442 = 0;
                while (while_method_6(v442)){
                    bool v444;
                    v444 = v435 && v439;
                    bool v445;
                    v445 = v444 == false;
                    if (v445){
                        assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v444);
                    } else {
                    }
                    bool v447;
                    v447 = 0 <= v442;
                    bool v449;
                    if (v447){
                        bool v448;
                        v448 = v442 < 1;
                        v449 = v448;
                    } else {
                        v449 = false;
                    }
                    bool v450;
                    v450 = v449 == false;
                    if (v450){
                        assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v449);
                    } else {
                    }
                    int v452;
                    v452 = v442 * 256;
                    int v453;
                    v453 = v452 + v434;
                    assert("Tensor range check" && 0 <= v442 && v442 < 1);
                    int v454;
                    v454 = 256 * v442;
                    int v455;
                    v455 = v454 + v434;
                    double * v456;
                    v456 = v426[v455];
                    double * v457;
                    v457 = v428[v455];
                    double * v458;
                    v458 = v430[v455];
                    double * v459;
                    v459 = v432[v455];
                    int v460;
                    v460 = blockIdx.x;
                    int v461;
                    v461 = v460 * 256;
                    int v462;
                    v462 = v461 + v453;
                    assert("Tensor range check" && 0 <= v438 && v438 < 1);
                    int v463;
                    v463 = 2 * v438;
                    double v464[2];
                    double v465[2];
                    int v466[2];
                    int v467;
                    v467 = 0;
                    while (while_method_6(v467)){
                        assert("Tensor range check" && 0 <= v467 && v467 < 1);
                        int v469;
                        v469 = 2 * v467;
                        assert("Tensor range check" && 0 <= v467 && v467 < 1);
                        int v470;
                        v470 = v469 + v463;
                        int4* v471;
                        v471 = reinterpret_cast<int4*>(v456 + v470);
                        int4* v472;
                        v472 = reinterpret_cast<int4*>(v464 + v469);
                        assert("Pointer alignment check" && reinterpret_cast<unsigned long long>(v471) % 16 == 0 && reinterpret_cast<unsigned long long>(v472) % 16 == 0);
                        *v472 = *v471;
                        int4* v473;
                        v473 = reinterpret_cast<int4*>(v457 + v470);
                        int4* v474;
                        v474 = reinterpret_cast<int4*>(v465 + v469);
                        assert("Pointer alignment check" && reinterpret_cast<unsigned long long>(v473) % 16 == 0 && reinterpret_cast<unsigned long long>(v474) % 16 == 0);
                        *v474 = *v473;
                        v467 += 1 ;
                    }
                    int v475;
                    v475 = 0;
                    while (while_method_6(v475)){
                        int v477;
                        v477 = 0;
                        while (while_method_0(v477)){
                            bool v479;
                            v479 = 0 <= v477;
                            bool v481;
                            if (v479){
                                bool v480;
                                v480 = v477 < 2;
                                v481 = v480;
                            } else {
                                v481 = false;
                            }
                            bool v482;
                            v482 = v481 == false;
                            if (v482){
                                assert("The indices should be inside the range of the dimension." && v481);
                            } else {
                            }
                            bool v484;
                            v484 = 0 <= v438;
                            bool v486;
                            if (v484){
                                bool v485;
                                v485 = v438 < 1;
                                v486 = v485;
                            } else {
                                v486 = false;
                            }
                            bool v487;
                            v487 = v486 == false;
                            if (v487){
                                assert("The indices should be inside the range of the dimension." && v486);
                            } else {
                            }
                            int v489;
                            v489 = v438 * 2;
                            int v490;
                            v490 = v477 + v489;
                            bool v491;
                            v491 = 0 <= v475;
                            bool v493;
                            if (v491){
                                bool v492;
                                v492 = v475 < 1;
                                v493 = v492;
                            } else {
                                v493 = false;
                            }
                            bool v494;
                            v494 = v493 == false;
                            if (v494){
                                assert("The indices should be inside the range of the dimension." && v493);
                            } else {
                            }
                            int v496;
                            v496 = v475 * 2;
                            int v497;
                            v497 = v490 + v496;
                            assert("Tensor range check" && 0 <= v475 && v475 < 1);
                            assert("Tensor range check" && 0 <= v477 && v477 < 2);
                            int v498;
                            v498 = 2 * v475;
                            int v499;
                            v499 = v498 + v477;
                            v466[v499] = v497;
                            v477 += 1 ;
                        }
                        v475 += 1 ;
                    }
                    double v500[2];
                    double v501[2];
                    int v502;
                    v502 = 0;
                    while (while_method_6(v502)){
                        int v504;
                        v504 = 0;
                        while (while_method_0(v504)){
                            assert("Tensor range check" && 0 <= v502 && v502 < 1);
                            assert("Tensor range check" && 0 <= v504 && v504 < 2);
                            int v506;
                            v506 = 2 * v502;
                            int v507;
                            v507 = v506 + v504;
                            double v508;
                            v508 = v464[v507];
                            double v509;
                            v509 = v465[v507];
                            assert("Tensor range check" && 0 <= v502 && v502 < 1);
                            assert("Tensor range check" && 0 <= v504 && v504 < 2);
                            v500[v507] = 0.0;
                            v501[v507] = 0.0;
                            v504 += 1 ;
                        }
                        v502 += 1 ;
                    }
                    int v510;
                    v510 = 0;
                    while (while_method_6(v510)){
                        assert("Tensor range check" && 0 <= v510 && v510 < 1);
                        int v512;
                        v512 = 2 * v510;
                        int v513;
                        v513 = v512 + v463;
                        assert("Tensor range check" && 0 <= v510 && v510 < 1);
                        int4* v514;
                        v514 = reinterpret_cast<int4*>(v500 + v512);
                        int4* v515;
                        v515 = reinterpret_cast<int4*>(v458 + v513);
                        assert("Pointer alignment check" && reinterpret_cast<unsigned long long>(v514) % 16 == 0 && reinterpret_cast<unsigned long long>(v515) % 16 == 0);
                        *v515 = *v514;
                        int4* v516;
                        v516 = reinterpret_cast<int4*>(v501 + v512);
                        int4* v517;
                        v517 = reinterpret_cast<int4*>(v459 + v513);
                        assert("Pointer alignment check" && reinterpret_cast<unsigned long long>(v516) % 16 == 0 && reinterpret_cast<unsigned long long>(v517) % 16 == 0);
                        *v517 = *v516;
                        v510 += 1 ;
                    }
                    assert("Tensor range check" && 0 <= v453 && v453 < 256);
                    v442 += 1 ;
                }
                __syncthreads();
                assert("Tensor range check" && 0 <= v434 && v434 < 256);
                __syncthreads();
                v388 += 1 ;
            }
            v29 += 1 ;
        }
        cooperative_groups::grid_group & v518 = v26.v1;
        cooperative_groups::grid_group & v519 = v518;
        curandStatePhilox4_32_10_t & v520 = v26.v5;
        curandStatePhilox4_32_10_t & v521 = v520;
        float * v522;
        v522 = reinterpret_cast<float *>(&v0[0ull]);
        float * v524;
        v524 = reinterpret_cast<float *>(&v2[0ull]);
        float * v526;
        v526 = reinterpret_cast<float *>(&v0[8388608ull]);
        float * v528;
        v528 = reinterpret_cast<float *>(&v2[8388608ull]);
        float * v530;
        v530 = reinterpret_cast<float *>(&v0[9437184ull]);
        float * v532;
        v532 = reinterpret_cast<float *>(&v2[9437184ull]);
        float * v534;
        v534 = reinterpret_cast<float *>(&v0[10485760ull]);
        float * v536;
        v536 = reinterpret_cast<float *>(&v2[10485760ull]);
        float * v538;
        v538 = reinterpret_cast<float *>(&v0[11534336ull]);
        float * v540;
        v540 = reinterpret_cast<float *>(&v2[11534336ull]);
        float * v542;
        v542 = reinterpret_cast<float *>(&v0[12582912ull]);
        float * v544;
        v544 = reinterpret_cast<float *>(&v2[12582912ull]);
        float * v546;
        v546 = reinterpret_cast<float *>(&v1[114819072ull]);
        int * v548;
        v548 = reinterpret_cast<int *>(&v0[12845056ull]);
        bool * v550;
        v550 = reinterpret_cast<bool *>(&v0[12845072ull]);
        float * v552;
        v552 = reinterpret_cast<float *>(&v0[12845088ull]);
        float * v554;
        v554 = reinterpret_cast<float *>(&v0[12845104ull]);
        double * v556;
        v556 = reinterpret_cast<double *>(&v1[121110528ull]);
        double * v558;
        v558 = reinterpret_cast<double *>(&v1[121503744ull]);
        v519.sync() ;
        int v560;
        v560 = threadIdx.x;
        int v561;
        v561 = blockIdx.x;
        int v562;
        v562 = v561 * 256;
        int v563;
        v563 = v560 + v562;
        bool v564;
        v564 = v563 == 0;
        if (v564){
            int v565;
            v565 = 0;
            int v566;
            v566 = 4;
            int v567;
            v567 = int_range_44(v566, v565, v521);
            v548[0] = v567;
        } else {
        }
        __syncwarp();
        float v568[4];
        int v569;
        v569 = 0;
        while (while_method_3(v569)){
            assert("Tensor range check" && 0 <= v569 && v569 < 4);
            float v571;
            v571 = v552[v569];
            float v572;
            v572 = v554[v569];
            bool v573;
            v573 = v572 == 0.0f;
            bool v574;
            v574 = v573 != true;
            float v576;
            if (v574){
                float v575;
                v575 = v571 / v572;
                v576 = v575;
            } else {
                v576 = 0.0f;
            }
            assert("Tensor range check" && 0 <= v569 && v569 < 4);
            v568[v569] = v576;
            v569 += 1 ;
        }
        float v577;
        v577 = 0.0f;
        int v578;
        v578 = 0;
        while (while_method_3(v578)){
            assert("Tensor range check" && 0 <= v578 && v578 < 4);
            float v580;
            v580 = v568[v578];
            float v581;
            v581 = v577 + v580;
            v577 = v581;
            v578 += 1 ;
        }
        float v582;
        v582 = v577 / 4.0f;
        int v583;
        v583 = 0;
        while (while_method_3(v583)){
            assert("Tensor range check" && 0 <= v583 && v583 < 4);
            v552[v583] = 0.0f;
            v554[v583] = 0.0f;
            v583 += 1 ;
        }
        bool v585[4];
        int v586;
        v586 = 0;
        while (while_method_3(v586)){
            assert("Tensor range check" && 0 <= v586 && v586 < 4);
            float v588;
            v588 = v568[v586];
            bool v589;
            v589 = v588 >= v582;
            assert("Tensor range check" && 0 <= v586 && v586 < 4);
            v585[v586] = v589;
            v586 += 1 ;
        }
        int v590;
        v590 = 0;
        while (while_method_3(v590)){
            assert("Tensor range check" && 0 <= v590 && v590 < 4);
            bool v592;
            v592 = v585[v590];
            assert("Tensor range check" && 0 <= v590 && v590 < 4);
            v550[v590] = v592;
            v590 += 1 ;
        }
        extern __shared__ unsigned char v593[];
        float * v594;
        v594 = reinterpret_cast<float *>(&v593[0ull]);
        int v596;
        v596 = blockIdx.x;
        int v597;
        v597 = v596;
        while (while_method_26(v597)){
            bool v599;
            v599 = 0 <= v597;
            bool v600;
            v600 = v599 == false;
            if (v600){
                assert("The index needs to be zero or positive." && v599);
            } else {
            }
            int v602;
            v602 = v597 % 1024;
            int v603;
            v603 = v597 / 1024;
            bool v604;
            v604 = v603 < 1;
            bool v605;
            v605 = v604 == false;
            if (v605){
                assert("The last element of the projection dimensions needs to be greater than the index remainder." && v604);
            } else {
            }
            assert("Tensor range check" && 0 <= v603 && v603 < 1);
            assert("Tensor range check" && 0 <= v602 && v602 < 1024);
            int v607;
            v607 = 512 * v602;
            int v608;
            v608 = 2097152 * v603;
            int v609;
            v609 = v608 + v607;
            int v610;
            v610 = 2048 * v602;
            int v611;
            v611 = 4 * v603;
            int v612;
            v612 = v611 + v610;
            int v613;
            v613 = threadIdx.x;
            int v614;
            v614 = v613;
            while (while_method_23(v614)){
                bool v616;
                v616 = 0 <= v614;
                bool v617;
                v617 = v616 == false;
                if (v617){
                    assert("The index needs to be zero or positive." && v616);
                } else {
                }
                int v619;
                v619 = v614 % 512;
                int v620;
                v620 = v614 / 512;
                bool v621;
                v621 = v620 < 4;
                bool v622;
                v622 = v621 == false;
                if (v622){
                    assert("The last element of the projection dimensions needs to be greater than the index remainder." && v621);
                } else {
                }
                assert("Tensor range check" && 0 <= v620 && v620 < 4);
                assert("Tensor range check" && 0 <= v619 && v619 < 512);
                int v624;
                v624 = v619 + v609;
                int v625;
                v625 = 524288 * v620;
                int v626;
                v626 = v625 + v624;
                float v627;
                v627 = v522[v626];
                assert("Tensor range check" && 0 <= v620 && v620 < 4);
                assert("Tensor range check" && 0 <= v619 && v619 < 512);
                int v628;
                v628 = 513 * v620;
                int v629;
                v629 = v628 + v619;
                v594[v629] = v627;
                v614 += 256 ;
            }
            __syncthreads();
            int v630;
            v630 = threadIdx.x;
            int v631;
            v631 = v630;
            while (while_method_23(v631)){
                bool v633;
                v633 = 0 <= v631;
                bool v634;
                v634 = v633 == false;
                if (v634){
                    assert("The index needs to be zero or positive." && v633);
                } else {
                }
                int v636;
                v636 = v631 % 4;
                int v637;
                v637 = v631 / 4;
                bool v638;
                v638 = v637 < 512;
                bool v639;
                v639 = v638 == false;
                if (v639){
                    assert("The last element of the projection dimensions needs to be greater than the index remainder." && v638);
                } else {
                }
                assert("Tensor range check" && 0 <= v637 && v637 < 512);
                assert("Tensor range check" && 0 <= v636 && v636 < 4);
                int v641;
                v641 = 513 * v636;
                int v642;
                v642 = v637 + v641;
                float v643;
                v643 = v594[v642];
                assert("Tensor range check" && 0 <= v637 && v637 < 512);
                assert("Tensor range check" && 0 <= v636 && v636 < 4);
                int v644;
                v644 = v636 + v612;
                int v645;
                v645 = 4 * v637;
                int v646;
                v646 = v645 + v644;
                v524[v646] = v643;
                v631 += 256 ;
            }
            __syncthreads();
            v597 += 24 ;
        }
        extern __shared__ unsigned char v647[];
        float * v648;
        v648 = reinterpret_cast<float *>(&v647[0ull]);
        int v650;
        v650 = blockIdx.x;
        int v651;
        v651 = v650;
        while (while_method_27(v651)){
            bool v653;
            v653 = 0 <= v651;
            bool v654;
            v654 = v653 == false;
            if (v654){
                assert("The index needs to be zero or positive." && v653);
            } else {
            }
            int v656;
            v656 = v651 % 128;
            int v657;
            v657 = v651 / 128;
            bool v658;
            v658 = v657 < 1;
            bool v659;
            v659 = v658 == false;
            if (v659){
                assert("The last element of the projection dimensions needs to be greater than the index remainder." && v658);
            } else {
            }
            assert("Tensor range check" && 0 <= v657 && v657 < 1);
            assert("Tensor range check" && 0 <= v656 && v656 < 128);
            int v661;
            v661 = 512 * v656;
            int v662;
            v662 = 262144 * v657;
            int v663;
            v663 = v662 + v661;
            int v664;
            v664 = 2048 * v656;
            int v665;
            v665 = 4 * v657;
            int v666;
            v666 = v665 + v664;
            int v667;
            v667 = threadIdx.x;
            int v668;
            v668 = v667;
            while (while_method_23(v668)){
                bool v670;
                v670 = 0 <= v668;
                bool v671;
                v671 = v670 == false;
                if (v671){
                    assert("The index needs to be zero or positive." && v670);
                } else {
                }
                int v673;
                v673 = v668 % 512;
                int v674;
                v674 = v668 / 512;
                bool v675;
                v675 = v674 < 4;
                bool v676;
                v676 = v675 == false;
                if (v676){
                    assert("The last element of the projection dimensions needs to be greater than the index remainder." && v675);
                } else {
                }
                assert("Tensor range check" && 0 <= v674 && v674 < 4);
                assert("Tensor range check" && 0 <= v673 && v673 < 512);
                int v678;
                v678 = v673 + v663;
                int v679;
                v679 = 65536 * v674;
                int v680;
                v680 = v679 + v678;
                float v681;
                v681 = v526[v680];
                assert("Tensor range check" && 0 <= v674 && v674 < 4);
                assert("Tensor range check" && 0 <= v673 && v673 < 512);
                int v682;
                v682 = 513 * v674;
                int v683;
                v683 = v682 + v673;
                v648[v683] = v681;
                v668 += 256 ;
            }
            __syncthreads();
            int v684;
            v684 = threadIdx.x;
            int v685;
            v685 = v684;
            while (while_method_23(v685)){
                bool v687;
                v687 = 0 <= v685;
                bool v688;
                v688 = v687 == false;
                if (v688){
                    assert("The index needs to be zero or positive." && v687);
                } else {
                }
                int v690;
                v690 = v685 % 4;
                int v691;
                v691 = v685 / 4;
                bool v692;
                v692 = v691 < 512;
                bool v693;
                v693 = v692 == false;
                if (v693){
                    assert("The last element of the projection dimensions needs to be greater than the index remainder." && v692);
                } else {
                }
                assert("Tensor range check" && 0 <= v691 && v691 < 512);
                assert("Tensor range check" && 0 <= v690 && v690 < 4);
                int v695;
                v695 = 513 * v690;
                int v696;
                v696 = v691 + v695;
                float v697;
                v697 = v648[v696];
                assert("Tensor range check" && 0 <= v691 && v691 < 512);
                assert("Tensor range check" && 0 <= v690 && v690 < 4);
                int v698;
                v698 = v690 + v666;
                int v699;
                v699 = 4 * v691;
                int v700;
                v700 = v699 + v698;
                v528[v700] = v697;
                v685 += 256 ;
            }
            __syncthreads();
            v651 += 24 ;
        }
        extern __shared__ unsigned char v701[];
        float * v702;
        v702 = reinterpret_cast<float *>(&v701[0ull]);
        int v704;
        v704 = blockIdx.x;
        int v705;
        v705 = v704;
        while (while_method_27(v705)){
            bool v707;
            v707 = 0 <= v705;
            bool v708;
            v708 = v707 == false;
            if (v708){
                assert("The index needs to be zero or positive." && v707);
            } else {
            }
            int v710;
            v710 = v705 % 128;
            int v711;
            v711 = v705 / 128;
            bool v712;
            v712 = v711 < 1;
            bool v713;
            v713 = v712 == false;
            if (v713){
                assert("The last element of the projection dimensions needs to be greater than the index remainder." && v712);
            } else {
            }
            assert("Tensor range check" && 0 <= v711 && v711 < 1);
            assert("Tensor range check" && 0 <= v710 && v710 < 128);
            int v715;
            v715 = 512 * v710;
            int v716;
            v716 = 262144 * v711;
            int v717;
            v717 = v716 + v715;
            int v718;
            v718 = 2048 * v710;
            int v719;
            v719 = 4 * v711;
            int v720;
            v720 = v719 + v718;
            int v721;
            v721 = threadIdx.x;
            int v722;
            v722 = v721;
            while (while_method_23(v722)){
                bool v724;
                v724 = 0 <= v722;
                bool v725;
                v725 = v724 == false;
                if (v725){
                    assert("The index needs to be zero or positive." && v724);
                } else {
                }
                int v727;
                v727 = v722 % 512;
                int v728;
                v728 = v722 / 512;
                bool v729;
                v729 = v728 < 4;
                bool v730;
                v730 = v729 == false;
                if (v730){
                    assert("The last element of the projection dimensions needs to be greater than the index remainder." && v729);
                } else {
                }
                assert("Tensor range check" && 0 <= v728 && v728 < 4);
                assert("Tensor range check" && 0 <= v727 && v727 < 512);
                int v732;
                v732 = v727 + v717;
                int v733;
                v733 = 65536 * v728;
                int v734;
                v734 = v733 + v732;
                float v735;
                v735 = v530[v734];
                assert("Tensor range check" && 0 <= v728 && v728 < 4);
                assert("Tensor range check" && 0 <= v727 && v727 < 512);
                int v736;
                v736 = 513 * v728;
                int v737;
                v737 = v736 + v727;
                v702[v737] = v735;
                v722 += 256 ;
            }
            __syncthreads();
            int v738;
            v738 = threadIdx.x;
            int v739;
            v739 = v738;
            while (while_method_23(v739)){
                bool v741;
                v741 = 0 <= v739;
                bool v742;
                v742 = v741 == false;
                if (v742){
                    assert("The index needs to be zero or positive." && v741);
                } else {
                }
                int v744;
                v744 = v739 % 4;
                int v745;
                v745 = v739 / 4;
                bool v746;
                v746 = v745 < 512;
                bool v747;
                v747 = v746 == false;
                if (v747){
                    assert("The last element of the projection dimensions needs to be greater than the index remainder." && v746);
                } else {
                }
                assert("Tensor range check" && 0 <= v745 && v745 < 512);
                assert("Tensor range check" && 0 <= v744 && v744 < 4);
                int v749;
                v749 = 513 * v744;
                int v750;
                v750 = v745 + v749;
                float v751;
                v751 = v702[v750];
                assert("Tensor range check" && 0 <= v745 && v745 < 512);
                assert("Tensor range check" && 0 <= v744 && v744 < 4);
                int v752;
                v752 = v744 + v720;
                int v753;
                v753 = 4 * v745;
                int v754;
                v754 = v753 + v752;
                v532[v754] = v751;
                v739 += 256 ;
            }
            __syncthreads();
            v705 += 24 ;
        }
        extern __shared__ unsigned char v755[];
        float * v756;
        v756 = reinterpret_cast<float *>(&v755[0ull]);
        int v758;
        v758 = blockIdx.x;
        int v759;
        v759 = v758;
        while (while_method_27(v759)){
            bool v761;
            v761 = 0 <= v759;
            bool v762;
            v762 = v761 == false;
            if (v762){
                assert("The index needs to be zero or positive." && v761);
            } else {
            }
            int v764;
            v764 = v759 % 128;
            int v765;
            v765 = v759 / 128;
            bool v766;
            v766 = v765 < 1;
            bool v767;
            v767 = v766 == false;
            if (v767){
                assert("The last element of the projection dimensions needs to be greater than the index remainder." && v766);
            } else {
            }
            assert("Tensor range check" && 0 <= v765 && v765 < 1);
            assert("Tensor range check" && 0 <= v764 && v764 < 128);
            int v769;
            v769 = 512 * v764;
            int v770;
            v770 = 262144 * v765;
            int v771;
            v771 = v770 + v769;
            int v772;
            v772 = 2048 * v764;
            int v773;
            v773 = 4 * v765;
            int v774;
            v774 = v773 + v772;
            int v775;
            v775 = threadIdx.x;
            int v776;
            v776 = v775;
            while (while_method_23(v776)){
                bool v778;
                v778 = 0 <= v776;
                bool v779;
                v779 = v778 == false;
                if (v779){
                    assert("The index needs to be zero or positive." && v778);
                } else {
                }
                int v781;
                v781 = v776 % 512;
                int v782;
                v782 = v776 / 512;
                bool v783;
                v783 = v782 < 4;
                bool v784;
                v784 = v783 == false;
                if (v784){
                    assert("The last element of the projection dimensions needs to be greater than the index remainder." && v783);
                } else {
                }
                assert("Tensor range check" && 0 <= v782 && v782 < 4);
                assert("Tensor range check" && 0 <= v781 && v781 < 512);
                int v786;
                v786 = v781 + v771;
                int v787;
                v787 = 65536 * v782;
                int v788;
                v788 = v787 + v786;
                float v789;
                v789 = v534[v788];
                assert("Tensor range check" && 0 <= v782 && v782 < 4);
                assert("Tensor range check" && 0 <= v781 && v781 < 512);
                int v790;
                v790 = 513 * v782;
                int v791;
                v791 = v790 + v781;
                v756[v791] = v789;
                v776 += 256 ;
            }
            __syncthreads();
            int v792;
            v792 = threadIdx.x;
            int v793;
            v793 = v792;
            while (while_method_23(v793)){
                bool v795;
                v795 = 0 <= v793;
                bool v796;
                v796 = v795 == false;
                if (v796){
                    assert("The index needs to be zero or positive." && v795);
                } else {
                }
                int v798;
                v798 = v793 % 4;
                int v799;
                v799 = v793 / 4;
                bool v800;
                v800 = v799 < 512;
                bool v801;
                v801 = v800 == false;
                if (v801){
                    assert("The last element of the projection dimensions needs to be greater than the index remainder." && v800);
                } else {
                }
                assert("Tensor range check" && 0 <= v799 && v799 < 512);
                assert("Tensor range check" && 0 <= v798 && v798 < 4);
                int v803;
                v803 = 513 * v798;
                int v804;
                v804 = v799 + v803;
                float v805;
                v805 = v756[v804];
                assert("Tensor range check" && 0 <= v799 && v799 < 512);
                assert("Tensor range check" && 0 <= v798 && v798 < 4);
                int v806;
                v806 = v798 + v774;
                int v807;
                v807 = 4 * v799;
                int v808;
                v808 = v807 + v806;
                v536[v808] = v805;
                v793 += 256 ;
            }
            __syncthreads();
            v759 += 24 ;
        }
        extern __shared__ unsigned char v809[];
        float * v810;
        v810 = reinterpret_cast<float *>(&v809[0ull]);
        int v812;
        v812 = blockIdx.x;
        int v813;
        v813 = v812;
        while (while_method_27(v813)){
            bool v815;
            v815 = 0 <= v813;
            bool v816;
            v816 = v815 == false;
            if (v816){
                assert("The index needs to be zero or positive." && v815);
            } else {
            }
            int v818;
            v818 = v813 % 128;
            int v819;
            v819 = v813 / 128;
            bool v820;
            v820 = v819 < 1;
            bool v821;
            v821 = v820 == false;
            if (v821){
                assert("The last element of the projection dimensions needs to be greater than the index remainder." && v820);
            } else {
            }
            assert("Tensor range check" && 0 <= v819 && v819 < 1);
            assert("Tensor range check" && 0 <= v818 && v818 < 128);
            int v823;
            v823 = 512 * v818;
            int v824;
            v824 = 262144 * v819;
            int v825;
            v825 = v824 + v823;
            int v826;
            v826 = 2048 * v818;
            int v827;
            v827 = 4 * v819;
            int v828;
            v828 = v827 + v826;
            int v829;
            v829 = threadIdx.x;
            int v830;
            v830 = v829;
            while (while_method_23(v830)){
                bool v832;
                v832 = 0 <= v830;
                bool v833;
                v833 = v832 == false;
                if (v833){
                    assert("The index needs to be zero or positive." && v832);
                } else {
                }
                int v835;
                v835 = v830 % 512;
                int v836;
                v836 = v830 / 512;
                bool v837;
                v837 = v836 < 4;
                bool v838;
                v838 = v837 == false;
                if (v838){
                    assert("The last element of the projection dimensions needs to be greater than the index remainder." && v837);
                } else {
                }
                assert("Tensor range check" && 0 <= v836 && v836 < 4);
                assert("Tensor range check" && 0 <= v835 && v835 < 512);
                int v840;
                v840 = v835 + v825;
                int v841;
                v841 = 65536 * v836;
                int v842;
                v842 = v841 + v840;
                float v843;
                v843 = v538[v842];
                assert("Tensor range check" && 0 <= v836 && v836 < 4);
                assert("Tensor range check" && 0 <= v835 && v835 < 512);
                int v844;
                v844 = 513 * v836;
                int v845;
                v845 = v844 + v835;
                v810[v845] = v843;
                v830 += 256 ;
            }
            __syncthreads();
            int v846;
            v846 = threadIdx.x;
            int v847;
            v847 = v846;
            while (while_method_23(v847)){
                bool v849;
                v849 = 0 <= v847;
                bool v850;
                v850 = v849 == false;
                if (v850){
                    assert("The index needs to be zero or positive." && v849);
                } else {
                }
                int v852;
                v852 = v847 % 4;
                int v853;
                v853 = v847 / 4;
                bool v854;
                v854 = v853 < 512;
                bool v855;
                v855 = v854 == false;
                if (v855){
                    assert("The last element of the projection dimensions needs to be greater than the index remainder." && v854);
                } else {
                }
                assert("Tensor range check" && 0 <= v853 && v853 < 512);
                assert("Tensor range check" && 0 <= v852 && v852 < 4);
                int v857;
                v857 = 513 * v852;
                int v858;
                v858 = v853 + v857;
                float v859;
                v859 = v810[v858];
                assert("Tensor range check" && 0 <= v853 && v853 < 512);
                assert("Tensor range check" && 0 <= v852 && v852 < 4);
                int v860;
                v860 = v852 + v828;
                int v861;
                v861 = 4 * v853;
                int v862;
                v862 = v861 + v860;
                v540[v862] = v859;
                v847 += 256 ;
            }
            __syncthreads();
            v813 += 24 ;
        }
        extern __shared__ unsigned char v863[];
        float * v864;
        v864 = reinterpret_cast<float *>(&v863[0ull]);
        int v866;
        v866 = blockIdx.x;
        int v867;
        v867 = v866;
        while (while_method_24(v867)){
            bool v869;
            v869 = 0 <= v867;
            bool v870;
            v870 = v869 == false;
            if (v870){
                assert("The index needs to be zero or positive." && v869);
            } else {
            }
            int v872;
            v872 = v867 % 32;
            int v873;
            v873 = v867 / 32;
            bool v874;
            v874 = v873 < 1;
            bool v875;
            v875 = v874 == false;
            if (v875){
                assert("The last element of the projection dimensions needs to be greater than the index remainder." && v874);
            } else {
            }
            assert("Tensor range check" && 0 <= v873 && v873 < 1);
            assert("Tensor range check" && 0 <= v872 && v872 < 32);
            int v877;
            v877 = 512 * v872;
            int v878;
            v878 = 65536 * v873;
            int v879;
            v879 = v878 + v877;
            int v880;
            v880 = 2048 * v872;
            int v881;
            v881 = 4 * v873;
            int v882;
            v882 = v881 + v880;
            int v883;
            v883 = threadIdx.x;
            int v884;
            v884 = v883;
            while (while_method_23(v884)){
                bool v886;
                v886 = 0 <= v884;
                bool v887;
                v887 = v886 == false;
                if (v887){
                    assert("The index needs to be zero or positive." && v886);
                } else {
                }
                int v889;
                v889 = v884 % 512;
                int v890;
                v890 = v884 / 512;
                bool v891;
                v891 = v890 < 4;
                bool v892;
                v892 = v891 == false;
                if (v892){
                    assert("The last element of the projection dimensions needs to be greater than the index remainder." && v891);
                } else {
                }
                assert("Tensor range check" && 0 <= v890 && v890 < 4);
                assert("Tensor range check" && 0 <= v889 && v889 < 512);
                int v894;
                v894 = v889 + v879;
                int v895;
                v895 = 16384 * v890;
                int v896;
                v896 = v895 + v894;
                float v897;
                v897 = v542[v896];
                assert("Tensor range check" && 0 <= v890 && v890 < 4);
                assert("Tensor range check" && 0 <= v889 && v889 < 512);
                int v898;
                v898 = 513 * v890;
                int v899;
                v899 = v898 + v889;
                v864[v899] = v897;
                v884 += 256 ;
            }
            __syncthreads();
            int v900;
            v900 = threadIdx.x;
            int v901;
            v901 = v900;
            while (while_method_23(v901)){
                bool v903;
                v903 = 0 <= v901;
                bool v904;
                v904 = v903 == false;
                if (v904){
                    assert("The index needs to be zero or positive." && v903);
                } else {
                }
                int v906;
                v906 = v901 % 4;
                int v907;
                v907 = v901 / 4;
                bool v908;
                v908 = v907 < 512;
                bool v909;
                v909 = v908 == false;
                if (v909){
                    assert("The last element of the projection dimensions needs to be greater than the index remainder." && v908);
                } else {
                }
                assert("Tensor range check" && 0 <= v907 && v907 < 512);
                assert("Tensor range check" && 0 <= v906 && v906 < 4);
                int v911;
                v911 = 513 * v906;
                int v912;
                v912 = v907 + v911;
                float v913;
                v913 = v864[v912];
                assert("Tensor range check" && 0 <= v907 && v907 < 512);
                assert("Tensor range check" && 0 <= v906 && v906 < 4);
                int v914;
                v914 = v906 + v882;
                int v915;
                v915 = 4 * v907;
                int v916;
                v916 = v915 + v914;
                v544[v916] = v913;
                v901 += 256 ;
            }
            __syncthreads();
            v867 += 24 ;
        }
        v519.sync() ;
        int v917;
        v917 = threadIdx.x;
        bool v918;
        v918 = 0 <= v917;
        bool v919;
        v919 = v918 == false;
        if (v919){
            assert("The index needs to be zero or positive." && v918);
        } else {
        }
        int v921;
        v921 = v917 % 1;
        int v922;
        v922 = v917 % 256;
        int v923;
        v923 = v917 / 256;
        bool v924;
        v924 = v923 < 1;
        bool v925;
        v925 = v924 == false;
        if (v925){
            assert("The last element of the projection dimensions needs to be greater than the index remainder." && v924);
        } else {
        }
        assert("Tensor range check" && 0 <= v923 && v923 < 1);
        assert("Tensor range check" && 0 <= v922 && v922 < 256);
        assert("Tensor range check" && 0 <= v921 && v921 < 1);
        int v927;
        v927 = 4 * v921;
        int v928;
        v928 = 4 * v922;
        int v929;
        v929 = v928 + v927;
        int v930;
        v930 = 8192 * v923;
        int v931;
        v931 = v930 + v929;
        assert("Tensor range check" && 0 <= v923 && v923 < 1);
        assert("Tensor range check" && 0 <= v922 && v922 < 256);
        assert("Tensor range check" && 0 <= v921 && v921 < 1);
        int v932;
        v932 = blockIdx.x;
        int v933;
        v933 = v932;
        while (while_method_23(v933)){
            bool v935;
            v935 = 0 <= v933;
            bool v936;
            v936 = v935 == false;
            if (v936){
                assert("The index needs to be zero or positive." && v935);
            } else {
            }
            int v938;
            v938 = v933 % 8;
            int v939;
            v939 = v933 / 8;
            bool v940;
            v940 = v939 < 256;
            bool v941;
            v941 = v940 == false;
            if (v941){
                assert("The last element of the projection dimensions needs to be greater than the index remainder." && v940);
            } else {
            }
            assert("Tensor range check" && 0 <= v939 && v939 < 256);
            assert("Tensor range check" && 0 <= v938 && v938 < 8);
            int v943;
            v943 = 1024 * v938;
            int v944;
            v944 = v943 + v931;
            int v945;
            v945 = 8192 * v939;
            int v946;
            v946 = v945 + v944;
            float v947[4];
            int v948[4];
            int v949;
            v949 = 0;
            while (while_method_6(v949)){
                assert("Tensor range check" && 0 <= v949 && v949 < 1);
                int v951;
                v951 = 4 * v949;
                assert("Tensor range check" && 0 <= v949 && v949 < 1);
                int v952;
                v952 = v951 + v946;
                int4* v953;
                v953 = reinterpret_cast<int4*>(v524 + v952);
                int4* v954;
                v954 = reinterpret_cast<int4*>(v947 + v951);
                assert("Pointer alignment check" && reinterpret_cast<unsigned long long>(v953) % 16 == 0 && reinterpret_cast<unsigned long long>(v954) % 16 == 0);
                *v954 = *v953;
                v949 += 1 ;
            }
            int v955;
            v955 = 0;
            while (while_method_6(v955)){
                int v957;
                v957 = 0;
                while (while_method_3(v957)){
                    bool v959;
                    v959 = 0 <= v957;
                    bool v961;
                    if (v959){
                        bool v960;
                        v960 = v957 < 4;
                        v961 = v960;
                    } else {
                        v961 = false;
                    }
                    bool v962;
                    v962 = v961 == false;
                    if (v962){
                        assert("The indices should be inside the range of the dimension." && v961);
                    } else {
                    }
                    bool v964;
                    v964 = 0 <= v921;
                    bool v966;
                    if (v964){
                        bool v965;
                        v965 = v921 < 1;
                        v966 = v965;
                    } else {
                        v966 = false;
                    }
                    bool v967;
                    v967 = v966 == false;
                    if (v967){
                        assert("The indices should be inside the range of the dimension." && v966);
                    } else {
                    }
                    int v969;
                    v969 = v921 * 4;
                    int v970;
                    v970 = v957 + v969;
                    bool v971;
                    v971 = 0 <= v955;
                    bool v973;
                    if (v971){
                        bool v972;
                        v972 = v955 < 1;
                        v973 = v972;
                    } else {
                        v973 = false;
                    }
                    bool v974;
                    v974 = v973 == false;
                    if (v974){
                        assert("The indices should be inside the range of the dimension." && v973);
                    } else {
                    }
                    int v976;
                    v976 = v955 * 4;
                    int v977;
                    v977 = v970 + v976;
                    assert("Tensor range check" && 0 <= v955 && v955 < 1);
                    assert("Tensor range check" && 0 <= v957 && v957 < 4);
                    int v978;
                    v978 = 4 * v955;
                    int v979;
                    v979 = v978 + v957;
                    v948[v979] = v977;
                    v957 += 1 ;
                }
                v955 += 1 ;
            }
            bool v980;
            v980 = 0 <= v923;
            bool v981;
            v981 = v980 && v924;
            bool v982;
            v982 = v981 == false;
            if (v982){
                assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v981);
            } else {
            }
            bool v984;
            v984 = 0 <= v922;
            bool v986;
            if (v984){
                bool v985;
                v985 = v922 < 256;
                v986 = v985;
            } else {
                v986 = false;
            }
            bool v987;
            v987 = v986 == false;
            if (v987){
                assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v986);
            } else {
            }
            bool v989;
            v989 = 0 <= v939;
            bool v990;
            v990 = v989 && v940;
            bool v991;
            v991 = v990 == false;
            if (v991){
                assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v990);
            } else {
            }
            bool v993;
            v993 = 0 <= v938;
            bool v995;
            if (v993){
                bool v994;
                v994 = v938 < 8;
                v995 = v994;
            } else {
                v995 = false;
            }
            bool v996;
            v996 = v995 == false;
            if (v996){
                assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v995);
            } else {
            }
            int v998;
            v998 = v938 * 256;
            int v999;
            v999 = v939 + v923;
            int v1000;
            v1000 = v998 + v922;
            bool v1001[4];
            int v1002;
            v1002 = 0;
            while (while_method_6(v1002)){
                int v1004;
                v1004 = 0;
                while (while_method_3(v1004)){
                    assert("Tensor range check" && 0 <= v1002 && v1002 < 1);
                    assert("Tensor range check" && 0 <= v1004 && v1004 < 4);
                    int v1006;
                    v1006 = 4 * v1002;
                    int v1007;
                    v1007 = v1006 + v1004;
                    int v1008;
                    v1008 = v948[v1007];
                    assert("Tensor range check" && 0 <= v1008 && v1008 < 4);
                    bool v1009;
                    v1009 = v550[v1008];
                    assert("Tensor range check" && 0 <= v1002 && v1002 < 1);
                    assert("Tensor range check" && 0 <= v1004 && v1004 < 4);
                    v1001[v1007] = v1009;
                    v1004 += 1 ;
                }
                v1002 += 1 ;
            }
            int v1010[4];
            int v1011;
            v1011 = 0;
            while (while_method_6(v1011)){
                int v1013;
                v1013 = 0;
                while (while_method_3(v1013)){
                    assert("Tensor range check" && 0 <= v1011 && v1011 < 1);
                    assert("Tensor range check" && 0 <= v1013 && v1013 < 4);
                    int v1015;
                    v1015 = 4 * v1011;
                    int v1016;
                    v1016 = v1015 + v1013;
                    bool v1017;
                    v1017 = v1001[v1016];
                    int v1018;
                    if (v1017){
                        v1018 = 1;
                    } else {
                        v1018 = 0;
                    }
                    assert("Tensor range check" && 0 <= v1011 && v1011 < 1);
                    assert("Tensor range check" && 0 <= v1013 && v1013 < 4);
                    v1010[v1016] = v1018;
                    v1013 += 1 ;
                }
                v1011 += 1 ;
            }
            int v1019;
            v1019 = 0;
            int v1020;
            v1020 = 0;
            while (while_method_6(v1020)){
                int v1022;
                v1022 = 0;
                while (while_method_3(v1022)){
                    assert("Tensor range check" && 0 <= v1020 && v1020 < 1);
                    assert("Tensor range check" && 0 <= v1022 && v1022 < 4);
                    int v1024;
                    v1024 = 4 * v1020;
                    int v1025;
                    v1025 = v1024 + v1022;
                    int v1026;
                    v1026 = v1010[v1025];
                    int v1027;
                    v1027 = v1019 + v1026;
                    v1019 = v1027;
                    v1022 += 1 ;
                }
                v1020 += 1 ;
            }
            auto v1028 = cooperative_groups::coalesced_threads();
            int v1029;
            v1029 = threadIdx.x;
            auto v1030 = cooperative_groups::labeled_partition(v1028,v1029);
            Closure1 v1031{};
            int v1032;
            v1032 = cooperative_groups::reduce(v1030, v1019, v1031);
            float v1033;
            v1033 = (float)v1032;
            float v1034[4];
            int v1035;
            v1035 = 0;
            while (while_method_6(v1035)){
                int v1037;
                v1037 = 0;
                while (while_method_3(v1037)){
                    assert("Tensor range check" && 0 <= v1035 && v1035 < 1);
                    assert("Tensor range check" && 0 <= v1037 && v1037 < 4);
                    int v1039;
                    v1039 = 4 * v1035;
                    int v1040;
                    v1040 = v1039 + v1037;
                    float v1041;
                    v1041 = v947[v1040];
                    bool v1042;
                    v1042 = v1001[v1040];
                    float v1043;
                    if (v1042){
                        v1043 = v1041;
                    } else {
                        v1043 = 0.0f;
                    }
                    assert("Tensor range check" && 0 <= v1035 && v1035 < 1);
                    assert("Tensor range check" && 0 <= v1037 && v1037 < 4);
                    v1034[v1040] = v1043;
                    v1037 += 1 ;
                }
                v1035 += 1 ;
            }
            float v1044;
            v1044 = 0.0f;
            int v1045;
            v1045 = 0;
            while (while_method_6(v1045)){
                int v1047;
                v1047 = 0;
                while (while_method_3(v1047)){
                    assert("Tensor range check" && 0 <= v1045 && v1045 < 1);
                    assert("Tensor range check" && 0 <= v1047 && v1047 < 4);
                    int v1049;
                    v1049 = 4 * v1045;
                    int v1050;
                    v1050 = v1049 + v1047;
                    float v1051;
                    v1051 = v1034[v1050];
                    float v1052;
                    v1052 = v1044 + v1051;
                    v1044 = v1052;
                    v1047 += 1 ;
                }
                v1045 += 1 ;
            }
            auto v1053 = cooperative_groups::coalesced_threads();
            int v1054;
            v1054 = threadIdx.x;
            auto v1055 = cooperative_groups::labeled_partition(v1053,v1054);
            Closure0 v1056{};
            float v1057;
            v1057 = cooperative_groups::reduce(v1055, v1044, v1056);
            float v1058;
            v1058 = v1057 / v1033;
            float v1059[4];
            int v1060;
            v1060 = 0;
            while (while_method_6(v1060)){
                int v1062;
                v1062 = 0;
                while (while_method_3(v1062)){
                    assert("Tensor range check" && 0 <= v1060 && v1060 < 1);
                    assert("Tensor range check" && 0 <= v1062 && v1062 < 4);
                    int v1064;
                    v1064 = 4 * v1060;
                    int v1065;
                    v1065 = v1064 + v1062;
                    float v1066;
                    v1066 = v947[v1065];
                    float v1067;
                    v1067 = v1066 - v1058;
                    float v1068;
                    v1068 = v1067 * v1067;
                    assert("Tensor range check" && 0 <= v1060 && v1060 < 1);
                    assert("Tensor range check" && 0 <= v1062 && v1062 < 4);
                    v1059[v1065] = v1068;
                    v1062 += 1 ;
                }
                v1060 += 1 ;
            }
            float v1069[4];
            int v1070;
            v1070 = 0;
            while (while_method_6(v1070)){
                int v1072;
                v1072 = 0;
                while (while_method_3(v1072)){
                    assert("Tensor range check" && 0 <= v1070 && v1070 < 1);
                    assert("Tensor range check" && 0 <= v1072 && v1072 < 4);
                    int v1074;
                    v1074 = 4 * v1070;
                    int v1075;
                    v1075 = v1074 + v1072;
                    float v1076;
                    v1076 = v1059[v1075];
                    bool v1077;
                    v1077 = v1001[v1075];
                    float v1078;
                    if (v1077){
                        v1078 = v1076;
                    } else {
                        v1078 = 0.0f;
                    }
                    assert("Tensor range check" && 0 <= v1070 && v1070 < 1);
                    assert("Tensor range check" && 0 <= v1072 && v1072 < 4);
                    v1069[v1075] = v1078;
                    v1072 += 1 ;
                }
                v1070 += 1 ;
            }
            float v1079;
            v1079 = 0.0f;
            int v1080;
            v1080 = 0;
            while (while_method_6(v1080)){
                int v1082;
                v1082 = 0;
                while (while_method_3(v1082)){
                    assert("Tensor range check" && 0 <= v1080 && v1080 < 1);
                    assert("Tensor range check" && 0 <= v1082 && v1082 < 4);
                    int v1084;
                    v1084 = 4 * v1080;
                    int v1085;
                    v1085 = v1084 + v1082;
                    float v1086;
                    v1086 = v1069[v1085];
                    float v1087;
                    v1087 = v1079 + v1086;
                    v1079 = v1087;
                    v1082 += 1 ;
                }
                v1080 += 1 ;
            }
            auto v1088 = cooperative_groups::coalesced_threads();
            int v1089;
            v1089 = threadIdx.x;
            auto v1090 = cooperative_groups::labeled_partition(v1088,v1089);
            float v1091;
            v1091 = cooperative_groups::reduce(v1090, v1079, v1056);
            float v1092;
            v1092 = v1091 / v1033;
            float v1093;
            v1093 = sqrt(v1092);
            bool v1094;
            v1094 = v1033 > 1.0f;
            float v1098;
            if (v1094){
                float v1095;
                v1095 = v1093 * v1033;
                float v1096;
                v1096 = v1033 - 1.0f;
                float v1097;
                v1097 = v1095 / v1096;
                v1098 = v1097;
            } else {
                v1098 = 0.0f;
            }
            float v1099[4];
            int v1100;
            v1100 = 0;
            while (while_method_6(v1100)){
                int v1102;
                v1102 = 0;
                while (while_method_3(v1102)){
                    assert("Tensor range check" && 0 <= v1100 && v1100 < 1);
                    assert("Tensor range check" && 0 <= v1102 && v1102 < 4);
                    int v1104;
                    v1104 = 4 * v1100;
                    int v1105;
                    v1105 = v1104 + v1102;
                    float v1106;
                    v1106 = v947[v1105];
                    bool v1107;
                    v1107 = v1001[v1105];
                    float v1108;
                    v1108 = curand_normal(&v521);
                    bool v1109;
                    v1109 = v1098 >= 0.1f;
                    float v1110;
                    if (v1109){
                        v1110 = v1098;
                    } else {
                        v1110 = 0.1f;
                    }
                    float v1111;
                    v1111 = v1108 * v1110;
                    float v1112;
                    v1112 = v1111 + v1058;
                    float v1113;
                    if (v1107){
                        v1113 = v1106;
                    } else {
                        v1113 = v1112;
                    }
                    assert("Tensor range check" && 0 <= v1100 && v1100 < 1);
                    assert("Tensor range check" && 0 <= v1102 && v1102 < 4);
                    v1099[v1105] = v1113;
                    v1102 += 1 ;
                }
                v1100 += 1 ;
            }
            assert("Tensor range check" && 0 <= v939 && v939 < 256);
            assert("Tensor range check" && 0 <= v938 && v938 < 8);
            int v1114;
            v1114 = 0;
            while (while_method_6(v1114)){
                assert("Tensor range check" && 0 <= v1114 && v1114 < 1);
                int v1116;
                v1116 = 4 * v1114;
                int v1117;
                v1117 = v1116 + v946;
                assert("Tensor range check" && 0 <= v1114 && v1114 < 1);
                int4* v1118;
                v1118 = reinterpret_cast<int4*>(v1099 + v1116);
                int4* v1119;
                v1119 = reinterpret_cast<int4*>(v524 + v1117);
                assert("Pointer alignment check" && reinterpret_cast<unsigned long long>(v1118) % 16 == 0 && reinterpret_cast<unsigned long long>(v1119) % 16 == 0);
                *v1119 = *v1118;
                v1114 += 1 ;
            }
            v933 += 24 ;
        }
        int v1120;
        v1120 = threadIdx.x;
        bool v1121;
        v1121 = 0 <= v1120;
        bool v1122;
        v1122 = v1121 == false;
        if (v1122){
            assert("The index needs to be zero or positive." && v1121);
        } else {
        }
        int v1124;
        v1124 = v1120 % 1;
        int v1125;
        v1125 = v1120 % 256;
        int v1126;
        v1126 = v1120 / 256;
        bool v1127;
        v1127 = v1126 < 1;
        bool v1128;
        v1128 = v1127 == false;
        if (v1128){
            assert("The last element of the projection dimensions needs to be greater than the index remainder." && v1127);
        } else {
        }
        assert("Tensor range check" && 0 <= v1126 && v1126 < 1);
        assert("Tensor range check" && 0 <= v1125 && v1125 < 256);
        assert("Tensor range check" && 0 <= v1124 && v1124 < 1);
        int v1130;
        v1130 = 4 * v1124;
        int v1131;
        v1131 = 4 * v1125;
        int v1132;
        v1132 = v1131 + v1130;
        int v1133;
        v1133 = 1024 * v1126;
        int v1134;
        v1134 = v1133 + v1132;
        assert("Tensor range check" && 0 <= v1126 && v1126 < 1);
        assert("Tensor range check" && 0 <= v1125 && v1125 < 256);
        assert("Tensor range check" && 0 <= v1124 && v1124 < 1);
        int v1135;
        v1135 = blockIdx.x;
        int v1136;
        v1136 = v1135;
        while (while_method_28(v1136)){
            bool v1138;
            v1138 = 0 <= v1136;
            bool v1139;
            v1139 = v1138 == false;
            if (v1139){
                assert("The index needs to be zero or positive." && v1138);
            } else {
            }
            int v1141;
            v1141 = v1136 % 1;
            bool v1142;
            v1142 = v1136 < 256;
            bool v1143;
            v1143 = v1142 == false;
            if (v1143){
                assert("The last element of the projection dimensions needs to be greater than the index remainder." && v1142);
            } else {
            }
            assert("Tensor range check" && 0 <= v1136 && v1136 < 256);
            assert("Tensor range check" && 0 <= v1141 && v1141 < 1);
            int v1145;
            v1145 = 1024 * v1141;
            int v1146;
            v1146 = v1145 + v1134;
            int v1147;
            v1147 = 1024 * v1136;
            int v1148;
            v1148 = v1147 + v1146;
            float v1149[4];
            int v1150[4];
            int v1151;
            v1151 = 0;
            while (while_method_6(v1151)){
                assert("Tensor range check" && 0 <= v1151 && v1151 < 1);
                int v1153;
                v1153 = 4 * v1151;
                assert("Tensor range check" && 0 <= v1151 && v1151 < 1);
                int v1154;
                v1154 = v1153 + v1148;
                int4* v1155;
                v1155 = reinterpret_cast<int4*>(v528 + v1154);
                int4* v1156;
                v1156 = reinterpret_cast<int4*>(v1149 + v1153);
                assert("Pointer alignment check" && reinterpret_cast<unsigned long long>(v1155) % 16 == 0 && reinterpret_cast<unsigned long long>(v1156) % 16 == 0);
                *v1156 = *v1155;
                v1151 += 1 ;
            }
            int v1157;
            v1157 = 0;
            while (while_method_6(v1157)){
                int v1159;
                v1159 = 0;
                while (while_method_3(v1159)){
                    bool v1161;
                    v1161 = 0 <= v1159;
                    bool v1163;
                    if (v1161){
                        bool v1162;
                        v1162 = v1159 < 4;
                        v1163 = v1162;
                    } else {
                        v1163 = false;
                    }
                    bool v1164;
                    v1164 = v1163 == false;
                    if (v1164){
                        assert("The indices should be inside the range of the dimension." && v1163);
                    } else {
                    }
                    bool v1166;
                    v1166 = 0 <= v1124;
                    bool v1168;
                    if (v1166){
                        bool v1167;
                        v1167 = v1124 < 1;
                        v1168 = v1167;
                    } else {
                        v1168 = false;
                    }
                    bool v1169;
                    v1169 = v1168 == false;
                    if (v1169){
                        assert("The indices should be inside the range of the dimension." && v1168);
                    } else {
                    }
                    int v1171;
                    v1171 = v1124 * 4;
                    int v1172;
                    v1172 = v1159 + v1171;
                    bool v1173;
                    v1173 = 0 <= v1157;
                    bool v1175;
                    if (v1173){
                        bool v1174;
                        v1174 = v1157 < 1;
                        v1175 = v1174;
                    } else {
                        v1175 = false;
                    }
                    bool v1176;
                    v1176 = v1175 == false;
                    if (v1176){
                        assert("The indices should be inside the range of the dimension." && v1175);
                    } else {
                    }
                    int v1178;
                    v1178 = v1157 * 4;
                    int v1179;
                    v1179 = v1172 + v1178;
                    assert("Tensor range check" && 0 <= v1157 && v1157 < 1);
                    assert("Tensor range check" && 0 <= v1159 && v1159 < 4);
                    int v1180;
                    v1180 = 4 * v1157;
                    int v1181;
                    v1181 = v1180 + v1159;
                    v1150[v1181] = v1179;
                    v1159 += 1 ;
                }
                v1157 += 1 ;
            }
            bool v1182;
            v1182 = 0 <= v1126;
            bool v1183;
            v1183 = v1182 && v1127;
            bool v1184;
            v1184 = v1183 == false;
            if (v1184){
                assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v1183);
            } else {
            }
            bool v1186;
            v1186 = 0 <= v1125;
            bool v1188;
            if (v1186){
                bool v1187;
                v1187 = v1125 < 256;
                v1188 = v1187;
            } else {
                v1188 = false;
            }
            bool v1189;
            v1189 = v1188 == false;
            if (v1189){
                assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v1188);
            } else {
            }
            bool v1191;
            v1191 = v1138 && v1142;
            bool v1192;
            v1192 = v1191 == false;
            if (v1192){
                assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v1191);
            } else {
            }
            bool v1194;
            v1194 = 0 <= v1141;
            bool v1196;
            if (v1194){
                bool v1195;
                v1195 = v1141 < 1;
                v1196 = v1195;
            } else {
                v1196 = false;
            }
            bool v1197;
            v1197 = v1196 == false;
            if (v1197){
                assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v1196);
            } else {
            }
            int v1199;
            v1199 = v1141 * 256;
            int v1200;
            v1200 = v1136 + v1126;
            int v1201;
            v1201 = v1199 + v1125;
            bool v1202[4];
            int v1203;
            v1203 = 0;
            while (while_method_6(v1203)){
                int v1205;
                v1205 = 0;
                while (while_method_3(v1205)){
                    assert("Tensor range check" && 0 <= v1203 && v1203 < 1);
                    assert("Tensor range check" && 0 <= v1205 && v1205 < 4);
                    int v1207;
                    v1207 = 4 * v1203;
                    int v1208;
                    v1208 = v1207 + v1205;
                    int v1209;
                    v1209 = v1150[v1208];
                    assert("Tensor range check" && 0 <= v1209 && v1209 < 4);
                    bool v1210;
                    v1210 = v550[v1209];
                    assert("Tensor range check" && 0 <= v1203 && v1203 < 1);
                    assert("Tensor range check" && 0 <= v1205 && v1205 < 4);
                    v1202[v1208] = v1210;
                    v1205 += 1 ;
                }
                v1203 += 1 ;
            }
            int v1211[4];
            int v1212;
            v1212 = 0;
            while (while_method_6(v1212)){
                int v1214;
                v1214 = 0;
                while (while_method_3(v1214)){
                    assert("Tensor range check" && 0 <= v1212 && v1212 < 1);
                    assert("Tensor range check" && 0 <= v1214 && v1214 < 4);
                    int v1216;
                    v1216 = 4 * v1212;
                    int v1217;
                    v1217 = v1216 + v1214;
                    bool v1218;
                    v1218 = v1202[v1217];
                    int v1219;
                    if (v1218){
                        v1219 = 1;
                    } else {
                        v1219 = 0;
                    }
                    assert("Tensor range check" && 0 <= v1212 && v1212 < 1);
                    assert("Tensor range check" && 0 <= v1214 && v1214 < 4);
                    v1211[v1217] = v1219;
                    v1214 += 1 ;
                }
                v1212 += 1 ;
            }
            int v1220;
            v1220 = 0;
            int v1221;
            v1221 = 0;
            while (while_method_6(v1221)){
                int v1223;
                v1223 = 0;
                while (while_method_3(v1223)){
                    assert("Tensor range check" && 0 <= v1221 && v1221 < 1);
                    assert("Tensor range check" && 0 <= v1223 && v1223 < 4);
                    int v1225;
                    v1225 = 4 * v1221;
                    int v1226;
                    v1226 = v1225 + v1223;
                    int v1227;
                    v1227 = v1211[v1226];
                    int v1228;
                    v1228 = v1220 + v1227;
                    v1220 = v1228;
                    v1223 += 1 ;
                }
                v1221 += 1 ;
            }
            auto v1229 = cooperative_groups::coalesced_threads();
            int v1230;
            v1230 = threadIdx.x;
            auto v1231 = cooperative_groups::labeled_partition(v1229,v1230);
            Closure1 v1232{};
            int v1233;
            v1233 = cooperative_groups::reduce(v1231, v1220, v1232);
            float v1234;
            v1234 = (float)v1233;
            float v1235[4];
            int v1236;
            v1236 = 0;
            while (while_method_6(v1236)){
                int v1238;
                v1238 = 0;
                while (while_method_3(v1238)){
                    assert("Tensor range check" && 0 <= v1236 && v1236 < 1);
                    assert("Tensor range check" && 0 <= v1238 && v1238 < 4);
                    int v1240;
                    v1240 = 4 * v1236;
                    int v1241;
                    v1241 = v1240 + v1238;
                    float v1242;
                    v1242 = v1149[v1241];
                    bool v1243;
                    v1243 = v1202[v1241];
                    float v1244;
                    if (v1243){
                        v1244 = v1242;
                    } else {
                        v1244 = 0.0f;
                    }
                    assert("Tensor range check" && 0 <= v1236 && v1236 < 1);
                    assert("Tensor range check" && 0 <= v1238 && v1238 < 4);
                    v1235[v1241] = v1244;
                    v1238 += 1 ;
                }
                v1236 += 1 ;
            }
            float v1245;
            v1245 = 0.0f;
            int v1246;
            v1246 = 0;
            while (while_method_6(v1246)){
                int v1248;
                v1248 = 0;
                while (while_method_3(v1248)){
                    assert("Tensor range check" && 0 <= v1246 && v1246 < 1);
                    assert("Tensor range check" && 0 <= v1248 && v1248 < 4);
                    int v1250;
                    v1250 = 4 * v1246;
                    int v1251;
                    v1251 = v1250 + v1248;
                    float v1252;
                    v1252 = v1235[v1251];
                    float v1253;
                    v1253 = v1245 + v1252;
                    v1245 = v1253;
                    v1248 += 1 ;
                }
                v1246 += 1 ;
            }
            auto v1254 = cooperative_groups::coalesced_threads();
            int v1255;
            v1255 = threadIdx.x;
            auto v1256 = cooperative_groups::labeled_partition(v1254,v1255);
            Closure0 v1257{};
            float v1258;
            v1258 = cooperative_groups::reduce(v1256, v1245, v1257);
            float v1259;
            v1259 = v1258 / v1234;
            float v1260[4];
            int v1261;
            v1261 = 0;
            while (while_method_6(v1261)){
                int v1263;
                v1263 = 0;
                while (while_method_3(v1263)){
                    assert("Tensor range check" && 0 <= v1261 && v1261 < 1);
                    assert("Tensor range check" && 0 <= v1263 && v1263 < 4);
                    int v1265;
                    v1265 = 4 * v1261;
                    int v1266;
                    v1266 = v1265 + v1263;
                    float v1267;
                    v1267 = v1149[v1266];
                    float v1268;
                    v1268 = v1267 - v1259;
                    float v1269;
                    v1269 = v1268 * v1268;
                    assert("Tensor range check" && 0 <= v1261 && v1261 < 1);
                    assert("Tensor range check" && 0 <= v1263 && v1263 < 4);
                    v1260[v1266] = v1269;
                    v1263 += 1 ;
                }
                v1261 += 1 ;
            }
            float v1270[4];
            int v1271;
            v1271 = 0;
            while (while_method_6(v1271)){
                int v1273;
                v1273 = 0;
                while (while_method_3(v1273)){
                    assert("Tensor range check" && 0 <= v1271 && v1271 < 1);
                    assert("Tensor range check" && 0 <= v1273 && v1273 < 4);
                    int v1275;
                    v1275 = 4 * v1271;
                    int v1276;
                    v1276 = v1275 + v1273;
                    float v1277;
                    v1277 = v1260[v1276];
                    bool v1278;
                    v1278 = v1202[v1276];
                    float v1279;
                    if (v1278){
                        v1279 = v1277;
                    } else {
                        v1279 = 0.0f;
                    }
                    assert("Tensor range check" && 0 <= v1271 && v1271 < 1);
                    assert("Tensor range check" && 0 <= v1273 && v1273 < 4);
                    v1270[v1276] = v1279;
                    v1273 += 1 ;
                }
                v1271 += 1 ;
            }
            float v1280;
            v1280 = 0.0f;
            int v1281;
            v1281 = 0;
            while (while_method_6(v1281)){
                int v1283;
                v1283 = 0;
                while (while_method_3(v1283)){
                    assert("Tensor range check" && 0 <= v1281 && v1281 < 1);
                    assert("Tensor range check" && 0 <= v1283 && v1283 < 4);
                    int v1285;
                    v1285 = 4 * v1281;
                    int v1286;
                    v1286 = v1285 + v1283;
                    float v1287;
                    v1287 = v1270[v1286];
                    float v1288;
                    v1288 = v1280 + v1287;
                    v1280 = v1288;
                    v1283 += 1 ;
                }
                v1281 += 1 ;
            }
            auto v1289 = cooperative_groups::coalesced_threads();
            int v1290;
            v1290 = threadIdx.x;
            auto v1291 = cooperative_groups::labeled_partition(v1289,v1290);
            float v1292;
            v1292 = cooperative_groups::reduce(v1291, v1280, v1257);
            float v1293;
            v1293 = v1292 / v1234;
            float v1294;
            v1294 = sqrt(v1293);
            bool v1295;
            v1295 = v1234 > 1.0f;
            float v1299;
            if (v1295){
                float v1296;
                v1296 = v1294 * v1234;
                float v1297;
                v1297 = v1234 - 1.0f;
                float v1298;
                v1298 = v1296 / v1297;
                v1299 = v1298;
            } else {
                v1299 = 0.0f;
            }
            float v1300[4];
            int v1301;
            v1301 = 0;
            while (while_method_6(v1301)){
                int v1303;
                v1303 = 0;
                while (while_method_3(v1303)){
                    assert("Tensor range check" && 0 <= v1301 && v1301 < 1);
                    assert("Tensor range check" && 0 <= v1303 && v1303 < 4);
                    int v1305;
                    v1305 = 4 * v1301;
                    int v1306;
                    v1306 = v1305 + v1303;
                    float v1307;
                    v1307 = v1149[v1306];
                    bool v1308;
                    v1308 = v1202[v1306];
                    float v1309;
                    v1309 = curand_normal(&v521);
                    bool v1310;
                    v1310 = v1299 >= 0.1f;
                    float v1311;
                    if (v1310){
                        v1311 = v1299;
                    } else {
                        v1311 = 0.1f;
                    }
                    float v1312;
                    v1312 = v1309 * v1311;
                    float v1313;
                    v1313 = v1312 + v1259;
                    float v1314;
                    if (v1308){
                        v1314 = v1307;
                    } else {
                        v1314 = v1313;
                    }
                    assert("Tensor range check" && 0 <= v1301 && v1301 < 1);
                    assert("Tensor range check" && 0 <= v1303 && v1303 < 4);
                    v1300[v1306] = v1314;
                    v1303 += 1 ;
                }
                v1301 += 1 ;
            }
            assert("Tensor range check" && 0 <= v1136 && v1136 < 256);
            assert("Tensor range check" && 0 <= v1141 && v1141 < 1);
            int v1315;
            v1315 = 0;
            while (while_method_6(v1315)){
                assert("Tensor range check" && 0 <= v1315 && v1315 < 1);
                int v1317;
                v1317 = 4 * v1315;
                int v1318;
                v1318 = v1317 + v1148;
                assert("Tensor range check" && 0 <= v1315 && v1315 < 1);
                int4* v1319;
                v1319 = reinterpret_cast<int4*>(v1300 + v1317);
                int4* v1320;
                v1320 = reinterpret_cast<int4*>(v528 + v1318);
                assert("Pointer alignment check" && reinterpret_cast<unsigned long long>(v1319) % 16 == 0 && reinterpret_cast<unsigned long long>(v1320) % 16 == 0);
                *v1320 = *v1319;
                v1315 += 1 ;
            }
            v1136 += 24 ;
        }
        int v1321;
        v1321 = threadIdx.x;
        bool v1322;
        v1322 = 0 <= v1321;
        bool v1323;
        v1323 = v1322 == false;
        if (v1323){
            assert("The index needs to be zero or positive." && v1322);
        } else {
        }
        int v1325;
        v1325 = v1321 % 1;
        int v1326;
        v1326 = v1321 % 256;
        int v1327;
        v1327 = v1321 / 256;
        bool v1328;
        v1328 = v1327 < 1;
        bool v1329;
        v1329 = v1328 == false;
        if (v1329){
            assert("The last element of the projection dimensions needs to be greater than the index remainder." && v1328);
        } else {
        }
        assert("Tensor range check" && 0 <= v1327 && v1327 < 1);
        assert("Tensor range check" && 0 <= v1326 && v1326 < 256);
        assert("Tensor range check" && 0 <= v1325 && v1325 < 1);
        int v1331;
        v1331 = 4 * v1325;
        int v1332;
        v1332 = 4 * v1326;
        int v1333;
        v1333 = v1332 + v1331;
        int v1334;
        v1334 = 1024 * v1327;
        int v1335;
        v1335 = v1334 + v1333;
        assert("Tensor range check" && 0 <= v1327 && v1327 < 1);
        assert("Tensor range check" && 0 <= v1326 && v1326 < 256);
        assert("Tensor range check" && 0 <= v1325 && v1325 < 1);
        int v1336;
        v1336 = blockIdx.x;
        int v1337;
        v1337 = v1336;
        while (while_method_28(v1337)){
            bool v1339;
            v1339 = 0 <= v1337;
            bool v1340;
            v1340 = v1339 == false;
            if (v1340){
                assert("The index needs to be zero or positive." && v1339);
            } else {
            }
            int v1342;
            v1342 = v1337 % 1;
            bool v1343;
            v1343 = v1337 < 256;
            bool v1344;
            v1344 = v1343 == false;
            if (v1344){
                assert("The last element of the projection dimensions needs to be greater than the index remainder." && v1343);
            } else {
            }
            assert("Tensor range check" && 0 <= v1337 && v1337 < 256);
            assert("Tensor range check" && 0 <= v1342 && v1342 < 1);
            int v1346;
            v1346 = 1024 * v1342;
            int v1347;
            v1347 = v1346 + v1335;
            int v1348;
            v1348 = 1024 * v1337;
            int v1349;
            v1349 = v1348 + v1347;
            float v1350[4];
            int v1351[4];
            int v1352;
            v1352 = 0;
            while (while_method_6(v1352)){
                assert("Tensor range check" && 0 <= v1352 && v1352 < 1);
                int v1354;
                v1354 = 4 * v1352;
                assert("Tensor range check" && 0 <= v1352 && v1352 < 1);
                int v1355;
                v1355 = v1354 + v1349;
                int4* v1356;
                v1356 = reinterpret_cast<int4*>(v532 + v1355);
                int4* v1357;
                v1357 = reinterpret_cast<int4*>(v1350 + v1354);
                assert("Pointer alignment check" && reinterpret_cast<unsigned long long>(v1356) % 16 == 0 && reinterpret_cast<unsigned long long>(v1357) % 16 == 0);
                *v1357 = *v1356;
                v1352 += 1 ;
            }
            int v1358;
            v1358 = 0;
            while (while_method_6(v1358)){
                int v1360;
                v1360 = 0;
                while (while_method_3(v1360)){
                    bool v1362;
                    v1362 = 0 <= v1360;
                    bool v1364;
                    if (v1362){
                        bool v1363;
                        v1363 = v1360 < 4;
                        v1364 = v1363;
                    } else {
                        v1364 = false;
                    }
                    bool v1365;
                    v1365 = v1364 == false;
                    if (v1365){
                        assert("The indices should be inside the range of the dimension." && v1364);
                    } else {
                    }
                    bool v1367;
                    v1367 = 0 <= v1325;
                    bool v1369;
                    if (v1367){
                        bool v1368;
                        v1368 = v1325 < 1;
                        v1369 = v1368;
                    } else {
                        v1369 = false;
                    }
                    bool v1370;
                    v1370 = v1369 == false;
                    if (v1370){
                        assert("The indices should be inside the range of the dimension." && v1369);
                    } else {
                    }
                    int v1372;
                    v1372 = v1325 * 4;
                    int v1373;
                    v1373 = v1360 + v1372;
                    bool v1374;
                    v1374 = 0 <= v1358;
                    bool v1376;
                    if (v1374){
                        bool v1375;
                        v1375 = v1358 < 1;
                        v1376 = v1375;
                    } else {
                        v1376 = false;
                    }
                    bool v1377;
                    v1377 = v1376 == false;
                    if (v1377){
                        assert("The indices should be inside the range of the dimension." && v1376);
                    } else {
                    }
                    int v1379;
                    v1379 = v1358 * 4;
                    int v1380;
                    v1380 = v1373 + v1379;
                    assert("Tensor range check" && 0 <= v1358 && v1358 < 1);
                    assert("Tensor range check" && 0 <= v1360 && v1360 < 4);
                    int v1381;
                    v1381 = 4 * v1358;
                    int v1382;
                    v1382 = v1381 + v1360;
                    v1351[v1382] = v1380;
                    v1360 += 1 ;
                }
                v1358 += 1 ;
            }
            bool v1383;
            v1383 = 0 <= v1327;
            bool v1384;
            v1384 = v1383 && v1328;
            bool v1385;
            v1385 = v1384 == false;
            if (v1385){
                assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v1384);
            } else {
            }
            bool v1387;
            v1387 = 0 <= v1326;
            bool v1389;
            if (v1387){
                bool v1388;
                v1388 = v1326 < 256;
                v1389 = v1388;
            } else {
                v1389 = false;
            }
            bool v1390;
            v1390 = v1389 == false;
            if (v1390){
                assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v1389);
            } else {
            }
            bool v1392;
            v1392 = v1339 && v1343;
            bool v1393;
            v1393 = v1392 == false;
            if (v1393){
                assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v1392);
            } else {
            }
            bool v1395;
            v1395 = 0 <= v1342;
            bool v1397;
            if (v1395){
                bool v1396;
                v1396 = v1342 < 1;
                v1397 = v1396;
            } else {
                v1397 = false;
            }
            bool v1398;
            v1398 = v1397 == false;
            if (v1398){
                assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v1397);
            } else {
            }
            int v1400;
            v1400 = v1342 * 256;
            int v1401;
            v1401 = v1337 + v1327;
            int v1402;
            v1402 = v1400 + v1326;
            bool v1403[4];
            int v1404;
            v1404 = 0;
            while (while_method_6(v1404)){
                int v1406;
                v1406 = 0;
                while (while_method_3(v1406)){
                    assert("Tensor range check" && 0 <= v1404 && v1404 < 1);
                    assert("Tensor range check" && 0 <= v1406 && v1406 < 4);
                    int v1408;
                    v1408 = 4 * v1404;
                    int v1409;
                    v1409 = v1408 + v1406;
                    int v1410;
                    v1410 = v1351[v1409];
                    assert("Tensor range check" && 0 <= v1410 && v1410 < 4);
                    bool v1411;
                    v1411 = v550[v1410];
                    assert("Tensor range check" && 0 <= v1404 && v1404 < 1);
                    assert("Tensor range check" && 0 <= v1406 && v1406 < 4);
                    v1403[v1409] = v1411;
                    v1406 += 1 ;
                }
                v1404 += 1 ;
            }
            int v1412[4];
            int v1413;
            v1413 = 0;
            while (while_method_6(v1413)){
                int v1415;
                v1415 = 0;
                while (while_method_3(v1415)){
                    assert("Tensor range check" && 0 <= v1413 && v1413 < 1);
                    assert("Tensor range check" && 0 <= v1415 && v1415 < 4);
                    int v1417;
                    v1417 = 4 * v1413;
                    int v1418;
                    v1418 = v1417 + v1415;
                    bool v1419;
                    v1419 = v1403[v1418];
                    int v1420;
                    if (v1419){
                        v1420 = 1;
                    } else {
                        v1420 = 0;
                    }
                    assert("Tensor range check" && 0 <= v1413 && v1413 < 1);
                    assert("Tensor range check" && 0 <= v1415 && v1415 < 4);
                    v1412[v1418] = v1420;
                    v1415 += 1 ;
                }
                v1413 += 1 ;
            }
            int v1421;
            v1421 = 0;
            int v1422;
            v1422 = 0;
            while (while_method_6(v1422)){
                int v1424;
                v1424 = 0;
                while (while_method_3(v1424)){
                    assert("Tensor range check" && 0 <= v1422 && v1422 < 1);
                    assert("Tensor range check" && 0 <= v1424 && v1424 < 4);
                    int v1426;
                    v1426 = 4 * v1422;
                    int v1427;
                    v1427 = v1426 + v1424;
                    int v1428;
                    v1428 = v1412[v1427];
                    int v1429;
                    v1429 = v1421 + v1428;
                    v1421 = v1429;
                    v1424 += 1 ;
                }
                v1422 += 1 ;
            }
            auto v1430 = cooperative_groups::coalesced_threads();
            int v1431;
            v1431 = threadIdx.x;
            auto v1432 = cooperative_groups::labeled_partition(v1430,v1431);
            Closure1 v1433{};
            int v1434;
            v1434 = cooperative_groups::reduce(v1432, v1421, v1433);
            float v1435;
            v1435 = (float)v1434;
            float v1436[4];
            int v1437;
            v1437 = 0;
            while (while_method_6(v1437)){
                int v1439;
                v1439 = 0;
                while (while_method_3(v1439)){
                    assert("Tensor range check" && 0 <= v1437 && v1437 < 1);
                    assert("Tensor range check" && 0 <= v1439 && v1439 < 4);
                    int v1441;
                    v1441 = 4 * v1437;
                    int v1442;
                    v1442 = v1441 + v1439;
                    float v1443;
                    v1443 = v1350[v1442];
                    bool v1444;
                    v1444 = v1403[v1442];
                    float v1445;
                    if (v1444){
                        v1445 = v1443;
                    } else {
                        v1445 = 0.0f;
                    }
                    assert("Tensor range check" && 0 <= v1437 && v1437 < 1);
                    assert("Tensor range check" && 0 <= v1439 && v1439 < 4);
                    v1436[v1442] = v1445;
                    v1439 += 1 ;
                }
                v1437 += 1 ;
            }
            float v1446;
            v1446 = 0.0f;
            int v1447;
            v1447 = 0;
            while (while_method_6(v1447)){
                int v1449;
                v1449 = 0;
                while (while_method_3(v1449)){
                    assert("Tensor range check" && 0 <= v1447 && v1447 < 1);
                    assert("Tensor range check" && 0 <= v1449 && v1449 < 4);
                    int v1451;
                    v1451 = 4 * v1447;
                    int v1452;
                    v1452 = v1451 + v1449;
                    float v1453;
                    v1453 = v1436[v1452];
                    float v1454;
                    v1454 = v1446 + v1453;
                    v1446 = v1454;
                    v1449 += 1 ;
                }
                v1447 += 1 ;
            }
            auto v1455 = cooperative_groups::coalesced_threads();
            int v1456;
            v1456 = threadIdx.x;
            auto v1457 = cooperative_groups::labeled_partition(v1455,v1456);
            Closure0 v1458{};
            float v1459;
            v1459 = cooperative_groups::reduce(v1457, v1446, v1458);
            float v1460;
            v1460 = v1459 / v1435;
            float v1461[4];
            int v1462;
            v1462 = 0;
            while (while_method_6(v1462)){
                int v1464;
                v1464 = 0;
                while (while_method_3(v1464)){
                    assert("Tensor range check" && 0 <= v1462 && v1462 < 1);
                    assert("Tensor range check" && 0 <= v1464 && v1464 < 4);
                    int v1466;
                    v1466 = 4 * v1462;
                    int v1467;
                    v1467 = v1466 + v1464;
                    float v1468;
                    v1468 = v1350[v1467];
                    float v1469;
                    v1469 = v1468 - v1460;
                    float v1470;
                    v1470 = v1469 * v1469;
                    assert("Tensor range check" && 0 <= v1462 && v1462 < 1);
                    assert("Tensor range check" && 0 <= v1464 && v1464 < 4);
                    v1461[v1467] = v1470;
                    v1464 += 1 ;
                }
                v1462 += 1 ;
            }
            float v1471[4];
            int v1472;
            v1472 = 0;
            while (while_method_6(v1472)){
                int v1474;
                v1474 = 0;
                while (while_method_3(v1474)){
                    assert("Tensor range check" && 0 <= v1472 && v1472 < 1);
                    assert("Tensor range check" && 0 <= v1474 && v1474 < 4);
                    int v1476;
                    v1476 = 4 * v1472;
                    int v1477;
                    v1477 = v1476 + v1474;
                    float v1478;
                    v1478 = v1461[v1477];
                    bool v1479;
                    v1479 = v1403[v1477];
                    float v1480;
                    if (v1479){
                        v1480 = v1478;
                    } else {
                        v1480 = 0.0f;
                    }
                    assert("Tensor range check" && 0 <= v1472 && v1472 < 1);
                    assert("Tensor range check" && 0 <= v1474 && v1474 < 4);
                    v1471[v1477] = v1480;
                    v1474 += 1 ;
                }
                v1472 += 1 ;
            }
            float v1481;
            v1481 = 0.0f;
            int v1482;
            v1482 = 0;
            while (while_method_6(v1482)){
                int v1484;
                v1484 = 0;
                while (while_method_3(v1484)){
                    assert("Tensor range check" && 0 <= v1482 && v1482 < 1);
                    assert("Tensor range check" && 0 <= v1484 && v1484 < 4);
                    int v1486;
                    v1486 = 4 * v1482;
                    int v1487;
                    v1487 = v1486 + v1484;
                    float v1488;
                    v1488 = v1471[v1487];
                    float v1489;
                    v1489 = v1481 + v1488;
                    v1481 = v1489;
                    v1484 += 1 ;
                }
                v1482 += 1 ;
            }
            auto v1490 = cooperative_groups::coalesced_threads();
            int v1491;
            v1491 = threadIdx.x;
            auto v1492 = cooperative_groups::labeled_partition(v1490,v1491);
            float v1493;
            v1493 = cooperative_groups::reduce(v1492, v1481, v1458);
            float v1494;
            v1494 = v1493 / v1435;
            float v1495;
            v1495 = sqrt(v1494);
            bool v1496;
            v1496 = v1435 > 1.0f;
            float v1500;
            if (v1496){
                float v1497;
                v1497 = v1495 * v1435;
                float v1498;
                v1498 = v1435 - 1.0f;
                float v1499;
                v1499 = v1497 / v1498;
                v1500 = v1499;
            } else {
                v1500 = 0.0f;
            }
            float v1501[4];
            int v1502;
            v1502 = 0;
            while (while_method_6(v1502)){
                int v1504;
                v1504 = 0;
                while (while_method_3(v1504)){
                    assert("Tensor range check" && 0 <= v1502 && v1502 < 1);
                    assert("Tensor range check" && 0 <= v1504 && v1504 < 4);
                    int v1506;
                    v1506 = 4 * v1502;
                    int v1507;
                    v1507 = v1506 + v1504;
                    float v1508;
                    v1508 = v1350[v1507];
                    bool v1509;
                    v1509 = v1403[v1507];
                    float v1510;
                    v1510 = curand_normal(&v521);
                    bool v1511;
                    v1511 = v1500 >= 0.1f;
                    float v1512;
                    if (v1511){
                        v1512 = v1500;
                    } else {
                        v1512 = 0.1f;
                    }
                    float v1513;
                    v1513 = v1510 * v1512;
                    float v1514;
                    v1514 = v1513 + v1460;
                    float v1515;
                    if (v1509){
                        v1515 = v1508;
                    } else {
                        v1515 = v1514;
                    }
                    assert("Tensor range check" && 0 <= v1502 && v1502 < 1);
                    assert("Tensor range check" && 0 <= v1504 && v1504 < 4);
                    v1501[v1507] = v1515;
                    v1504 += 1 ;
                }
                v1502 += 1 ;
            }
            assert("Tensor range check" && 0 <= v1337 && v1337 < 256);
            assert("Tensor range check" && 0 <= v1342 && v1342 < 1);
            int v1516;
            v1516 = 0;
            while (while_method_6(v1516)){
                assert("Tensor range check" && 0 <= v1516 && v1516 < 1);
                int v1518;
                v1518 = 4 * v1516;
                int v1519;
                v1519 = v1518 + v1349;
                assert("Tensor range check" && 0 <= v1516 && v1516 < 1);
                int4* v1520;
                v1520 = reinterpret_cast<int4*>(v1501 + v1518);
                int4* v1521;
                v1521 = reinterpret_cast<int4*>(v532 + v1519);
                assert("Pointer alignment check" && reinterpret_cast<unsigned long long>(v1520) % 16 == 0 && reinterpret_cast<unsigned long long>(v1521) % 16 == 0);
                *v1521 = *v1520;
                v1516 += 1 ;
            }
            v1337 += 24 ;
        }
        int v1522;
        v1522 = threadIdx.x;
        bool v1523;
        v1523 = 0 <= v1522;
        bool v1524;
        v1524 = v1523 == false;
        if (v1524){
            assert("The index needs to be zero or positive." && v1523);
        } else {
        }
        int v1526;
        v1526 = v1522 % 1;
        int v1527;
        v1527 = v1522 % 256;
        int v1528;
        v1528 = v1522 / 256;
        bool v1529;
        v1529 = v1528 < 1;
        bool v1530;
        v1530 = v1529 == false;
        if (v1530){
            assert("The last element of the projection dimensions needs to be greater than the index remainder." && v1529);
        } else {
        }
        assert("Tensor range check" && 0 <= v1528 && v1528 < 1);
        assert("Tensor range check" && 0 <= v1527 && v1527 < 256);
        assert("Tensor range check" && 0 <= v1526 && v1526 < 1);
        int v1532;
        v1532 = 4 * v1526;
        int v1533;
        v1533 = 4 * v1527;
        int v1534;
        v1534 = v1533 + v1532;
        int v1535;
        v1535 = 1024 * v1528;
        int v1536;
        v1536 = v1535 + v1534;
        assert("Tensor range check" && 0 <= v1528 && v1528 < 1);
        assert("Tensor range check" && 0 <= v1527 && v1527 < 256);
        assert("Tensor range check" && 0 <= v1526 && v1526 < 1);
        int v1537;
        v1537 = blockIdx.x;
        int v1538;
        v1538 = v1537;
        while (while_method_28(v1538)){
            bool v1540;
            v1540 = 0 <= v1538;
            bool v1541;
            v1541 = v1540 == false;
            if (v1541){
                assert("The index needs to be zero or positive." && v1540);
            } else {
            }
            int v1543;
            v1543 = v1538 % 1;
            bool v1544;
            v1544 = v1538 < 256;
            bool v1545;
            v1545 = v1544 == false;
            if (v1545){
                assert("The last element of the projection dimensions needs to be greater than the index remainder." && v1544);
            } else {
            }
            assert("Tensor range check" && 0 <= v1538 && v1538 < 256);
            assert("Tensor range check" && 0 <= v1543 && v1543 < 1);
            int v1547;
            v1547 = 1024 * v1543;
            int v1548;
            v1548 = v1547 + v1536;
            int v1549;
            v1549 = 1024 * v1538;
            int v1550;
            v1550 = v1549 + v1548;
            float v1551[4];
            int v1552[4];
            int v1553;
            v1553 = 0;
            while (while_method_6(v1553)){
                assert("Tensor range check" && 0 <= v1553 && v1553 < 1);
                int v1555;
                v1555 = 4 * v1553;
                assert("Tensor range check" && 0 <= v1553 && v1553 < 1);
                int v1556;
                v1556 = v1555 + v1550;
                int4* v1557;
                v1557 = reinterpret_cast<int4*>(v536 + v1556);
                int4* v1558;
                v1558 = reinterpret_cast<int4*>(v1551 + v1555);
                assert("Pointer alignment check" && reinterpret_cast<unsigned long long>(v1557) % 16 == 0 && reinterpret_cast<unsigned long long>(v1558) % 16 == 0);
                *v1558 = *v1557;
                v1553 += 1 ;
            }
            int v1559;
            v1559 = 0;
            while (while_method_6(v1559)){
                int v1561;
                v1561 = 0;
                while (while_method_3(v1561)){
                    bool v1563;
                    v1563 = 0 <= v1561;
                    bool v1565;
                    if (v1563){
                        bool v1564;
                        v1564 = v1561 < 4;
                        v1565 = v1564;
                    } else {
                        v1565 = false;
                    }
                    bool v1566;
                    v1566 = v1565 == false;
                    if (v1566){
                        assert("The indices should be inside the range of the dimension." && v1565);
                    } else {
                    }
                    bool v1568;
                    v1568 = 0 <= v1526;
                    bool v1570;
                    if (v1568){
                        bool v1569;
                        v1569 = v1526 < 1;
                        v1570 = v1569;
                    } else {
                        v1570 = false;
                    }
                    bool v1571;
                    v1571 = v1570 == false;
                    if (v1571){
                        assert("The indices should be inside the range of the dimension." && v1570);
                    } else {
                    }
                    int v1573;
                    v1573 = v1526 * 4;
                    int v1574;
                    v1574 = v1561 + v1573;
                    bool v1575;
                    v1575 = 0 <= v1559;
                    bool v1577;
                    if (v1575){
                        bool v1576;
                        v1576 = v1559 < 1;
                        v1577 = v1576;
                    } else {
                        v1577 = false;
                    }
                    bool v1578;
                    v1578 = v1577 == false;
                    if (v1578){
                        assert("The indices should be inside the range of the dimension." && v1577);
                    } else {
                    }
                    int v1580;
                    v1580 = v1559 * 4;
                    int v1581;
                    v1581 = v1574 + v1580;
                    assert("Tensor range check" && 0 <= v1559 && v1559 < 1);
                    assert("Tensor range check" && 0 <= v1561 && v1561 < 4);
                    int v1582;
                    v1582 = 4 * v1559;
                    int v1583;
                    v1583 = v1582 + v1561;
                    v1552[v1583] = v1581;
                    v1561 += 1 ;
                }
                v1559 += 1 ;
            }
            bool v1584;
            v1584 = 0 <= v1528;
            bool v1585;
            v1585 = v1584 && v1529;
            bool v1586;
            v1586 = v1585 == false;
            if (v1586){
                assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v1585);
            } else {
            }
            bool v1588;
            v1588 = 0 <= v1527;
            bool v1590;
            if (v1588){
                bool v1589;
                v1589 = v1527 < 256;
                v1590 = v1589;
            } else {
                v1590 = false;
            }
            bool v1591;
            v1591 = v1590 == false;
            if (v1591){
                assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v1590);
            } else {
            }
            bool v1593;
            v1593 = v1540 && v1544;
            bool v1594;
            v1594 = v1593 == false;
            if (v1594){
                assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v1593);
            } else {
            }
            bool v1596;
            v1596 = 0 <= v1543;
            bool v1598;
            if (v1596){
                bool v1597;
                v1597 = v1543 < 1;
                v1598 = v1597;
            } else {
                v1598 = false;
            }
            bool v1599;
            v1599 = v1598 == false;
            if (v1599){
                assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v1598);
            } else {
            }
            int v1601;
            v1601 = v1543 * 256;
            int v1602;
            v1602 = v1538 + v1528;
            int v1603;
            v1603 = v1601 + v1527;
            bool v1604[4];
            int v1605;
            v1605 = 0;
            while (while_method_6(v1605)){
                int v1607;
                v1607 = 0;
                while (while_method_3(v1607)){
                    assert("Tensor range check" && 0 <= v1605 && v1605 < 1);
                    assert("Tensor range check" && 0 <= v1607 && v1607 < 4);
                    int v1609;
                    v1609 = 4 * v1605;
                    int v1610;
                    v1610 = v1609 + v1607;
                    int v1611;
                    v1611 = v1552[v1610];
                    assert("Tensor range check" && 0 <= v1611 && v1611 < 4);
                    bool v1612;
                    v1612 = v550[v1611];
                    assert("Tensor range check" && 0 <= v1605 && v1605 < 1);
                    assert("Tensor range check" && 0 <= v1607 && v1607 < 4);
                    v1604[v1610] = v1612;
                    v1607 += 1 ;
                }
                v1605 += 1 ;
            }
            int v1613[4];
            int v1614;
            v1614 = 0;
            while (while_method_6(v1614)){
                int v1616;
                v1616 = 0;
                while (while_method_3(v1616)){
                    assert("Tensor range check" && 0 <= v1614 && v1614 < 1);
                    assert("Tensor range check" && 0 <= v1616 && v1616 < 4);
                    int v1618;
                    v1618 = 4 * v1614;
                    int v1619;
                    v1619 = v1618 + v1616;
                    bool v1620;
                    v1620 = v1604[v1619];
                    int v1621;
                    if (v1620){
                        v1621 = 1;
                    } else {
                        v1621 = 0;
                    }
                    assert("Tensor range check" && 0 <= v1614 && v1614 < 1);
                    assert("Tensor range check" && 0 <= v1616 && v1616 < 4);
                    v1613[v1619] = v1621;
                    v1616 += 1 ;
                }
                v1614 += 1 ;
            }
            int v1622;
            v1622 = 0;
            int v1623;
            v1623 = 0;
            while (while_method_6(v1623)){
                int v1625;
                v1625 = 0;
                while (while_method_3(v1625)){
                    assert("Tensor range check" && 0 <= v1623 && v1623 < 1);
                    assert("Tensor range check" && 0 <= v1625 && v1625 < 4);
                    int v1627;
                    v1627 = 4 * v1623;
                    int v1628;
                    v1628 = v1627 + v1625;
                    int v1629;
                    v1629 = v1613[v1628];
                    int v1630;
                    v1630 = v1622 + v1629;
                    v1622 = v1630;
                    v1625 += 1 ;
                }
                v1623 += 1 ;
            }
            auto v1631 = cooperative_groups::coalesced_threads();
            int v1632;
            v1632 = threadIdx.x;
            auto v1633 = cooperative_groups::labeled_partition(v1631,v1632);
            Closure1 v1634{};
            int v1635;
            v1635 = cooperative_groups::reduce(v1633, v1622, v1634);
            float v1636;
            v1636 = (float)v1635;
            float v1637[4];
            int v1638;
            v1638 = 0;
            while (while_method_6(v1638)){
                int v1640;
                v1640 = 0;
                while (while_method_3(v1640)){
                    assert("Tensor range check" && 0 <= v1638 && v1638 < 1);
                    assert("Tensor range check" && 0 <= v1640 && v1640 < 4);
                    int v1642;
                    v1642 = 4 * v1638;
                    int v1643;
                    v1643 = v1642 + v1640;
                    float v1644;
                    v1644 = v1551[v1643];
                    bool v1645;
                    v1645 = v1604[v1643];
                    float v1646;
                    if (v1645){
                        v1646 = v1644;
                    } else {
                        v1646 = 0.0f;
                    }
                    assert("Tensor range check" && 0 <= v1638 && v1638 < 1);
                    assert("Tensor range check" && 0 <= v1640 && v1640 < 4);
                    v1637[v1643] = v1646;
                    v1640 += 1 ;
                }
                v1638 += 1 ;
            }
            float v1647;
            v1647 = 0.0f;
            int v1648;
            v1648 = 0;
            while (while_method_6(v1648)){
                int v1650;
                v1650 = 0;
                while (while_method_3(v1650)){
                    assert("Tensor range check" && 0 <= v1648 && v1648 < 1);
                    assert("Tensor range check" && 0 <= v1650 && v1650 < 4);
                    int v1652;
                    v1652 = 4 * v1648;
                    int v1653;
                    v1653 = v1652 + v1650;
                    float v1654;
                    v1654 = v1637[v1653];
                    float v1655;
                    v1655 = v1647 + v1654;
                    v1647 = v1655;
                    v1650 += 1 ;
                }
                v1648 += 1 ;
            }
            auto v1656 = cooperative_groups::coalesced_threads();
            int v1657;
            v1657 = threadIdx.x;
            auto v1658 = cooperative_groups::labeled_partition(v1656,v1657);
            Closure0 v1659{};
            float v1660;
            v1660 = cooperative_groups::reduce(v1658, v1647, v1659);
            float v1661;
            v1661 = v1660 / v1636;
            float v1662[4];
            int v1663;
            v1663 = 0;
            while (while_method_6(v1663)){
                int v1665;
                v1665 = 0;
                while (while_method_3(v1665)){
                    assert("Tensor range check" && 0 <= v1663 && v1663 < 1);
                    assert("Tensor range check" && 0 <= v1665 && v1665 < 4);
                    int v1667;
                    v1667 = 4 * v1663;
                    int v1668;
                    v1668 = v1667 + v1665;
                    float v1669;
                    v1669 = v1551[v1668];
                    float v1670;
                    v1670 = v1669 - v1661;
                    float v1671;
                    v1671 = v1670 * v1670;
                    assert("Tensor range check" && 0 <= v1663 && v1663 < 1);
                    assert("Tensor range check" && 0 <= v1665 && v1665 < 4);
                    v1662[v1668] = v1671;
                    v1665 += 1 ;
                }
                v1663 += 1 ;
            }
            float v1672[4];
            int v1673;
            v1673 = 0;
            while (while_method_6(v1673)){
                int v1675;
                v1675 = 0;
                while (while_method_3(v1675)){
                    assert("Tensor range check" && 0 <= v1673 && v1673 < 1);
                    assert("Tensor range check" && 0 <= v1675 && v1675 < 4);
                    int v1677;
                    v1677 = 4 * v1673;
                    int v1678;
                    v1678 = v1677 + v1675;
                    float v1679;
                    v1679 = v1662[v1678];
                    bool v1680;
                    v1680 = v1604[v1678];
                    float v1681;
                    if (v1680){
                        v1681 = v1679;
                    } else {
                        v1681 = 0.0f;
                    }
                    assert("Tensor range check" && 0 <= v1673 && v1673 < 1);
                    assert("Tensor range check" && 0 <= v1675 && v1675 < 4);
                    v1672[v1678] = v1681;
                    v1675 += 1 ;
                }
                v1673 += 1 ;
            }
            float v1682;
            v1682 = 0.0f;
            int v1683;
            v1683 = 0;
            while (while_method_6(v1683)){
                int v1685;
                v1685 = 0;
                while (while_method_3(v1685)){
                    assert("Tensor range check" && 0 <= v1683 && v1683 < 1);
                    assert("Tensor range check" && 0 <= v1685 && v1685 < 4);
                    int v1687;
                    v1687 = 4 * v1683;
                    int v1688;
                    v1688 = v1687 + v1685;
                    float v1689;
                    v1689 = v1672[v1688];
                    float v1690;
                    v1690 = v1682 + v1689;
                    v1682 = v1690;
                    v1685 += 1 ;
                }
                v1683 += 1 ;
            }
            auto v1691 = cooperative_groups::coalesced_threads();
            int v1692;
            v1692 = threadIdx.x;
            auto v1693 = cooperative_groups::labeled_partition(v1691,v1692);
            float v1694;
            v1694 = cooperative_groups::reduce(v1693, v1682, v1659);
            float v1695;
            v1695 = v1694 / v1636;
            float v1696;
            v1696 = sqrt(v1695);
            bool v1697;
            v1697 = v1636 > 1.0f;
            float v1701;
            if (v1697){
                float v1698;
                v1698 = v1696 * v1636;
                float v1699;
                v1699 = v1636 - 1.0f;
                float v1700;
                v1700 = v1698 / v1699;
                v1701 = v1700;
            } else {
                v1701 = 0.0f;
            }
            float v1702[4];
            int v1703;
            v1703 = 0;
            while (while_method_6(v1703)){
                int v1705;
                v1705 = 0;
                while (while_method_3(v1705)){
                    assert("Tensor range check" && 0 <= v1703 && v1703 < 1);
                    assert("Tensor range check" && 0 <= v1705 && v1705 < 4);
                    int v1707;
                    v1707 = 4 * v1703;
                    int v1708;
                    v1708 = v1707 + v1705;
                    float v1709;
                    v1709 = v1551[v1708];
                    bool v1710;
                    v1710 = v1604[v1708];
                    float v1711;
                    v1711 = curand_normal(&v521);
                    bool v1712;
                    v1712 = v1701 >= 0.1f;
                    float v1713;
                    if (v1712){
                        v1713 = v1701;
                    } else {
                        v1713 = 0.1f;
                    }
                    float v1714;
                    v1714 = v1711 * v1713;
                    float v1715;
                    v1715 = v1714 + v1661;
                    float v1716;
                    if (v1710){
                        v1716 = v1709;
                    } else {
                        v1716 = v1715;
                    }
                    assert("Tensor range check" && 0 <= v1703 && v1703 < 1);
                    assert("Tensor range check" && 0 <= v1705 && v1705 < 4);
                    v1702[v1708] = v1716;
                    v1705 += 1 ;
                }
                v1703 += 1 ;
            }
            assert("Tensor range check" && 0 <= v1538 && v1538 < 256);
            assert("Tensor range check" && 0 <= v1543 && v1543 < 1);
            int v1717;
            v1717 = 0;
            while (while_method_6(v1717)){
                assert("Tensor range check" && 0 <= v1717 && v1717 < 1);
                int v1719;
                v1719 = 4 * v1717;
                int v1720;
                v1720 = v1719 + v1550;
                assert("Tensor range check" && 0 <= v1717 && v1717 < 1);
                int4* v1721;
                v1721 = reinterpret_cast<int4*>(v1702 + v1719);
                int4* v1722;
                v1722 = reinterpret_cast<int4*>(v536 + v1720);
                assert("Pointer alignment check" && reinterpret_cast<unsigned long long>(v1721) % 16 == 0 && reinterpret_cast<unsigned long long>(v1722) % 16 == 0);
                *v1722 = *v1721;
                v1717 += 1 ;
            }
            v1538 += 24 ;
        }
        int v1723;
        v1723 = threadIdx.x;
        bool v1724;
        v1724 = 0 <= v1723;
        bool v1725;
        v1725 = v1724 == false;
        if (v1725){
            assert("The index needs to be zero or positive." && v1724);
        } else {
        }
        int v1727;
        v1727 = v1723 % 1;
        int v1728;
        v1728 = v1723 % 256;
        int v1729;
        v1729 = v1723 / 256;
        bool v1730;
        v1730 = v1729 < 1;
        bool v1731;
        v1731 = v1730 == false;
        if (v1731){
            assert("The last element of the projection dimensions needs to be greater than the index remainder." && v1730);
        } else {
        }
        assert("Tensor range check" && 0 <= v1729 && v1729 < 1);
        assert("Tensor range check" && 0 <= v1728 && v1728 < 256);
        assert("Tensor range check" && 0 <= v1727 && v1727 < 1);
        int v1733;
        v1733 = 4 * v1727;
        int v1734;
        v1734 = 4 * v1728;
        int v1735;
        v1735 = v1734 + v1733;
        int v1736;
        v1736 = 1024 * v1729;
        int v1737;
        v1737 = v1736 + v1735;
        assert("Tensor range check" && 0 <= v1729 && v1729 < 1);
        assert("Tensor range check" && 0 <= v1728 && v1728 < 256);
        assert("Tensor range check" && 0 <= v1727 && v1727 < 1);
        int v1738;
        v1738 = blockIdx.x;
        int v1739;
        v1739 = v1738;
        while (while_method_28(v1739)){
            bool v1741;
            v1741 = 0 <= v1739;
            bool v1742;
            v1742 = v1741 == false;
            if (v1742){
                assert("The index needs to be zero or positive." && v1741);
            } else {
            }
            int v1744;
            v1744 = v1739 % 1;
            bool v1745;
            v1745 = v1739 < 256;
            bool v1746;
            v1746 = v1745 == false;
            if (v1746){
                assert("The last element of the projection dimensions needs to be greater than the index remainder." && v1745);
            } else {
            }
            assert("Tensor range check" && 0 <= v1739 && v1739 < 256);
            assert("Tensor range check" && 0 <= v1744 && v1744 < 1);
            int v1748;
            v1748 = 1024 * v1744;
            int v1749;
            v1749 = v1748 + v1737;
            int v1750;
            v1750 = 1024 * v1739;
            int v1751;
            v1751 = v1750 + v1749;
            float v1752[4];
            int v1753[4];
            int v1754;
            v1754 = 0;
            while (while_method_6(v1754)){
                assert("Tensor range check" && 0 <= v1754 && v1754 < 1);
                int v1756;
                v1756 = 4 * v1754;
                assert("Tensor range check" && 0 <= v1754 && v1754 < 1);
                int v1757;
                v1757 = v1756 + v1751;
                int4* v1758;
                v1758 = reinterpret_cast<int4*>(v540 + v1757);
                int4* v1759;
                v1759 = reinterpret_cast<int4*>(v1752 + v1756);
                assert("Pointer alignment check" && reinterpret_cast<unsigned long long>(v1758) % 16 == 0 && reinterpret_cast<unsigned long long>(v1759) % 16 == 0);
                *v1759 = *v1758;
                v1754 += 1 ;
            }
            int v1760;
            v1760 = 0;
            while (while_method_6(v1760)){
                int v1762;
                v1762 = 0;
                while (while_method_3(v1762)){
                    bool v1764;
                    v1764 = 0 <= v1762;
                    bool v1766;
                    if (v1764){
                        bool v1765;
                        v1765 = v1762 < 4;
                        v1766 = v1765;
                    } else {
                        v1766 = false;
                    }
                    bool v1767;
                    v1767 = v1766 == false;
                    if (v1767){
                        assert("The indices should be inside the range of the dimension." && v1766);
                    } else {
                    }
                    bool v1769;
                    v1769 = 0 <= v1727;
                    bool v1771;
                    if (v1769){
                        bool v1770;
                        v1770 = v1727 < 1;
                        v1771 = v1770;
                    } else {
                        v1771 = false;
                    }
                    bool v1772;
                    v1772 = v1771 == false;
                    if (v1772){
                        assert("The indices should be inside the range of the dimension." && v1771);
                    } else {
                    }
                    int v1774;
                    v1774 = v1727 * 4;
                    int v1775;
                    v1775 = v1762 + v1774;
                    bool v1776;
                    v1776 = 0 <= v1760;
                    bool v1778;
                    if (v1776){
                        bool v1777;
                        v1777 = v1760 < 1;
                        v1778 = v1777;
                    } else {
                        v1778 = false;
                    }
                    bool v1779;
                    v1779 = v1778 == false;
                    if (v1779){
                        assert("The indices should be inside the range of the dimension." && v1778);
                    } else {
                    }
                    int v1781;
                    v1781 = v1760 * 4;
                    int v1782;
                    v1782 = v1775 + v1781;
                    assert("Tensor range check" && 0 <= v1760 && v1760 < 1);
                    assert("Tensor range check" && 0 <= v1762 && v1762 < 4);
                    int v1783;
                    v1783 = 4 * v1760;
                    int v1784;
                    v1784 = v1783 + v1762;
                    v1753[v1784] = v1782;
                    v1762 += 1 ;
                }
                v1760 += 1 ;
            }
            bool v1785;
            v1785 = 0 <= v1729;
            bool v1786;
            v1786 = v1785 && v1730;
            bool v1787;
            v1787 = v1786 == false;
            if (v1787){
                assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v1786);
            } else {
            }
            bool v1789;
            v1789 = 0 <= v1728;
            bool v1791;
            if (v1789){
                bool v1790;
                v1790 = v1728 < 256;
                v1791 = v1790;
            } else {
                v1791 = false;
            }
            bool v1792;
            v1792 = v1791 == false;
            if (v1792){
                assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v1791);
            } else {
            }
            bool v1794;
            v1794 = v1741 && v1745;
            bool v1795;
            v1795 = v1794 == false;
            if (v1795){
                assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v1794);
            } else {
            }
            bool v1797;
            v1797 = 0 <= v1744;
            bool v1799;
            if (v1797){
                bool v1798;
                v1798 = v1744 < 1;
                v1799 = v1798;
            } else {
                v1799 = false;
            }
            bool v1800;
            v1800 = v1799 == false;
            if (v1800){
                assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v1799);
            } else {
            }
            int v1802;
            v1802 = v1744 * 256;
            int v1803;
            v1803 = v1739 + v1729;
            int v1804;
            v1804 = v1802 + v1728;
            bool v1805[4];
            int v1806;
            v1806 = 0;
            while (while_method_6(v1806)){
                int v1808;
                v1808 = 0;
                while (while_method_3(v1808)){
                    assert("Tensor range check" && 0 <= v1806 && v1806 < 1);
                    assert("Tensor range check" && 0 <= v1808 && v1808 < 4);
                    int v1810;
                    v1810 = 4 * v1806;
                    int v1811;
                    v1811 = v1810 + v1808;
                    int v1812;
                    v1812 = v1753[v1811];
                    assert("Tensor range check" && 0 <= v1812 && v1812 < 4);
                    bool v1813;
                    v1813 = v550[v1812];
                    assert("Tensor range check" && 0 <= v1806 && v1806 < 1);
                    assert("Tensor range check" && 0 <= v1808 && v1808 < 4);
                    v1805[v1811] = v1813;
                    v1808 += 1 ;
                }
                v1806 += 1 ;
            }
            int v1814[4];
            int v1815;
            v1815 = 0;
            while (while_method_6(v1815)){
                int v1817;
                v1817 = 0;
                while (while_method_3(v1817)){
                    assert("Tensor range check" && 0 <= v1815 && v1815 < 1);
                    assert("Tensor range check" && 0 <= v1817 && v1817 < 4);
                    int v1819;
                    v1819 = 4 * v1815;
                    int v1820;
                    v1820 = v1819 + v1817;
                    bool v1821;
                    v1821 = v1805[v1820];
                    int v1822;
                    if (v1821){
                        v1822 = 1;
                    } else {
                        v1822 = 0;
                    }
                    assert("Tensor range check" && 0 <= v1815 && v1815 < 1);
                    assert("Tensor range check" && 0 <= v1817 && v1817 < 4);
                    v1814[v1820] = v1822;
                    v1817 += 1 ;
                }
                v1815 += 1 ;
            }
            int v1823;
            v1823 = 0;
            int v1824;
            v1824 = 0;
            while (while_method_6(v1824)){
                int v1826;
                v1826 = 0;
                while (while_method_3(v1826)){
                    assert("Tensor range check" && 0 <= v1824 && v1824 < 1);
                    assert("Tensor range check" && 0 <= v1826 && v1826 < 4);
                    int v1828;
                    v1828 = 4 * v1824;
                    int v1829;
                    v1829 = v1828 + v1826;
                    int v1830;
                    v1830 = v1814[v1829];
                    int v1831;
                    v1831 = v1823 + v1830;
                    v1823 = v1831;
                    v1826 += 1 ;
                }
                v1824 += 1 ;
            }
            auto v1832 = cooperative_groups::coalesced_threads();
            int v1833;
            v1833 = threadIdx.x;
            auto v1834 = cooperative_groups::labeled_partition(v1832,v1833);
            Closure1 v1835{};
            int v1836;
            v1836 = cooperative_groups::reduce(v1834, v1823, v1835);
            float v1837;
            v1837 = (float)v1836;
            float v1838[4];
            int v1839;
            v1839 = 0;
            while (while_method_6(v1839)){
                int v1841;
                v1841 = 0;
                while (while_method_3(v1841)){
                    assert("Tensor range check" && 0 <= v1839 && v1839 < 1);
                    assert("Tensor range check" && 0 <= v1841 && v1841 < 4);
                    int v1843;
                    v1843 = 4 * v1839;
                    int v1844;
                    v1844 = v1843 + v1841;
                    float v1845;
                    v1845 = v1752[v1844];
                    bool v1846;
                    v1846 = v1805[v1844];
                    float v1847;
                    if (v1846){
                        v1847 = v1845;
                    } else {
                        v1847 = 0.0f;
                    }
                    assert("Tensor range check" && 0 <= v1839 && v1839 < 1);
                    assert("Tensor range check" && 0 <= v1841 && v1841 < 4);
                    v1838[v1844] = v1847;
                    v1841 += 1 ;
                }
                v1839 += 1 ;
            }
            float v1848;
            v1848 = 0.0f;
            int v1849;
            v1849 = 0;
            while (while_method_6(v1849)){
                int v1851;
                v1851 = 0;
                while (while_method_3(v1851)){
                    assert("Tensor range check" && 0 <= v1849 && v1849 < 1);
                    assert("Tensor range check" && 0 <= v1851 && v1851 < 4);
                    int v1853;
                    v1853 = 4 * v1849;
                    int v1854;
                    v1854 = v1853 + v1851;
                    float v1855;
                    v1855 = v1838[v1854];
                    float v1856;
                    v1856 = v1848 + v1855;
                    v1848 = v1856;
                    v1851 += 1 ;
                }
                v1849 += 1 ;
            }
            auto v1857 = cooperative_groups::coalesced_threads();
            int v1858;
            v1858 = threadIdx.x;
            auto v1859 = cooperative_groups::labeled_partition(v1857,v1858);
            Closure0 v1860{};
            float v1861;
            v1861 = cooperative_groups::reduce(v1859, v1848, v1860);
            float v1862;
            v1862 = v1861 / v1837;
            float v1863[4];
            int v1864;
            v1864 = 0;
            while (while_method_6(v1864)){
                int v1866;
                v1866 = 0;
                while (while_method_3(v1866)){
                    assert("Tensor range check" && 0 <= v1864 && v1864 < 1);
                    assert("Tensor range check" && 0 <= v1866 && v1866 < 4);
                    int v1868;
                    v1868 = 4 * v1864;
                    int v1869;
                    v1869 = v1868 + v1866;
                    float v1870;
                    v1870 = v1752[v1869];
                    float v1871;
                    v1871 = v1870 - v1862;
                    float v1872;
                    v1872 = v1871 * v1871;
                    assert("Tensor range check" && 0 <= v1864 && v1864 < 1);
                    assert("Tensor range check" && 0 <= v1866 && v1866 < 4);
                    v1863[v1869] = v1872;
                    v1866 += 1 ;
                }
                v1864 += 1 ;
            }
            float v1873[4];
            int v1874;
            v1874 = 0;
            while (while_method_6(v1874)){
                int v1876;
                v1876 = 0;
                while (while_method_3(v1876)){
                    assert("Tensor range check" && 0 <= v1874 && v1874 < 1);
                    assert("Tensor range check" && 0 <= v1876 && v1876 < 4);
                    int v1878;
                    v1878 = 4 * v1874;
                    int v1879;
                    v1879 = v1878 + v1876;
                    float v1880;
                    v1880 = v1863[v1879];
                    bool v1881;
                    v1881 = v1805[v1879];
                    float v1882;
                    if (v1881){
                        v1882 = v1880;
                    } else {
                        v1882 = 0.0f;
                    }
                    assert("Tensor range check" && 0 <= v1874 && v1874 < 1);
                    assert("Tensor range check" && 0 <= v1876 && v1876 < 4);
                    v1873[v1879] = v1882;
                    v1876 += 1 ;
                }
                v1874 += 1 ;
            }
            float v1883;
            v1883 = 0.0f;
            int v1884;
            v1884 = 0;
            while (while_method_6(v1884)){
                int v1886;
                v1886 = 0;
                while (while_method_3(v1886)){
                    assert("Tensor range check" && 0 <= v1884 && v1884 < 1);
                    assert("Tensor range check" && 0 <= v1886 && v1886 < 4);
                    int v1888;
                    v1888 = 4 * v1884;
                    int v1889;
                    v1889 = v1888 + v1886;
                    float v1890;
                    v1890 = v1873[v1889];
                    float v1891;
                    v1891 = v1883 + v1890;
                    v1883 = v1891;
                    v1886 += 1 ;
                }
                v1884 += 1 ;
            }
            auto v1892 = cooperative_groups::coalesced_threads();
            int v1893;
            v1893 = threadIdx.x;
            auto v1894 = cooperative_groups::labeled_partition(v1892,v1893);
            float v1895;
            v1895 = cooperative_groups::reduce(v1894, v1883, v1860);
            float v1896;
            v1896 = v1895 / v1837;
            float v1897;
            v1897 = sqrt(v1896);
            bool v1898;
            v1898 = v1837 > 1.0f;
            float v1902;
            if (v1898){
                float v1899;
                v1899 = v1897 * v1837;
                float v1900;
                v1900 = v1837 - 1.0f;
                float v1901;
                v1901 = v1899 / v1900;
                v1902 = v1901;
            } else {
                v1902 = 0.0f;
            }
            float v1903[4];
            int v1904;
            v1904 = 0;
            while (while_method_6(v1904)){
                int v1906;
                v1906 = 0;
                while (while_method_3(v1906)){
                    assert("Tensor range check" && 0 <= v1904 && v1904 < 1);
                    assert("Tensor range check" && 0 <= v1906 && v1906 < 4);
                    int v1908;
                    v1908 = 4 * v1904;
                    int v1909;
                    v1909 = v1908 + v1906;
                    float v1910;
                    v1910 = v1752[v1909];
                    bool v1911;
                    v1911 = v1805[v1909];
                    float v1912;
                    v1912 = curand_normal(&v521);
                    bool v1913;
                    v1913 = v1902 >= 0.1f;
                    float v1914;
                    if (v1913){
                        v1914 = v1902;
                    } else {
                        v1914 = 0.1f;
                    }
                    float v1915;
                    v1915 = v1912 * v1914;
                    float v1916;
                    v1916 = v1915 + v1862;
                    float v1917;
                    if (v1911){
                        v1917 = v1910;
                    } else {
                        v1917 = v1916;
                    }
                    assert("Tensor range check" && 0 <= v1904 && v1904 < 1);
                    assert("Tensor range check" && 0 <= v1906 && v1906 < 4);
                    v1903[v1909] = v1917;
                    v1906 += 1 ;
                }
                v1904 += 1 ;
            }
            assert("Tensor range check" && 0 <= v1739 && v1739 < 256);
            assert("Tensor range check" && 0 <= v1744 && v1744 < 1);
            int v1918;
            v1918 = 0;
            while (while_method_6(v1918)){
                assert("Tensor range check" && 0 <= v1918 && v1918 < 1);
                int v1920;
                v1920 = 4 * v1918;
                int v1921;
                v1921 = v1920 + v1751;
                assert("Tensor range check" && 0 <= v1918 && v1918 < 1);
                int4* v1922;
                v1922 = reinterpret_cast<int4*>(v1903 + v1920);
                int4* v1923;
                v1923 = reinterpret_cast<int4*>(v540 + v1921);
                assert("Pointer alignment check" && reinterpret_cast<unsigned long long>(v1922) % 16 == 0 && reinterpret_cast<unsigned long long>(v1923) % 16 == 0);
                *v1923 = *v1922;
                v1918 += 1 ;
            }
            v1739 += 24 ;
        }
        int v1924;
        v1924 = threadIdx.x;
        bool v1925;
        v1925 = 0 <= v1924;
        bool v1926;
        v1926 = v1925 == false;
        if (v1926){
            assert("The index needs to be zero or positive." && v1925);
        } else {
        }
        int v1928;
        v1928 = v1924 % 1;
        int v1929;
        v1929 = v1924 % 256;
        int v1930;
        v1930 = v1924 / 256;
        bool v1931;
        v1931 = v1930 < 1;
        bool v1932;
        v1932 = v1931 == false;
        if (v1932){
            assert("The last element of the projection dimensions needs to be greater than the index remainder." && v1931);
        } else {
        }
        assert("Tensor range check" && 0 <= v1930 && v1930 < 1);
        assert("Tensor range check" && 0 <= v1929 && v1929 < 256);
        assert("Tensor range check" && 0 <= v1928 && v1928 < 1);
        int v1934;
        v1934 = 4 * v1928;
        int v1935;
        v1935 = 4 * v1929;
        int v1936;
        v1936 = v1935 + v1934;
        int v1937;
        v1937 = 1024 * v1930;
        int v1938;
        v1938 = v1937 + v1936;
        assert("Tensor range check" && 0 <= v1930 && v1930 < 1);
        assert("Tensor range check" && 0 <= v1929 && v1929 < 256);
        assert("Tensor range check" && 0 <= v1928 && v1928 < 1);
        int v1939;
        v1939 = blockIdx.x;
        int v1940;
        v1940 = v1939;
        while (while_method_29(v1940)){
            bool v1942;
            v1942 = 0 <= v1940;
            bool v1943;
            v1943 = v1942 == false;
            if (v1943){
                assert("The index needs to be zero or positive." && v1942);
            } else {
            }
            int v1945;
            v1945 = v1940 % 1;
            bool v1946;
            v1946 = v1940 < 64;
            bool v1947;
            v1947 = v1946 == false;
            if (v1947){
                assert("The last element of the projection dimensions needs to be greater than the index remainder." && v1946);
            } else {
            }
            assert("Tensor range check" && 0 <= v1940 && v1940 < 64);
            assert("Tensor range check" && 0 <= v1945 && v1945 < 1);
            int v1949;
            v1949 = 1024 * v1945;
            int v1950;
            v1950 = v1949 + v1938;
            int v1951;
            v1951 = 1024 * v1940;
            int v1952;
            v1952 = v1951 + v1950;
            float v1953[4];
            int v1954[4];
            int v1955;
            v1955 = 0;
            while (while_method_6(v1955)){
                assert("Tensor range check" && 0 <= v1955 && v1955 < 1);
                int v1957;
                v1957 = 4 * v1955;
                assert("Tensor range check" && 0 <= v1955 && v1955 < 1);
                int v1958;
                v1958 = v1957 + v1952;
                int4* v1959;
                v1959 = reinterpret_cast<int4*>(v544 + v1958);
                int4* v1960;
                v1960 = reinterpret_cast<int4*>(v1953 + v1957);
                assert("Pointer alignment check" && reinterpret_cast<unsigned long long>(v1959) % 16 == 0 && reinterpret_cast<unsigned long long>(v1960) % 16 == 0);
                *v1960 = *v1959;
                v1955 += 1 ;
            }
            int v1961;
            v1961 = 0;
            while (while_method_6(v1961)){
                int v1963;
                v1963 = 0;
                while (while_method_3(v1963)){
                    bool v1965;
                    v1965 = 0 <= v1963;
                    bool v1967;
                    if (v1965){
                        bool v1966;
                        v1966 = v1963 < 4;
                        v1967 = v1966;
                    } else {
                        v1967 = false;
                    }
                    bool v1968;
                    v1968 = v1967 == false;
                    if (v1968){
                        assert("The indices should be inside the range of the dimension." && v1967);
                    } else {
                    }
                    bool v1970;
                    v1970 = 0 <= v1928;
                    bool v1972;
                    if (v1970){
                        bool v1971;
                        v1971 = v1928 < 1;
                        v1972 = v1971;
                    } else {
                        v1972 = false;
                    }
                    bool v1973;
                    v1973 = v1972 == false;
                    if (v1973){
                        assert("The indices should be inside the range of the dimension." && v1972);
                    } else {
                    }
                    int v1975;
                    v1975 = v1928 * 4;
                    int v1976;
                    v1976 = v1963 + v1975;
                    bool v1977;
                    v1977 = 0 <= v1961;
                    bool v1979;
                    if (v1977){
                        bool v1978;
                        v1978 = v1961 < 1;
                        v1979 = v1978;
                    } else {
                        v1979 = false;
                    }
                    bool v1980;
                    v1980 = v1979 == false;
                    if (v1980){
                        assert("The indices should be inside the range of the dimension." && v1979);
                    } else {
                    }
                    int v1982;
                    v1982 = v1961 * 4;
                    int v1983;
                    v1983 = v1976 + v1982;
                    assert("Tensor range check" && 0 <= v1961 && v1961 < 1);
                    assert("Tensor range check" && 0 <= v1963 && v1963 < 4);
                    int v1984;
                    v1984 = 4 * v1961;
                    int v1985;
                    v1985 = v1984 + v1963;
                    v1954[v1985] = v1983;
                    v1963 += 1 ;
                }
                v1961 += 1 ;
            }
            bool v1986;
            v1986 = 0 <= v1930;
            bool v1987;
            v1987 = v1986 && v1931;
            bool v1988;
            v1988 = v1987 == false;
            if (v1988){
                assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v1987);
            } else {
            }
            bool v1990;
            v1990 = 0 <= v1929;
            bool v1992;
            if (v1990){
                bool v1991;
                v1991 = v1929 < 256;
                v1992 = v1991;
            } else {
                v1992 = false;
            }
            bool v1993;
            v1993 = v1992 == false;
            if (v1993){
                assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v1992);
            } else {
            }
            bool v1995;
            v1995 = v1942 && v1946;
            bool v1996;
            v1996 = v1995 == false;
            if (v1996){
                assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v1995);
            } else {
            }
            bool v1998;
            v1998 = 0 <= v1945;
            bool v2000;
            if (v1998){
                bool v1999;
                v1999 = v1945 < 1;
                v2000 = v1999;
            } else {
                v2000 = false;
            }
            bool v2001;
            v2001 = v2000 == false;
            if (v2001){
                assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v2000);
            } else {
            }
            int v2003;
            v2003 = v1945 * 256;
            int v2004;
            v2004 = v1940 + v1930;
            int v2005;
            v2005 = v2003 + v1929;
            bool v2006[4];
            int v2007;
            v2007 = 0;
            while (while_method_6(v2007)){
                int v2009;
                v2009 = 0;
                while (while_method_3(v2009)){
                    assert("Tensor range check" && 0 <= v2007 && v2007 < 1);
                    assert("Tensor range check" && 0 <= v2009 && v2009 < 4);
                    int v2011;
                    v2011 = 4 * v2007;
                    int v2012;
                    v2012 = v2011 + v2009;
                    int v2013;
                    v2013 = v1954[v2012];
                    assert("Tensor range check" && 0 <= v2013 && v2013 < 4);
                    bool v2014;
                    v2014 = v550[v2013];
                    assert("Tensor range check" && 0 <= v2007 && v2007 < 1);
                    assert("Tensor range check" && 0 <= v2009 && v2009 < 4);
                    v2006[v2012] = v2014;
                    v2009 += 1 ;
                }
                v2007 += 1 ;
            }
            int v2015[4];
            int v2016;
            v2016 = 0;
            while (while_method_6(v2016)){
                int v2018;
                v2018 = 0;
                while (while_method_3(v2018)){
                    assert("Tensor range check" && 0 <= v2016 && v2016 < 1);
                    assert("Tensor range check" && 0 <= v2018 && v2018 < 4);
                    int v2020;
                    v2020 = 4 * v2016;
                    int v2021;
                    v2021 = v2020 + v2018;
                    bool v2022;
                    v2022 = v2006[v2021];
                    int v2023;
                    if (v2022){
                        v2023 = 1;
                    } else {
                        v2023 = 0;
                    }
                    assert("Tensor range check" && 0 <= v2016 && v2016 < 1);
                    assert("Tensor range check" && 0 <= v2018 && v2018 < 4);
                    v2015[v2021] = v2023;
                    v2018 += 1 ;
                }
                v2016 += 1 ;
            }
            int v2024;
            v2024 = 0;
            int v2025;
            v2025 = 0;
            while (while_method_6(v2025)){
                int v2027;
                v2027 = 0;
                while (while_method_3(v2027)){
                    assert("Tensor range check" && 0 <= v2025 && v2025 < 1);
                    assert("Tensor range check" && 0 <= v2027 && v2027 < 4);
                    int v2029;
                    v2029 = 4 * v2025;
                    int v2030;
                    v2030 = v2029 + v2027;
                    int v2031;
                    v2031 = v2015[v2030];
                    int v2032;
                    v2032 = v2024 + v2031;
                    v2024 = v2032;
                    v2027 += 1 ;
                }
                v2025 += 1 ;
            }
            auto v2033 = cooperative_groups::coalesced_threads();
            int v2034;
            v2034 = threadIdx.x;
            auto v2035 = cooperative_groups::labeled_partition(v2033,v2034);
            Closure1 v2036{};
            int v2037;
            v2037 = cooperative_groups::reduce(v2035, v2024, v2036);
            float v2038;
            v2038 = (float)v2037;
            float v2039[4];
            int v2040;
            v2040 = 0;
            while (while_method_6(v2040)){
                int v2042;
                v2042 = 0;
                while (while_method_3(v2042)){
                    assert("Tensor range check" && 0 <= v2040 && v2040 < 1);
                    assert("Tensor range check" && 0 <= v2042 && v2042 < 4);
                    int v2044;
                    v2044 = 4 * v2040;
                    int v2045;
                    v2045 = v2044 + v2042;
                    float v2046;
                    v2046 = v1953[v2045];
                    bool v2047;
                    v2047 = v2006[v2045];
                    float v2048;
                    if (v2047){
                        v2048 = v2046;
                    } else {
                        v2048 = 0.0f;
                    }
                    assert("Tensor range check" && 0 <= v2040 && v2040 < 1);
                    assert("Tensor range check" && 0 <= v2042 && v2042 < 4);
                    v2039[v2045] = v2048;
                    v2042 += 1 ;
                }
                v2040 += 1 ;
            }
            float v2049;
            v2049 = 0.0f;
            int v2050;
            v2050 = 0;
            while (while_method_6(v2050)){
                int v2052;
                v2052 = 0;
                while (while_method_3(v2052)){
                    assert("Tensor range check" && 0 <= v2050 && v2050 < 1);
                    assert("Tensor range check" && 0 <= v2052 && v2052 < 4);
                    int v2054;
                    v2054 = 4 * v2050;
                    int v2055;
                    v2055 = v2054 + v2052;
                    float v2056;
                    v2056 = v2039[v2055];
                    float v2057;
                    v2057 = v2049 + v2056;
                    v2049 = v2057;
                    v2052 += 1 ;
                }
                v2050 += 1 ;
            }
            auto v2058 = cooperative_groups::coalesced_threads();
            int v2059;
            v2059 = threadIdx.x;
            auto v2060 = cooperative_groups::labeled_partition(v2058,v2059);
            Closure0 v2061{};
            float v2062;
            v2062 = cooperative_groups::reduce(v2060, v2049, v2061);
            float v2063;
            v2063 = v2062 / v2038;
            float v2064[4];
            int v2065;
            v2065 = 0;
            while (while_method_6(v2065)){
                int v2067;
                v2067 = 0;
                while (while_method_3(v2067)){
                    assert("Tensor range check" && 0 <= v2065 && v2065 < 1);
                    assert("Tensor range check" && 0 <= v2067 && v2067 < 4);
                    int v2069;
                    v2069 = 4 * v2065;
                    int v2070;
                    v2070 = v2069 + v2067;
                    float v2071;
                    v2071 = v1953[v2070];
                    float v2072;
                    v2072 = v2071 - v2063;
                    float v2073;
                    v2073 = v2072 * v2072;
                    assert("Tensor range check" && 0 <= v2065 && v2065 < 1);
                    assert("Tensor range check" && 0 <= v2067 && v2067 < 4);
                    v2064[v2070] = v2073;
                    v2067 += 1 ;
                }
                v2065 += 1 ;
            }
            float v2074[4];
            int v2075;
            v2075 = 0;
            while (while_method_6(v2075)){
                int v2077;
                v2077 = 0;
                while (while_method_3(v2077)){
                    assert("Tensor range check" && 0 <= v2075 && v2075 < 1);
                    assert("Tensor range check" && 0 <= v2077 && v2077 < 4);
                    int v2079;
                    v2079 = 4 * v2075;
                    int v2080;
                    v2080 = v2079 + v2077;
                    float v2081;
                    v2081 = v2064[v2080];
                    bool v2082;
                    v2082 = v2006[v2080];
                    float v2083;
                    if (v2082){
                        v2083 = v2081;
                    } else {
                        v2083 = 0.0f;
                    }
                    assert("Tensor range check" && 0 <= v2075 && v2075 < 1);
                    assert("Tensor range check" && 0 <= v2077 && v2077 < 4);
                    v2074[v2080] = v2083;
                    v2077 += 1 ;
                }
                v2075 += 1 ;
            }
            float v2084;
            v2084 = 0.0f;
            int v2085;
            v2085 = 0;
            while (while_method_6(v2085)){
                int v2087;
                v2087 = 0;
                while (while_method_3(v2087)){
                    assert("Tensor range check" && 0 <= v2085 && v2085 < 1);
                    assert("Tensor range check" && 0 <= v2087 && v2087 < 4);
                    int v2089;
                    v2089 = 4 * v2085;
                    int v2090;
                    v2090 = v2089 + v2087;
                    float v2091;
                    v2091 = v2074[v2090];
                    float v2092;
                    v2092 = v2084 + v2091;
                    v2084 = v2092;
                    v2087 += 1 ;
                }
                v2085 += 1 ;
            }
            auto v2093 = cooperative_groups::coalesced_threads();
            int v2094;
            v2094 = threadIdx.x;
            auto v2095 = cooperative_groups::labeled_partition(v2093,v2094);
            float v2096;
            v2096 = cooperative_groups::reduce(v2095, v2084, v2061);
            float v2097;
            v2097 = v2096 / v2038;
            float v2098;
            v2098 = sqrt(v2097);
            bool v2099;
            v2099 = v2038 > 1.0f;
            float v2103;
            if (v2099){
                float v2100;
                v2100 = v2098 * v2038;
                float v2101;
                v2101 = v2038 - 1.0f;
                float v2102;
                v2102 = v2100 / v2101;
                v2103 = v2102;
            } else {
                v2103 = 0.0f;
            }
            float v2104[4];
            int v2105;
            v2105 = 0;
            while (while_method_6(v2105)){
                int v2107;
                v2107 = 0;
                while (while_method_3(v2107)){
                    assert("Tensor range check" && 0 <= v2105 && v2105 < 1);
                    assert("Tensor range check" && 0 <= v2107 && v2107 < 4);
                    int v2109;
                    v2109 = 4 * v2105;
                    int v2110;
                    v2110 = v2109 + v2107;
                    float v2111;
                    v2111 = v1953[v2110];
                    bool v2112;
                    v2112 = v2006[v2110];
                    float v2113;
                    v2113 = curand_normal(&v521);
                    bool v2114;
                    v2114 = v2103 >= 0.1f;
                    float v2115;
                    if (v2114){
                        v2115 = v2103;
                    } else {
                        v2115 = 0.1f;
                    }
                    float v2116;
                    v2116 = v2113 * v2115;
                    float v2117;
                    v2117 = v2116 + v2063;
                    float v2118;
                    if (v2112){
                        v2118 = v2111;
                    } else {
                        v2118 = v2117;
                    }
                    assert("Tensor range check" && 0 <= v2105 && v2105 < 1);
                    assert("Tensor range check" && 0 <= v2107 && v2107 < 4);
                    v2104[v2110] = v2118;
                    v2107 += 1 ;
                }
                v2105 += 1 ;
            }
            assert("Tensor range check" && 0 <= v1940 && v1940 < 64);
            assert("Tensor range check" && 0 <= v1945 && v1945 < 1);
            int v2119;
            v2119 = 0;
            while (while_method_6(v2119)){
                assert("Tensor range check" && 0 <= v2119 && v2119 < 1);
                int v2121;
                v2121 = 4 * v2119;
                int v2122;
                v2122 = v2121 + v1952;
                assert("Tensor range check" && 0 <= v2119 && v2119 < 1);
                int4* v2123;
                v2123 = reinterpret_cast<int4*>(v2104 + v2121);
                int4* v2124;
                v2124 = reinterpret_cast<int4*>(v544 + v2122);
                assert("Pointer alignment check" && reinterpret_cast<unsigned long long>(v2123) % 16 == 0 && reinterpret_cast<unsigned long long>(v2124) % 16 == 0);
                *v2124 = *v2123;
                v2119 += 1 ;
            }
            v1940 += 24 ;
        }
        v519.sync() ;
        static float v2125[524288];
        int v2126;
        v2126 = threadIdx.x;
        int v2127;
        v2127 = blockIdx.x;
        int v2128;
        v2128 = v2127 * 256;
        int v2129;
        v2129 = v2126 + v2128;
        int v2130;
        v2130 = v2129 / 32;
        int v2131;
        v2131 = v2130;
        while (while_method_7(v2131)){
            bool v2133;
            v2133 = 0 <= v2131;
            bool v2134;
            v2134 = v2133 == false;
            if (v2134){
                assert("The index needs to be zero or positive." && v2133);
            } else {
            }
            int v2136;
            v2136 = v2131 % 2048;
            int v2137;
            v2137 = v2131 / 2048;
            bool v2138;
            v2138 = v2137 < 256;
            bool v2139;
            v2139 = v2138 == false;
            if (v2139){
                assert("The last element of the projection dimensions needs to be greater than the index remainder." && v2138);
            } else {
            }
            assert("Tensor range check" && 0 <= v2137 && v2137 < 256);
            assert("Tensor range check" && 0 <= v2136 && v2136 < 2048);
            int v2141;
            v2141 = 4 * v2136;
            int v2142;
            v2142 = 8192 * v2137;
            int v2143;
            v2143 = v2142 + v2141;
            float v2144;
            v2144 = 0.0f;
            int v2145;
            v2145 = threadIdx.x;
            int v2146;
            v2146 = v2145 % 32;
            int v2147;
            v2147 = v2146;
            while (while_method_6(v2147)){
                bool v2149;
                v2149 = 0 <= v2147;
                bool v2150;
                v2150 = v2149 == false;
                if (v2150){
                    assert("The index needs to be zero or positive." && v2149);
                } else {
                }
                bool v2152;
                v2152 = v2147 < 1;
                bool v2153;
                v2153 = v2152 == false;
                if (v2153){
                    assert("The last element of the projection dimensions needs to be greater than the index remainder." && v2152);
                } else {
                }
                assert("Tensor range check" && 0 <= v2147 && v2147 < 1);
                int v2155;
                v2155 = 4 * v2147;
                int v2156;
                v2156 = v2155 + v2143;
                float v2157[4];
                int4* v2158;
                v2158 = reinterpret_cast<int4*>(v524 + v2156);
                int4* v2159;
                v2159 = reinterpret_cast<int4*>(v2157 + 0);
                assert("Pointer alignment check" && reinterpret_cast<unsigned long long>(v2158) % 16 == 0 && reinterpret_cast<unsigned long long>(v2159) % 16 == 0);
                *v2159 = *v2158;
                int v2160;
                v2160 = 0;
                while (while_method_3(v2160)){
                    assert("Tensor range check" && 0 <= v2160 && v2160 < 4);
                    float v2162;
                    v2162 = v2157[v2160];
                    float v2163;
                    v2163 = v2162 * v2162;
                    float v2164;
                    v2164 = v2144 + v2163;
                    v2144 = v2164;
                    v2160 += 1 ;
                }
                v2147 += 32 ;
            }
            __syncwarp();
            auto v2165 = cooperative_groups::coalesced_threads();
            Closure0 v2166{};
            float v2167;
            v2167 = cooperative_groups::reduce(v2165, v2144, v2166);
            float v2168;
            v2168 = sqrt(v2167);
            assert("Tensor range check" && 0 <= v2137 && v2137 < 256);
            assert("Tensor range check" && 0 <= v2136 && v2136 < 2048);
            int v2169;
            v2169 = 2048 * v2137;
            int v2170;
            v2170 = v2169 + v2136;
            v2125[v2170] = v2168;
            v2131 += 192 ;
        }
        __syncthreads();
        v519.sync() ;
        float v2171;
        v2171 = 0.0f;
        int v2172;
        v2172 = threadIdx.x;
        int v2173;
        v2173 = blockIdx.x;
        int v2174;
        v2174 = v2173 * 256;
        int v2175;
        v2175 = v2172 + v2174;
        int v2176;
        v2176 = v2175;
        while (while_method_30(v2176)){
            bool v2178;
            v2178 = 0 <= v2176;
            bool v2179;
            v2179 = v2178 == false;
            if (v2179){
                assert("The index needs to be zero or positive." && v2178);
            } else {
            }
            int v2181;
            v2181 = v2176 % 512;
            int v2182;
            v2182 = v2176 / 512;
            bool v2183;
            v2183 = v2182 < 256;
            bool v2184;
            v2184 = v2183 == false;
            if (v2184){
                assert("The last element of the projection dimensions needs to be greater than the index remainder." && v2183);
            } else {
            }
            assert("Tensor range check" && 0 <= v2182 && v2182 < 256);
            assert("Tensor range check" && 0 <= v2181 && v2181 < 512);
            int v2186;
            v2186 = 4 * v2181;
            int v2187;
            v2187 = 2048 * v2182;
            int v2188;
            v2188 = v2187 + v2186;
            float v2189[4];
            int4* v2190;
            v2190 = reinterpret_cast<int4*>(v2125 + v2188);
            int4* v2191;
            v2191 = reinterpret_cast<int4*>(v2189 + 0);
            assert("Pointer alignment check" && reinterpret_cast<unsigned long long>(v2190) % 16 == 0 && reinterpret_cast<unsigned long long>(v2191) % 16 == 0);
            *v2191 = *v2190;
            int v2192; float v2193;
            Tuple25 tmp165 = Tuple25{0, v2171};
            v2192 = tmp165.v0; v2193 = tmp165.v1;
            while (while_method_3(v2192)){
                assert("Tensor range check" && 0 <= v2192 && v2192 < 4);
                float v2195;
                v2195 = v2189[v2192];
                bool v2196;
                v2196 = v2193 >= v2195;
                float v2197;
                if (v2196){
                    v2197 = v2193;
                } else {
                    v2197 = v2195;
                }
                v2193 = v2197;
                v2192 += 1 ;
            }
            v2171 = v2193;
            v2176 += 6144 ;
        }
        __syncwarp();
        auto v2198 = cooperative_groups::coalesced_threads();
        Closure7 v2199{};
        float v2200;
        v2200 = cooperative_groups::reduce(v2198, v2171, v2199);
        int v2201;
        v2201 = threadIdx.x;
        int v2202;
        v2202 = v2201 / 32;
        extern __shared__ unsigned char v2203[];
        float * v2204;
        v2204 = reinterpret_cast<float *>(&v2203[0ull]);
        assert("Tensor range check" && 0 <= v2202 && v2202 < 8);
        v2204[v2202] = v2200;
        __syncthreads();
        int v2206;
        v2206 = threadIdx.x;
        int v2207;
        v2207 = v2206 % 32;
        bool v2208;
        v2208 = v2207 < 8;
        float v2210;
        if (v2208){
            assert("Tensor range check" && 0 <= v2207 && v2207 < 8);
            float v2209;
            v2209 = v2204[v2207];
            v2210 = v2209;
        } else {
            v2210 = 0.0f;
        }
        __syncthreads();
        auto v2211 = cooperative_groups::coalesced_threads();
        float v2212;
        v2212 = cooperative_groups::reduce(v2211, v2210, v2199);
        int v2213;
        v2213 = blockIdx.x;
        static float v2214[24];
        assert("Tensor range check" && 0 <= v2213 && v2213 < 24);
        v2214[v2213] = v2212;
        v519.sync() ;
        float v2215;
        v2215 = 0.0f;
        int v2216;
        v2216 = threadIdx.x;
        int v2217;
        v2217 = v2216 % 32;
        int v2218;
        v2218 = v2217;
        while (while_method_31(v2218)){
            bool v2220;
            v2220 = 0 <= v2218;
            bool v2221;
            v2221 = v2220 == false;
            if (v2221){
                assert("The index needs to be zero or positive." && v2220);
            } else {
            }
            bool v2223;
            v2223 = v2218 < 24;
            bool v2224;
            v2224 = v2223 == false;
            if (v2224){
                assert("The last element of the projection dimensions needs to be greater than the index remainder." && v2223);
            } else {
            }
            assert("Tensor range check" && 0 <= v2218 && v2218 < 24);
            float v2226;
            v2226 = v2214[v2218];
            bool v2227;
            v2227 = v2215 >= v2226;
            float v2228;
            if (v2227){
                v2228 = v2215;
            } else {
                v2228 = v2226;
            }
            v2215 = v2228;
            v2218 += 32 ;
        }
        __syncwarp();
        auto v2229 = cooperative_groups::coalesced_threads();
        float v2230;
        v2230 = cooperative_groups::reduce(v2229, v2215, v2199);
        int v2231;
        v2231 = threadIdx.x;
        int v2232;
        v2232 = blockIdx.x;
        int v2233;
        v2233 = v2232 * 256;
        int v2234;
        v2234 = v2231 + v2233;
        bool v2235;
        v2235 = v2234 == 0;
        if (v2235){
            cuda::counting_semaphore<cuda::thread_scope_system, 1> & v2236 = console_lock;
            auto v2237 = cooperative_groups::coalesced_threads();
            v2236.acquire();
            printf("{%s = %f}\n","max_norm", v2230);
            v2236.release();
            v2237.sync() ;
        } else {
        }
        __syncwarp();
        static float v2240[65536];
        int v2241;
        v2241 = threadIdx.x;
        int v2242;
        v2242 = blockIdx.x;
        int v2243;
        v2243 = v2242 * 256;
        int v2244;
        v2244 = v2241 + v2243;
        int v2245;
        v2245 = v2244 / 32;
        int v2246;
        v2246 = v2245;
        while (while_method_32(v2246)){
            bool v2248;
            v2248 = 0 <= v2246;
            bool v2249;
            v2249 = v2248 == false;
            if (v2249){
                assert("The index needs to be zero or positive." && v2248);
            } else {
            }
            int v2251;
            v2251 = v2246 % 256;
            int v2252;
            v2252 = v2246 / 256;
            bool v2253;
            v2253 = v2252 < 256;
            bool v2254;
            v2254 = v2253 == false;
            if (v2254){
                assert("The last element of the projection dimensions needs to be greater than the index remainder." && v2253);
            } else {
            }
            assert("Tensor range check" && 0 <= v2252 && v2252 < 256);
            assert("Tensor range check" && 0 <= v2251 && v2251 < 256);
            int v2256;
            v2256 = 4 * v2251;
            int v2257;
            v2257 = 1024 * v2252;
            int v2258;
            v2258 = v2257 + v2256;
            float v2259;
            v2259 = 0.0f;
            int v2260;
            v2260 = threadIdx.x;
            int v2261;
            v2261 = v2260 % 32;
            int v2262;
            v2262 = v2261;
            while (while_method_6(v2262)){
                bool v2264;
                v2264 = 0 <= v2262;
                bool v2265;
                v2265 = v2264 == false;
                if (v2265){
                    assert("The index needs to be zero or positive." && v2264);
                } else {
                }
                bool v2267;
                v2267 = v2262 < 1;
                bool v2268;
                v2268 = v2267 == false;
                if (v2268){
                    assert("The last element of the projection dimensions needs to be greater than the index remainder." && v2267);
                } else {
                }
                assert("Tensor range check" && 0 <= v2262 && v2262 < 1);
                int v2270;
                v2270 = 4 * v2262;
                int v2271;
                v2271 = v2270 + v2258;
                float v2272[4];
                int4* v2273;
                v2273 = reinterpret_cast<int4*>(v528 + v2271);
                int4* v2274;
                v2274 = reinterpret_cast<int4*>(v2272 + 0);
                assert("Pointer alignment check" && reinterpret_cast<unsigned long long>(v2273) % 16 == 0 && reinterpret_cast<unsigned long long>(v2274) % 16 == 0);
                *v2274 = *v2273;
                int v2275;
                v2275 = 0;
                while (while_method_3(v2275)){
                    assert("Tensor range check" && 0 <= v2275 && v2275 < 4);
                    float v2277;
                    v2277 = v2272[v2275];
                    float v2278;
                    v2278 = v2277 * v2277;
                    float v2279;
                    v2279 = v2259 + v2278;
                    v2259 = v2279;
                    v2275 += 1 ;
                }
                v2262 += 32 ;
            }
            __syncwarp();
            auto v2280 = cooperative_groups::coalesced_threads();
            Closure0 v2281{};
            float v2282;
            v2282 = cooperative_groups::reduce(v2280, v2259, v2281);
            float v2283;
            v2283 = sqrt(v2282);
            assert("Tensor range check" && 0 <= v2252 && v2252 < 256);
            assert("Tensor range check" && 0 <= v2251 && v2251 < 256);
            int v2284;
            v2284 = 256 * v2252;
            int v2285;
            v2285 = v2284 + v2251;
            v2240[v2285] = v2283;
            v2246 += 192 ;
        }
        __syncthreads();
        v519.sync() ;
        float v2286;
        v2286 = 0.0f;
        int v2287;
        v2287 = threadIdx.x;
        int v2288;
        v2288 = blockIdx.x;
        int v2289;
        v2289 = v2288 * 256;
        int v2290;
        v2290 = v2287 + v2289;
        int v2291;
        v2291 = v2290;
        while (while_method_13(v2291)){
            bool v2293;
            v2293 = 0 <= v2291;
            bool v2294;
            v2294 = v2293 == false;
            if (v2294){
                assert("The index needs to be zero or positive." && v2293);
            } else {
            }
            int v2296;
            v2296 = v2291 % 64;
            int v2297;
            v2297 = v2291 / 64;
            bool v2298;
            v2298 = v2297 < 256;
            bool v2299;
            v2299 = v2298 == false;
            if (v2299){
                assert("The last element of the projection dimensions needs to be greater than the index remainder." && v2298);
            } else {
            }
            assert("Tensor range check" && 0 <= v2297 && v2297 < 256);
            assert("Tensor range check" && 0 <= v2296 && v2296 < 64);
            int v2301;
            v2301 = 4 * v2296;
            int v2302;
            v2302 = 256 * v2297;
            int v2303;
            v2303 = v2302 + v2301;
            float v2304[4];
            int4* v2305;
            v2305 = reinterpret_cast<int4*>(v2240 + v2303);
            int4* v2306;
            v2306 = reinterpret_cast<int4*>(v2304 + 0);
            assert("Pointer alignment check" && reinterpret_cast<unsigned long long>(v2305) % 16 == 0 && reinterpret_cast<unsigned long long>(v2306) % 16 == 0);
            *v2306 = *v2305;
            int v2307; float v2308;
            Tuple25 tmp166 = Tuple25{0, v2286};
            v2307 = tmp166.v0; v2308 = tmp166.v1;
            while (while_method_3(v2307)){
                assert("Tensor range check" && 0 <= v2307 && v2307 < 4);
                float v2310;
                v2310 = v2304[v2307];
                bool v2311;
                v2311 = v2308 >= v2310;
                float v2312;
                if (v2311){
                    v2312 = v2308;
                } else {
                    v2312 = v2310;
                }
                v2308 = v2312;
                v2307 += 1 ;
            }
            v2286 = v2308;
            v2291 += 6144 ;
        }
        __syncwarp();
        auto v2313 = cooperative_groups::coalesced_threads();
        float v2314;
        v2314 = cooperative_groups::reduce(v2313, v2286, v2199);
        int v2315;
        v2315 = threadIdx.x;
        int v2316;
        v2316 = v2315 / 32;
        extern __shared__ unsigned char v2317[];
        float * v2318;
        v2318 = reinterpret_cast<float *>(&v2317[0ull]);
        assert("Tensor range check" && 0 <= v2316 && v2316 < 8);
        v2318[v2316] = v2314;
        __syncthreads();
        int v2320;
        v2320 = threadIdx.x;
        int v2321;
        v2321 = v2320 % 32;
        bool v2322;
        v2322 = v2321 < 8;
        float v2324;
        if (v2322){
            assert("Tensor range check" && 0 <= v2321 && v2321 < 8);
            float v2323;
            v2323 = v2318[v2321];
            v2324 = v2323;
        } else {
            v2324 = 0.0f;
        }
        __syncthreads();
        auto v2325 = cooperative_groups::coalesced_threads();
        float v2326;
        v2326 = cooperative_groups::reduce(v2325, v2324, v2199);
        int v2327;
        v2327 = blockIdx.x;
        static float v2328[24];
        assert("Tensor range check" && 0 <= v2327 && v2327 < 24);
        v2328[v2327] = v2326;
        v519.sync() ;
        float v2329;
        v2329 = 0.0f;
        int v2330;
        v2330 = threadIdx.x;
        int v2331;
        v2331 = v2330 % 32;
        int v2332;
        v2332 = v2331;
        while (while_method_31(v2332)){
            bool v2334;
            v2334 = 0 <= v2332;
            bool v2335;
            v2335 = v2334 == false;
            if (v2335){
                assert("The index needs to be zero or positive." && v2334);
            } else {
            }
            bool v2337;
            v2337 = v2332 < 24;
            bool v2338;
            v2338 = v2337 == false;
            if (v2338){
                assert("The last element of the projection dimensions needs to be greater than the index remainder." && v2337);
            } else {
            }
            assert("Tensor range check" && 0 <= v2332 && v2332 < 24);
            float v2340;
            v2340 = v2328[v2332];
            bool v2341;
            v2341 = v2329 >= v2340;
            float v2342;
            if (v2341){
                v2342 = v2329;
            } else {
                v2342 = v2340;
            }
            v2329 = v2342;
            v2332 += 32 ;
        }
        __syncwarp();
        auto v2343 = cooperative_groups::coalesced_threads();
        float v2344;
        v2344 = cooperative_groups::reduce(v2343, v2329, v2199);
        int v2345;
        v2345 = threadIdx.x;
        int v2346;
        v2346 = blockIdx.x;
        int v2347;
        v2347 = v2346 * 256;
        int v2348;
        v2348 = v2345 + v2347;
        bool v2349;
        v2349 = v2348 == 0;
        if (v2349){
            cuda::counting_semaphore<cuda::thread_scope_system, 1> & v2350 = console_lock;
            auto v2351 = cooperative_groups::coalesced_threads();
            v2350.acquire();
            printf("{%s = %f}\n","max_norm", v2344);
            v2350.release();
            v2351.sync() ;
        } else {
        }
        __syncwarp();
        static float v2354[65536];
        int v2355;
        v2355 = threadIdx.x;
        int v2356;
        v2356 = blockIdx.x;
        int v2357;
        v2357 = v2356 * 256;
        int v2358;
        v2358 = v2355 + v2357;
        int v2359;
        v2359 = v2358 / 32;
        int v2360;
        v2360 = v2359;
        while (while_method_32(v2360)){
            bool v2362;
            v2362 = 0 <= v2360;
            bool v2363;
            v2363 = v2362 == false;
            if (v2363){
                assert("The index needs to be zero or positive." && v2362);
            } else {
            }
            int v2365;
            v2365 = v2360 % 256;
            int v2366;
            v2366 = v2360 / 256;
            bool v2367;
            v2367 = v2366 < 256;
            bool v2368;
            v2368 = v2367 == false;
            if (v2368){
                assert("The last element of the projection dimensions needs to be greater than the index remainder." && v2367);
            } else {
            }
            assert("Tensor range check" && 0 <= v2366 && v2366 < 256);
            assert("Tensor range check" && 0 <= v2365 && v2365 < 256);
            int v2370;
            v2370 = 4 * v2365;
            int v2371;
            v2371 = 1024 * v2366;
            int v2372;
            v2372 = v2371 + v2370;
            float v2373;
            v2373 = 0.0f;
            int v2374;
            v2374 = threadIdx.x;
            int v2375;
            v2375 = v2374 % 32;
            int v2376;
            v2376 = v2375;
            while (while_method_6(v2376)){
                bool v2378;
                v2378 = 0 <= v2376;
                bool v2379;
                v2379 = v2378 == false;
                if (v2379){
                    assert("The index needs to be zero or positive." && v2378);
                } else {
                }
                bool v2381;
                v2381 = v2376 < 1;
                bool v2382;
                v2382 = v2381 == false;
                if (v2382){
                    assert("The last element of the projection dimensions needs to be greater than the index remainder." && v2381);
                } else {
                }
                assert("Tensor range check" && 0 <= v2376 && v2376 < 1);
                int v2384;
                v2384 = 4 * v2376;
                int v2385;
                v2385 = v2384 + v2372;
                float v2386[4];
                int4* v2387;
                v2387 = reinterpret_cast<int4*>(v532 + v2385);
                int4* v2388;
                v2388 = reinterpret_cast<int4*>(v2386 + 0);
                assert("Pointer alignment check" && reinterpret_cast<unsigned long long>(v2387) % 16 == 0 && reinterpret_cast<unsigned long long>(v2388) % 16 == 0);
                *v2388 = *v2387;
                int v2389;
                v2389 = 0;
                while (while_method_3(v2389)){
                    assert("Tensor range check" && 0 <= v2389 && v2389 < 4);
                    float v2391;
                    v2391 = v2386[v2389];
                    float v2392;
                    v2392 = v2391 * v2391;
                    float v2393;
                    v2393 = v2373 + v2392;
                    v2373 = v2393;
                    v2389 += 1 ;
                }
                v2376 += 32 ;
            }
            __syncwarp();
            auto v2394 = cooperative_groups::coalesced_threads();
            Closure0 v2395{};
            float v2396;
            v2396 = cooperative_groups::reduce(v2394, v2373, v2395);
            float v2397;
            v2397 = sqrt(v2396);
            assert("Tensor range check" && 0 <= v2366 && v2366 < 256);
            assert("Tensor range check" && 0 <= v2365 && v2365 < 256);
            int v2398;
            v2398 = 256 * v2366;
            int v2399;
            v2399 = v2398 + v2365;
            v2354[v2399] = v2397;
            v2360 += 192 ;
        }
        __syncthreads();
        v519.sync() ;
        float v2400;
        v2400 = 0.0f;
        int v2401;
        v2401 = threadIdx.x;
        int v2402;
        v2402 = blockIdx.x;
        int v2403;
        v2403 = v2402 * 256;
        int v2404;
        v2404 = v2401 + v2403;
        int v2405;
        v2405 = v2404;
        while (while_method_13(v2405)){
            bool v2407;
            v2407 = 0 <= v2405;
            bool v2408;
            v2408 = v2407 == false;
            if (v2408){
                assert("The index needs to be zero or positive." && v2407);
            } else {
            }
            int v2410;
            v2410 = v2405 % 64;
            int v2411;
            v2411 = v2405 / 64;
            bool v2412;
            v2412 = v2411 < 256;
            bool v2413;
            v2413 = v2412 == false;
            if (v2413){
                assert("The last element of the projection dimensions needs to be greater than the index remainder." && v2412);
            } else {
            }
            assert("Tensor range check" && 0 <= v2411 && v2411 < 256);
            assert("Tensor range check" && 0 <= v2410 && v2410 < 64);
            int v2415;
            v2415 = 4 * v2410;
            int v2416;
            v2416 = 256 * v2411;
            int v2417;
            v2417 = v2416 + v2415;
            float v2418[4];
            int4* v2419;
            v2419 = reinterpret_cast<int4*>(v2354 + v2417);
            int4* v2420;
            v2420 = reinterpret_cast<int4*>(v2418 + 0);
            assert("Pointer alignment check" && reinterpret_cast<unsigned long long>(v2419) % 16 == 0 && reinterpret_cast<unsigned long long>(v2420) % 16 == 0);
            *v2420 = *v2419;
            int v2421; float v2422;
            Tuple25 tmp167 = Tuple25{0, v2400};
            v2421 = tmp167.v0; v2422 = tmp167.v1;
            while (while_method_3(v2421)){
                assert("Tensor range check" && 0 <= v2421 && v2421 < 4);
                float v2424;
                v2424 = v2418[v2421];
                bool v2425;
                v2425 = v2422 >= v2424;
                float v2426;
                if (v2425){
                    v2426 = v2422;
                } else {
                    v2426 = v2424;
                }
                v2422 = v2426;
                v2421 += 1 ;
            }
            v2400 = v2422;
            v2405 += 6144 ;
        }
        __syncwarp();
        auto v2427 = cooperative_groups::coalesced_threads();
        float v2428;
        v2428 = cooperative_groups::reduce(v2427, v2400, v2199);
        int v2429;
        v2429 = threadIdx.x;
        int v2430;
        v2430 = v2429 / 32;
        extern __shared__ unsigned char v2431[];
        float * v2432;
        v2432 = reinterpret_cast<float *>(&v2431[0ull]);
        assert("Tensor range check" && 0 <= v2430 && v2430 < 8);
        v2432[v2430] = v2428;
        __syncthreads();
        int v2434;
        v2434 = threadIdx.x;
        int v2435;
        v2435 = v2434 % 32;
        bool v2436;
        v2436 = v2435 < 8;
        float v2438;
        if (v2436){
            assert("Tensor range check" && 0 <= v2435 && v2435 < 8);
            float v2437;
            v2437 = v2432[v2435];
            v2438 = v2437;
        } else {
            v2438 = 0.0f;
        }
        __syncthreads();
        auto v2439 = cooperative_groups::coalesced_threads();
        float v2440;
        v2440 = cooperative_groups::reduce(v2439, v2438, v2199);
        int v2441;
        v2441 = blockIdx.x;
        static float v2442[24];
        assert("Tensor range check" && 0 <= v2441 && v2441 < 24);
        v2442[v2441] = v2440;
        v519.sync() ;
        float v2443;
        v2443 = 0.0f;
        int v2444;
        v2444 = threadIdx.x;
        int v2445;
        v2445 = v2444 % 32;
        int v2446;
        v2446 = v2445;
        while (while_method_31(v2446)){
            bool v2448;
            v2448 = 0 <= v2446;
            bool v2449;
            v2449 = v2448 == false;
            if (v2449){
                assert("The index needs to be zero or positive." && v2448);
            } else {
            }
            bool v2451;
            v2451 = v2446 < 24;
            bool v2452;
            v2452 = v2451 == false;
            if (v2452){
                assert("The last element of the projection dimensions needs to be greater than the index remainder." && v2451);
            } else {
            }
            assert("Tensor range check" && 0 <= v2446 && v2446 < 24);
            float v2454;
            v2454 = v2442[v2446];
            bool v2455;
            v2455 = v2443 >= v2454;
            float v2456;
            if (v2455){
                v2456 = v2443;
            } else {
                v2456 = v2454;
            }
            v2443 = v2456;
            v2446 += 32 ;
        }
        __syncwarp();
        auto v2457 = cooperative_groups::coalesced_threads();
        float v2458;
        v2458 = cooperative_groups::reduce(v2457, v2443, v2199);
        int v2459;
        v2459 = threadIdx.x;
        int v2460;
        v2460 = blockIdx.x;
        int v2461;
        v2461 = v2460 * 256;
        int v2462;
        v2462 = v2459 + v2461;
        bool v2463;
        v2463 = v2462 == 0;
        if (v2463){
            cuda::counting_semaphore<cuda::thread_scope_system, 1> & v2464 = console_lock;
            auto v2465 = cooperative_groups::coalesced_threads();
            v2464.acquire();
            printf("{%s = %f}\n","max_norm", v2458);
            v2464.release();
            v2465.sync() ;
        } else {
        }
        __syncwarp();
        static float v2468[65536];
        int v2469;
        v2469 = threadIdx.x;
        int v2470;
        v2470 = blockIdx.x;
        int v2471;
        v2471 = v2470 * 256;
        int v2472;
        v2472 = v2469 + v2471;
        int v2473;
        v2473 = v2472 / 32;
        int v2474;
        v2474 = v2473;
        while (while_method_32(v2474)){
            bool v2476;
            v2476 = 0 <= v2474;
            bool v2477;
            v2477 = v2476 == false;
            if (v2477){
                assert("The index needs to be zero or positive." && v2476);
            } else {
            }
            int v2479;
            v2479 = v2474 % 256;
            int v2480;
            v2480 = v2474 / 256;
            bool v2481;
            v2481 = v2480 < 256;
            bool v2482;
            v2482 = v2481 == false;
            if (v2482){
                assert("The last element of the projection dimensions needs to be greater than the index remainder." && v2481);
            } else {
            }
            assert("Tensor range check" && 0 <= v2480 && v2480 < 256);
            assert("Tensor range check" && 0 <= v2479 && v2479 < 256);
            int v2484;
            v2484 = 4 * v2479;
            int v2485;
            v2485 = 1024 * v2480;
            int v2486;
            v2486 = v2485 + v2484;
            float v2487;
            v2487 = 0.0f;
            int v2488;
            v2488 = threadIdx.x;
            int v2489;
            v2489 = v2488 % 32;
            int v2490;
            v2490 = v2489;
            while (while_method_6(v2490)){
                bool v2492;
                v2492 = 0 <= v2490;
                bool v2493;
                v2493 = v2492 == false;
                if (v2493){
                    assert("The index needs to be zero or positive." && v2492);
                } else {
                }
                bool v2495;
                v2495 = v2490 < 1;
                bool v2496;
                v2496 = v2495 == false;
                if (v2496){
                    assert("The last element of the projection dimensions needs to be greater than the index remainder." && v2495);
                } else {
                }
                assert("Tensor range check" && 0 <= v2490 && v2490 < 1);
                int v2498;
                v2498 = 4 * v2490;
                int v2499;
                v2499 = v2498 + v2486;
                float v2500[4];
                int4* v2501;
                v2501 = reinterpret_cast<int4*>(v536 + v2499);
                int4* v2502;
                v2502 = reinterpret_cast<int4*>(v2500 + 0);
                assert("Pointer alignment check" && reinterpret_cast<unsigned long long>(v2501) % 16 == 0 && reinterpret_cast<unsigned long long>(v2502) % 16 == 0);
                *v2502 = *v2501;
                int v2503;
                v2503 = 0;
                while (while_method_3(v2503)){
                    assert("Tensor range check" && 0 <= v2503 && v2503 < 4);
                    float v2505;
                    v2505 = v2500[v2503];
                    float v2506;
                    v2506 = v2505 * v2505;
                    float v2507;
                    v2507 = v2487 + v2506;
                    v2487 = v2507;
                    v2503 += 1 ;
                }
                v2490 += 32 ;
            }
            __syncwarp();
            auto v2508 = cooperative_groups::coalesced_threads();
            Closure0 v2509{};
            float v2510;
            v2510 = cooperative_groups::reduce(v2508, v2487, v2509);
            float v2511;
            v2511 = sqrt(v2510);
            assert("Tensor range check" && 0 <= v2480 && v2480 < 256);
            assert("Tensor range check" && 0 <= v2479 && v2479 < 256);
            int v2512;
            v2512 = 256 * v2480;
            int v2513;
            v2513 = v2512 + v2479;
            v2468[v2513] = v2511;
            v2474 += 192 ;
        }
        __syncthreads();
        v519.sync() ;
        float v2514;
        v2514 = 0.0f;
        int v2515;
        v2515 = threadIdx.x;
        int v2516;
        v2516 = blockIdx.x;
        int v2517;
        v2517 = v2516 * 256;
        int v2518;
        v2518 = v2515 + v2517;
        int v2519;
        v2519 = v2518;
        while (while_method_13(v2519)){
            bool v2521;
            v2521 = 0 <= v2519;
            bool v2522;
            v2522 = v2521 == false;
            if (v2522){
                assert("The index needs to be zero or positive." && v2521);
            } else {
            }
            int v2524;
            v2524 = v2519 % 64;
            int v2525;
            v2525 = v2519 / 64;
            bool v2526;
            v2526 = v2525 < 256;
            bool v2527;
            v2527 = v2526 == false;
            if (v2527){
                assert("The last element of the projection dimensions needs to be greater than the index remainder." && v2526);
            } else {
            }
            assert("Tensor range check" && 0 <= v2525 && v2525 < 256);
            assert("Tensor range check" && 0 <= v2524 && v2524 < 64);
            int v2529;
            v2529 = 4 * v2524;
            int v2530;
            v2530 = 256 * v2525;
            int v2531;
            v2531 = v2530 + v2529;
            float v2532[4];
            int4* v2533;
            v2533 = reinterpret_cast<int4*>(v2468 + v2531);
            int4* v2534;
            v2534 = reinterpret_cast<int4*>(v2532 + 0);
            assert("Pointer alignment check" && reinterpret_cast<unsigned long long>(v2533) % 16 == 0 && reinterpret_cast<unsigned long long>(v2534) % 16 == 0);
            *v2534 = *v2533;
            int v2535; float v2536;
            Tuple25 tmp168 = Tuple25{0, v2514};
            v2535 = tmp168.v0; v2536 = tmp168.v1;
            while (while_method_3(v2535)){
                assert("Tensor range check" && 0 <= v2535 && v2535 < 4);
                float v2538;
                v2538 = v2532[v2535];
                bool v2539;
                v2539 = v2536 >= v2538;
                float v2540;
                if (v2539){
                    v2540 = v2536;
                } else {
                    v2540 = v2538;
                }
                v2536 = v2540;
                v2535 += 1 ;
            }
            v2514 = v2536;
            v2519 += 6144 ;
        }
        __syncwarp();
        auto v2541 = cooperative_groups::coalesced_threads();
        float v2542;
        v2542 = cooperative_groups::reduce(v2541, v2514, v2199);
        int v2543;
        v2543 = threadIdx.x;
        int v2544;
        v2544 = v2543 / 32;
        extern __shared__ unsigned char v2545[];
        float * v2546;
        v2546 = reinterpret_cast<float *>(&v2545[0ull]);
        assert("Tensor range check" && 0 <= v2544 && v2544 < 8);
        v2546[v2544] = v2542;
        __syncthreads();
        int v2548;
        v2548 = threadIdx.x;
        int v2549;
        v2549 = v2548 % 32;
        bool v2550;
        v2550 = v2549 < 8;
        float v2552;
        if (v2550){
            assert("Tensor range check" && 0 <= v2549 && v2549 < 8);
            float v2551;
            v2551 = v2546[v2549];
            v2552 = v2551;
        } else {
            v2552 = 0.0f;
        }
        __syncthreads();
        auto v2553 = cooperative_groups::coalesced_threads();
        float v2554;
        v2554 = cooperative_groups::reduce(v2553, v2552, v2199);
        int v2555;
        v2555 = blockIdx.x;
        static float v2556[24];
        assert("Tensor range check" && 0 <= v2555 && v2555 < 24);
        v2556[v2555] = v2554;
        v519.sync() ;
        float v2557;
        v2557 = 0.0f;
        int v2558;
        v2558 = threadIdx.x;
        int v2559;
        v2559 = v2558 % 32;
        int v2560;
        v2560 = v2559;
        while (while_method_31(v2560)){
            bool v2562;
            v2562 = 0 <= v2560;
            bool v2563;
            v2563 = v2562 == false;
            if (v2563){
                assert("The index needs to be zero or positive." && v2562);
            } else {
            }
            bool v2565;
            v2565 = v2560 < 24;
            bool v2566;
            v2566 = v2565 == false;
            if (v2566){
                assert("The last element of the projection dimensions needs to be greater than the index remainder." && v2565);
            } else {
            }
            assert("Tensor range check" && 0 <= v2560 && v2560 < 24);
            float v2568;
            v2568 = v2556[v2560];
            bool v2569;
            v2569 = v2557 >= v2568;
            float v2570;
            if (v2569){
                v2570 = v2557;
            } else {
                v2570 = v2568;
            }
            v2557 = v2570;
            v2560 += 32 ;
        }
        __syncwarp();
        auto v2571 = cooperative_groups::coalesced_threads();
        float v2572;
        v2572 = cooperative_groups::reduce(v2571, v2557, v2199);
        int v2573;
        v2573 = threadIdx.x;
        int v2574;
        v2574 = blockIdx.x;
        int v2575;
        v2575 = v2574 * 256;
        int v2576;
        v2576 = v2573 + v2575;
        bool v2577;
        v2577 = v2576 == 0;
        if (v2577){
            cuda::counting_semaphore<cuda::thread_scope_system, 1> & v2578 = console_lock;
            auto v2579 = cooperative_groups::coalesced_threads();
            v2578.acquire();
            printf("{%s = %f}\n","max_norm", v2572);
            v2578.release();
            v2579.sync() ;
        } else {
        }
        __syncwarp();
        static float v2582[65536];
        int v2583;
        v2583 = threadIdx.x;
        int v2584;
        v2584 = blockIdx.x;
        int v2585;
        v2585 = v2584 * 256;
        int v2586;
        v2586 = v2583 + v2585;
        int v2587;
        v2587 = v2586 / 32;
        int v2588;
        v2588 = v2587;
        while (while_method_32(v2588)){
            bool v2590;
            v2590 = 0 <= v2588;
            bool v2591;
            v2591 = v2590 == false;
            if (v2591){
                assert("The index needs to be zero or positive." && v2590);
            } else {
            }
            int v2593;
            v2593 = v2588 % 256;
            int v2594;
            v2594 = v2588 / 256;
            bool v2595;
            v2595 = v2594 < 256;
            bool v2596;
            v2596 = v2595 == false;
            if (v2596){
                assert("The last element of the projection dimensions needs to be greater than the index remainder." && v2595);
            } else {
            }
            assert("Tensor range check" && 0 <= v2594 && v2594 < 256);
            assert("Tensor range check" && 0 <= v2593 && v2593 < 256);
            int v2598;
            v2598 = 4 * v2593;
            int v2599;
            v2599 = 1024 * v2594;
            int v2600;
            v2600 = v2599 + v2598;
            float v2601;
            v2601 = 0.0f;
            int v2602;
            v2602 = threadIdx.x;
            int v2603;
            v2603 = v2602 % 32;
            int v2604;
            v2604 = v2603;
            while (while_method_6(v2604)){
                bool v2606;
                v2606 = 0 <= v2604;
                bool v2607;
                v2607 = v2606 == false;
                if (v2607){
                    assert("The index needs to be zero or positive." && v2606);
                } else {
                }
                bool v2609;
                v2609 = v2604 < 1;
                bool v2610;
                v2610 = v2609 == false;
                if (v2610){
                    assert("The last element of the projection dimensions needs to be greater than the index remainder." && v2609);
                } else {
                }
                assert("Tensor range check" && 0 <= v2604 && v2604 < 1);
                int v2612;
                v2612 = 4 * v2604;
                int v2613;
                v2613 = v2612 + v2600;
                float v2614[4];
                int4* v2615;
                v2615 = reinterpret_cast<int4*>(v540 + v2613);
                int4* v2616;
                v2616 = reinterpret_cast<int4*>(v2614 + 0);
                assert("Pointer alignment check" && reinterpret_cast<unsigned long long>(v2615) % 16 == 0 && reinterpret_cast<unsigned long long>(v2616) % 16 == 0);
                *v2616 = *v2615;
                int v2617;
                v2617 = 0;
                while (while_method_3(v2617)){
                    assert("Tensor range check" && 0 <= v2617 && v2617 < 4);
                    float v2619;
                    v2619 = v2614[v2617];
                    float v2620;
                    v2620 = v2619 * v2619;
                    float v2621;
                    v2621 = v2601 + v2620;
                    v2601 = v2621;
                    v2617 += 1 ;
                }
                v2604 += 32 ;
            }
            __syncwarp();
            auto v2622 = cooperative_groups::coalesced_threads();
            Closure0 v2623{};
            float v2624;
            v2624 = cooperative_groups::reduce(v2622, v2601, v2623);
            float v2625;
            v2625 = sqrt(v2624);
            assert("Tensor range check" && 0 <= v2594 && v2594 < 256);
            assert("Tensor range check" && 0 <= v2593 && v2593 < 256);
            int v2626;
            v2626 = 256 * v2594;
            int v2627;
            v2627 = v2626 + v2593;
            v2582[v2627] = v2625;
            v2588 += 192 ;
        }
        __syncthreads();
        v519.sync() ;
        float v2628;
        v2628 = 0.0f;
        int v2629;
        v2629 = threadIdx.x;
        int v2630;
        v2630 = blockIdx.x;
        int v2631;
        v2631 = v2630 * 256;
        int v2632;
        v2632 = v2629 + v2631;
        int v2633;
        v2633 = v2632;
        while (while_method_13(v2633)){
            bool v2635;
            v2635 = 0 <= v2633;
            bool v2636;
            v2636 = v2635 == false;
            if (v2636){
                assert("The index needs to be zero or positive." && v2635);
            } else {
            }
            int v2638;
            v2638 = v2633 % 64;
            int v2639;
            v2639 = v2633 / 64;
            bool v2640;
            v2640 = v2639 < 256;
            bool v2641;
            v2641 = v2640 == false;
            if (v2641){
                assert("The last element of the projection dimensions needs to be greater than the index remainder." && v2640);
            } else {
            }
            assert("Tensor range check" && 0 <= v2639 && v2639 < 256);
            assert("Tensor range check" && 0 <= v2638 && v2638 < 64);
            int v2643;
            v2643 = 4 * v2638;
            int v2644;
            v2644 = 256 * v2639;
            int v2645;
            v2645 = v2644 + v2643;
            float v2646[4];
            int4* v2647;
            v2647 = reinterpret_cast<int4*>(v2582 + v2645);
            int4* v2648;
            v2648 = reinterpret_cast<int4*>(v2646 + 0);
            assert("Pointer alignment check" && reinterpret_cast<unsigned long long>(v2647) % 16 == 0 && reinterpret_cast<unsigned long long>(v2648) % 16 == 0);
            *v2648 = *v2647;
            int v2649; float v2650;
            Tuple25 tmp169 = Tuple25{0, v2628};
            v2649 = tmp169.v0; v2650 = tmp169.v1;
            while (while_method_3(v2649)){
                assert("Tensor range check" && 0 <= v2649 && v2649 < 4);
                float v2652;
                v2652 = v2646[v2649];
                bool v2653;
                v2653 = v2650 >= v2652;
                float v2654;
                if (v2653){
                    v2654 = v2650;
                } else {
                    v2654 = v2652;
                }
                v2650 = v2654;
                v2649 += 1 ;
            }
            v2628 = v2650;
            v2633 += 6144 ;
        }
        __syncwarp();
        auto v2655 = cooperative_groups::coalesced_threads();
        float v2656;
        v2656 = cooperative_groups::reduce(v2655, v2628, v2199);
        int v2657;
        v2657 = threadIdx.x;
        int v2658;
        v2658 = v2657 / 32;
        extern __shared__ unsigned char v2659[];
        float * v2660;
        v2660 = reinterpret_cast<float *>(&v2659[0ull]);
        assert("Tensor range check" && 0 <= v2658 && v2658 < 8);
        v2660[v2658] = v2656;
        __syncthreads();
        int v2662;
        v2662 = threadIdx.x;
        int v2663;
        v2663 = v2662 % 32;
        bool v2664;
        v2664 = v2663 < 8;
        float v2666;
        if (v2664){
            assert("Tensor range check" && 0 <= v2663 && v2663 < 8);
            float v2665;
            v2665 = v2660[v2663];
            v2666 = v2665;
        } else {
            v2666 = 0.0f;
        }
        __syncthreads();
        auto v2667 = cooperative_groups::coalesced_threads();
        float v2668;
        v2668 = cooperative_groups::reduce(v2667, v2666, v2199);
        int v2669;
        v2669 = blockIdx.x;
        static float v2670[24];
        assert("Tensor range check" && 0 <= v2669 && v2669 < 24);
        v2670[v2669] = v2668;
        v519.sync() ;
        float v2671;
        v2671 = 0.0f;
        int v2672;
        v2672 = threadIdx.x;
        int v2673;
        v2673 = v2672 % 32;
        int v2674;
        v2674 = v2673;
        while (while_method_31(v2674)){
            bool v2676;
            v2676 = 0 <= v2674;
            bool v2677;
            v2677 = v2676 == false;
            if (v2677){
                assert("The index needs to be zero or positive." && v2676);
            } else {
            }
            bool v2679;
            v2679 = v2674 < 24;
            bool v2680;
            v2680 = v2679 == false;
            if (v2680){
                assert("The last element of the projection dimensions needs to be greater than the index remainder." && v2679);
            } else {
            }
            assert("Tensor range check" && 0 <= v2674 && v2674 < 24);
            float v2682;
            v2682 = v2670[v2674];
            bool v2683;
            v2683 = v2671 >= v2682;
            float v2684;
            if (v2683){
                v2684 = v2671;
            } else {
                v2684 = v2682;
            }
            v2671 = v2684;
            v2674 += 32 ;
        }
        __syncwarp();
        auto v2685 = cooperative_groups::coalesced_threads();
        float v2686;
        v2686 = cooperative_groups::reduce(v2685, v2671, v2199);
        int v2687;
        v2687 = threadIdx.x;
        int v2688;
        v2688 = blockIdx.x;
        int v2689;
        v2689 = v2688 * 256;
        int v2690;
        v2690 = v2687 + v2689;
        bool v2691;
        v2691 = v2690 == 0;
        if (v2691){
            cuda::counting_semaphore<cuda::thread_scope_system, 1> & v2692 = console_lock;
            auto v2693 = cooperative_groups::coalesced_threads();
            v2692.acquire();
            printf("{%s = %f}\n","max_norm", v2686);
            v2692.release();
            v2693.sync() ;
        } else {
        }
        __syncwarp();
        static float v2696[16384];
        int v2697;
        v2697 = threadIdx.x;
        int v2698;
        v2698 = blockIdx.x;
        int v2699;
        v2699 = v2698 * 256;
        int v2700;
        v2700 = v2697 + v2699;
        int v2701;
        v2701 = v2700 / 32;
        int v2702;
        v2702 = v2701;
        while (while_method_13(v2702)){
            bool v2704;
            v2704 = 0 <= v2702;
            bool v2705;
            v2705 = v2704 == false;
            if (v2705){
                assert("The index needs to be zero or positive." && v2704);
            } else {
            }
            int v2707;
            v2707 = v2702 % 256;
            int v2708;
            v2708 = v2702 / 256;
            bool v2709;
            v2709 = v2708 < 64;
            bool v2710;
            v2710 = v2709 == false;
            if (v2710){
                assert("The last element of the projection dimensions needs to be greater than the index remainder." && v2709);
            } else {
            }
            assert("Tensor range check" && 0 <= v2708 && v2708 < 64);
            assert("Tensor range check" && 0 <= v2707 && v2707 < 256);
            int v2712;
            v2712 = 4 * v2707;
            int v2713;
            v2713 = 1024 * v2708;
            int v2714;
            v2714 = v2713 + v2712;
            float v2715;
            v2715 = 0.0f;
            int v2716;
            v2716 = threadIdx.x;
            int v2717;
            v2717 = v2716 % 32;
            int v2718;
            v2718 = v2717;
            while (while_method_6(v2718)){
                bool v2720;
                v2720 = 0 <= v2718;
                bool v2721;
                v2721 = v2720 == false;
                if (v2721){
                    assert("The index needs to be zero or positive." && v2720);
                } else {
                }
                bool v2723;
                v2723 = v2718 < 1;
                bool v2724;
                v2724 = v2723 == false;
                if (v2724){
                    assert("The last element of the projection dimensions needs to be greater than the index remainder." && v2723);
                } else {
                }
                assert("Tensor range check" && 0 <= v2718 && v2718 < 1);
                int v2726;
                v2726 = 4 * v2718;
                int v2727;
                v2727 = v2726 + v2714;
                float v2728[4];
                int4* v2729;
                v2729 = reinterpret_cast<int4*>(v544 + v2727);
                int4* v2730;
                v2730 = reinterpret_cast<int4*>(v2728 + 0);
                assert("Pointer alignment check" && reinterpret_cast<unsigned long long>(v2729) % 16 == 0 && reinterpret_cast<unsigned long long>(v2730) % 16 == 0);
                *v2730 = *v2729;
                int v2731;
                v2731 = 0;
                while (while_method_3(v2731)){
                    assert("Tensor range check" && 0 <= v2731 && v2731 < 4);
                    float v2733;
                    v2733 = v2728[v2731];
                    float v2734;
                    v2734 = v2733 * v2733;
                    float v2735;
                    v2735 = v2715 + v2734;
                    v2715 = v2735;
                    v2731 += 1 ;
                }
                v2718 += 32 ;
            }
            __syncwarp();
            auto v2736 = cooperative_groups::coalesced_threads();
            Closure0 v2737{};
            float v2738;
            v2738 = cooperative_groups::reduce(v2736, v2715, v2737);
            float v2739;
            v2739 = sqrt(v2738);
            assert("Tensor range check" && 0 <= v2708 && v2708 < 64);
            assert("Tensor range check" && 0 <= v2707 && v2707 < 256);
            int v2740;
            v2740 = 256 * v2708;
            int v2741;
            v2741 = v2740 + v2707;
            v2696[v2741] = v2739;
            v2702 += 192 ;
        }
        __syncthreads();
        v519.sync() ;
        float v2742;
        v2742 = 0.0f;
        int v2743;
        v2743 = threadIdx.x;
        int v2744;
        v2744 = blockIdx.x;
        int v2745;
        v2745 = v2744 * 256;
        int v2746;
        v2746 = v2743 + v2745;
        int v2747;
        v2747 = v2746;
        while (while_method_33(v2747)){
            bool v2749;
            v2749 = 0 <= v2747;
            bool v2750;
            v2750 = v2749 == false;
            if (v2750){
                assert("The index needs to be zero or positive." && v2749);
            } else {
            }
            int v2752;
            v2752 = v2747 % 64;
            int v2753;
            v2753 = v2747 / 64;
            bool v2754;
            v2754 = v2753 < 64;
            bool v2755;
            v2755 = v2754 == false;
            if (v2755){
                assert("The last element of the projection dimensions needs to be greater than the index remainder." && v2754);
            } else {
            }
            assert("Tensor range check" && 0 <= v2753 && v2753 < 64);
            assert("Tensor range check" && 0 <= v2752 && v2752 < 64);
            int v2757;
            v2757 = 4 * v2752;
            int v2758;
            v2758 = 256 * v2753;
            int v2759;
            v2759 = v2758 + v2757;
            float v2760[4];
            int4* v2761;
            v2761 = reinterpret_cast<int4*>(v2696 + v2759);
            int4* v2762;
            v2762 = reinterpret_cast<int4*>(v2760 + 0);
            assert("Pointer alignment check" && reinterpret_cast<unsigned long long>(v2761) % 16 == 0 && reinterpret_cast<unsigned long long>(v2762) % 16 == 0);
            *v2762 = *v2761;
            int v2763; float v2764;
            Tuple25 tmp170 = Tuple25{0, v2742};
            v2763 = tmp170.v0; v2764 = tmp170.v1;
            while (while_method_3(v2763)){
                assert("Tensor range check" && 0 <= v2763 && v2763 < 4);
                float v2766;
                v2766 = v2760[v2763];
                bool v2767;
                v2767 = v2764 >= v2766;
                float v2768;
                if (v2767){
                    v2768 = v2764;
                } else {
                    v2768 = v2766;
                }
                v2764 = v2768;
                v2763 += 1 ;
            }
            v2742 = v2764;
            v2747 += 6144 ;
        }
        __syncwarp();
        auto v2769 = cooperative_groups::coalesced_threads();
        float v2770;
        v2770 = cooperative_groups::reduce(v2769, v2742, v2199);
        int v2771;
        v2771 = threadIdx.x;
        int v2772;
        v2772 = v2771 / 32;
        extern __shared__ unsigned char v2773[];
        float * v2774;
        v2774 = reinterpret_cast<float *>(&v2773[0ull]);
        assert("Tensor range check" && 0 <= v2772 && v2772 < 8);
        v2774[v2772] = v2770;
        __syncthreads();
        int v2776;
        v2776 = threadIdx.x;
        int v2777;
        v2777 = v2776 % 32;
        bool v2778;
        v2778 = v2777 < 8;
        float v2780;
        if (v2778){
            assert("Tensor range check" && 0 <= v2777 && v2777 < 8);
            float v2779;
            v2779 = v2774[v2777];
            v2780 = v2779;
        } else {
            v2780 = 0.0f;
        }
        __syncthreads();
        auto v2781 = cooperative_groups::coalesced_threads();
        float v2782;
        v2782 = cooperative_groups::reduce(v2781, v2780, v2199);
        int v2783;
        v2783 = blockIdx.x;
        static float v2784[24];
        assert("Tensor range check" && 0 <= v2783 && v2783 < 24);
        v2784[v2783] = v2782;
        v519.sync() ;
        float v2785;
        v2785 = 0.0f;
        int v2786;
        v2786 = threadIdx.x;
        int v2787;
        v2787 = v2786 % 32;
        int v2788;
        v2788 = v2787;
        while (while_method_31(v2788)){
            bool v2790;
            v2790 = 0 <= v2788;
            bool v2791;
            v2791 = v2790 == false;
            if (v2791){
                assert("The index needs to be zero or positive." && v2790);
            } else {
            }
            bool v2793;
            v2793 = v2788 < 24;
            bool v2794;
            v2794 = v2793 == false;
            if (v2794){
                assert("The last element of the projection dimensions needs to be greater than the index remainder." && v2793);
            } else {
            }
            assert("Tensor range check" && 0 <= v2788 && v2788 < 24);
            float v2796;
            v2796 = v2784[v2788];
            bool v2797;
            v2797 = v2785 >= v2796;
            float v2798;
            if (v2797){
                v2798 = v2785;
            } else {
                v2798 = v2796;
            }
            v2785 = v2798;
            v2788 += 32 ;
        }
        __syncwarp();
        auto v2799 = cooperative_groups::coalesced_threads();
        float v2800;
        v2800 = cooperative_groups::reduce(v2799, v2785, v2199);
        int v2801;
        v2801 = threadIdx.x;
        int v2802;
        v2802 = blockIdx.x;
        int v2803;
        v2803 = v2802 * 256;
        int v2804;
        v2804 = v2801 + v2803;
        bool v2805;
        v2805 = v2804 == 0;
        if (v2805){
            cuda::counting_semaphore<cuda::thread_scope_system, 1> & v2806 = console_lock;
            auto v2807 = cooperative_groups::coalesced_threads();
            v2806.acquire();
            printf("{%s = %f}\n","max_norm", v2800);
            v2806.release();
            v2807.sync() ;
        } else {
        }
        __syncwarp();
        extern __shared__ unsigned char v2810[];
        float * v2811;
        v2811 = reinterpret_cast<float *>(&v2810[0ull]);
        int v2813;
        v2813 = blockIdx.x;
        int v2814;
        v2814 = v2813;
        while (while_method_26(v2814)){
            bool v2816;
            v2816 = 0 <= v2814;
            bool v2817;
            v2817 = v2816 == false;
            if (v2817){
                assert("The index needs to be zero or positive." && v2816);
            } else {
            }
            int v2819;
            v2819 = v2814 % 1;
            bool v2820;
            v2820 = v2814 < 1024;
            bool v2821;
            v2821 = v2820 == false;
            if (v2821){
                assert("The last element of the projection dimensions needs to be greater than the index remainder." && v2820);
            } else {
            }
            assert("Tensor range check" && 0 <= v2814 && v2814 < 1024);
            assert("Tensor range check" && 0 <= v2819 && v2819 < 1);
            int v2823;
            v2823 = 4 * v2819;
            int v2824;
            v2824 = 2048 * v2814;
            int v2825;
            v2825 = v2824 + v2823;
            int v2826;
            v2826 = 2097152 * v2819;
            int v2827;
            v2827 = 512 * v2814;
            int v2828;
            v2828 = v2827 + v2826;
            int v2829;
            v2829 = threadIdx.x;
            int v2830;
            v2830 = v2829;
            while (while_method_23(v2830)){
                bool v2832;
                v2832 = 0 <= v2830;
                bool v2833;
                v2833 = v2832 == false;
                if (v2833){
                    assert("The index needs to be zero or positive." && v2832);
                } else {
                }
                int v2835;
                v2835 = v2830 % 4;
                int v2836;
                v2836 = v2830 / 4;
                bool v2837;
                v2837 = v2836 < 512;
                bool v2838;
                v2838 = v2837 == false;
                if (v2838){
                    assert("The last element of the projection dimensions needs to be greater than the index remainder." && v2837);
                } else {
                }
                assert("Tensor range check" && 0 <= v2836 && v2836 < 512);
                assert("Tensor range check" && 0 <= v2835 && v2835 < 4);
                int v2840;
                v2840 = v2835 + v2825;
                int v2841;
                v2841 = 4 * v2836;
                int v2842;
                v2842 = v2841 + v2840;
                float v2843;
                v2843 = v524[v2842];
                assert("Tensor range check" && 0 <= v2836 && v2836 < 512);
                assert("Tensor range check" && 0 <= v2835 && v2835 < 4);
                int v2844;
                v2844 = 33 * v2836;
                int v2845;
                v2845 = v2844 + v2835;
                v2811[v2845] = v2843;
                v2830 += 256 ;
            }
            __syncthreads();
            int v2846;
            v2846 = threadIdx.x;
            int v2847;
            v2847 = v2846;
            while (while_method_23(v2847)){
                bool v2849;
                v2849 = 0 <= v2847;
                bool v2850;
                v2850 = v2849 == false;
                if (v2850){
                    assert("The index needs to be zero or positive." && v2849);
                } else {
                }
                int v2852;
                v2852 = v2847 % 512;
                int v2853;
                v2853 = v2847 / 512;
                bool v2854;
                v2854 = v2853 < 4;
                bool v2855;
                v2855 = v2854 == false;
                if (v2855){
                    assert("The last element of the projection dimensions needs to be greater than the index remainder." && v2854);
                } else {
                }
                assert("Tensor range check" && 0 <= v2853 && v2853 < 4);
                assert("Tensor range check" && 0 <= v2852 && v2852 < 512);
                int v2857;
                v2857 = 33 * v2852;
                int v2858;
                v2858 = v2853 + v2857;
                float v2859;
                v2859 = v2811[v2858];
                assert("Tensor range check" && 0 <= v2853 && v2853 < 4);
                assert("Tensor range check" && 0 <= v2852 && v2852 < 512);
                int v2860;
                v2860 = v2852 + v2828;
                int v2861;
                v2861 = 524288 * v2853;
                int v2862;
                v2862 = v2861 + v2860;
                v522[v2862] = v2859;
                v2847 += 256 ;
            }
            __syncthreads();
            v2814 += 24 ;
        }
        extern __shared__ unsigned char v2863[];
        float * v2864;
        v2864 = reinterpret_cast<float *>(&v2863[0ull]);
        int v2866;
        v2866 = blockIdx.x;
        int v2867;
        v2867 = v2866;
        while (while_method_27(v2867)){
            bool v2869;
            v2869 = 0 <= v2867;
            bool v2870;
            v2870 = v2869 == false;
            if (v2870){
                assert("The index needs to be zero or positive." && v2869);
            } else {
            }
            int v2872;
            v2872 = v2867 % 1;
            bool v2873;
            v2873 = v2867 < 128;
            bool v2874;
            v2874 = v2873 == false;
            if (v2874){
                assert("The last element of the projection dimensions needs to be greater than the index remainder." && v2873);
            } else {
            }
            assert("Tensor range check" && 0 <= v2867 && v2867 < 128);
            assert("Tensor range check" && 0 <= v2872 && v2872 < 1);
            int v2876;
            v2876 = 4 * v2872;
            int v2877;
            v2877 = 2048 * v2867;
            int v2878;
            v2878 = v2877 + v2876;
            int v2879;
            v2879 = 262144 * v2872;
            int v2880;
            v2880 = 512 * v2867;
            int v2881;
            v2881 = v2880 + v2879;
            int v2882;
            v2882 = threadIdx.x;
            int v2883;
            v2883 = v2882;
            while (while_method_23(v2883)){
                bool v2885;
                v2885 = 0 <= v2883;
                bool v2886;
                v2886 = v2885 == false;
                if (v2886){
                    assert("The index needs to be zero or positive." && v2885);
                } else {
                }
                int v2888;
                v2888 = v2883 % 4;
                int v2889;
                v2889 = v2883 / 4;
                bool v2890;
                v2890 = v2889 < 512;
                bool v2891;
                v2891 = v2890 == false;
                if (v2891){
                    assert("The last element of the projection dimensions needs to be greater than the index remainder." && v2890);
                } else {
                }
                assert("Tensor range check" && 0 <= v2889 && v2889 < 512);
                assert("Tensor range check" && 0 <= v2888 && v2888 < 4);
                int v2893;
                v2893 = v2888 + v2878;
                int v2894;
                v2894 = 4 * v2889;
                int v2895;
                v2895 = v2894 + v2893;
                float v2896;
                v2896 = v528[v2895];
                assert("Tensor range check" && 0 <= v2889 && v2889 < 512);
                assert("Tensor range check" && 0 <= v2888 && v2888 < 4);
                int v2897;
                v2897 = 33 * v2889;
                int v2898;
                v2898 = v2897 + v2888;
                v2864[v2898] = v2896;
                v2883 += 256 ;
            }
            __syncthreads();
            int v2899;
            v2899 = threadIdx.x;
            int v2900;
            v2900 = v2899;
            while (while_method_23(v2900)){
                bool v2902;
                v2902 = 0 <= v2900;
                bool v2903;
                v2903 = v2902 == false;
                if (v2903){
                    assert("The index needs to be zero or positive." && v2902);
                } else {
                }
                int v2905;
                v2905 = v2900 % 512;
                int v2906;
                v2906 = v2900 / 512;
                bool v2907;
                v2907 = v2906 < 4;
                bool v2908;
                v2908 = v2907 == false;
                if (v2908){
                    assert("The last element of the projection dimensions needs to be greater than the index remainder." && v2907);
                } else {
                }
                assert("Tensor range check" && 0 <= v2906 && v2906 < 4);
                assert("Tensor range check" && 0 <= v2905 && v2905 < 512);
                int v2910;
                v2910 = 33 * v2905;
                int v2911;
                v2911 = v2906 + v2910;
                float v2912;
                v2912 = v2864[v2911];
                assert("Tensor range check" && 0 <= v2906 && v2906 < 4);
                assert("Tensor range check" && 0 <= v2905 && v2905 < 512);
                int v2913;
                v2913 = v2905 + v2881;
                int v2914;
                v2914 = 65536 * v2906;
                int v2915;
                v2915 = v2914 + v2913;
                v526[v2915] = v2912;
                v2900 += 256 ;
            }
            __syncthreads();
            v2867 += 24 ;
        }
        extern __shared__ unsigned char v2916[];
        float * v2917;
        v2917 = reinterpret_cast<float *>(&v2916[0ull]);
        int v2919;
        v2919 = blockIdx.x;
        int v2920;
        v2920 = v2919;
        while (while_method_27(v2920)){
            bool v2922;
            v2922 = 0 <= v2920;
            bool v2923;
            v2923 = v2922 == false;
            if (v2923){
                assert("The index needs to be zero or positive." && v2922);
            } else {
            }
            int v2925;
            v2925 = v2920 % 1;
            bool v2926;
            v2926 = v2920 < 128;
            bool v2927;
            v2927 = v2926 == false;
            if (v2927){
                assert("The last element of the projection dimensions needs to be greater than the index remainder." && v2926);
            } else {
            }
            assert("Tensor range check" && 0 <= v2920 && v2920 < 128);
            assert("Tensor range check" && 0 <= v2925 && v2925 < 1);
            int v2929;
            v2929 = 4 * v2925;
            int v2930;
            v2930 = 2048 * v2920;
            int v2931;
            v2931 = v2930 + v2929;
            int v2932;
            v2932 = 262144 * v2925;
            int v2933;
            v2933 = 512 * v2920;
            int v2934;
            v2934 = v2933 + v2932;
            int v2935;
            v2935 = threadIdx.x;
            int v2936;
            v2936 = v2935;
            while (while_method_23(v2936)){
                bool v2938;
                v2938 = 0 <= v2936;
                bool v2939;
                v2939 = v2938 == false;
                if (v2939){
                    assert("The index needs to be zero or positive." && v2938);
                } else {
                }
                int v2941;
                v2941 = v2936 % 4;
                int v2942;
                v2942 = v2936 / 4;
                bool v2943;
                v2943 = v2942 < 512;
                bool v2944;
                v2944 = v2943 == false;
                if (v2944){
                    assert("The last element of the projection dimensions needs to be greater than the index remainder." && v2943);
                } else {
                }
                assert("Tensor range check" && 0 <= v2942 && v2942 < 512);
                assert("Tensor range check" && 0 <= v2941 && v2941 < 4);
                int v2946;
                v2946 = v2941 + v2931;
                int v2947;
                v2947 = 4 * v2942;
                int v2948;
                v2948 = v2947 + v2946;
                float v2949;
                v2949 = v532[v2948];
                assert("Tensor range check" && 0 <= v2942 && v2942 < 512);
                assert("Tensor range check" && 0 <= v2941 && v2941 < 4);
                int v2950;
                v2950 = 33 * v2942;
                int v2951;
                v2951 = v2950 + v2941;
                v2917[v2951] = v2949;
                v2936 += 256 ;
            }
            __syncthreads();
            int v2952;
            v2952 = threadIdx.x;
            int v2953;
            v2953 = v2952;
            while (while_method_23(v2953)){
                bool v2955;
                v2955 = 0 <= v2953;
                bool v2956;
                v2956 = v2955 == false;
                if (v2956){
                    assert("The index needs to be zero or positive." && v2955);
                } else {
                }
                int v2958;
                v2958 = v2953 % 512;
                int v2959;
                v2959 = v2953 / 512;
                bool v2960;
                v2960 = v2959 < 4;
                bool v2961;
                v2961 = v2960 == false;
                if (v2961){
                    assert("The last element of the projection dimensions needs to be greater than the index remainder." && v2960);
                } else {
                }
                assert("Tensor range check" && 0 <= v2959 && v2959 < 4);
                assert("Tensor range check" && 0 <= v2958 && v2958 < 512);
                int v2963;
                v2963 = 33 * v2958;
                int v2964;
                v2964 = v2959 + v2963;
                float v2965;
                v2965 = v2917[v2964];
                assert("Tensor range check" && 0 <= v2959 && v2959 < 4);
                assert("Tensor range check" && 0 <= v2958 && v2958 < 512);
                int v2966;
                v2966 = v2958 + v2934;
                int v2967;
                v2967 = 65536 * v2959;
                int v2968;
                v2968 = v2967 + v2966;
                v530[v2968] = v2965;
                v2953 += 256 ;
            }
            __syncthreads();
            v2920 += 24 ;
        }
        extern __shared__ unsigned char v2969[];
        float * v2970;
        v2970 = reinterpret_cast<float *>(&v2969[0ull]);
        int v2972;
        v2972 = blockIdx.x;
        int v2973;
        v2973 = v2972;
        while (while_method_27(v2973)){
            bool v2975;
            v2975 = 0 <= v2973;
            bool v2976;
            v2976 = v2975 == false;
            if (v2976){
                assert("The index needs to be zero or positive." && v2975);
            } else {
            }
            int v2978;
            v2978 = v2973 % 1;
            bool v2979;
            v2979 = v2973 < 128;
            bool v2980;
            v2980 = v2979 == false;
            if (v2980){
                assert("The last element of the projection dimensions needs to be greater than the index remainder." && v2979);
            } else {
            }
            assert("Tensor range check" && 0 <= v2973 && v2973 < 128);
            assert("Tensor range check" && 0 <= v2978 && v2978 < 1);
            int v2982;
            v2982 = 4 * v2978;
            int v2983;
            v2983 = 2048 * v2973;
            int v2984;
            v2984 = v2983 + v2982;
            int v2985;
            v2985 = 262144 * v2978;
            int v2986;
            v2986 = 512 * v2973;
            int v2987;
            v2987 = v2986 + v2985;
            int v2988;
            v2988 = threadIdx.x;
            int v2989;
            v2989 = v2988;
            while (while_method_23(v2989)){
                bool v2991;
                v2991 = 0 <= v2989;
                bool v2992;
                v2992 = v2991 == false;
                if (v2992){
                    assert("The index needs to be zero or positive." && v2991);
                } else {
                }
                int v2994;
                v2994 = v2989 % 4;
                int v2995;
                v2995 = v2989 / 4;
                bool v2996;
                v2996 = v2995 < 512;
                bool v2997;
                v2997 = v2996 == false;
                if (v2997){
                    assert("The last element of the projection dimensions needs to be greater than the index remainder." && v2996);
                } else {
                }
                assert("Tensor range check" && 0 <= v2995 && v2995 < 512);
                assert("Tensor range check" && 0 <= v2994 && v2994 < 4);
                int v2999;
                v2999 = v2994 + v2984;
                int v3000;
                v3000 = 4 * v2995;
                int v3001;
                v3001 = v3000 + v2999;
                float v3002;
                v3002 = v536[v3001];
                assert("Tensor range check" && 0 <= v2995 && v2995 < 512);
                assert("Tensor range check" && 0 <= v2994 && v2994 < 4);
                int v3003;
                v3003 = 33 * v2995;
                int v3004;
                v3004 = v3003 + v2994;
                v2970[v3004] = v3002;
                v2989 += 256 ;
            }
            __syncthreads();
            int v3005;
            v3005 = threadIdx.x;
            int v3006;
            v3006 = v3005;
            while (while_method_23(v3006)){
                bool v3008;
                v3008 = 0 <= v3006;
                bool v3009;
                v3009 = v3008 == false;
                if (v3009){
                    assert("The index needs to be zero or positive." && v3008);
                } else {
                }
                int v3011;
                v3011 = v3006 % 512;
                int v3012;
                v3012 = v3006 / 512;
                bool v3013;
                v3013 = v3012 < 4;
                bool v3014;
                v3014 = v3013 == false;
                if (v3014){
                    assert("The last element of the projection dimensions needs to be greater than the index remainder." && v3013);
                } else {
                }
                assert("Tensor range check" && 0 <= v3012 && v3012 < 4);
                assert("Tensor range check" && 0 <= v3011 && v3011 < 512);
                int v3016;
                v3016 = 33 * v3011;
                int v3017;
                v3017 = v3012 + v3016;
                float v3018;
                v3018 = v2970[v3017];
                assert("Tensor range check" && 0 <= v3012 && v3012 < 4);
                assert("Tensor range check" && 0 <= v3011 && v3011 < 512);
                int v3019;
                v3019 = v3011 + v2987;
                int v3020;
                v3020 = 65536 * v3012;
                int v3021;
                v3021 = v3020 + v3019;
                v534[v3021] = v3018;
                v3006 += 256 ;
            }
            __syncthreads();
            v2973 += 24 ;
        }
        extern __shared__ unsigned char v3022[];
        float * v3023;
        v3023 = reinterpret_cast<float *>(&v3022[0ull]);
        int v3025;
        v3025 = blockIdx.x;
        int v3026;
        v3026 = v3025;
        while (while_method_27(v3026)){
            bool v3028;
            v3028 = 0 <= v3026;
            bool v3029;
            v3029 = v3028 == false;
            if (v3029){
                assert("The index needs to be zero or positive." && v3028);
            } else {
            }
            int v3031;
            v3031 = v3026 % 1;
            bool v3032;
            v3032 = v3026 < 128;
            bool v3033;
            v3033 = v3032 == false;
            if (v3033){
                assert("The last element of the projection dimensions needs to be greater than the index remainder." && v3032);
            } else {
            }
            assert("Tensor range check" && 0 <= v3026 && v3026 < 128);
            assert("Tensor range check" && 0 <= v3031 && v3031 < 1);
            int v3035;
            v3035 = 4 * v3031;
            int v3036;
            v3036 = 2048 * v3026;
            int v3037;
            v3037 = v3036 + v3035;
            int v3038;
            v3038 = 262144 * v3031;
            int v3039;
            v3039 = 512 * v3026;
            int v3040;
            v3040 = v3039 + v3038;
            int v3041;
            v3041 = threadIdx.x;
            int v3042;
            v3042 = v3041;
            while (while_method_23(v3042)){
                bool v3044;
                v3044 = 0 <= v3042;
                bool v3045;
                v3045 = v3044 == false;
                if (v3045){
                    assert("The index needs to be zero or positive." && v3044);
                } else {
                }
                int v3047;
                v3047 = v3042 % 4;
                int v3048;
                v3048 = v3042 / 4;
                bool v3049;
                v3049 = v3048 < 512;
                bool v3050;
                v3050 = v3049 == false;
                if (v3050){
                    assert("The last element of the projection dimensions needs to be greater than the index remainder." && v3049);
                } else {
                }
                assert("Tensor range check" && 0 <= v3048 && v3048 < 512);
                assert("Tensor range check" && 0 <= v3047 && v3047 < 4);
                int v3052;
                v3052 = v3047 + v3037;
                int v3053;
                v3053 = 4 * v3048;
                int v3054;
                v3054 = v3053 + v3052;
                float v3055;
                v3055 = v540[v3054];
                assert("Tensor range check" && 0 <= v3048 && v3048 < 512);
                assert("Tensor range check" && 0 <= v3047 && v3047 < 4);
                int v3056;
                v3056 = 33 * v3048;
                int v3057;
                v3057 = v3056 + v3047;
                v3023[v3057] = v3055;
                v3042 += 256 ;
            }
            __syncthreads();
            int v3058;
            v3058 = threadIdx.x;
            int v3059;
            v3059 = v3058;
            while (while_method_23(v3059)){
                bool v3061;
                v3061 = 0 <= v3059;
                bool v3062;
                v3062 = v3061 == false;
                if (v3062){
                    assert("The index needs to be zero or positive." && v3061);
                } else {
                }
                int v3064;
                v3064 = v3059 % 512;
                int v3065;
                v3065 = v3059 / 512;
                bool v3066;
                v3066 = v3065 < 4;
                bool v3067;
                v3067 = v3066 == false;
                if (v3067){
                    assert("The last element of the projection dimensions needs to be greater than the index remainder." && v3066);
                } else {
                }
                assert("Tensor range check" && 0 <= v3065 && v3065 < 4);
                assert("Tensor range check" && 0 <= v3064 && v3064 < 512);
                int v3069;
                v3069 = 33 * v3064;
                int v3070;
                v3070 = v3065 + v3069;
                float v3071;
                v3071 = v3023[v3070];
                assert("Tensor range check" && 0 <= v3065 && v3065 < 4);
                assert("Tensor range check" && 0 <= v3064 && v3064 < 512);
                int v3072;
                v3072 = v3064 + v3040;
                int v3073;
                v3073 = 65536 * v3065;
                int v3074;
                v3074 = v3073 + v3072;
                v538[v3074] = v3071;
                v3059 += 256 ;
            }
            __syncthreads();
            v3026 += 24 ;
        }
        extern __shared__ unsigned char v3075[];
        float * v3076;
        v3076 = reinterpret_cast<float *>(&v3075[0ull]);
        int v3078;
        v3078 = blockIdx.x;
        int v3079;
        v3079 = v3078;
        while (while_method_24(v3079)){
            bool v3081;
            v3081 = 0 <= v3079;
            bool v3082;
            v3082 = v3081 == false;
            if (v3082){
                assert("The index needs to be zero or positive." && v3081);
            } else {
            }
            int v3084;
            v3084 = v3079 % 1;
            bool v3085;
            v3085 = v3079 < 32;
            bool v3086;
            v3086 = v3085 == false;
            if (v3086){
                assert("The last element of the projection dimensions needs to be greater than the index remainder." && v3085);
            } else {
            }
            assert("Tensor range check" && 0 <= v3079 && v3079 < 32);
            assert("Tensor range check" && 0 <= v3084 && v3084 < 1);
            int v3088;
            v3088 = 4 * v3084;
            int v3089;
            v3089 = 2048 * v3079;
            int v3090;
            v3090 = v3089 + v3088;
            int v3091;
            v3091 = 65536 * v3084;
            int v3092;
            v3092 = 512 * v3079;
            int v3093;
            v3093 = v3092 + v3091;
            int v3094;
            v3094 = threadIdx.x;
            int v3095;
            v3095 = v3094;
            while (while_method_23(v3095)){
                bool v3097;
                v3097 = 0 <= v3095;
                bool v3098;
                v3098 = v3097 == false;
                if (v3098){
                    assert("The index needs to be zero or positive." && v3097);
                } else {
                }
                int v3100;
                v3100 = v3095 % 4;
                int v3101;
                v3101 = v3095 / 4;
                bool v3102;
                v3102 = v3101 < 512;
                bool v3103;
                v3103 = v3102 == false;
                if (v3103){
                    assert("The last element of the projection dimensions needs to be greater than the index remainder." && v3102);
                } else {
                }
                assert("Tensor range check" && 0 <= v3101 && v3101 < 512);
                assert("Tensor range check" && 0 <= v3100 && v3100 < 4);
                int v3105;
                v3105 = v3100 + v3090;
                int v3106;
                v3106 = 4 * v3101;
                int v3107;
                v3107 = v3106 + v3105;
                float v3108;
                v3108 = v544[v3107];
                assert("Tensor range check" && 0 <= v3101 && v3101 < 512);
                assert("Tensor range check" && 0 <= v3100 && v3100 < 4);
                int v3109;
                v3109 = 33 * v3101;
                int v3110;
                v3110 = v3109 + v3100;
                v3076[v3110] = v3108;
                v3095 += 256 ;
            }
            __syncthreads();
            int v3111;
            v3111 = threadIdx.x;
            int v3112;
            v3112 = v3111;
            while (while_method_23(v3112)){
                bool v3114;
                v3114 = 0 <= v3112;
                bool v3115;
                v3115 = v3114 == false;
                if (v3115){
                    assert("The index needs to be zero or positive." && v3114);
                } else {
                }
                int v3117;
                v3117 = v3112 % 512;
                int v3118;
                v3118 = v3112 / 512;
                bool v3119;
                v3119 = v3118 < 4;
                bool v3120;
                v3120 = v3119 == false;
                if (v3120){
                    assert("The last element of the projection dimensions needs to be greater than the index remainder." && v3119);
                } else {
                }
                assert("Tensor range check" && 0 <= v3118 && v3118 < 4);
                assert("Tensor range check" && 0 <= v3117 && v3117 < 512);
                int v3122;
                v3122 = 33 * v3117;
                int v3123;
                v3123 = v3118 + v3122;
                float v3124;
                v3124 = v3076[v3123];
                assert("Tensor range check" && 0 <= v3118 && v3118 < 4);
                assert("Tensor range check" && 0 <= v3117 && v3117 < 512);
                int v3125;
                v3125 = v3117 + v3093;
                int v3126;
                v3126 = 16384 * v3118;
                int v3127;
                v3127 = v3126 + v3125;
                v542[v3127] = v3124;
                v3112 += 256 ;
            }
            __syncthreads();
            v3079 += 24 ;
        }
        v519.sync() ;
        v27 += 1 ;
    }
    cooperative_groups::grid_group & v3128 = v26.v1;
    cooperative_groups::grid_group & v3129 = v3128;
    int v3130;
    v3130 = threadIdx.x;
    int v3131;
    v3131 = blockIdx.x;
    int v3132;
    v3132 = v3131 * 256;
    int v3133;
    v3133 = v3130 + v3132;
    int v3134;
    v3134 = v3133;
    while (while_method_23(v3134)){
        bool v3136;
        v3136 = 0 <= v3134;
        bool v3137;
        v3137 = v3136 == false;
        if (v3137){
            assert("The index needs to be zero or positive." && v3136);
        } else {
        }
        int v3139;
        v3139 = v3134 % 512;
        int v3140;
        v3140 = v3134 / 512;
        bool v3141;
        v3141 = v3140 < 4;
        bool v3142;
        v3142 = v3141 == false;
        if (v3142){
            assert("The last element of the projection dimensions needs to be greater than the index remainder." && v3141);
        } else {
        }
        assert("Tensor range check" && 0 <= v3140 && v3140 < 4);
        assert("Tensor range check" && 0 <= v3139 && v3139 < 512);
        int v3144;
        v3144 = 4 * v3139;
        int v3145;
        v3145 = 2048 * v3140;
        int v3146;
        v3146 = v3145 + v3144;
        assert("Tensor range check" && 0 <= v3140 && v3140 < 4);
        assert("Tensor range check" && 0 <= v3139 && v3139 < 512);
        float v3147[4];
        float v3148[4];
        float v3149[4];
        int4* v3150;
        v3150 = reinterpret_cast<int4*>(v3 + v3146);
        int4* v3151;
        v3151 = reinterpret_cast<int4*>(v3147 + 0);
        assert("Pointer alignment check" && reinterpret_cast<unsigned long long>(v3150) % 16 == 0 && reinterpret_cast<unsigned long long>(v3151) % 16 == 0);
        *v3151 = *v3150;
        int4* v3152;
        v3152 = reinterpret_cast<int4*>(v4 + v3146);
        int4* v3153;
        v3153 = reinterpret_cast<int4*>(v3148 + 0);
        assert("Pointer alignment check" && reinterpret_cast<unsigned long long>(v3152) % 16 == 0 && reinterpret_cast<unsigned long long>(v3153) % 16 == 0);
        *v3153 = *v3152;
        // Pushing the loop unrolling to: 0
        int v3154;
        v3154 = 0;
        #pragma unroll
        while (while_method_3(v3154)){
            assert("Tensor range check" && 0 <= v3154 && v3154 < 4);
            float v3156;
            v3156 = v3147[v3154];
            float v3157;
            v3157 = v3148[v3154];
            bool v3158;
            v3158 = v3157 == 0.0f;
            bool v3159;
            v3159 = v3158 != true;
            float v3161;
            if (v3159){
                float v3160;
                v3160 = v3156 / v3157;
                v3161 = v3160;
            } else {
                v3161 = 0.0f;
            }
            assert("Tensor range check" && 0 <= v3154 && v3154 < 4);
            v3149[v3154] = v3161;
            v3154 += 1 ;
        }
        // Poping the loop unrolling to: 0
        int4* v3162;
        v3162 = reinterpret_cast<int4*>(v3149 + 0);
        int4* v3163;
        v3163 = reinterpret_cast<int4*>(v5 + v3146);
        assert("Pointer alignment check" && reinterpret_cast<unsigned long long>(v3162) % 16 == 0 && reinterpret_cast<unsigned long long>(v3163) % 16 == 0);
        *v3163 = *v3162;
        v3134 += 6144 ;
    }
    v3129.sync() ;
    return ;
}
"""
class static_array():
    def __init__(self, length):
        self.ptr = []
        for _ in range(length):
            self.ptr.append(None)

    def __getitem__(self, index):
        assert 0 <= index < len(self.ptr), "The get index needs to be in range."
        return self.ptr[index]
    
    def __setitem__(self, index, value):
        assert 0 <= index < len(self.ptr), "The set index needs to be in range."
        self.ptr[index] = value

class static_array_list(static_array):
    def __init__(self, length):
        super().__init__(length)
        self.length = 0

    def __getitem__(self, index):
        assert 0 <= index < self.length, "The get index needs to be in range."
        return self.ptr[index]
    
    def __setitem__(self, index, value):
        assert 0 <= index < self.length, "The set index needs to be in range."
        self.ptr[index] = value

    def push(self,value):
        assert (self.length < len(self.ptr)), "The length before pushing has to be less than the maximum length of the array."
        self.ptr[self.length] = value
        self.length += 1

    def pop(self):
        assert (0 < self.length), "The length before popping has to be greater than 0."
        self.length -= 1
        return self.ptr[self.length]

    def unsafe_set_length(self,i):
        assert 0 <= i <= len(self.ptr), "The new length has to be in range."
        self.length = i

class dynamic_array(static_array): 
    pass

class dynamic_array_list(static_array_list):
    def length_(self): return self.length

import cupy as cp
from dataclasses import dataclass
from typing import NamedTuple, Union, Callable, Tuple
i8 = int; i16 = int; i32 = int; i64 = int; u8 = int; u16 = int; u32 = int; u64 = int; f32 = float; f64 = float; char = str; string = str

import time
options = []
options.append('--define-macro=NDEBUG')
options.append('--dopt=on')
options.append('--diag-suppress=550,20012,68,39,177')
options.append('--restrict')
options.append('--maxrregcount=255')
options.append('--std=c++20')
options.append('-D__CUDA_NO_HALF_CONVERSIONS__')
raw_module = cp.RawModule(code=kernel, backend='nvcc', enable_cooperative_groups=True, options=tuple(options))
import collections
class US1_0(NamedTuple): # A_All_In
    tag = 0
class US1_1(NamedTuple): # A_Call
    tag = 1
class US1_2(NamedTuple): # A_Fold
    tag = 2
class US1_3(NamedTuple): # A_Raise
    v0 : i32
    tag = 3
US1 = Union[US1_0, US1_1, US1_2, US1_3]
class US0_0(NamedTuple): # ActionSelected
    v0 : US1
    tag = 0
class US0_1(NamedTuple): # PlayerChanged
    v0 : static_array
    tag = 1
class US0_2(NamedTuple): # StartGame
    tag = 2
class US0_3(NamedTuple): # StartTrainingVsCallingMachine
    tag = 3
class US0_4(NamedTuple): # StartTrainingVsSelf
    tag = 4
US0 = Union[US0_0, US0_1, US0_2, US0_3, US0_4]
class US2_0(NamedTuple): # CallingMachine
    tag = 0
class US2_1(NamedTuple): # Computer
    tag = 1
class US2_2(NamedTuple): # Human
    tag = 2
class US2_3(NamedTuple): # Random
    tag = 3
US2 = Union[US2_0, US2_1, US2_2, US2_3]
class US5_0(NamedTuple): # Flop
    v0 : static_array
    tag = 0
class US5_1(NamedTuple): # Preflop
    tag = 1
class US5_2(NamedTuple): # River
    v0 : static_array
    tag = 2
class US5_3(NamedTuple): # Turn
    v0 : static_array
    tag = 3
US5 = Union[US5_0, US5_1, US5_2, US5_3]
class US4_0(NamedTuple): # G_Flop
    v0 : i32
    v1 : static_array
    v2 : static_array
    v3 : i32
    v4 : static_array
    v5 : US5
    tag = 0
class US4_1(NamedTuple): # G_Fold
    v0 : i32
    v1 : static_array
    v2 : static_array
    v3 : i32
    v4 : static_array
    v5 : US5
    tag = 1
class US4_2(NamedTuple): # G_Preflop
    tag = 2
class US4_3(NamedTuple): # G_River
    v0 : i32
    v1 : static_array
    v2 : static_array
    v3 : i32
    v4 : static_array
    v5 : US5
    tag = 3
class US4_4(NamedTuple): # G_Round
    v0 : i32
    v1 : static_array
    v2 : static_array
    v3 : i32
    v4 : static_array
    v5 : US5
    tag = 4
class US4_5(NamedTuple): # G_Round'
    v0 : i32
    v1 : static_array
    v2 : static_array
    v3 : i32
    v4 : static_array
    v5 : US5
    v6 : US1
    tag = 5
class US4_6(NamedTuple): # G_Showdown
    v0 : i32
    v1 : static_array
    v2 : static_array
    v3 : i32
    v4 : static_array
    v5 : US5
    tag = 6
class US4_7(NamedTuple): # G_Turn
    v0 : i32
    v1 : static_array
    v2 : static_array
    v3 : i32
    v4 : static_array
    v5 : US5
    tag = 7
US4 = Union[US4_0, US4_1, US4_2, US4_3, US4_4, US4_5, US4_6, US4_7]
class US3_0(NamedTuple): # None
    tag = 0
class US3_1(NamedTuple): # Some
    v0 : US4
    tag = 1
US3 = Union[US3_0, US3_1]
class US6_0(NamedTuple): # GameNotStarted
    tag = 0
class US6_1(NamedTuple): # GameOver
    v0 : i32
    v1 : static_array
    v2 : static_array
    v3 : i32
    v4 : static_array
    v5 : US5
    tag = 1
class US6_2(NamedTuple): # WaitingForActionFromPlayerId
    v0 : i32
    v1 : static_array
    v2 : static_array
    v3 : i32
    v4 : static_array
    v5 : US5
    tag = 2
US6 = Union[US6_0, US6_1, US6_2]
class US7_0(NamedTuple): # CommunityCardsAre
    v0 : static_array_list
    tag = 0
class US7_1(NamedTuple): # Fold
    v0 : i32
    v1 : i32
    tag = 1
class US7_2(NamedTuple): # PlayerAction
    v0 : i32
    v1 : US1
    tag = 2
class US7_3(NamedTuple): # PlayerGotCards
    v0 : i32
    v1 : static_array
    tag = 3
class US7_4(NamedTuple): # Showdown
    v0 : i32
    v1 : static_array
    v2 : i32
    tag = 4
US7 = Union[US7_0, US7_1, US7_2, US7_3, US7_4]
class US8_0(NamedTuple): # AddRewardsCallingMachine
    v0 : list
    tag = 0
class US8_1(NamedTuple): # AddRewardsSelf
    v0 : list
    tag = 1
US8 = Union[US8_0, US8_1]
def Closure0():
    def inner(v0 : object, v1 : object) -> object:
        v2 = method0(v0)
        v3, v4, v5, v6, v7, v8, v9, v10 = method8(v1)
        v11 = cp.empty(16,dtype=cp.uint8)
        v12 = cp.empty(6304,dtype=cp.uint8)
        method46(v12, v3, v4, v5, v6, v7)
        del v3, v4, v5, v6, v7
        v15 = "{}\n"
        v16 = "Going to run the NL Holdem full kernel."
        print(v15.format(v16),end="")
        del v15, v16
        v17 = time.perf_counter()
        v18 = []
        match v2:
            case US0_0(_): # ActionSelected
                method78(v11, v2)
                v77 = cp.cuda.Device().attributes['MultiProcessorCount']
                v78 = v77 == 24
                del v77
                v79 = v78 == False
                if v79:
                    v80 = "The number of SMs per GPU at runtime must much that what is declared atop of corecuda.base. Make sure to use the correct constant so it can be propagated at compile time."
                    assert v78, v80
                    del v80
                else:
                    pass
                del v78, v79
                v81 = 0
                v82 = raw_module.get_function(f"entry{v81}")
                del v81
                v82.max_dynamic_shared_size_bytes = 98304 
                print(f'Threads per block, blocks per grid: {256}, {24}')
                v82((24,),(256,),(v12, v11, v8, v9, v10),shared_mem=98304)
                del v82
            case US0_1(_): # PlayerChanged
                method78(v11, v2)
                v70 = cp.cuda.Device().attributes['MultiProcessorCount']
                v71 = v70 == 24
                del v70
                v72 = v71 == False
                if v72:
                    v73 = "The number of SMs per GPU at runtime must much that what is declared atop of corecuda.base. Make sure to use the correct constant so it can be propagated at compile time."
                    assert v71, v73
                    del v73
                else:
                    pass
                del v71, v72
                v74 = 0
                v75 = raw_module.get_function(f"entry{v74}")
                del v74
                v75.max_dynamic_shared_size_bytes = 98304 
                print(f'Threads per block, blocks per grid: {256}, {24}')
                v75((24,),(256,),(v12, v11, v8, v9, v10),shared_mem=98304)
                del v75
            case US0_2(): # StartGame
                method78(v11, v2)
                v63 = cp.cuda.Device().attributes['MultiProcessorCount']
                v64 = v63 == 24
                del v63
                v65 = v64 == False
                if v65:
                    v66 = "The number of SMs per GPU at runtime must much that what is declared atop of corecuda.base. Make sure to use the correct constant so it can be propagated at compile time."
                    assert v64, v66
                    del v66
                else:
                    pass
                del v64, v65
                v67 = 0
                v68 = raw_module.get_function(f"entry{v67}")
                del v67
                v68.max_dynamic_shared_size_bytes = 98304 
                print(f'Threads per block, blocks per grid: {256}, {24}')
                v68((24,),(256,),(v12, v11, v8, v9, v10),shared_mem=98304)
                del v68
            case US0_3(): # StartTrainingVsCallingMachine
                v19 = cp.zeros(8192,dtype=cp.float32) # type: ignore
                v20 = cp.zeros(8192,dtype=cp.float32) # type: ignore
                v21 = cp.empty(8192,dtype=cp.float32)
                v22 = cp.cuda.Device().attributes['MultiProcessorCount']
                v23 = v22 == 24
                del v22
                v24 = v23 == False
                if v24:
                    v25 = "The number of SMs per GPU at runtime must much that what is declared atop of corecuda.base. Make sure to use the correct constant so it can be propagated at compile time."
                    assert v23, v25
                    del v25
                else:
                    pass
                del v23, v24
                v26 = 1
                v27 = raw_module.get_function(f"entry{v26}")
                del v26
                v27.max_dynamic_shared_size_bytes = 98304 
                print(f'Threads per block, blocks per grid: {256}, {24}')
                v27((24,),(256,),(v8, v9, v10, v19, v20, v21),shared_mem=98304)
                del v19, v20, v27
                v28 = []
                v30 = v21[0:]
                del v21
                v31 = v30.get()
                del v30
                v32 = 0
                while method63(v32):
                    v34 = []
                    v35 = 0
                    while method81(v35):
                        assert 0 <= v32 < 4, 'Tensor range check'
                        assert 0 <= v35 < 2048, 'Tensor range check'
                        v37 = 2048 * v32
                        v38 = v37 + v35
                        del v37
                        v39 = v31[v38].item()
                        del v38
                        v34.append(v39)
                        del v39
                        v35 += 1 
                    del v35
                    v28.append(v34)
                    del v34
                    v32 += 1 
                del v31, v32
                v40 = US8_0(v28)
                del v28
                v18.append(v40)
                del v40
            case US0_4(): # StartTrainingVsSelf
                v41 = cp.zeros(8192,dtype=cp.float32) # type: ignore
                v42 = cp.zeros(8192,dtype=cp.float32) # type: ignore
                v43 = cp.empty(8192,dtype=cp.float32)
                v44 = cp.cuda.Device().attributes['MultiProcessorCount']
                v45 = v44 == 24
                del v44
                v46 = v45 == False
                if v46:
                    v47 = "The number of SMs per GPU at runtime must much that what is declared atop of corecuda.base. Make sure to use the correct constant so it can be propagated at compile time."
                    assert v45, v47
                    del v47
                else:
                    pass
                del v45, v46
                v48 = 2
                v49 = raw_module.get_function(f"entry{v48}")
                del v48
                v49.max_dynamic_shared_size_bytes = 98304 
                print(f'Threads per block, blocks per grid: {256}, {24}')
                v49((24,),(256,),(v8, v9, v10, v41, v42, v43),shared_mem=98304)
                del v41, v42, v49
                v50 = []
                v52 = v43[0:]
                del v43
                v53 = v52.get()
                del v52
                v54 = 0
                while method63(v54):
                    v56 = []
                    v57 = 0
                    while method81(v57):
                        assert 0 <= v54 < 4, 'Tensor range check'
                        assert 0 <= v57 < 2048, 'Tensor range check'
                        v59 = 2048 * v54
                        v60 = v59 + v57
                        del v59
                        v61 = v53[v60].item()
                        del v60
                        v56.append(v61)
                        del v61
                        v57 += 1 
                    del v57
                    v50.append(v56)
                    del v56
                    v54 += 1 
                del v53, v54
                v62 = US8_1(v50)
                del v50
                v18.append(v62)
                del v62
            case t:
                raise Exception(f'Pattern matching miss. Got: {t}')
        del v2, v11
        cp.cuda.get_current_stream().synchronize()
        v83 = time.perf_counter()
        v86 = "{}"
        v87 = "The time it took to run the kernel (in seconds) is: "
        print(v86.format(v87),end="")
        del v86, v87
        v88 = v83 - v17
        del v17, v83
        v91 = "{:.6f}\n"
        print(v91.format(v88),end="")
        del v88, v91
        v92, v93, v94, v95, v96 = method82(v12)
        del v12
        return method110(v92, v93, v94, v95, v96, v8, v9, v10, v18)
    return inner
def Closure1():
    def inner() -> object:
        v0 = cp.empty(12845056,dtype=cp.uint8)
        v1 = cp.empty(121896960,dtype=cp.uint8)
        v2 = cp.empty(12845120,dtype=cp.uint8)
        v4 = v1[0:0+4*12582912].view(cp.float32)
        del v4
        v6 = v2[0:0+4*2097152].view(cp.float32)
        v8 = v0[0:0+4*2097152].view(cp.float32)
        del v8
        v10 = v2[8388608:8388608+4*262144].view(cp.float32)
        v12 = v0[8388608:8388608+4*262144].view(cp.float32)
        del v12
        v14 = v2[9437184:9437184+4*262144].view(cp.float32)
        v16 = v0[9437184:9437184+4*262144].view(cp.float32)
        del v16
        v18 = v2[10485760:10485760+4*262144].view(cp.float32)
        v20 = v0[10485760:10485760+4*262144].view(cp.float32)
        del v20
        v22 = v2[11534336:11534336+4*262144].view(cp.float32)
        v24 = v0[11534336:11534336+4*262144].view(cp.float32)
        del v24
        v26 = v2[12582912:12582912+4*65536].view(cp.float32)
        v28 = v0[12582912:12582912+4*65536].view(cp.float32)
        del v28
        v30 = v1[114819072:114819072+4*1572864].view(cp.float32)
        del v30
        v32 = v2[12845056:12845056+4*1].view(cp.int32)
        v34 = v2[12845072:12845072+1*4].view(cp.bool_)
        v36 = v2[12845088:12845088+4*4].view(cp.float32)
        v38 = v2[12845104:12845104+4*4].view(cp.float32)
        v40 = v1[121110528:121110528+8*49152].view(cp.float64)
        v42 = v1[121503744:121503744+8*49152].view(cp.float64)
        v43 = cp.random.normal(0.0,0.1,2097152,dtype=cp.float32) # type: ignore
        cp.copyto(v6[0:0+2097152],v43[0:0+2097152])
        del v6, v43
        v44 = cp.random.normal(0.0,0.1,262144,dtype=cp.float32) # type: ignore
        cp.copyto(v10[0:0+262144],v44[0:0+262144])
        del v10, v44
        v45 = cp.random.normal(0.0,0.1,262144,dtype=cp.float32) # type: ignore
        cp.copyto(v14[0:0+262144],v45[0:0+262144])
        del v14, v45
        v46 = cp.random.normal(0.0,0.1,262144,dtype=cp.float32) # type: ignore
        cp.copyto(v18[0:0+262144],v46[0:0+262144])
        del v18, v46
        v47 = cp.random.normal(0.0,0.1,262144,dtype=cp.float32) # type: ignore
        cp.copyto(v22[0:0+262144],v47[0:0+262144])
        del v22, v47
        v48 = cp.random.normal(0.0,0.1,65536,dtype=cp.float32) # type: ignore
        cp.copyto(v26[0:0+65536],v48[0:0+65536])
        del v26, v48
        v32[:] = 0
        del v32
        v36[:] = 0
        del v36
        v38[:] = 0
        del v38
        v34[:] = 1
        del v34
        v40[:] = 0
        del v40
        v42[:] = 0
        del v42
        v50 = static_array(2)
        v52 = US2_1()
        v50[0] = v52
        del v52
        v54 = US2_2()
        v50[1] = v54
        del v54
        v56 = static_array_list(128)
        v57 = 4503599627370495
        v58 = US3_0()
        v59 = US6_0()
        return method159(v57, v58, v56, v50, v59, v2, v1, v0)
    return inner
def method3(v0 : object) -> None:
    assert v0 == [], f'Expected an unit type. Got: {v0}'
    del v0
    return 
def method4(v0 : object) -> i32:
    assert isinstance(v0,i32), f'The object needs to be the right primitive type. Got: {v0}'
    v1 = v0
    del v0
    return v1
def method2(v0 : object) -> US1:
    v1 = v0[0] # type: ignore
    v2 = v0[1] # type: ignore
    del v0
    v3 = "A_All_In" == v1
    if v3:
        del v1, v3
        method3(v2)
        del v2
        return US1_0()
    else:
        del v3
        v5 = "A_Call" == v1
        if v5:
            del v1, v5
            method3(v2)
            del v2
            return US1_1()
        else:
            del v5
            v7 = "A_Fold" == v1
            if v7:
                del v1, v7
                method3(v2)
                del v2
                return US1_2()
            else:
                del v7
                v9 = "A_Raise" == v1
                if v9:
                    del v1, v9
                    v10 = method4(v2)
                    del v2
                    return US1_3(v10)
                else:
                    del v2, v9
                    raise TypeError(f"Cannot convert the Python object into a Spiral union type. Invalid string tag. Got: {v1}")
                    del v1
                    raise Exception("Error")
def method6(v0 : i32, v1 : i32) -> bool:
    v2 = v1 < v0
    del v0, v1
    return v2
def method7(v0 : object) -> US2:
    v1 = v0[0] # type: ignore
    v2 = v0[1] # type: ignore
    del v0
    v3 = "CallingMachine" == v1
    if v3:
        del v1, v3
        method3(v2)
        del v2
        return US2_0()
    else:
        del v3
        v5 = "Computer" == v1
        if v5:
            del v1, v5
            method3(v2)
            del v2
            return US2_1()
        else:
            del v5
            v7 = "Human" == v1
            if v7:
                del v1, v7
                method3(v2)
                del v2
                return US2_2()
            else:
                del v7
                v9 = "Random" == v1
                if v9:
                    del v1, v9
                    method3(v2)
                    del v2
                    return US2_3()
                else:
                    del v2, v9
                    raise TypeError(f"Cannot convert the Python object into a Spiral union type. Invalid string tag. Got: {v1}")
                    del v1
                    raise Exception("Error")
def method5(v0 : object) -> static_array:
    assert isinstance(v0,list), f'The object needs to be a Python list. Got: {v0}'
    v1 = len(v0) # type: ignore
    v2 = 2 == v1
    v3 = v2 == False
    if v3:
        v4 = "The type level dimension has to equal the value passed at runtime into create."
        assert v2, v4
        del v4
    else:
        pass
    del v2, v3
    v6 = static_array(2)
    v7 = 0
    while method6(v1, v7):
        v9 = v0[v7]
        v10 = method7(v9)
        del v9
        v6[v7] = v10
        del v10
        v7 += 1 
    del v0, v1, v7
    return v6
def method1(v0 : object) -> US0:
    v1 = v0[0] # type: ignore
    v2 = v0[1] # type: ignore
    del v0
    v3 = "ActionSelected" == v1
    if v3:
        del v1, v3
        v4 = method2(v2)
        del v2
        return US0_0(v4)
    else:
        del v3
        v6 = "PlayerChanged" == v1
        if v6:
            del v1, v6
            v7 = method5(v2)
            del v2
            return US0_1(v7)
        else:
            del v6
            v9 = "StartGame" == v1
            if v9:
                del v1, v9
                method3(v2)
                del v2
                return US0_2()
            else:
                del v9
                v11 = "StartTrainingVsCallingMachine" == v1
                if v11:
                    del v1, v11
                    method3(v2)
                    del v2
                    return US0_3()
                else:
                    del v11
                    v13 = "StartTrainingVsSelf" == v1
                    if v13:
                        del v1, v13
                        method3(v2)
                        del v2
                        return US0_4()
                    else:
                        del v2, v13
                        raise TypeError(f"Cannot convert the Python object into a Spiral union type. Invalid string tag. Got: {v1}")
                        del v1
                        raise Exception("Error")
def method0(v0 : object) -> US0:
    return method1(v0)
def method13(v0 : object) -> u64:
    assert isinstance(v0,u64), f'The object needs to be the right primitive type. Got: {v0}'
    v1 = v0
    del v0
    return v1
def method12(v0 : object) -> u64:
    v1 = method13(v0)
    del v0
    return v1
def method20(v0 : object) -> u8:
    assert isinstance(v0,u8), f'The object needs to be the right primitive type. Got: {v0}'
    v1 = v0
    del v0
    return v1
def method19(v0 : object) -> u8:
    v1 = method20(v0)
    del v0
    return v1
def method18(v0 : object) -> static_array:
    assert isinstance(v0,list), f'The object needs to be a Python list. Got: {v0}'
    v1 = len(v0) # type: ignore
    v2 = 2 == v1
    v3 = v2 == False
    if v3:
        v4 = "The type level dimension has to equal the value passed at runtime into create."
        assert v2, v4
        del v4
    else:
        pass
    del v2, v3
    v6 = static_array(2)
    v7 = 0
    while method6(v1, v7):
        v9 = v0[v7]
        v10 = method19(v9)
        del v9
        v6[v7] = v10
        del v10
        v7 += 1 
    del v0, v1, v7
    return v6
def method17(v0 : object) -> static_array:
    assert isinstance(v0,list), f'The object needs to be a Python list. Got: {v0}'
    v1 = len(v0) # type: ignore
    v2 = 2 == v1
    v3 = v2 == False
    if v3:
        v4 = "The type level dimension has to equal the value passed at runtime into create."
        assert v2, v4
        del v4
    else:
        pass
    del v2, v3
    v6 = static_array(2)
    v7 = 0
    while method6(v1, v7):
        v9 = v0[v7]
        v10 = method18(v9)
        del v9
        v6[v7] = v10
        del v10
        v7 += 1 
    del v0, v1, v7
    return v6
def method21(v0 : object) -> static_array:
    assert isinstance(v0,list), f'The object needs to be a Python list. Got: {v0}'
    v1 = len(v0) # type: ignore
    v2 = 2 == v1
    v3 = v2 == False
    if v3:
        v4 = "The type level dimension has to equal the value passed at runtime into create."
        assert v2, v4
        del v4
    else:
        pass
    del v2, v3
    v6 = static_array(2)
    v7 = 0
    while method6(v1, v7):
        v9 = v0[v7]
        v10 = method4(v9)
        del v9
        v6[v7] = v10
        del v10
        v7 += 1 
    del v0, v1, v7
    return v6
def method23(v0 : object) -> static_array:
    assert isinstance(v0,list), f'The object needs to be a Python list. Got: {v0}'
    v1 = len(v0) # type: ignore
    v2 = 3 == v1
    v3 = v2 == False
    if v3:
        v4 = "The type level dimension has to equal the value passed at runtime into create."
        assert v2, v4
        del v4
    else:
        pass
    del v2, v3
    v6 = static_array(3)
    v7 = 0
    while method6(v1, v7):
        v9 = v0[v7]
        v10 = method19(v9)
        del v9
        v6[v7] = v10
        del v10
        v7 += 1 
    del v0, v1, v7
    return v6
def method24(v0 : object) -> static_array:
    assert isinstance(v0,list), f'The object needs to be a Python list. Got: {v0}'
    v1 = len(v0) # type: ignore
    v2 = 5 == v1
    v3 = v2 == False
    if v3:
        v4 = "The type level dimension has to equal the value passed at runtime into create."
        assert v2, v4
        del v4
    else:
        pass
    del v2, v3
    v6 = static_array(5)
    v7 = 0
    while method6(v1, v7):
        v9 = v0[v7]
        v10 = method19(v9)
        del v9
        v6[v7] = v10
        del v10
        v7 += 1 
    del v0, v1, v7
    return v6
def method25(v0 : object) -> static_array:
    assert isinstance(v0,list), f'The object needs to be a Python list. Got: {v0}'
    v1 = len(v0) # type: ignore
    v2 = 4 == v1
    v3 = v2 == False
    if v3:
        v4 = "The type level dimension has to equal the value passed at runtime into create."
        assert v2, v4
        del v4
    else:
        pass
    del v2, v3
    v6 = static_array(4)
    v7 = 0
    while method6(v1, v7):
        v9 = v0[v7]
        v10 = method19(v9)
        del v9
        v6[v7] = v10
        del v10
        v7 += 1 
    del v0, v1, v7
    return v6
def method22(v0 : object) -> US5:
    v1 = v0[0] # type: ignore
    v2 = v0[1] # type: ignore
    del v0
    v3 = "Flop" == v1
    if v3:
        del v1, v3
        v4 = method23(v2)
        del v2
        return US5_0(v4)
    else:
        del v3
        v6 = "Preflop" == v1
        if v6:
            del v1, v6
            method3(v2)
            del v2
            return US5_1()
        else:
            del v6
            v8 = "River" == v1
            if v8:
                del v1, v8
                v9 = method24(v2)
                del v2
                return US5_2(v9)
            else:
                del v8
                v11 = "Turn" == v1
                if v11:
                    del v1, v11
                    v12 = method25(v2)
                    del v2
                    return US5_3(v12)
                else:
                    del v2, v11
                    raise TypeError(f"Cannot convert the Python object into a Spiral union type. Invalid string tag. Got: {v1}")
                    del v1
                    raise Exception("Error")
def method16(v0 : object) -> Tuple[i32, static_array, static_array, i32, static_array, US5]:
    v1 = v0["min_raise"] # type: ignore
    v2 = method4(v1)
    del v1
    v3 = v0["pl_card"] # type: ignore
    v4 = method17(v3)
    del v3
    v5 = v0["pot"] # type: ignore
    v6 = method21(v5)
    del v5
    v7 = v0["round_turn"] # type: ignore
    v8 = method4(v7)
    del v7
    v9 = v0["stack"] # type: ignore
    v10 = method21(v9)
    del v9
    v11 = v0["street"] # type: ignore
    del v0
    v12 = method22(v11)
    del v11
    return v2, v4, v6, v8, v10, v12
def method26(v0 : object) -> Tuple[i32, static_array, static_array, i32, static_array, US5, US1]:
    v1 = v0[0] # type: ignore
    v2, v3, v4, v5, v6, v7 = method16(v1)
    del v1
    v8 = v0[1] # type: ignore
    del v0
    v9 = method2(v8)
    del v8
    return v2, v3, v4, v5, v6, v7, v9
def method15(v0 : object) -> US4:
    v1 = v0[0] # type: ignore
    v2 = v0[1] # type: ignore
    del v0
    v3 = "G_Flop" == v1
    if v3:
        del v1, v3
        v4, v5, v6, v7, v8, v9 = method16(v2)
        del v2
        return US4_0(v4, v5, v6, v7, v8, v9)
    else:
        del v3
        v11 = "G_Fold" == v1
        if v11:
            del v1, v11
            v12, v13, v14, v15, v16, v17 = method16(v2)
            del v2
            return US4_1(v12, v13, v14, v15, v16, v17)
        else:
            del v11
            v19 = "G_Preflop" == v1
            if v19:
                del v1, v19
                method3(v2)
                del v2
                return US4_2()
            else:
                del v19
                v21 = "G_River" == v1
                if v21:
                    del v1, v21
                    v22, v23, v24, v25, v26, v27 = method16(v2)
                    del v2
                    return US4_3(v22, v23, v24, v25, v26, v27)
                else:
                    del v21
                    v29 = "G_Round" == v1
                    if v29:
                        del v1, v29
                        v30, v31, v32, v33, v34, v35 = method16(v2)
                        del v2
                        return US4_4(v30, v31, v32, v33, v34, v35)
                    else:
                        del v29
                        v37 = "G_Round'" == v1
                        if v37:
                            del v1, v37
                            v38, v39, v40, v41, v42, v43, v44 = method26(v2)
                            del v2
                            return US4_5(v38, v39, v40, v41, v42, v43, v44)
                        else:
                            del v37
                            v46 = "G_Showdown" == v1
                            if v46:
                                del v1, v46
                                v47, v48, v49, v50, v51, v52 = method16(v2)
                                del v2
                                return US4_6(v47, v48, v49, v50, v51, v52)
                            else:
                                del v46
                                v54 = "G_Turn" == v1
                                if v54:
                                    del v1, v54
                                    v55, v56, v57, v58, v59, v60 = method16(v2)
                                    del v2
                                    return US4_7(v55, v56, v57, v58, v59, v60)
                                else:
                                    del v2, v54
                                    raise TypeError(f"Cannot convert the Python object into a Spiral union type. Invalid string tag. Got: {v1}")
                                    del v1
                                    raise Exception("Error")
def method14(v0 : object) -> US3:
    v1 = v0[0] # type: ignore
    v2 = v0[1] # type: ignore
    del v0
    v3 = "None" == v1
    if v3:
        del v1, v3
        method3(v2)
        del v2
        return US3_0()
    else:
        del v3
        v5 = "Some" == v1
        if v5:
            del v1, v5
            v6 = method15(v2)
            del v2
            return US3_1(v6)
        else:
            del v2, v5
            raise TypeError(f"Cannot convert the Python object into a Spiral union type. Invalid string tag. Got: {v1}")
            del v1
            raise Exception("Error")
def method11(v0 : object) -> Tuple[u64, US3]:
    v1 = v0["deck"] # type: ignore
    v2 = method12(v1)
    del v1
    v3 = v0["game"] # type: ignore
    del v0
    v4 = method14(v3)
    del v3
    return v2, v4
def method30(v0 : object) -> static_array_list:
    v1 = len(v0) # type: ignore
    assert (5 >= v1), f'The length of the original object has to be greater than or equal to the static array dimension.\nExpected: 5\nGot: {v1} '
    del v1
    assert isinstance(v0,list), f'The object needs to be a Python list. Got: {v0}'
    v2 = len(v0) # type: ignore
    v3 = 5 >= v2
    v4 = v3 == False
    if v4:
        v5 = "The type level dimension has to equal the value passed at runtime into create."
        assert v3, v5
        del v5
    else:
        pass
    del v3, v4
    v7 = static_array_list(5)
    v7.unsafe_set_length(v2)
    v8 = 0
    while method6(v2, v8):
        v10 = v0[v8]
        v11 = method19(v10)
        del v10
        v7[v8] = v11
        del v11
        v8 += 1 
    del v0, v2, v8
    return v7
def method31(v0 : object) -> Tuple[i32, i32]:
    v1 = v0["chips_won"] # type: ignore
    v2 = method4(v1)
    del v1
    v3 = v0["winner_id"] # type: ignore
    del v0
    v4 = method4(v3)
    del v3
    return v2, v4
def method32(v0 : object) -> Tuple[i32, US1]:
    v1 = v0[0] # type: ignore
    v2 = method4(v1)
    del v1
    v3 = v0[1] # type: ignore
    del v0
    v4 = method2(v3)
    del v3
    return v2, v4
def method33(v0 : object) -> Tuple[i32, static_array]:
    v1 = v0[0] # type: ignore
    v2 = method4(v1)
    del v1
    v3 = v0[1] # type: ignore
    del v0
    v4 = method18(v3)
    del v3
    return v2, v4
def method38(v0 : object) -> i8:
    assert isinstance(v0,i8), f'The object needs to be the right primitive type. Got: {v0}'
    v1 = v0
    del v0
    return v1
def method37(v0 : object) -> Tuple[static_array, i8]:
    v1 = v0["hand"] # type: ignore
    v2 = method24(v1)
    del v1
    v3 = v0["score"] # type: ignore
    del v0
    v4 = method38(v3)
    del v3
    return v2, v4
def method36(v0 : object) -> Tuple[static_array, i8]:
    v1, v2 = method37(v0)
    del v0
    return v1, v2
def method35(v0 : object) -> static_array:
    assert isinstance(v0,list), f'The object needs to be a Python list. Got: {v0}'
    v1 = len(v0) # type: ignore
    v2 = 2 == v1
    v3 = v2 == False
    if v3:
        v4 = "The type level dimension has to equal the value passed at runtime into create."
        assert v2, v4
        del v4
    else:
        pass
    del v2, v3
    v6 = static_array(2)
    v7 = 0
    while method6(v1, v7):
        v9 = v0[v7]
        v10, v11 = method36(v9)
        del v9
        v6[v7] = (v10, v11)
        del v10, v11
        v7 += 1 
    del v0, v1, v7
    return v6
def method34(v0 : object) -> Tuple[i32, static_array, i32]:
    v1 = v0["chips_won"] # type: ignore
    v2 = method4(v1)
    del v1
    v3 = v0["hands_shown"] # type: ignore
    v4 = method35(v3)
    del v3
    v5 = v0["winner_id"] # type: ignore
    del v0
    v6 = method4(v5)
    del v5
    return v2, v4, v6
def method29(v0 : object) -> US7:
    v1 = v0[0] # type: ignore
    v2 = v0[1] # type: ignore
    del v0
    v3 = "CommunityCardsAre" == v1
    if v3:
        del v1, v3
        v4 = method30(v2)
        del v2
        return US7_0(v4)
    else:
        del v3
        v6 = "Fold" == v1
        if v6:
            del v1, v6
            v7, v8 = method31(v2)
            del v2
            return US7_1(v7, v8)
        else:
            del v6
            v10 = "PlayerAction" == v1
            if v10:
                del v1, v10
                v11, v12 = method32(v2)
                del v2
                return US7_2(v11, v12)
            else:
                del v10
                v14 = "PlayerGotCards" == v1
                if v14:
                    del v1, v14
                    v15, v16 = method33(v2)
                    del v2
                    return US7_3(v15, v16)
                else:
                    del v14
                    v18 = "Showdown" == v1
                    if v18:
                        del v1, v18
                        v19, v20, v21 = method34(v2)
                        del v2
                        return US7_4(v19, v20, v21)
                    else:
                        del v2, v18
                        raise TypeError(f"Cannot convert the Python object into a Spiral union type. Invalid string tag. Got: {v1}")
                        del v1
                        raise Exception("Error")
def method28(v0 : object) -> static_array_list:
    v1 = len(v0) # type: ignore
    assert (128 >= v1), f'The length of the original object has to be greater than or equal to the static array dimension.\nExpected: 128\nGot: {v1} '
    del v1
    assert isinstance(v0,list), f'The object needs to be a Python list. Got: {v0}'
    v2 = len(v0) # type: ignore
    v3 = 128 >= v2
    v4 = v3 == False
    if v4:
        v5 = "The type level dimension has to equal the value passed at runtime into create."
        assert v3, v5
        del v5
    else:
        pass
    del v3, v4
    v7 = static_array_list(128)
    v7.unsafe_set_length(v2)
    v8 = 0
    while method6(v2, v8):
        v10 = v0[v8]
        v11 = method29(v10)
        del v10
        v7[v8] = v11
        del v11
        v8 += 1 
    del v0, v2, v8
    return v7
def method39(v0 : object) -> US6:
    v1 = v0[0] # type: ignore
    v2 = v0[1] # type: ignore
    del v0
    v3 = "GameNotStarted" == v1
    if v3:
        del v1, v3
        method3(v2)
        del v2
        return US6_0()
    else:
        del v3
        v5 = "GameOver" == v1
        if v5:
            del v1, v5
            v6, v7, v8, v9, v10, v11 = method16(v2)
            del v2
            return US6_1(v6, v7, v8, v9, v10, v11)
        else:
            del v5
            v13 = "WaitingForActionFromPlayerId" == v1
            if v13:
                del v1, v13
                v14, v15, v16, v17, v18, v19 = method16(v2)
                del v2
                return US6_2(v14, v15, v16, v17, v18, v19)
            else:
                del v2, v13
                raise TypeError(f"Cannot convert the Python object into a Spiral union type. Invalid string tag. Got: {v1}")
                del v1
                raise Exception("Error")
def method27(v0 : object) -> Tuple[static_array_list, static_array, US6]:
    v1 = v0["messages"] # type: ignore
    v2 = method28(v1)
    del v1
    v3 = v0["pl_type"] # type: ignore
    v4 = method5(v3)
    del v3
    v5 = v0["ui_game_state"] # type: ignore
    del v0
    v6 = method39(v5)
    del v5
    return v2, v4, v6
def method10(v0 : object) -> Tuple[u64, US3, static_array_list, static_array, US6]:
    v1 = v0["private"] # type: ignore
    v2, v3 = method11(v1)
    del v1
    v4 = v0["public"] # type: ignore
    del v0
    v5, v6, v7 = method27(v4)
    del v4
    return v2, v3, v5, v6, v7
def method45(v0 : object) -> cp.ndarray:
    assert isinstance(v0,cp.ndarray), f'The object needs to be the right primitive type. Got: {v0}'
    v1 = v0
    del v0
    return v1
def method44(v0 : object) -> cp.ndarray:
    v1 = method45(v0)
    del v0
    return v1
def method43(v0 : object) -> Tuple[cp.ndarray, cp.ndarray, cp.ndarray]:
    v1 = v0[0] # type: ignore
    v2 = method44(v1)
    del v1
    v3 = v0[1] # type: ignore
    v4 = method44(v3)
    del v3
    v5 = v0[2] # type: ignore
    v6 = method44(v5)
    del v5
    v7 = v0[3] # type: ignore
    del v0
    method3(v7)
    del v7
    return v2, v4, v6
def method42(v0 : object) -> Tuple[cp.ndarray, cp.ndarray, cp.ndarray]:
    v1, v2, v3 = method43(v0)
    del v0
    return v1, v2, v3
def method41(v0 : object) -> Tuple[cp.ndarray, cp.ndarray, cp.ndarray]:
    v1, v2, v3 = method42(v0)
    del v0
    return v1, v2, v3
def method40(v0 : object) -> Tuple[cp.ndarray, cp.ndarray, cp.ndarray]:
    v1 = v0["model_ptrs"] # type: ignore
    del v0
    v2, v3, v4 = method41(v1)
    del v1
    return v2, v3, v4
def method9(v0 : object) -> Tuple[u64, US3, static_array_list, static_array, US6, cp.ndarray, cp.ndarray, cp.ndarray]:
    v1 = v0["game"] # type: ignore
    v2, v3, v4, v5, v6 = method10(v1)
    del v1
    v7 = v0["neural"] # type: ignore
    del v0
    v8, v9, v10 = method40(v7)
    del v7
    return v2, v3, v4, v5, v6, v8, v9, v10
def method8(v0 : object) -> Tuple[u64, US3, static_array_list, static_array, US6, cp.ndarray, cp.ndarray, cp.ndarray]:
    return method9(v0)
def method47(v0 : cp.ndarray, v1 : u64) -> None:
    v3 = v0[0:].view(cp.uint64)
    del v0
    v3[0] = v1
    del v1, v3
    return 
def method48(v0 : cp.ndarray, v1 : i32) -> None:
    v3 = v0[8:].view(cp.int32)
    del v0
    v3[0] = v1
    del v1, v3
    return 
def method49(v0 : cp.ndarray) -> None:
    del v0
    return 
def method51(v0 : cp.ndarray, v1 : i32) -> None:
    v3 = v0[0:].view(cp.int32)
    del v0
    v3[0] = v1
    del v1, v3
    return 
def method53(v0 : i32) -> bool:
    v1 = v0 < 2
    del v0
    return v1
def method56(v0 : cp.ndarray, v1 : u8) -> None:
    v3 = v0[0:].view(cp.uint8)
    del v0
    v3[0] = v1
    del v1, v3
    return 
def method55(v0 : cp.ndarray, v1 : u8) -> None:
    return method56(v0, v1)
def method54(v0 : cp.ndarray, v1 : static_array) -> None:
    v2 = 0
    while method53(v2):
        v4 = u64(v2)
        v6 = v0[v4:].view(cp.uint8)
        del v4
        v7 = 0 <= v2
        if v7:
            v8 = v2 < 2
            v9 = v8
        else:
            v9 = False
        del v7
        v10 = v9 == False
        if v10:
            v11 = "Index must be in range."
            assert v9, v11
            del v11
        else:
            pass
        del v9, v10
        v13 = v1[v2]
        method55(v6, v13)
        del v6, v13
        v2 += 1 
    del v0, v1, v2
    return 
def method57(v0 : cp.ndarray, v1 : i32) -> None:
    v3 = v0[28:].view(cp.int32)
    del v0
    v3[0] = v1
    del v1, v3
    return 
def method59(v0 : i32) -> bool:
    v1 = v0 < 3
    del v0
    return v1
def method58(v0 : cp.ndarray, v1 : static_array) -> None:
    v2 = 0
    while method59(v2):
        v4 = u64(v2)
        v6 = v0[v4:].view(cp.uint8)
        del v4
        v7 = 0 <= v2
        if v7:
            v8 = v2 < 3
            v9 = v8
        else:
            v9 = False
        del v7
        v10 = v9 == False
        if v10:
            v11 = "Index must be in range."
            assert v9, v11
            del v11
        else:
            pass
        del v9, v10
        v13 = v1[v2]
        method55(v6, v13)
        del v6, v13
        v2 += 1 
    del v0, v1, v2
    return 
def method61(v0 : i32) -> bool:
    v1 = v0 < 5
    del v0
    return v1
def method60(v0 : cp.ndarray, v1 : static_array) -> None:
    v2 = 0
    while method61(v2):
        v4 = u64(v2)
        v6 = v0[v4:].view(cp.uint8)
        del v4
        v7 = 0 <= v2
        if v7:
            v8 = v2 < 5
            v9 = v8
        else:
            v9 = False
        del v7
        v10 = v9 == False
        if v10:
            v11 = "Index must be in range."
            assert v9, v11
            del v11
        else:
            pass
        del v9, v10
        v13 = v1[v2]
        method55(v6, v13)
        del v6, v13
        v2 += 1 
    del v0, v1, v2
    return 
def method63(v0 : i32) -> bool:
    v1 = v0 < 4
    del v0
    return v1
def method62(v0 : cp.ndarray, v1 : static_array) -> None:
    v2 = 0
    while method63(v2):
        v4 = u64(v2)
        v6 = v0[v4:].view(cp.uint8)
        del v4
        v7 = 0 <= v2
        if v7:
            v8 = v2 < 4
            v9 = v8
        else:
            v9 = False
        del v7
        v10 = v9 == False
        if v10:
            v11 = "Index must be in range."
            assert v9, v11
            del v11
        else:
            pass
        del v9, v10
        v13 = v1[v2]
        method55(v6, v13)
        del v6, v13
        v2 += 1 
    del v0, v1, v2
    return 
def method52(v0 : cp.ndarray, v1 : i32, v2 : static_array, v3 : static_array, v4 : i32, v5 : static_array, v6 : US5) -> None:
    v8 = v0[0:].view(cp.int32)
    v8[0] = v1
    del v1, v8
    v9 = 0
    while method53(v9):
        v11 = u64(v9)
        v12 = v11 * 2
        del v11
        v13 = 4 + v12
        del v12
        v15 = v0[v13:].view(cp.uint8)
        del v13
        v16 = 0 <= v9
        if v16:
            v17 = v9 < 2
            v18 = v17
        else:
            v18 = False
        del v16
        v19 = v18 == False
        if v19:
            v20 = "Index must be in range."
            assert v18, v20
            del v20
        else:
            pass
        del v18, v19
        v22 = v2[v9]
        method54(v15, v22)
        del v15, v22
        v9 += 1 
    del v2, v9
    v23 = 0
    while method53(v23):
        v25 = u64(v23)
        v26 = v25 * 4
        del v25
        v27 = 8 + v26
        del v26
        v29 = v0[v27:].view(cp.uint8)
        del v27
        v30 = 0 <= v23
        if v30:
            v31 = v23 < 2
            v32 = v31
        else:
            v32 = False
        del v30
        v33 = v32 == False
        if v33:
            v34 = "Index must be in range."
            assert v32, v34
            del v34
        else:
            pass
        del v32, v33
        v36 = v3[v23]
        method51(v29, v36)
        del v29, v36
        v23 += 1 
    del v3, v23
    v38 = v0[16:].view(cp.int32)
    v38[0] = v4
    del v4, v38
    v39 = 0
    while method53(v39):
        v41 = u64(v39)
        v42 = v41 * 4
        del v41
        v43 = 20 + v42
        del v42
        v45 = v0[v43:].view(cp.uint8)
        del v43
        v46 = 0 <= v39
        if v46:
            v47 = v39 < 2
            v48 = v47
        else:
            v48 = False
        del v46
        v49 = v48 == False
        if v49:
            v50 = "Index must be in range."
            assert v48, v50
            del v50
        else:
            pass
        del v48, v49
        v52 = v5[v39]
        method51(v45, v52)
        del v45, v52
        v39 += 1 
    del v5, v39
    v53 = v6.tag
    method57(v0, v53)
    del v53
    v55 = v0[32:].view(cp.uint8)
    del v0
    match v6:
        case US5_0(v56): # Flop
            del v6
            return method58(v55, v56)
        case US5_1(): # Preflop
            del v6
            return method49(v55)
        case US5_2(v57): # River
            del v6
            return method60(v55, v57)
        case US5_3(v58): # Turn
            del v6
            return method62(v55, v58)
        case t:
            raise Exception(f'Pattern matching miss. Got: {t}')
def method65(v0 : cp.ndarray, v1 : i32) -> None:
    v3 = v0[40:].view(cp.int32)
    del v0
    v3[0] = v1
    del v1, v3
    return 
def method64(v0 : cp.ndarray, v1 : i32, v2 : static_array, v3 : static_array, v4 : i32, v5 : static_array, v6 : US5, v7 : US1) -> None:
    v9 = v0[0:].view(cp.int32)
    v9[0] = v1
    del v1, v9
    v10 = 0
    while method53(v10):
        v12 = u64(v10)
        v13 = v12 * 2
        del v12
        v14 = 4 + v13
        del v13
        v16 = v0[v14:].view(cp.uint8)
        del v14
        v17 = 0 <= v10
        if v17:
            v18 = v10 < 2
            v19 = v18
        else:
            v19 = False
        del v17
        v20 = v19 == False
        if v20:
            v21 = "Index must be in range."
            assert v19, v21
            del v21
        else:
            pass
        del v19, v20
        v23 = v2[v10]
        method54(v16, v23)
        del v16, v23
        v10 += 1 
    del v2, v10
    v24 = 0
    while method53(v24):
        v26 = u64(v24)
        v27 = v26 * 4
        del v26
        v28 = 8 + v27
        del v27
        v30 = v0[v28:].view(cp.uint8)
        del v28
        v31 = 0 <= v24
        if v31:
            v32 = v24 < 2
            v33 = v32
        else:
            v33 = False
        del v31
        v34 = v33 == False
        if v34:
            v35 = "Index must be in range."
            assert v33, v35
            del v35
        else:
            pass
        del v33, v34
        v37 = v3[v24]
        method51(v30, v37)
        del v30, v37
        v24 += 1 
    del v3, v24
    v39 = v0[16:].view(cp.int32)
    v39[0] = v4
    del v4, v39
    v40 = 0
    while method53(v40):
        v42 = u64(v40)
        v43 = v42 * 4
        del v42
        v44 = 20 + v43
        del v43
        v46 = v0[v44:].view(cp.uint8)
        del v44
        v47 = 0 <= v40
        if v47:
            v48 = v40 < 2
            v49 = v48
        else:
            v49 = False
        del v47
        v50 = v49 == False
        if v50:
            v51 = "Index must be in range."
            assert v49, v51
            del v51
        else:
            pass
        del v49, v50
        v53 = v5[v40]
        method51(v46, v53)
        del v46, v53
        v40 += 1 
    del v5, v40
    v54 = v6.tag
    method57(v0, v54)
    del v54
    v56 = v0[32:].view(cp.uint8)
    match v6:
        case US5_0(v57): # Flop
            method58(v56, v57)
        case US5_1(): # Preflop
            method49(v56)
        case US5_2(v58): # River
            method60(v56, v58)
        case US5_3(v59): # Turn
            method62(v56, v59)
        case t:
            raise Exception(f'Pattern matching miss. Got: {t}')
    del v6, v56
    v60 = v7.tag
    method65(v0, v60)
    del v60
    v62 = v0[44:].view(cp.uint8)
    del v0
    match v7:
        case US1_0(): # A_All_In
            del v7
            return method49(v62)
        case US1_1(): # A_Call
            del v7
            return method49(v62)
        case US1_2(): # A_Fold
            del v7
            return method49(v62)
        case US1_3(v63): # A_Raise
            del v7
            return method51(v62, v63)
        case t:
            raise Exception(f'Pattern matching miss. Got: {t}')
def method50(v0 : cp.ndarray, v1 : US4) -> None:
    v2 = v1.tag
    method51(v0, v2)
    del v2
    v4 = v0[16:].view(cp.uint8)
    del v0
    match v1:
        case US4_0(v5, v6, v7, v8, v9, v10): # G_Flop
            del v1
            return method52(v4, v5, v6, v7, v8, v9, v10)
        case US4_1(v11, v12, v13, v14, v15, v16): # G_Fold
            del v1
            return method52(v4, v11, v12, v13, v14, v15, v16)
        case US4_2(): # G_Preflop
            del v1
            return method49(v4)
        case US4_3(v17, v18, v19, v20, v21, v22): # G_River
            del v1
            return method52(v4, v17, v18, v19, v20, v21, v22)
        case US4_4(v23, v24, v25, v26, v27, v28): # G_Round
            del v1
            return method52(v4, v23, v24, v25, v26, v27, v28)
        case US4_5(v29, v30, v31, v32, v33, v34, v35): # G_Round'
            del v1
            return method64(v4, v29, v30, v31, v32, v33, v34, v35)
        case US4_6(v36, v37, v38, v39, v40, v41): # G_Showdown
            del v1
            return method52(v4, v36, v37, v38, v39, v40, v41)
        case US4_7(v42, v43, v44, v45, v46, v47): # G_Turn
            del v1
            return method52(v4, v42, v43, v44, v45, v46, v47)
        case t:
            raise Exception(f'Pattern matching miss. Got: {t}')
def method66(v0 : cp.ndarray, v1 : i32) -> None:
    v3 = v0[80:].view(cp.int32)
    del v0
    v3[0] = v1
    del v1, v3
    return 
def method68(v0 : cp.ndarray, v1 : static_array_list) -> None:
    v2 = v1.length
    method51(v0, v2)
    del v2
    v3 = v1.length
    v4 = 0
    while method6(v3, v4):
        v6 = u64(v4)
        v7 = 4 + v6
        del v6
        v9 = v0[v7:].view(cp.uint8)
        del v7
        v11 = v1[v4]
        method55(v9, v11)
        del v9, v11
        v4 += 1 
    del v0, v1, v3, v4
    return 
def method69(v0 : cp.ndarray, v1 : i32, v2 : i32) -> None:
    v4 = v0[0:].view(cp.int32)
    v4[0] = v1
    del v1, v4
    v6 = v0[4:].view(cp.int32)
    del v0
    v6[0] = v2
    del v2, v6
    return 
def method71(v0 : cp.ndarray, v1 : i32) -> None:
    v3 = v0[4:].view(cp.int32)
    del v0
    v3[0] = v1
    del v1, v3
    return 
def method70(v0 : cp.ndarray, v1 : i32, v2 : US1) -> None:
    v4 = v0[0:].view(cp.int32)
    v4[0] = v1
    del v1, v4
    v5 = v2.tag
    method71(v0, v5)
    del v5
    v7 = v0[8:].view(cp.uint8)
    del v0
    match v2:
        case US1_0(): # A_All_In
            del v2
            return method49(v7)
        case US1_1(): # A_Call
            del v2
            return method49(v7)
        case US1_2(): # A_Fold
            del v2
            return method49(v7)
        case US1_3(v8): # A_Raise
            del v2
            return method51(v7, v8)
        case t:
            raise Exception(f'Pattern matching miss. Got: {t}')
def method72(v0 : cp.ndarray, v1 : i32, v2 : static_array) -> None:
    v4 = v0[0:].view(cp.int32)
    v4[0] = v1
    del v1, v4
    v5 = 0
    while method53(v5):
        v7 = u64(v5)
        v8 = 4 + v7
        del v7
        v10 = v0[v8:].view(cp.uint8)
        del v8
        v11 = 0 <= v5
        if v11:
            v12 = v5 < 2
            v13 = v12
        else:
            v13 = False
        del v11
        v14 = v13 == False
        if v14:
            v15 = "Index must be in range."
            assert v13, v15
            del v15
        else:
            pass
        del v13, v14
        v17 = v2[v5]
        method55(v10, v17)
        del v10, v17
        v5 += 1 
    del v0, v2, v5
    return 
def method75(v0 : cp.ndarray, v1 : static_array, v2 : i8) -> None:
    v3 = 0
    while method61(v3):
        v5 = u64(v3)
        v7 = v0[v5:].view(cp.uint8)
        del v5
        v8 = 0 <= v3
        if v8:
            v9 = v3 < 5
            v10 = v9
        else:
            v10 = False
        del v8
        v11 = v10 == False
        if v11:
            v12 = "Index must be in range."
            assert v10, v12
            del v12
        else:
            pass
        del v10, v11
        v14 = v1[v3]
        method55(v7, v14)
        del v7, v14
        v3 += 1 
    del v1, v3
    v16 = v0[5:].view(cp.int8)
    del v0
    v16[0] = v2
    del v2, v16
    return 
def method74(v0 : cp.ndarray, v1 : static_array, v2 : i8) -> None:
    return method75(v0, v1, v2)
def method73(v0 : cp.ndarray, v1 : i32, v2 : static_array, v3 : i32) -> None:
    v5 = v0[0:].view(cp.int32)
    v5[0] = v1
    del v1, v5
    v6 = 0
    while method53(v6):
        v8 = u64(v6)
        v9 = v8 * 8
        del v8
        v10 = 8 + v9
        del v9
        v12 = v0[v10:].view(cp.uint8)
        del v10
        v13 = 0 <= v6
        if v13:
            v14 = v6 < 2
            v15 = v14
        else:
            v15 = False
        del v13
        v16 = v15 == False
        if v16:
            v17 = "Index must be in range."
            assert v15, v17
            del v17
        else:
            pass
        del v15, v16
        v20, v21 = v2[v6]
        method74(v12, v20, v21)
        del v12, v20, v21
        v6 += 1 
    del v2, v6
    v23 = v0[24:].view(cp.int32)
    del v0
    v23[0] = v3
    del v3, v23
    return 
def method67(v0 : cp.ndarray, v1 : US7) -> None:
    v2 = v1.tag
    method51(v0, v2)
    del v2
    v4 = v0[16:].view(cp.uint8)
    del v0
    match v1:
        case US7_0(v5): # CommunityCardsAre
            del v1
            return method68(v4, v5)
        case US7_1(v6, v7): # Fold
            del v1
            return method69(v4, v6, v7)
        case US7_2(v8, v9): # PlayerAction
            del v1
            return method70(v4, v8, v9)
        case US7_3(v10, v11): # PlayerGotCards
            del v1
            return method72(v4, v10, v11)
        case US7_4(v12, v13, v14): # Showdown
            del v1
            return method73(v4, v12, v13, v14)
        case t:
            raise Exception(f'Pattern matching miss. Got: {t}')
def method76(v0 : cp.ndarray, v1 : US2) -> None:
    v2 = v1.tag
    method51(v0, v2)
    del v2
    v4 = v0[4:].view(cp.uint8)
    del v0
    match v1:
        case US2_0(): # CallingMachine
            del v1
            return method49(v4)
        case US2_1(): # Computer
            del v1
            return method49(v4)
        case US2_2(): # Human
            del v1
            return method49(v4)
        case US2_3(): # Random
            del v1
            return method49(v4)
        case t:
            raise Exception(f'Pattern matching miss. Got: {t}')
def method77(v0 : cp.ndarray, v1 : i32) -> None:
    v3 = v0[6248:].view(cp.int32)
    del v0
    v3[0] = v1
    del v1, v3
    return 
def method46(v0 : cp.ndarray, v1 : u64, v2 : US3, v3 : static_array_list, v4 : static_array, v5 : US6) -> None:
    method47(v0, v1)
    del v1
    v6 = v2.tag
    method48(v0, v6)
    del v6
    v8 = v0[16:].view(cp.uint8)
    match v2:
        case US3_0(): # None
            method49(v8)
        case US3_1(v9): # Some
            method50(v8, v9)
        case t:
            raise Exception(f'Pattern matching miss. Got: {t}')
    del v2, v8
    v10 = v3.length
    method66(v0, v10)
    del v10
    v11 = v3.length
    v12 = 0
    while method6(v11, v12):
        v14 = u64(v12)
        v15 = v14 * 48
        del v14
        v16 = 96 + v15
        del v15
        v18 = v0[v16:].view(cp.uint8)
        del v16
        v20 = v3[v12]
        method67(v18, v20)
        del v18, v20
        v12 += 1 
    del v3, v11, v12
    v21 = 0
    while method53(v21):
        v23 = u64(v21)
        v24 = v23 * 4
        del v23
        v25 = 6240 + v24
        del v24
        v27 = v0[v25:].view(cp.uint8)
        del v25
        v28 = 0 <= v21
        if v28:
            v29 = v21 < 2
            v30 = v29
        else:
            v30 = False
        del v28
        v31 = v30 == False
        if v31:
            v32 = "Index must be in range."
            assert v30, v32
            del v32
        else:
            pass
        del v30, v31
        v34 = v4[v21]
        method76(v27, v34)
        del v27, v34
        v21 += 1 
    del v4, v21
    v35 = v5.tag
    method77(v0, v35)
    del v35
    v37 = v0[6256:].view(cp.uint8)
    del v0
    match v5:
        case US6_0(): # GameNotStarted
            del v5
            return method49(v37)
        case US6_1(v38, v39, v40, v41, v42, v43): # GameOver
            del v5
            return method52(v37, v38, v39, v40, v41, v42, v43)
        case US6_2(v44, v45, v46, v47, v48, v49): # WaitingForActionFromPlayerId
            del v5
            return method52(v37, v44, v45, v46, v47, v48, v49)
        case t:
            raise Exception(f'Pattern matching miss. Got: {t}')
def method79(v0 : cp.ndarray, v1 : US1) -> None:
    v2 = v1.tag
    method51(v0, v2)
    del v2
    v4 = v0[4:].view(cp.uint8)
    del v0
    match v1:
        case US1_0(): # A_All_In
            del v1
            return method49(v4)
        case US1_1(): # A_Call
            del v1
            return method49(v4)
        case US1_2(): # A_Fold
            del v1
            return method49(v4)
        case US1_3(v5): # A_Raise
            del v1
            return method51(v4, v5)
        case t:
            raise Exception(f'Pattern matching miss. Got: {t}')
def method80(v0 : cp.ndarray, v1 : static_array) -> None:
    v2 = 0
    while method53(v2):
        v4 = u64(v2)
        v5 = v4 * 4
        del v4
        v7 = v0[v5:].view(cp.uint8)
        del v5
        v8 = 0 <= v2
        if v8:
            v9 = v2 < 2
            v10 = v9
        else:
            v10 = False
        del v8
        v11 = v10 == False
        if v11:
            v12 = "Index must be in range."
            assert v10, v12
            del v12
        else:
            pass
        del v10, v11
        v14 = v1[v2]
        method76(v7, v14)
        del v7, v14
        v2 += 1 
    del v0, v1, v2
    return 
def method78(v0 : cp.ndarray, v1 : US0) -> None:
    v2 = v1.tag
    method51(v0, v2)
    del v2
    v4 = v0[8:].view(cp.uint8)
    del v0
    match v1:
        case US0_0(v5): # ActionSelected
            del v1
            return method79(v4, v5)
        case US0_1(v6): # PlayerChanged
            del v1
            return method80(v4, v6)
        case US0_2(): # StartGame
            del v1
            return method49(v4)
        case US0_3(): # StartTrainingVsCallingMachine
            del v1
            return method49(v4)
        case US0_4(): # StartTrainingVsSelf
            del v1
            return method49(v4)
        case t:
            raise Exception(f'Pattern matching miss. Got: {t}')
def method81(v0 : i32) -> bool:
    v1 = v0 < 2048
    del v0
    return v1
def method83(v0 : cp.ndarray) -> u64:
    v2 = v0[0:].view(cp.uint64)
    del v0
    v3 = v2[0].item()
    del v2
    return v3
def method84(v0 : cp.ndarray) -> i32:
    v2 = v0[8:].view(cp.int32)
    del v0
    v3 = v2[0].item()
    del v2
    return v3
def method85(v0 : cp.ndarray) -> None:
    del v0
    return 
def method87(v0 : cp.ndarray) -> i32:
    v2 = v0[0:].view(cp.int32)
    del v0
    v3 = v2[0].item()
    del v2
    return v3
def method91(v0 : cp.ndarray) -> u8:
    v2 = v0[0:].view(cp.uint8)
    del v0
    v3 = v2[0].item()
    del v2
    return v3
def method90(v0 : cp.ndarray) -> u8:
    v1 = method91(v0)
    del v0
    return v1
def method89(v0 : cp.ndarray) -> static_array:
    v2 = static_array(2)
    v3 = 0
    while method53(v3):
        v5 = u64(v3)
        v7 = v0[v5:].view(cp.uint8)
        del v5
        v8 = method90(v7)
        del v7
        v2[v3] = v8
        del v8
        v3 += 1 
    del v0, v3
    return v2
def method92(v0 : cp.ndarray) -> i32:
    v2 = v0[28:].view(cp.int32)
    del v0
    v3 = v2[0].item()
    del v2
    return v3
def method93(v0 : cp.ndarray) -> static_array:
    v2 = static_array(3)
    v3 = 0
    while method59(v3):
        v5 = u64(v3)
        v7 = v0[v5:].view(cp.uint8)
        del v5
        v8 = method90(v7)
        del v7
        v2[v3] = v8
        del v8
        v3 += 1 
    del v0, v3
    return v2
def method94(v0 : cp.ndarray) -> static_array:
    v2 = static_array(5)
    v3 = 0
    while method61(v3):
        v5 = u64(v3)
        v7 = v0[v5:].view(cp.uint8)
        del v5
        v8 = method90(v7)
        del v7
        v2[v3] = v8
        del v8
        v3 += 1 
    del v0, v3
    return v2
def method95(v0 : cp.ndarray) -> static_array:
    v2 = static_array(4)
    v3 = 0
    while method63(v3):
        v5 = u64(v3)
        v7 = v0[v5:].view(cp.uint8)
        del v5
        v8 = method90(v7)
        del v7
        v2[v3] = v8
        del v8
        v3 += 1 
    del v0, v3
    return v2
def method88(v0 : cp.ndarray) -> Tuple[i32, static_array, static_array, i32, static_array, US5]:
    v2 = v0[0:].view(cp.int32)
    v3 = v2[0].item()
    del v2
    v5 = static_array(2)
    v6 = 0
    while method53(v6):
        v8 = u64(v6)
        v9 = v8 * 2
        del v8
        v10 = 4 + v9
        del v9
        v12 = v0[v10:].view(cp.uint8)
        del v10
        v13 = method89(v12)
        del v12
        v5[v6] = v13
        del v13
        v6 += 1 
    del v6
    v15 = static_array(2)
    v16 = 0
    while method53(v16):
        v18 = u64(v16)
        v19 = v18 * 4
        del v18
        v20 = 8 + v19
        del v19
        v22 = v0[v20:].view(cp.uint8)
        del v20
        v23 = method87(v22)
        del v22
        v15[v16] = v23
        del v23
        v16 += 1 
    del v16
    v25 = v0[16:].view(cp.int32)
    v26 = v25[0].item()
    del v25
    v28 = static_array(2)
    v29 = 0
    while method53(v29):
        v31 = u64(v29)
        v32 = v31 * 4
        del v31
        v33 = 20 + v32
        del v32
        v35 = v0[v33:].view(cp.uint8)
        del v33
        v36 = method87(v35)
        del v35
        v28[v29] = v36
        del v36
        v29 += 1 
    del v29
    v37 = method92(v0)
    v39 = v0[32:].view(cp.uint8)
    del v0
    if v37 == 0:
        v41 = method93(v39)
        v48 = US5_0(v41)
    elif v37 == 1:
        method85(v39)
        v48 = US5_1()
    elif v37 == 2:
        v44 = method94(v39)
        v48 = US5_2(v44)
    elif v37 == 3:
        v46 = method95(v39)
        v48 = US5_3(v46)
    else:
        raise Exception("Invalid tag.")
    del v37, v39
    return v3, v5, v15, v26, v28, v48
def method97(v0 : cp.ndarray) -> i32:
    v2 = v0[40:].view(cp.int32)
    del v0
    v3 = v2[0].item()
    del v2
    return v3
def method96(v0 : cp.ndarray) -> Tuple[i32, static_array, static_array, i32, static_array, US5, US1]:
    v2 = v0[0:].view(cp.int32)
    v3 = v2[0].item()
    del v2
    v5 = static_array(2)
    v6 = 0
    while method53(v6):
        v8 = u64(v6)
        v9 = v8 * 2
        del v8
        v10 = 4 + v9
        del v9
        v12 = v0[v10:].view(cp.uint8)
        del v10
        v13 = method89(v12)
        del v12
        v5[v6] = v13
        del v13
        v6 += 1 
    del v6
    v15 = static_array(2)
    v16 = 0
    while method53(v16):
        v18 = u64(v16)
        v19 = v18 * 4
        del v18
        v20 = 8 + v19
        del v19
        v22 = v0[v20:].view(cp.uint8)
        del v20
        v23 = method87(v22)
        del v22
        v15[v16] = v23
        del v23
        v16 += 1 
    del v16
    v25 = v0[16:].view(cp.int32)
    v26 = v25[0].item()
    del v25
    v28 = static_array(2)
    v29 = 0
    while method53(v29):
        v31 = u64(v29)
        v32 = v31 * 4
        del v31
        v33 = 20 + v32
        del v32
        v35 = v0[v33:].view(cp.uint8)
        del v33
        v36 = method87(v35)
        del v35
        v28[v29] = v36
        del v36
        v29 += 1 
    del v29
    v37 = method92(v0)
    v39 = v0[32:].view(cp.uint8)
    if v37 == 0:
        v41 = method93(v39)
        v48 = US5_0(v41)
    elif v37 == 1:
        method85(v39)
        v48 = US5_1()
    elif v37 == 2:
        v44 = method94(v39)
        v48 = US5_2(v44)
    elif v37 == 3:
        v46 = method95(v39)
        v48 = US5_3(v46)
    else:
        raise Exception("Invalid tag.")
    del v37, v39
    v49 = method97(v0)
    v51 = v0[44:].view(cp.uint8)
    del v0
    if v49 == 0:
        method85(v51)
        v58 = US1_0()
    elif v49 == 1:
        method85(v51)
        v58 = US1_1()
    elif v49 == 2:
        method85(v51)
        v58 = US1_2()
    elif v49 == 3:
        v56 = method87(v51)
        v58 = US1_3(v56)
    else:
        raise Exception("Invalid tag.")
    del v49, v51
    return v3, v5, v15, v26, v28, v48, v58
def method86(v0 : cp.ndarray) -> US4:
    v1 = method87(v0)
    v3 = v0[16:].view(cp.uint8)
    del v0
    if v1 == 0:
        del v1
        v5, v6, v7, v8, v9, v10 = method88(v3)
        del v3
        return US4_0(v5, v6, v7, v8, v9, v10)
    elif v1 == 1:
        del v1
        v12, v13, v14, v15, v16, v17 = method88(v3)
        del v3
        return US4_1(v12, v13, v14, v15, v16, v17)
    elif v1 == 2:
        del v1
        method85(v3)
        del v3
        return US4_2()
    elif v1 == 3:
        del v1
        v20, v21, v22, v23, v24, v25 = method88(v3)
        del v3
        return US4_3(v20, v21, v22, v23, v24, v25)
    elif v1 == 4:
        del v1
        v27, v28, v29, v30, v31, v32 = method88(v3)
        del v3
        return US4_4(v27, v28, v29, v30, v31, v32)
    elif v1 == 5:
        del v1
        v34, v35, v36, v37, v38, v39, v40 = method96(v3)
        del v3
        return US4_5(v34, v35, v36, v37, v38, v39, v40)
    elif v1 == 6:
        del v1
        v42, v43, v44, v45, v46, v47 = method88(v3)
        del v3
        return US4_6(v42, v43, v44, v45, v46, v47)
    elif v1 == 7:
        del v1
        v49, v50, v51, v52, v53, v54 = method88(v3)
        del v3
        return US4_7(v49, v50, v51, v52, v53, v54)
    else:
        del v1, v3
        raise Exception("Invalid tag.")
def method98(v0 : cp.ndarray) -> i32:
    v2 = v0[80:].view(cp.int32)
    del v0
    v3 = v2[0].item()
    del v2
    return v3
def method100(v0 : cp.ndarray) -> static_array_list:
    v2 = static_array_list(5)
    v3 = method87(v0)
    v2.unsafe_set_length(v3)
    del v3
    v4 = v2.length
    v5 = 0
    while method6(v4, v5):
        v7 = u64(v5)
        v8 = 4 + v7
        del v7
        v10 = v0[v8:].view(cp.uint8)
        del v8
        v11 = method90(v10)
        del v10
        v2[v5] = v11
        del v11
        v5 += 1 
    del v0, v4, v5
    return v2
def method101(v0 : cp.ndarray) -> Tuple[i32, i32]:
    v2 = v0[0:].view(cp.int32)
    v3 = v2[0].item()
    del v2
    v5 = v0[4:].view(cp.int32)
    del v0
    v6 = v5[0].item()
    del v5
    return v3, v6
def method103(v0 : cp.ndarray) -> i32:
    v2 = v0[4:].view(cp.int32)
    del v0
    v3 = v2[0].item()
    del v2
    return v3
def method102(v0 : cp.ndarray) -> Tuple[i32, US1]:
    v2 = v0[0:].view(cp.int32)
    v3 = v2[0].item()
    del v2
    v4 = method103(v0)
    v6 = v0[8:].view(cp.uint8)
    del v0
    if v4 == 0:
        method85(v6)
        v13 = US1_0()
    elif v4 == 1:
        method85(v6)
        v13 = US1_1()
    elif v4 == 2:
        method85(v6)
        v13 = US1_2()
    elif v4 == 3:
        v11 = method87(v6)
        v13 = US1_3(v11)
    else:
        raise Exception("Invalid tag.")
    del v4, v6
    return v3, v13
def method104(v0 : cp.ndarray) -> Tuple[i32, static_array]:
    v2 = v0[0:].view(cp.int32)
    v3 = v2[0].item()
    del v2
    v5 = static_array(2)
    v6 = 0
    while method53(v6):
        v8 = u64(v6)
        v9 = 4 + v8
        del v8
        v11 = v0[v9:].view(cp.uint8)
        del v9
        v12 = method90(v11)
        del v11
        v5[v6] = v12
        del v12
        v6 += 1 
    del v0, v6
    return v3, v5
def method107(v0 : cp.ndarray) -> Tuple[static_array, i8]:
    v2 = static_array(5)
    v3 = 0
    while method61(v3):
        v5 = u64(v3)
        v7 = v0[v5:].view(cp.uint8)
        del v5
        v8 = method90(v7)
        del v7
        v2[v3] = v8
        del v8
        v3 += 1 
    del v3
    v10 = v0[5:].view(cp.int8)
    del v0
    v11 = v10[0].item()
    del v10
    return v2, v11
def method106(v0 : cp.ndarray) -> Tuple[static_array, i8]:
    v1, v2 = method107(v0)
    del v0
    return v1, v2
def method105(v0 : cp.ndarray) -> Tuple[i32, static_array, i32]:
    v2 = v0[0:].view(cp.int32)
    v3 = v2[0].item()
    del v2
    v5 = static_array(2)
    v6 = 0
    while method53(v6):
        v8 = u64(v6)
        v9 = v8 * 8
        del v8
        v10 = 8 + v9
        del v9
        v12 = v0[v10:].view(cp.uint8)
        del v10
        v13, v14 = method106(v12)
        del v12
        v5[v6] = (v13, v14)
        del v13, v14
        v6 += 1 
    del v6
    v16 = v0[24:].view(cp.int32)
    del v0
    v17 = v16[0].item()
    del v16
    return v3, v5, v17
def method99(v0 : cp.ndarray) -> US7:
    v1 = method87(v0)
    v3 = v0[16:].view(cp.uint8)
    del v0
    if v1 == 0:
        del v1
        v5 = method100(v3)
        del v3
        return US7_0(v5)
    elif v1 == 1:
        del v1
        v7, v8 = method101(v3)
        del v3
        return US7_1(v7, v8)
    elif v1 == 2:
        del v1
        v10, v11 = method102(v3)
        del v3
        return US7_2(v10, v11)
    elif v1 == 3:
        del v1
        v13, v14 = method104(v3)
        del v3
        return US7_3(v13, v14)
    elif v1 == 4:
        del v1
        v16, v17, v18 = method105(v3)
        del v3
        return US7_4(v16, v17, v18)
    else:
        del v1, v3
        raise Exception("Invalid tag.")
def method108(v0 : cp.ndarray) -> US2:
    v1 = method87(v0)
    v3 = v0[4:].view(cp.uint8)
    del v0
    if v1 == 0:
        del v1
        method85(v3)
        del v3
        return US2_0()
    elif v1 == 1:
        del v1
        method85(v3)
        del v3
        return US2_1()
    elif v1 == 2:
        del v1
        method85(v3)
        del v3
        return US2_2()
    elif v1 == 3:
        del v1
        method85(v3)
        del v3
        return US2_3()
    else:
        del v1, v3
        raise Exception("Invalid tag.")
def method109(v0 : cp.ndarray) -> i32:
    v2 = v0[6248:].view(cp.int32)
    del v0
    v3 = v2[0].item()
    del v2
    return v3
def method82(v0 : cp.ndarray) -> Tuple[u64, US3, static_array_list, static_array, US6]:
    v1 = method83(v0)
    v2 = method84(v0)
    v4 = v0[16:].view(cp.uint8)
    if v2 == 0:
        method85(v4)
        v9 = US3_0()
    elif v2 == 1:
        v7 = method86(v4)
        v9 = US3_1(v7)
    else:
        raise Exception("Invalid tag.")
    del v2, v4
    v11 = static_array_list(128)
    v12 = method98(v0)
    v11.unsafe_set_length(v12)
    del v12
    v13 = v11.length
    v14 = 0
    while method6(v13, v14):
        v16 = u64(v14)
        v17 = v16 * 48
        del v16
        v18 = 96 + v17
        del v17
        v20 = v0[v18:].view(cp.uint8)
        del v18
        v21 = method99(v20)
        del v20
        v11[v14] = v21
        del v21
        v14 += 1 
    del v13, v14
    v23 = static_array(2)
    v24 = 0
    while method53(v24):
        v26 = u64(v24)
        v27 = v26 * 4
        del v26
        v28 = 6240 + v27
        del v27
        v30 = v0[v28:].view(cp.uint8)
        del v28
        v31 = method108(v30)
        del v30
        v23[v24] = v31
        del v31
        v24 += 1 
    del v24
    v32 = method109(v0)
    v34 = v0[6256:].view(cp.uint8)
    del v0
    if v32 == 0:
        method85(v34)
        v51 = US6_0()
    elif v32 == 1:
        v37, v38, v39, v40, v41, v42 = method88(v34)
        v51 = US6_1(v37, v38, v39, v40, v41, v42)
    elif v32 == 2:
        v44, v45, v46, v47, v48, v49 = method88(v34)
        v51 = US6_2(v44, v45, v46, v47, v48, v49)
    else:
        raise Exception("Invalid tag.")
    del v32, v34
    return v1, v9, v11, v23, v51
def method116(v0 : u64) -> object:
    v1 = v0
    del v0
    return v1
def method115(v0 : u64) -> object:
    return method116(v0)
def method118() -> object:
    v0 = []
    return v0
def method121(v0 : i32) -> object:
    v1 = v0
    del v0
    return v1
def method125(v0 : u8) -> object:
    v1 = v0
    del v0
    return v1
def method124(v0 : u8) -> object:
    return method125(v0)
def method123(v0 : static_array) -> object:
    v1 = []
    v2 = 0
    while method53(v2):
        v4 = 0 <= v2
        if v4:
            v5 = v2 < 2
            v6 = v5
        else:
            v6 = False
        del v4
        v7 = v6 == False
        if v7:
            v8 = "Index must be in range."
            assert v6, v8
            del v8
        else:
            pass
        del v6, v7
        v10 = v0[v2]
        v11 = method124(v10)
        del v10
        v1.append(v11)
        del v11
        v2 += 1 
    del v0, v2
    return v1
def method122(v0 : static_array) -> object:
    v1 = []
    v2 = 0
    while method53(v2):
        v4 = 0 <= v2
        if v4:
            v5 = v2 < 2
            v6 = v5
        else:
            v6 = False
        del v4
        v7 = v6 == False
        if v7:
            v8 = "Index must be in range."
            assert v6, v8
            del v8
        else:
            pass
        del v6, v7
        v10 = v0[v2]
        v11 = method123(v10)
        del v10
        v1.append(v11)
        del v11
        v2 += 1 
    del v0, v2
    return v1
def method126(v0 : static_array) -> object:
    v1 = []
    v2 = 0
    while method53(v2):
        v4 = 0 <= v2
        if v4:
            v5 = v2 < 2
            v6 = v5
        else:
            v6 = False
        del v4
        v7 = v6 == False
        if v7:
            v8 = "Index must be in range."
            assert v6, v8
            del v8
        else:
            pass
        del v6, v7
        v10 = v0[v2]
        v11 = method121(v10)
        del v10
        v1.append(v11)
        del v11
        v2 += 1 
    del v0, v2
    return v1
def method128(v0 : static_array) -> object:
    v1 = []
    v2 = 0
    while method59(v2):
        v4 = 0 <= v2
        if v4:
            v5 = v2 < 3
            v6 = v5
        else:
            v6 = False
        del v4
        v7 = v6 == False
        if v7:
            v8 = "Index must be in range."
            assert v6, v8
            del v8
        else:
            pass
        del v6, v7
        v10 = v0[v2]
        v11 = method124(v10)
        del v10
        v1.append(v11)
        del v11
        v2 += 1 
    del v0, v2
    return v1
def method129(v0 : static_array) -> object:
    v1 = []
    v2 = 0
    while method61(v2):
        v4 = 0 <= v2
        if v4:
            v5 = v2 < 5
            v6 = v5
        else:
            v6 = False
        del v4
        v7 = v6 == False
        if v7:
            v8 = "Index must be in range."
            assert v6, v8
            del v8
        else:
            pass
        del v6, v7
        v10 = v0[v2]
        v11 = method124(v10)
        del v10
        v1.append(v11)
        del v11
        v2 += 1 
    del v0, v2
    return v1
def method130(v0 : static_array) -> object:
    v1 = []
    v2 = 0
    while method63(v2):
        v4 = 0 <= v2
        if v4:
            v5 = v2 < 4
            v6 = v5
        else:
            v6 = False
        del v4
        v7 = v6 == False
        if v7:
            v8 = "Index must be in range."
            assert v6, v8
            del v8
        else:
            pass
        del v6, v7
        v10 = v0[v2]
        v11 = method124(v10)
        del v10
        v1.append(v11)
        del v11
        v2 += 1 
    del v0, v2
    return v1
def method127(v0 : US5) -> object:
    match v0:
        case US5_0(v1): # Flop
            del v0
            v2 = method128(v1)
            del v1
            v3 = "Flop"
            v4 = [v3,v2]
            del v2, v3
            return v4
        case US5_1(): # Preflop
            del v0
            v5 = method118()
            v6 = "Preflop"
            v7 = [v6,v5]
            del v5, v6
            return v7
        case US5_2(v8): # River
            del v0
            v9 = method129(v8)
            del v8
            v10 = "River"
            v11 = [v10,v9]
            del v9, v10
            return v11
        case US5_3(v12): # Turn
            del v0
            v13 = method130(v12)
            del v12
            v14 = "Turn"
            v15 = [v14,v13]
            del v13, v14
            return v15
        case t:
            raise Exception(f'Pattern matching miss. Got: {t}')
def method120(v0 : i32, v1 : static_array, v2 : static_array, v3 : i32, v4 : static_array, v5 : US5) -> object:
    v6 = method121(v0)
    del v0
    v7 = method122(v1)
    del v1
    v8 = method126(v2)
    del v2
    v9 = method121(v3)
    del v3
    v10 = method126(v4)
    del v4
    v11 = method127(v5)
    del v5
    v12 = {'min_raise': v6, 'pl_card': v7, 'pot': v8, 'round_turn': v9, 'stack': v10, 'street': v11}
    del v6, v7, v8, v9, v10, v11
    return v12
def method132(v0 : US1) -> object:
    match v0:
        case US1_0(): # A_All_In
            del v0
            v1 = method118()
            v2 = "A_All_In"
            v3 = [v2,v1]
            del v1, v2
            return v3
        case US1_1(): # A_Call
            del v0
            v4 = method118()
            v5 = "A_Call"
            v6 = [v5,v4]
            del v4, v5
            return v6
        case US1_2(): # A_Fold
            del v0
            v7 = method118()
            v8 = "A_Fold"
            v9 = [v8,v7]
            del v7, v8
            return v9
        case US1_3(v10): # A_Raise
            del v0
            v11 = method121(v10)
            del v10
            v12 = "A_Raise"
            v13 = [v12,v11]
            del v11, v12
            return v13
        case t:
            raise Exception(f'Pattern matching miss. Got: {t}')
def method131(v0 : i32, v1 : static_array, v2 : static_array, v3 : i32, v4 : static_array, v5 : US5, v6 : US1) -> object:
    v7 = []
    v8 = method120(v0, v1, v2, v3, v4, v5)
    del v0, v1, v2, v3, v4, v5
    v7.append(v8)
    del v8
    v9 = method132(v6)
    del v6
    v7.append(v9)
    del v9
    v10 = v7
    del v7
    return v10
def method119(v0 : US4) -> object:
    match v0:
        case US4_0(v1, v2, v3, v4, v5, v6): # G_Flop
            del v0
            v7 = method120(v1, v2, v3, v4, v5, v6)
            del v1, v2, v3, v4, v5, v6
            v8 = "G_Flop"
            v9 = [v8,v7]
            del v7, v8
            return v9
        case US4_1(v10, v11, v12, v13, v14, v15): # G_Fold
            del v0
            v16 = method120(v10, v11, v12, v13, v14, v15)
            del v10, v11, v12, v13, v14, v15
            v17 = "G_Fold"
            v18 = [v17,v16]
            del v16, v17
            return v18
        case US4_2(): # G_Preflop
            del v0
            v19 = method118()
            v20 = "G_Preflop"
            v21 = [v20,v19]
            del v19, v20
            return v21
        case US4_3(v22, v23, v24, v25, v26, v27): # G_River
            del v0
            v28 = method120(v22, v23, v24, v25, v26, v27)
            del v22, v23, v24, v25, v26, v27
            v29 = "G_River"
            v30 = [v29,v28]
            del v28, v29
            return v30
        case US4_4(v31, v32, v33, v34, v35, v36): # G_Round
            del v0
            v37 = method120(v31, v32, v33, v34, v35, v36)
            del v31, v32, v33, v34, v35, v36
            v38 = "G_Round"
            v39 = [v38,v37]
            del v37, v38
            return v39
        case US4_5(v40, v41, v42, v43, v44, v45, v46): # G_Round'
            del v0
            v47 = method131(v40, v41, v42, v43, v44, v45, v46)
            del v40, v41, v42, v43, v44, v45, v46
            v48 = "G_Round'"
            v49 = [v48,v47]
            del v47, v48
            return v49
        case US4_6(v50, v51, v52, v53, v54, v55): # G_Showdown
            del v0
            v56 = method120(v50, v51, v52, v53, v54, v55)
            del v50, v51, v52, v53, v54, v55
            v57 = "G_Showdown"
            v58 = [v57,v56]
            del v56, v57
            return v58
        case US4_7(v59, v60, v61, v62, v63, v64): # G_Turn
            del v0
            v65 = method120(v59, v60, v61, v62, v63, v64)
            del v59, v60, v61, v62, v63, v64
            v66 = "G_Turn"
            v67 = [v66,v65]
            del v65, v66
            return v67
        case t:
            raise Exception(f'Pattern matching miss. Got: {t}')
def method117(v0 : US3) -> object:
    match v0:
        case US3_0(): # None
            del v0
            v1 = method118()
            v2 = "None"
            v3 = [v2,v1]
            del v1, v2
            return v3
        case US3_1(v4): # Some
            del v0
            v5 = method119(v4)
            del v4
            v6 = "Some"
            v7 = [v6,v5]
            del v5, v6
            return v7
        case t:
            raise Exception(f'Pattern matching miss. Got: {t}')
def method114(v0 : u64, v1 : US3) -> object:
    v2 = method115(v0)
    del v0
    v3 = method117(v1)
    del v1
    v4 = {'deck': v2, 'game': v3}
    del v2, v3
    return v4
def method136(v0 : static_array_list) -> object:
    v1 = []
    v2 = v0.length
    v3 = 0
    while method6(v2, v3):
        v6 = v0[v3]
        v7 = method124(v6)
        del v6
        v1.append(v7)
        del v7
        v3 += 1 
    del v0, v2, v3
    return v1
def method137(v0 : i32, v1 : i32) -> object:
    v2 = method121(v0)
    del v0
    v3 = method121(v1)
    del v1
    v4 = {'chips_won': v2, 'winner_id': v3}
    del v2, v3
    return v4
def method138(v0 : i32, v1 : US1) -> object:
    v2 = []
    v3 = method121(v0)
    del v0
    v2.append(v3)
    del v3
    v4 = method132(v1)
    del v1
    v2.append(v4)
    del v4
    v5 = v2
    del v2
    return v5
def method139(v0 : i32, v1 : static_array) -> object:
    v2 = []
    v3 = method121(v0)
    del v0
    v2.append(v3)
    del v3
    v4 = method123(v1)
    del v1
    v2.append(v4)
    del v4
    v5 = v2
    del v2
    return v5
def method144(v0 : i8) -> object:
    v1 = v0
    del v0
    return v1
def method143(v0 : static_array, v1 : i8) -> object:
    v2 = method129(v0)
    del v0
    v3 = method144(v1)
    del v1
    v4 = {'hand': v2, 'score': v3}
    del v2, v3
    return v4
def method142(v0 : static_array, v1 : i8) -> object:
    return method143(v0, v1)
def method141(v0 : static_array) -> object:
    v1 = []
    v2 = 0
    while method53(v2):
        v4 = 0 <= v2
        if v4:
            v5 = v2 < 2
            v6 = v5
        else:
            v6 = False
        del v4
        v7 = v6 == False
        if v7:
            v8 = "Index must be in range."
            assert v6, v8
            del v8
        else:
            pass
        del v6, v7
        v11, v12 = v0[v2]
        v13 = method142(v11, v12)
        del v11, v12
        v1.append(v13)
        del v13
        v2 += 1 
    del v0, v2
    return v1
def method140(v0 : i32, v1 : static_array, v2 : i32) -> object:
    v3 = method121(v0)
    del v0
    v4 = method141(v1)
    del v1
    v5 = method121(v2)
    del v2
    v6 = {'chips_won': v3, 'hands_shown': v4, 'winner_id': v5}
    del v3, v4, v5
    return v6
def method135(v0 : US7) -> object:
    match v0:
        case US7_0(v1): # CommunityCardsAre
            del v0
            v2 = method136(v1)
            del v1
            v3 = "CommunityCardsAre"
            v4 = [v3,v2]
            del v2, v3
            return v4
        case US7_1(v5, v6): # Fold
            del v0
            v7 = method137(v5, v6)
            del v5, v6
            v8 = "Fold"
            v9 = [v8,v7]
            del v7, v8
            return v9
        case US7_2(v10, v11): # PlayerAction
            del v0
            v12 = method138(v10, v11)
            del v10, v11
            v13 = "PlayerAction"
            v14 = [v13,v12]
            del v12, v13
            return v14
        case US7_3(v15, v16): # PlayerGotCards
            del v0
            v17 = method139(v15, v16)
            del v15, v16
            v18 = "PlayerGotCards"
            v19 = [v18,v17]
            del v17, v18
            return v19
        case US7_4(v20, v21, v22): # Showdown
            del v0
            v23 = method140(v20, v21, v22)
            del v20, v21, v22
            v24 = "Showdown"
            v25 = [v24,v23]
            del v23, v24
            return v25
        case t:
            raise Exception(f'Pattern matching miss. Got: {t}')
def method134(v0 : static_array_list) -> object:
    v1 = []
    v2 = v0.length
    v3 = 0
    while method6(v2, v3):
        v6 = v0[v3]
        v7 = method135(v6)
        del v6
        v1.append(v7)
        del v7
        v3 += 1 
    del v0, v2, v3
    return v1
def method146(v0 : US2) -> object:
    match v0:
        case US2_0(): # CallingMachine
            del v0
            v1 = method118()
            v2 = "CallingMachine"
            v3 = [v2,v1]
            del v1, v2
            return v3
        case US2_1(): # Computer
            del v0
            v4 = method118()
            v5 = "Computer"
            v6 = [v5,v4]
            del v4, v5
            return v6
        case US2_2(): # Human
            del v0
            v7 = method118()
            v8 = "Human"
            v9 = [v8,v7]
            del v7, v8
            return v9
        case US2_3(): # Random
            del v0
            v10 = method118()
            v11 = "Random"
            v12 = [v11,v10]
            del v10, v11
            return v12
        case t:
            raise Exception(f'Pattern matching miss. Got: {t}')
def method145(v0 : static_array) -> object:
    v1 = []
    v2 = 0
    while method53(v2):
        v4 = 0 <= v2
        if v4:
            v5 = v2 < 2
            v6 = v5
        else:
            v6 = False
        del v4
        v7 = v6 == False
        if v7:
            v8 = "Index must be in range."
            assert v6, v8
            del v8
        else:
            pass
        del v6, v7
        v10 = v0[v2]
        v11 = method146(v10)
        del v10
        v1.append(v11)
        del v11
        v2 += 1 
    del v0, v2
    return v1
def method147(v0 : US6) -> object:
    match v0:
        case US6_0(): # GameNotStarted
            del v0
            v1 = method118()
            v2 = "GameNotStarted"
            v3 = [v2,v1]
            del v1, v2
            return v3
        case US6_1(v4, v5, v6, v7, v8, v9): # GameOver
            del v0
            v10 = method120(v4, v5, v6, v7, v8, v9)
            del v4, v5, v6, v7, v8, v9
            v11 = "GameOver"
            v12 = [v11,v10]
            del v10, v11
            return v12
        case US6_2(v13, v14, v15, v16, v17, v18): # WaitingForActionFromPlayerId
            del v0
            v19 = method120(v13, v14, v15, v16, v17, v18)
            del v13, v14, v15, v16, v17, v18
            v20 = "WaitingForActionFromPlayerId"
            v21 = [v20,v19]
            del v19, v20
            return v21
        case t:
            raise Exception(f'Pattern matching miss. Got: {t}')
def method133(v0 : static_array_list, v1 : static_array, v2 : US6) -> object:
    v3 = method134(v0)
    del v0
    v4 = method145(v1)
    del v1
    v5 = method147(v2)
    del v2
    v6 = {'messages': v3, 'pl_type': v4, 'ui_game_state': v5}
    del v3, v4, v5
    return v6
def method113(v0 : u64, v1 : US3, v2 : static_array_list, v3 : static_array, v4 : US6) -> object:
    v5 = method114(v0, v1)
    del v0, v1
    v6 = method133(v2, v3, v4)
    del v2, v3, v4
    v7 = {'private': v5, 'public': v6}
    del v5, v6
    return v7
def method153(v0 : cp.ndarray) -> object:
    v1 = v0
    del v0
    return v1
def method152(v0 : cp.ndarray) -> object:
    return method153(v0)
def method151(v0 : cp.ndarray, v1 : cp.ndarray, v2 : cp.ndarray) -> object:
    v3 = []
    v4 = method152(v0)
    del v0
    v3.append(v4)
    del v4
    v5 = method152(v1)
    del v1
    v3.append(v5)
    del v5
    v6 = method152(v2)
    del v2
    v3.append(v6)
    del v6
    v7 = method118()
    v3.append(v7)
    del v7
    v8 = v3
    del v3
    return v8
def method150(v0 : cp.ndarray, v1 : cp.ndarray, v2 : cp.ndarray) -> object:
    return method151(v0, v1, v2)
def method149(v0 : cp.ndarray, v1 : cp.ndarray, v2 : cp.ndarray) -> object:
    return method150(v0, v1, v2)
def method148(v0 : cp.ndarray, v1 : cp.ndarray, v2 : cp.ndarray) -> object:
    v3 = method149(v0, v1, v2)
    del v0, v1, v2
    v4 = {'model_ptrs': v3}
    del v3
    return v4
def method112(v0 : u64, v1 : US3, v2 : static_array_list, v3 : static_array, v4 : US6, v5 : cp.ndarray, v6 : cp.ndarray, v7 : cp.ndarray) -> object:
    v8 = method113(v0, v1, v2, v3, v4)
    del v0, v1, v2, v3, v4
    v9 = method148(v5, v6, v7)
    del v5, v6, v7
    v10 = {'game': v8, 'neural': v9}
    del v8, v9
    return v10
def method158(v0 : f32) -> object:
    v1 = v0
    del v0
    return v1
def method157(v0 : list) -> object:
    v1 = []
    v2 = len(v0)
    v3 = 0
    while method6(v2, v3):
        v5 = v0[v3]
        v6 = method158(v5)
        del v5
        v1.append(v6)
        del v6
        v3 += 1 
    del v0, v2, v3
    return v1
def method156(v0 : list) -> object:
    v1 = []
    v2 = len(v0)
    v3 = 0
    while method6(v2, v3):
        v5 = v0[v3]
        v6 = method157(v5)
        del v5
        v1.append(v6)
        del v6
        v3 += 1 
    del v0, v2, v3
    return v1
def method155(v0 : US8) -> object:
    match v0:
        case US8_0(v1): # AddRewardsCallingMachine
            del v0
            v2 = method156(v1)
            del v1
            v3 = "AddRewardsCallingMachine"
            v4 = [v3,v2]
            del v2, v3
            return v4
        case US8_1(v5): # AddRewardsSelf
            del v0
            v6 = method156(v5)
            del v5
            v7 = "AddRewardsSelf"
            v8 = [v7,v6]
            del v6, v7
            return v8
        case t:
            raise Exception(f'Pattern matching miss. Got: {t}')
def method154(v0 : list) -> object:
    v1 = []
    v2 = len(v0)
    v3 = 0
    while method6(v2, v3):
        v5 = v0[v3]
        v6 = method155(v5)
        del v5
        v1.append(v6)
        del v6
        v3 += 1 
    del v0, v2, v3
    return v1
def method111(v0 : u64, v1 : US3, v2 : static_array_list, v3 : static_array, v4 : US6, v5 : cp.ndarray, v6 : cp.ndarray, v7 : cp.ndarray, v8 : list) -> object:
    v9 = []
    v10 = method112(v0, v1, v2, v3, v4, v5, v6, v7)
    del v0, v1, v2, v3, v4, v5, v6, v7
    v9.append(v10)
    del v10
    v11 = method154(v8)
    del v8
    v9.append(v11)
    del v11
    v12 = v9
    del v9
    return v12
def method110(v0 : u64, v1 : US3, v2 : static_array_list, v3 : static_array, v4 : US6, v5 : cp.ndarray, v6 : cp.ndarray, v7 : cp.ndarray, v8 : list) -> object:
    v9 = method111(v0, v1, v2, v3, v4, v5, v6, v7, v8)
    del v0, v1, v2, v3, v4, v5, v6, v7, v8
    return v9
def method159(v0 : u64, v1 : US3, v2 : static_array_list, v3 : static_array, v4 : US6, v5 : cp.ndarray, v6 : cp.ndarray, v7 : cp.ndarray) -> object:
    v8 = method112(v0, v1, v2, v3, v4, v5, v6, v7)
    del v0, v1, v2, v3, v4, v5, v6, v7
    return v8
def main_body():
    v0 = Closure0()
    v1 = Closure1()
    v2 = collections.namedtuple("Holdem_Full",['event_loop_gpu', 'init'])(v0, v1)
    del v0, v1
    return v2

def main():
    r = main_body()
    cp.cuda.get_current_stream().synchronize() # This line is here so the `__trap()` calls on the kernel aren't missed.
    return r

if __name__ == '__main__': print(main())
