kernel = r"""
#include <new>
#include <assert.h>
#include <stdio.h>
#include <curand_kernel.h>
#include <mma.h>
using namespace nvcuda;
#include <cuda/pipeline>
#include <cooperative_groups/memcpy_async.h>
#include <cooperative_groups.h>
#include <cooperative_groups/reduce.h>
#include <cooperative_groups/scan.h>
using default_int = int;
using default_uint = unsigned int;
template <typename el>
struct sptr // Shared pointer for the Spiral datatypes. They have to have the refc field inside them to work.
{
    el* base;

    __device__ sptr() : base(nullptr) {}
    __device__ sptr(el* ptr) : base(ptr) { this->base->refc++; }

    __device__ ~sptr()
    {
        if (this->base != nullptr && --this->base->refc == 0)
        {
            delete this->base;
            this->base = nullptr;
        }
    }

    __device__ sptr(sptr& x)
    {
        this->base = x.base;
        this->base->refc++;
    }

    __device__ sptr(sptr&& x)
    {
        this->base = x.base;
        x.base = nullptr;
    }

    __device__ sptr& operator=(sptr& x)
    {
        if (this->base != x.base)
        {
            delete this->base;
            this->base = x.base;
            this->base->refc++;
        }
        return *this;
    }

    __device__ sptr& operator=(sptr&& x)
    {
        if (this->base != x.base)
        {
            delete this->base;
            this->base = x.base;
            x.base = nullptr;
        }
        return *this;
    }
};

template <typename el>
struct csptr : public sptr<el>
{ // Shared pointer for closures specifically.
    using sptr<el>::sptr;
    template <typename... Args>
    __device__ auto operator()(Args... args) -> decltype(this->base->operator()(args...))
    {
        return this->base->operator()(args...);
    }
};

template <typename el, default_int max_length>
struct static_array
{
    el ptr[max_length];
    __device__ el& operator[](default_int i) {
        assert("The index has to be in range." && 0 <= i && i < max_length);
        return this->ptr[i];
    }
};

template <typename el, default_int max_length>
struct static_array_list
{
    default_int length{ 0 };
    el ptr[max_length];

    __device__ el& operator[](default_int i) {
        assert("The index has to be in range." && 0 <= i && i < this->length);
        return this->ptr[i];
    }
    __device__ void push(el& x) {
        ptr[this->length++] = x;
        assert("The array after pushing should not be greater than max length." && this->length <= max_length);
    }
    __device__ void push(el&& x) {
        ptr[this->length++] = std::move(x);
        assert("The array after pushing should not be greater than max length." && this->length <= max_length);
    }
    __device__ el pop() {
        assert("The array before popping should be greater than 0." && 0 < this->length);
        auto x = ptr[--this->length];
        ptr[this->length].~el();
        new (&ptr[this->length]) el();
        return x;
    }
    // Should be used only during initialization.
    __device__ void unsafe_set_length(default_int i) {
        assert("The new length should be in range." && 0 <= i && i <= max_length);
        this->length = i;
    }
};

template <typename el, default_int max_length>
struct dynamic_array_base
{
    int refc{ 0 };
    el* ptr;

    __device__ dynamic_array_base() : ptr(new el[max_length]) {}
    __device__ ~dynamic_array_base() { delete[] this->ptr; }

    __device__ el& operator[](default_int i) {
        assert("The index has to be in range." && 0 <= i && i < this->length);
        return this->ptr[i];
    }
};

template <typename el, default_int max_length>
struct dynamic_array
{
    sptr<dynamic_array_base<el, max_length>> ptr;

    __device__ dynamic_array() = default;
    __device__ dynamic_array(bool t) : ptr(new dynamic_array_base<el, max_length>()) {}
    __device__ el& operator[](default_int i) {
        return this->ptr.base->operator[](i);
    }
};

template <typename el, default_int max_length>
struct dynamic_array_list_base
{
    int refc{ 0 };
    default_int length{ 0 };
    el* ptr;

    __device__ dynamic_array_list_base() : ptr(new el[max_length]) {}
    __device__ dynamic_array_list_base(default_int l) : ptr(new el[max_length]) { this->unsafe_set_length(l); }
    __device__ ~dynamic_array_list_base() { delete[] this->ptr; }

    __device__ el& operator[](default_int i) {
        assert("The index has to be in range." && 0 <= i && i < this->length);
        return this->ptr[i];
    }
    __device__ void push(el& x) {
        ptr[this->length++] = x;
        assert("The array after pushing should not be greater than max length." && this->length <= max_length);
    }
    __device__ void push(el&& x) {
        ptr[this->length++] = std::move(x);
        assert("The array after pushing should not be greater than max length." && this->length <= max_length);
    }
    __device__ el pop() {
        assert("The array before popping should be greater than 0." && 0 < this->length);
        auto x = ptr[--this->length];
        ptr[this->length].~el();
        new (&ptr[this->length]) el();
        return x;
    }
    // Should be used only during initialization.
    __device__ void unsafe_set_length(default_int i) {
        assert("The new length should be in range." && 0 <= i && i <= max_length);
        this->length = i;
    }
};

template <typename el, default_int max_length>
struct dynamic_array_list
{
    sptr<dynamic_array_list_base<el, max_length>> ptr;

    __device__ dynamic_array_list() = default;
    __device__ dynamic_array_list(default_int l) : ptr(new dynamic_array_list_base<el, max_length>(l)) {}

    __device__ el& operator[](default_int i) {
        return this->ptr.base->operator[](i);
    }
    __device__ void push(el& x) {
        this->ptr.base->push(x);
    }
    __device__ void push(el&& x) {
        this->ptr.base->push(std::move(x));
    }
    __device__ el pop() {
        return this->ptr.base->pop();
    }
    // Should be used only during initialization.
    __device__ void unsafe_set_length(default_int i) {
        this->ptr.base->unsafe_set_length(i);
    }
    __device__ default_int length_() {
        return this->ptr.base->length;
    }
};

struct Union1;
struct Union2;
struct Union0;
__device__ int f_1(unsigned char * v0);
__device__ void f_3(unsigned char * v0);
__device__ Union1 f_2(unsigned char * v0);
__device__ Union2 f_5(unsigned char * v0);
__device__ static_array<Union2,2> f_4(unsigned char * v0);
__device__ Union0 f_0(unsigned char * v0);
struct Union5;
struct Union4;
struct Union3;
struct Tuple0;
struct Union6;
struct Union7;
struct Tuple1;
__device__ unsigned long long f_7(unsigned char * v0);
__device__ int f_8(unsigned char * v0);
struct Tuple2;
__device__ unsigned char f_13(unsigned char * v0);
__device__ unsigned char f_12(unsigned char * v0);
__device__ static_array<unsigned char,2> f_11(unsigned char * v0);
__device__ int f_14(unsigned char * v0);
__device__ static_array<unsigned char,3> f_15(unsigned char * v0);
__device__ static_array<unsigned char,5> f_16(unsigned char * v0);
__device__ static_array<unsigned char,4> f_17(unsigned char * v0);
__device__ Tuple2 f_10(unsigned char * v0);
struct Tuple3;
__device__ int f_19(unsigned char * v0);
__device__ Tuple3 f_18(unsigned char * v0);
__device__ Union4 f_9(unsigned char * v0);
__device__ int f_20(unsigned char * v0);
__device__ static_array_list<unsigned char,5> f_22(unsigned char * v0);
struct Tuple4;
__device__ Tuple4 f_23(unsigned char * v0);
struct Tuple5;
__device__ int f_25(unsigned char * v0);
__device__ Tuple5 f_24(unsigned char * v0);
struct Tuple6;
__device__ Tuple6 f_26(unsigned char * v0);
struct Tuple7;
__device__ Tuple0 f_29(unsigned char * v0);
__device__ Tuple0 f_28(unsigned char * v0);
__device__ Tuple7 f_27(unsigned char * v0);
__device__ Union6 f_21(unsigned char * v0);
__device__ int f_30(unsigned char * v0);
__device__ Tuple1 f_6(unsigned char * v0);
struct StackMut0;
struct Tuple8;
struct Tuple9;
struct Tuple10;
__device__ unsigned int loop_34(unsigned int v0, curandStatePhilox4_32_10_t & v1);
__device__ Tuple10 draw_card_33(curandStatePhilox4_32_10_t & v0, unsigned long long v1);
__device__ Tuple8 draw_cards_32(curandStatePhilox4_32_10_t & v0, unsigned long long v1);
__device__ static_array_list<unsigned char,5> get_community_cards_35(Union5 v0, static_array<unsigned char,3> v1);
__device__ bool player_can_act_37(int v0, static_array<static_array<unsigned char,2>,2> v1, static_array<int,2> v2, int v3, static_array<int,2> v4, Union5 v5);
__device__ Union4 go_next_street_38(int v0, static_array<static_array<unsigned char,2>,2> v1, static_array<int,2> v2, int v3, static_array<int,2> v4, Union5 v5);
__device__ Union4 try_round_36(int v0, static_array<static_array<unsigned char,2>,2> v1, static_array<int,2> v2, int v3, static_array<int,2> v4, Union5 v5);
struct Tuple11;
__device__ Tuple11 draw_cards_39(curandStatePhilox4_32_10_t & v0, unsigned long long v1);
struct Tuple12;
__device__ Tuple12 draw_cards_40(curandStatePhilox4_32_10_t & v0, unsigned long long v1);
__device__ static_array_list<unsigned char,5> get_community_cards_41(Union5 v0, static_array<unsigned char,1> v1);
struct Union8;
struct Tuple13;
__device__ void method_42(unsigned int v0, float * v1, int v2);
__device__ void method_43(unsigned int v0, float * v1, int v2);
__device__ int int_range_44(int v0, int v1, curandStatePhilox4_32_10_t & v2);
struct Union9;
__device__ void method_45(unsigned int * v0, int v1, float * v2);
struct Tuple14;
struct Tuple15;
struct Tuple16;
struct Tuple17;
__device__ Tuple14 method_46(curandStatePhilox4_32_10_t & v0, int * v1, float * v2, float * v3, float * v4, float * v5, float * v6, float * v7, float * v8, int v9, int v10);
struct Union10;
struct Tuple18;
__device__ int loop_50(static_array<float,6> v0, float v1, int v2);
__device__ int pick_discrete__49(static_array<float,6> v0, float v1);
__device__ int sample_discrete__48(static_array<float,6> v0, curandStatePhilox4_32_10_t & v1);
__device__ Union1 sample_discrete_47(static_array<Tuple18,6> v0, curandStatePhilox4_32_10_t & v1);
struct Tuple19;
struct Tuple20;
struct Union11;
struct Tuple21;
struct Union12;
struct Tuple22;
struct Tuple23;
struct Union13;
struct Union14;
struct Union15;
struct Union16;
struct Union17;
__device__ Tuple0 score_51(static_array<unsigned char,7> v0);
__device__ void play_loop_31(unsigned char * v0, unsigned long long v1, unsigned char * v2, unsigned long long v3, StackMut0 & v4, Union4 v5);
__device__ void f_53(unsigned char * v0, unsigned long long v1);
__device__ void f_54(unsigned char * v0, int v1);
__device__ void f_55(unsigned char * v0);
__device__ void f_57(unsigned char * v0, int v1);
__device__ void f_61(unsigned char * v0, unsigned char v1);
__device__ void f_60(unsigned char * v0, unsigned char v1);
__device__ void f_59(unsigned char * v0, static_array<unsigned char,2> v1);
__device__ void f_62(unsigned char * v0, int v1);
__device__ void f_63(unsigned char * v0, static_array<unsigned char,3> v1);
__device__ void f_64(unsigned char * v0, static_array<unsigned char,5> v1);
__device__ void f_65(unsigned char * v0, static_array<unsigned char,4> v1);
__device__ void f_58(unsigned char * v0, int v1, static_array<static_array<unsigned char,2>,2> v2, static_array<int,2> v3, int v4, static_array<int,2> v5, Union5 v6);
__device__ void f_67(unsigned char * v0, int v1);
__device__ void f_66(unsigned char * v0, int v1, static_array<static_array<unsigned char,2>,2> v2, static_array<int,2> v3, int v4, static_array<int,2> v5, Union5 v6, Union1 v7);
__device__ void f_56(unsigned char * v0, Union4 v1);
__device__ void f_68(unsigned char * v0, int v1);
__device__ void f_70(unsigned char * v0, static_array_list<unsigned char,5> v1);
__device__ void f_71(unsigned char * v0, int v1, int v2);
__device__ void f_73(unsigned char * v0, int v1);
__device__ void f_72(unsigned char * v0, int v1, Union1 v2);
__device__ void f_74(unsigned char * v0, int v1, static_array<unsigned char,2> v2);
__device__ void f_77(unsigned char * v0, static_array<unsigned char,5> v1, char v2);
__device__ void f_76(unsigned char * v0, static_array<unsigned char,5> v1, char v2);
__device__ void f_75(unsigned char * v0, int v1, static_array<Tuple0,2> v2, int v3);
__device__ void f_69(unsigned char * v0, Union6 v1);
__device__ void f_78(unsigned char * v0, Union2 v1);
__device__ void f_79(unsigned char * v0, int v1);
__device__ void f_52(unsigned char * v0, unsigned long long v1, Union3 v2, static_array_list<Union6,128> v3, static_array<Union2,2> v4, Union7 v5);
struct StackMut1;
struct Union18;
__device__ static_array_list<unsigned char,5> get_community_cards_81(Union5 v0, static_array<unsigned char,3> v1);
__device__ static_array_list<unsigned char,5> get_community_cards_82(Union5 v0, static_array<unsigned char,1> v1);
__device__ float method_83(int * v0, float * v1, float * v2, float * v3, float * v4, float * v5, float * v6, float * v7, int v8, int v9, int v10);
__device__ void method_80(unsigned char * v0, unsigned char * v1, StackMut1 & v2, int v3, Union4 v4);
struct Tuple24;
__device__ void method_84(unsigned char * v0, unsigned char * v1, StackMut1 & v2, Union4 v3);
__device__ float method_86(int * v0, float * v1, float * v2, float * v3, float * v4, float * v5, float * v6, float * v7, int v8, int v9, int v10);
__device__ void method_85(unsigned char * v0, unsigned char * v1, StackMut1 & v2, Union4 v3);
struct Union1_0 { // A_All_In
};
struct Union1_1 { // A_Call
};
struct Union1_2 { // A_Fold
};
struct Union1_3 { // A_Raise
    int v0;
    __device__ Union1_3(int t0) : v0(t0) {}
    __device__ Union1_3() = delete;
};
struct Union1 {
    union {
        Union1_0 case0; // A_All_In
        Union1_1 case1; // A_Call
        Union1_2 case2; // A_Fold
        Union1_3 case3; // A_Raise
    };
    unsigned char tag{255};
    __device__ Union1() {}
    __device__ Union1(Union1_0 t) : tag(0), case0(t) {} // A_All_In
    __device__ Union1(Union1_1 t) : tag(1), case1(t) {} // A_Call
    __device__ Union1(Union1_2 t) : tag(2), case2(t) {} // A_Fold
    __device__ Union1(Union1_3 t) : tag(3), case3(t) {} // A_Raise
    __device__ Union1(Union1 & x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union1_0(x.case0); break; // A_All_In
            case 1: new (&this->case1) Union1_1(x.case1); break; // A_Call
            case 2: new (&this->case2) Union1_2(x.case2); break; // A_Fold
            case 3: new (&this->case3) Union1_3(x.case3); break; // A_Raise
        }
    }
    __device__ Union1(Union1 && x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union1_0(std::move(x.case0)); break; // A_All_In
            case 1: new (&this->case1) Union1_1(std::move(x.case1)); break; // A_Call
            case 2: new (&this->case2) Union1_2(std::move(x.case2)); break; // A_Fold
            case 3: new (&this->case3) Union1_3(std::move(x.case3)); break; // A_Raise
        }
    }
    __device__ Union1 & operator=(Union1 & x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = x.case0; break; // A_All_In
                case 1: this->case1 = x.case1; break; // A_Call
                case 2: this->case2 = x.case2; break; // A_Fold
                case 3: this->case3 = x.case3; break; // A_Raise
            }
        } else {
            this->~Union1();
            new (this) Union1{x};
        }
        return *this;
    }
    __device__ Union1 & operator=(Union1 && x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = std::move(x.case0); break; // A_All_In
                case 1: this->case1 = std::move(x.case1); break; // A_Call
                case 2: this->case2 = std::move(x.case2); break; // A_Fold
                case 3: this->case3 = std::move(x.case3); break; // A_Raise
            }
        } else {
            this->~Union1();
            new (this) Union1{std::move(x)};
        }
        return *this;
    }
    __device__ ~Union1() {
        switch(this->tag){
            case 0: this->case0.~Union1_0(); break; // A_All_In
            case 1: this->case1.~Union1_1(); break; // A_Call
            case 2: this->case2.~Union1_2(); break; // A_Fold
            case 3: this->case3.~Union1_3(); break; // A_Raise
        }
        this->tag = 255;
    }
};
struct Union2_0 { // Computer
};
struct Union2_1 { // Human
};
struct Union2_2 { // Random
};
struct Union2 {
    union {
        Union2_0 case0; // Computer
        Union2_1 case1; // Human
        Union2_2 case2; // Random
    };
    unsigned char tag{255};
    __device__ Union2() {}
    __device__ Union2(Union2_0 t) : tag(0), case0(t) {} // Computer
    __device__ Union2(Union2_1 t) : tag(1), case1(t) {} // Human
    __device__ Union2(Union2_2 t) : tag(2), case2(t) {} // Random
    __device__ Union2(Union2 & x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union2_0(x.case0); break; // Computer
            case 1: new (&this->case1) Union2_1(x.case1); break; // Human
            case 2: new (&this->case2) Union2_2(x.case2); break; // Random
        }
    }
    __device__ Union2(Union2 && x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union2_0(std::move(x.case0)); break; // Computer
            case 1: new (&this->case1) Union2_1(std::move(x.case1)); break; // Human
            case 2: new (&this->case2) Union2_2(std::move(x.case2)); break; // Random
        }
    }
    __device__ Union2 & operator=(Union2 & x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = x.case0; break; // Computer
                case 1: this->case1 = x.case1; break; // Human
                case 2: this->case2 = x.case2; break; // Random
            }
        } else {
            this->~Union2();
            new (this) Union2{x};
        }
        return *this;
    }
    __device__ Union2 & operator=(Union2 && x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = std::move(x.case0); break; // Computer
                case 1: this->case1 = std::move(x.case1); break; // Human
                case 2: this->case2 = std::move(x.case2); break; // Random
            }
        } else {
            this->~Union2();
            new (this) Union2{std::move(x)};
        }
        return *this;
    }
    __device__ ~Union2() {
        switch(this->tag){
            case 0: this->case0.~Union2_0(); break; // Computer
            case 1: this->case1.~Union2_1(); break; // Human
            case 2: this->case2.~Union2_2(); break; // Random
        }
        this->tag = 255;
    }
};
struct Union0_0 { // ActionSelected
    Union1 v0;
    __device__ Union0_0(Union1 t0) : v0(t0) {}
    __device__ Union0_0() = delete;
};
struct Union0_1 { // PlayerChanged
    static_array<Union2,2> v0;
    __device__ Union0_1(static_array<Union2,2> t0) : v0(t0) {}
    __device__ Union0_1() = delete;
};
struct Union0_2 { // StartGame
};
struct Union0_3 { // StartTrainingVsRando
};
struct Union0_4 { // StartTrainingVsSelf
};
struct Union0 {
    union {
        Union0_0 case0; // ActionSelected
        Union0_1 case1; // PlayerChanged
        Union0_2 case2; // StartGame
        Union0_3 case3; // StartTrainingVsRando
        Union0_4 case4; // StartTrainingVsSelf
    };
    unsigned char tag{255};
    __device__ Union0() {}
    __device__ Union0(Union0_0 t) : tag(0), case0(t) {} // ActionSelected
    __device__ Union0(Union0_1 t) : tag(1), case1(t) {} // PlayerChanged
    __device__ Union0(Union0_2 t) : tag(2), case2(t) {} // StartGame
    __device__ Union0(Union0_3 t) : tag(3), case3(t) {} // StartTrainingVsRando
    __device__ Union0(Union0_4 t) : tag(4), case4(t) {} // StartTrainingVsSelf
    __device__ Union0(Union0 & x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union0_0(x.case0); break; // ActionSelected
            case 1: new (&this->case1) Union0_1(x.case1); break; // PlayerChanged
            case 2: new (&this->case2) Union0_2(x.case2); break; // StartGame
            case 3: new (&this->case3) Union0_3(x.case3); break; // StartTrainingVsRando
            case 4: new (&this->case4) Union0_4(x.case4); break; // StartTrainingVsSelf
        }
    }
    __device__ Union0(Union0 && x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union0_0(std::move(x.case0)); break; // ActionSelected
            case 1: new (&this->case1) Union0_1(std::move(x.case1)); break; // PlayerChanged
            case 2: new (&this->case2) Union0_2(std::move(x.case2)); break; // StartGame
            case 3: new (&this->case3) Union0_3(std::move(x.case3)); break; // StartTrainingVsRando
            case 4: new (&this->case4) Union0_4(std::move(x.case4)); break; // StartTrainingVsSelf
        }
    }
    __device__ Union0 & operator=(Union0 & x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = x.case0; break; // ActionSelected
                case 1: this->case1 = x.case1; break; // PlayerChanged
                case 2: this->case2 = x.case2; break; // StartGame
                case 3: this->case3 = x.case3; break; // StartTrainingVsRando
                case 4: this->case4 = x.case4; break; // StartTrainingVsSelf
            }
        } else {
            this->~Union0();
            new (this) Union0{x};
        }
        return *this;
    }
    __device__ Union0 & operator=(Union0 && x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = std::move(x.case0); break; // ActionSelected
                case 1: this->case1 = std::move(x.case1); break; // PlayerChanged
                case 2: this->case2 = std::move(x.case2); break; // StartGame
                case 3: this->case3 = std::move(x.case3); break; // StartTrainingVsRando
                case 4: this->case4 = std::move(x.case4); break; // StartTrainingVsSelf
            }
        } else {
            this->~Union0();
            new (this) Union0{std::move(x)};
        }
        return *this;
    }
    __device__ ~Union0() {
        switch(this->tag){
            case 0: this->case0.~Union0_0(); break; // ActionSelected
            case 1: this->case1.~Union0_1(); break; // PlayerChanged
            case 2: this->case2.~Union0_2(); break; // StartGame
            case 3: this->case3.~Union0_3(); break; // StartTrainingVsRando
            case 4: this->case4.~Union0_4(); break; // StartTrainingVsSelf
        }
        this->tag = 255;
    }
};
struct Union5_0 { // Flop
    static_array<unsigned char,3> v0;
    __device__ Union5_0(static_array<unsigned char,3> t0) : v0(t0) {}
    __device__ Union5_0() = delete;
};
struct Union5_1 { // Preflop
};
struct Union5_2 { // River
    static_array<unsigned char,5> v0;
    __device__ Union5_2(static_array<unsigned char,5> t0) : v0(t0) {}
    __device__ Union5_2() = delete;
};
struct Union5_3 { // Turn
    static_array<unsigned char,4> v0;
    __device__ Union5_3(static_array<unsigned char,4> t0) : v0(t0) {}
    __device__ Union5_3() = delete;
};
struct Union5 {
    union {
        Union5_0 case0; // Flop
        Union5_1 case1; // Preflop
        Union5_2 case2; // River
        Union5_3 case3; // Turn
    };
    unsigned char tag{255};
    __device__ Union5() {}
    __device__ Union5(Union5_0 t) : tag(0), case0(t) {} // Flop
    __device__ Union5(Union5_1 t) : tag(1), case1(t) {} // Preflop
    __device__ Union5(Union5_2 t) : tag(2), case2(t) {} // River
    __device__ Union5(Union5_3 t) : tag(3), case3(t) {} // Turn
    __device__ Union5(Union5 & x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union5_0(x.case0); break; // Flop
            case 1: new (&this->case1) Union5_1(x.case1); break; // Preflop
            case 2: new (&this->case2) Union5_2(x.case2); break; // River
            case 3: new (&this->case3) Union5_3(x.case3); break; // Turn
        }
    }
    __device__ Union5(Union5 && x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union5_0(std::move(x.case0)); break; // Flop
            case 1: new (&this->case1) Union5_1(std::move(x.case1)); break; // Preflop
            case 2: new (&this->case2) Union5_2(std::move(x.case2)); break; // River
            case 3: new (&this->case3) Union5_3(std::move(x.case3)); break; // Turn
        }
    }
    __device__ Union5 & operator=(Union5 & x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = x.case0; break; // Flop
                case 1: this->case1 = x.case1; break; // Preflop
                case 2: this->case2 = x.case2; break; // River
                case 3: this->case3 = x.case3; break; // Turn
            }
        } else {
            this->~Union5();
            new (this) Union5{x};
        }
        return *this;
    }
    __device__ Union5 & operator=(Union5 && x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = std::move(x.case0); break; // Flop
                case 1: this->case1 = std::move(x.case1); break; // Preflop
                case 2: this->case2 = std::move(x.case2); break; // River
                case 3: this->case3 = std::move(x.case3); break; // Turn
            }
        } else {
            this->~Union5();
            new (this) Union5{std::move(x)};
        }
        return *this;
    }
    __device__ ~Union5() {
        switch(this->tag){
            case 0: this->case0.~Union5_0(); break; // Flop
            case 1: this->case1.~Union5_1(); break; // Preflop
            case 2: this->case2.~Union5_2(); break; // River
            case 3: this->case3.~Union5_3(); break; // Turn
        }
        this->tag = 255;
    }
};
struct Union4_0 { // G_Flop
    static_array<static_array<unsigned char,2>,2> v1;
    static_array<int,2> v2;
    static_array<int,2> v4;
    Union5 v5;
    int v0;
    int v3;
    __device__ Union4_0(int t0, static_array<static_array<unsigned char,2>,2> t1, static_array<int,2> t2, int t3, static_array<int,2> t4, Union5 t5) : v0(t0), v1(t1), v2(t2), v3(t3), v4(t4), v5(t5) {}
    __device__ Union4_0() = delete;
};
struct Union4_1 { // G_Fold
    static_array<static_array<unsigned char,2>,2> v1;
    static_array<int,2> v2;
    static_array<int,2> v4;
    Union5 v5;
    int v0;
    int v3;
    __device__ Union4_1(int t0, static_array<static_array<unsigned char,2>,2> t1, static_array<int,2> t2, int t3, static_array<int,2> t4, Union5 t5) : v0(t0), v1(t1), v2(t2), v3(t3), v4(t4), v5(t5) {}
    __device__ Union4_1() = delete;
};
struct Union4_2 { // G_Preflop
};
struct Union4_3 { // G_River
    static_array<static_array<unsigned char,2>,2> v1;
    static_array<int,2> v2;
    static_array<int,2> v4;
    Union5 v5;
    int v0;
    int v3;
    __device__ Union4_3(int t0, static_array<static_array<unsigned char,2>,2> t1, static_array<int,2> t2, int t3, static_array<int,2> t4, Union5 t5) : v0(t0), v1(t1), v2(t2), v3(t3), v4(t4), v5(t5) {}
    __device__ Union4_3() = delete;
};
struct Union4_4 { // G_Round
    static_array<static_array<unsigned char,2>,2> v1;
    static_array<int,2> v2;
    static_array<int,2> v4;
    Union5 v5;
    int v0;
    int v3;
    __device__ Union4_4(int t0, static_array<static_array<unsigned char,2>,2> t1, static_array<int,2> t2, int t3, static_array<int,2> t4, Union5 t5) : v0(t0), v1(t1), v2(t2), v3(t3), v4(t4), v5(t5) {}
    __device__ Union4_4() = delete;
};
struct Union4_5 { // G_Round'
    static_array<static_array<unsigned char,2>,2> v1;
    static_array<int,2> v2;
    static_array<int,2> v4;
    Union5 v5;
    Union1 v6;
    int v0;
    int v3;
    __device__ Union4_5(int t0, static_array<static_array<unsigned char,2>,2> t1, static_array<int,2> t2, int t3, static_array<int,2> t4, Union5 t5, Union1 t6) : v0(t0), v1(t1), v2(t2), v3(t3), v4(t4), v5(t5), v6(t6) {}
    __device__ Union4_5() = delete;
};
struct Union4_6 { // G_Showdown
    static_array<static_array<unsigned char,2>,2> v1;
    static_array<int,2> v2;
    static_array<int,2> v4;
    Union5 v5;
    int v0;
    int v3;
    __device__ Union4_6(int t0, static_array<static_array<unsigned char,2>,2> t1, static_array<int,2> t2, int t3, static_array<int,2> t4, Union5 t5) : v0(t0), v1(t1), v2(t2), v3(t3), v4(t4), v5(t5) {}
    __device__ Union4_6() = delete;
};
struct Union4_7 { // G_Turn
    static_array<static_array<unsigned char,2>,2> v1;
    static_array<int,2> v2;
    static_array<int,2> v4;
    Union5 v5;
    int v0;
    int v3;
    __device__ Union4_7(int t0, static_array<static_array<unsigned char,2>,2> t1, static_array<int,2> t2, int t3, static_array<int,2> t4, Union5 t5) : v0(t0), v1(t1), v2(t2), v3(t3), v4(t4), v5(t5) {}
    __device__ Union4_7() = delete;
};
struct Union4 {
    union {
        Union4_0 case0; // G_Flop
        Union4_1 case1; // G_Fold
        Union4_2 case2; // G_Preflop
        Union4_3 case3; // G_River
        Union4_4 case4; // G_Round
        Union4_5 case5; // G_Round'
        Union4_6 case6; // G_Showdown
        Union4_7 case7; // G_Turn
    };
    unsigned char tag{255};
    __device__ Union4() {}
    __device__ Union4(Union4_0 t) : tag(0), case0(t) {} // G_Flop
    __device__ Union4(Union4_1 t) : tag(1), case1(t) {} // G_Fold
    __device__ Union4(Union4_2 t) : tag(2), case2(t) {} // G_Preflop
    __device__ Union4(Union4_3 t) : tag(3), case3(t) {} // G_River
    __device__ Union4(Union4_4 t) : tag(4), case4(t) {} // G_Round
    __device__ Union4(Union4_5 t) : tag(5), case5(t) {} // G_Round'
    __device__ Union4(Union4_6 t) : tag(6), case6(t) {} // G_Showdown
    __device__ Union4(Union4_7 t) : tag(7), case7(t) {} // G_Turn
    __device__ Union4(Union4 & x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union4_0(x.case0); break; // G_Flop
            case 1: new (&this->case1) Union4_1(x.case1); break; // G_Fold
            case 2: new (&this->case2) Union4_2(x.case2); break; // G_Preflop
            case 3: new (&this->case3) Union4_3(x.case3); break; // G_River
            case 4: new (&this->case4) Union4_4(x.case4); break; // G_Round
            case 5: new (&this->case5) Union4_5(x.case5); break; // G_Round'
            case 6: new (&this->case6) Union4_6(x.case6); break; // G_Showdown
            case 7: new (&this->case7) Union4_7(x.case7); break; // G_Turn
        }
    }
    __device__ Union4(Union4 && x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union4_0(std::move(x.case0)); break; // G_Flop
            case 1: new (&this->case1) Union4_1(std::move(x.case1)); break; // G_Fold
            case 2: new (&this->case2) Union4_2(std::move(x.case2)); break; // G_Preflop
            case 3: new (&this->case3) Union4_3(std::move(x.case3)); break; // G_River
            case 4: new (&this->case4) Union4_4(std::move(x.case4)); break; // G_Round
            case 5: new (&this->case5) Union4_5(std::move(x.case5)); break; // G_Round'
            case 6: new (&this->case6) Union4_6(std::move(x.case6)); break; // G_Showdown
            case 7: new (&this->case7) Union4_7(std::move(x.case7)); break; // G_Turn
        }
    }
    __device__ Union4 & operator=(Union4 & x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = x.case0; break; // G_Flop
                case 1: this->case1 = x.case1; break; // G_Fold
                case 2: this->case2 = x.case2; break; // G_Preflop
                case 3: this->case3 = x.case3; break; // G_River
                case 4: this->case4 = x.case4; break; // G_Round
                case 5: this->case5 = x.case5; break; // G_Round'
                case 6: this->case6 = x.case6; break; // G_Showdown
                case 7: this->case7 = x.case7; break; // G_Turn
            }
        } else {
            this->~Union4();
            new (this) Union4{x};
        }
        return *this;
    }
    __device__ Union4 & operator=(Union4 && x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = std::move(x.case0); break; // G_Flop
                case 1: this->case1 = std::move(x.case1); break; // G_Fold
                case 2: this->case2 = std::move(x.case2); break; // G_Preflop
                case 3: this->case3 = std::move(x.case3); break; // G_River
                case 4: this->case4 = std::move(x.case4); break; // G_Round
                case 5: this->case5 = std::move(x.case5); break; // G_Round'
                case 6: this->case6 = std::move(x.case6); break; // G_Showdown
                case 7: this->case7 = std::move(x.case7); break; // G_Turn
            }
        } else {
            this->~Union4();
            new (this) Union4{std::move(x)};
        }
        return *this;
    }
    __device__ ~Union4() {
        switch(this->tag){
            case 0: this->case0.~Union4_0(); break; // G_Flop
            case 1: this->case1.~Union4_1(); break; // G_Fold
            case 2: this->case2.~Union4_2(); break; // G_Preflop
            case 3: this->case3.~Union4_3(); break; // G_River
            case 4: this->case4.~Union4_4(); break; // G_Round
            case 5: this->case5.~Union4_5(); break; // G_Round'
            case 6: this->case6.~Union4_6(); break; // G_Showdown
            case 7: this->case7.~Union4_7(); break; // G_Turn
        }
        this->tag = 255;
    }
};
struct Union3_0 { // None
};
struct Union3_1 { // Some
    Union4 v0;
    __device__ Union3_1(Union4 t0) : v0(t0) {}
    __device__ Union3_1() = delete;
};
struct Union3 {
    union {
        Union3_0 case0; // None
        Union3_1 case1; // Some
    };
    unsigned char tag{255};
    __device__ Union3() {}
    __device__ Union3(Union3_0 t) : tag(0), case0(t) {} // None
    __device__ Union3(Union3_1 t) : tag(1), case1(t) {} // Some
    __device__ Union3(Union3 & x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union3_0(x.case0); break; // None
            case 1: new (&this->case1) Union3_1(x.case1); break; // Some
        }
    }
    __device__ Union3(Union3 && x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union3_0(std::move(x.case0)); break; // None
            case 1: new (&this->case1) Union3_1(std::move(x.case1)); break; // Some
        }
    }
    __device__ Union3 & operator=(Union3 & x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = x.case0; break; // None
                case 1: this->case1 = x.case1; break; // Some
            }
        } else {
            this->~Union3();
            new (this) Union3{x};
        }
        return *this;
    }
    __device__ Union3 & operator=(Union3 && x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = std::move(x.case0); break; // None
                case 1: this->case1 = std::move(x.case1); break; // Some
            }
        } else {
            this->~Union3();
            new (this) Union3{std::move(x)};
        }
        return *this;
    }
    __device__ ~Union3() {
        switch(this->tag){
            case 0: this->case0.~Union3_0(); break; // None
            case 1: this->case1.~Union3_1(); break; // Some
        }
        this->tag = 255;
    }
};
struct Tuple0 {
    static_array<unsigned char,5> v0;
    char v1;
    __device__ Tuple0() = default;
    __device__ Tuple0(static_array<unsigned char,5> t0, char t1) : v0(t0), v1(t1) {}
};
struct Union6_0 { // CommunityCardsAre
    static_array_list<unsigned char,5> v0;
    __device__ Union6_0(static_array_list<unsigned char,5> t0) : v0(t0) {}
    __device__ Union6_0() = delete;
};
struct Union6_1 { // Fold
    int v0;
    int v1;
    __device__ Union6_1(int t0, int t1) : v0(t0), v1(t1) {}
    __device__ Union6_1() = delete;
};
struct Union6_2 { // PlayerAction
    Union1 v1;
    int v0;
    __device__ Union6_2(int t0, Union1 t1) : v0(t0), v1(t1) {}
    __device__ Union6_2() = delete;
};
struct Union6_3 { // PlayerGotCards
    static_array<unsigned char,2> v1;
    int v0;
    __device__ Union6_3(int t0, static_array<unsigned char,2> t1) : v0(t0), v1(t1) {}
    __device__ Union6_3() = delete;
};
struct Union6_4 { // Showdown
    static_array<Tuple0,2> v1;
    int v0;
    int v2;
    __device__ Union6_4(int t0, static_array<Tuple0,2> t1, int t2) : v0(t0), v1(t1), v2(t2) {}
    __device__ Union6_4() = delete;
};
struct Union6 {
    union {
        Union6_0 case0; // CommunityCardsAre
        Union6_1 case1; // Fold
        Union6_2 case2; // PlayerAction
        Union6_3 case3; // PlayerGotCards
        Union6_4 case4; // Showdown
    };
    unsigned char tag{255};
    __device__ Union6() {}
    __device__ Union6(Union6_0 t) : tag(0), case0(t) {} // CommunityCardsAre
    __device__ Union6(Union6_1 t) : tag(1), case1(t) {} // Fold
    __device__ Union6(Union6_2 t) : tag(2), case2(t) {} // PlayerAction
    __device__ Union6(Union6_3 t) : tag(3), case3(t) {} // PlayerGotCards
    __device__ Union6(Union6_4 t) : tag(4), case4(t) {} // Showdown
    __device__ Union6(Union6 & x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union6_0(x.case0); break; // CommunityCardsAre
            case 1: new (&this->case1) Union6_1(x.case1); break; // Fold
            case 2: new (&this->case2) Union6_2(x.case2); break; // PlayerAction
            case 3: new (&this->case3) Union6_3(x.case3); break; // PlayerGotCards
            case 4: new (&this->case4) Union6_4(x.case4); break; // Showdown
        }
    }
    __device__ Union6(Union6 && x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union6_0(std::move(x.case0)); break; // CommunityCardsAre
            case 1: new (&this->case1) Union6_1(std::move(x.case1)); break; // Fold
            case 2: new (&this->case2) Union6_2(std::move(x.case2)); break; // PlayerAction
            case 3: new (&this->case3) Union6_3(std::move(x.case3)); break; // PlayerGotCards
            case 4: new (&this->case4) Union6_4(std::move(x.case4)); break; // Showdown
        }
    }
    __device__ Union6 & operator=(Union6 & x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = x.case0; break; // CommunityCardsAre
                case 1: this->case1 = x.case1; break; // Fold
                case 2: this->case2 = x.case2; break; // PlayerAction
                case 3: this->case3 = x.case3; break; // PlayerGotCards
                case 4: this->case4 = x.case4; break; // Showdown
            }
        } else {
            this->~Union6();
            new (this) Union6{x};
        }
        return *this;
    }
    __device__ Union6 & operator=(Union6 && x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = std::move(x.case0); break; // CommunityCardsAre
                case 1: this->case1 = std::move(x.case1); break; // Fold
                case 2: this->case2 = std::move(x.case2); break; // PlayerAction
                case 3: this->case3 = std::move(x.case3); break; // PlayerGotCards
                case 4: this->case4 = std::move(x.case4); break; // Showdown
            }
        } else {
            this->~Union6();
            new (this) Union6{std::move(x)};
        }
        return *this;
    }
    __device__ ~Union6() {
        switch(this->tag){
            case 0: this->case0.~Union6_0(); break; // CommunityCardsAre
            case 1: this->case1.~Union6_1(); break; // Fold
            case 2: this->case2.~Union6_2(); break; // PlayerAction
            case 3: this->case3.~Union6_3(); break; // PlayerGotCards
            case 4: this->case4.~Union6_4(); break; // Showdown
        }
        this->tag = 255;
    }
};
struct Union7_0 { // GameNotStarted
};
struct Union7_1 { // GameOver
    static_array<static_array<unsigned char,2>,2> v1;
    static_array<int,2> v2;
    static_array<int,2> v4;
    Union5 v5;
    int v0;
    int v3;
    __device__ Union7_1(int t0, static_array<static_array<unsigned char,2>,2> t1, static_array<int,2> t2, int t3, static_array<int,2> t4, Union5 t5) : v0(t0), v1(t1), v2(t2), v3(t3), v4(t4), v5(t5) {}
    __device__ Union7_1() = delete;
};
struct Union7_2 { // WaitingForActionFromPlayerId
    static_array<static_array<unsigned char,2>,2> v1;
    static_array<int,2> v2;
    static_array<int,2> v4;
    Union5 v5;
    int v0;
    int v3;
    __device__ Union7_2(int t0, static_array<static_array<unsigned char,2>,2> t1, static_array<int,2> t2, int t3, static_array<int,2> t4, Union5 t5) : v0(t0), v1(t1), v2(t2), v3(t3), v4(t4), v5(t5) {}
    __device__ Union7_2() = delete;
};
struct Union7 {
    union {
        Union7_0 case0; // GameNotStarted
        Union7_1 case1; // GameOver
        Union7_2 case2; // WaitingForActionFromPlayerId
    };
    unsigned char tag{255};
    __device__ Union7() {}
    __device__ Union7(Union7_0 t) : tag(0), case0(t) {} // GameNotStarted
    __device__ Union7(Union7_1 t) : tag(1), case1(t) {} // GameOver
    __device__ Union7(Union7_2 t) : tag(2), case2(t) {} // WaitingForActionFromPlayerId
    __device__ Union7(Union7 & x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union7_0(x.case0); break; // GameNotStarted
            case 1: new (&this->case1) Union7_1(x.case1); break; // GameOver
            case 2: new (&this->case2) Union7_2(x.case2); break; // WaitingForActionFromPlayerId
        }
    }
    __device__ Union7(Union7 && x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union7_0(std::move(x.case0)); break; // GameNotStarted
            case 1: new (&this->case1) Union7_1(std::move(x.case1)); break; // GameOver
            case 2: new (&this->case2) Union7_2(std::move(x.case2)); break; // WaitingForActionFromPlayerId
        }
    }
    __device__ Union7 & operator=(Union7 & x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = x.case0; break; // GameNotStarted
                case 1: this->case1 = x.case1; break; // GameOver
                case 2: this->case2 = x.case2; break; // WaitingForActionFromPlayerId
            }
        } else {
            this->~Union7();
            new (this) Union7{x};
        }
        return *this;
    }
    __device__ Union7 & operator=(Union7 && x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = std::move(x.case0); break; // GameNotStarted
                case 1: this->case1 = std::move(x.case1); break; // GameOver
                case 2: this->case2 = std::move(x.case2); break; // WaitingForActionFromPlayerId
            }
        } else {
            this->~Union7();
            new (this) Union7{std::move(x)};
        }
        return *this;
    }
    __device__ ~Union7() {
        switch(this->tag){
            case 0: this->case0.~Union7_0(); break; // GameNotStarted
            case 1: this->case1.~Union7_1(); break; // GameOver
            case 2: this->case2.~Union7_2(); break; // WaitingForActionFromPlayerId
        }
        this->tag = 255;
    }
};
struct Tuple1 {
    unsigned long long v0;
    Union3 v1;
    static_array_list<Union6,128> v2;
    static_array<Union2,2> v3;
    Union7 v4;
    __device__ Tuple1() = default;
    __device__ Tuple1(unsigned long long t0, Union3 t1, static_array_list<Union6,128> t2, static_array<Union2,2> t3, Union7 t4) : v0(t0), v1(t1), v2(t2), v3(t3), v4(t4) {}
};
struct Tuple2 {
    static_array<static_array<unsigned char,2>,2> v1;
    static_array<int,2> v2;
    static_array<int,2> v4;
    Union5 v5;
    int v0;
    int v3;
    __device__ Tuple2() = default;
    __device__ Tuple2(int t0, static_array<static_array<unsigned char,2>,2> t1, static_array<int,2> t2, int t3, static_array<int,2> t4, Union5 t5) : v0(t0), v1(t1), v2(t2), v3(t3), v4(t4), v5(t5) {}
};
struct Tuple3 {
    static_array<static_array<unsigned char,2>,2> v1;
    static_array<int,2> v2;
    static_array<int,2> v4;
    Union5 v5;
    Union1 v6;
    int v0;
    int v3;
    __device__ Tuple3() = default;
    __device__ Tuple3(int t0, static_array<static_array<unsigned char,2>,2> t1, static_array<int,2> t2, int t3, static_array<int,2> t4, Union5 t5, Union1 t6) : v0(t0), v1(t1), v2(t2), v3(t3), v4(t4), v5(t5), v6(t6) {}
};
struct Tuple4 {
    int v0;
    int v1;
    __device__ Tuple4() = default;
    __device__ Tuple4(int t0, int t1) : v0(t0), v1(t1) {}
};
struct Tuple5 {
    Union1 v1;
    int v0;
    __device__ Tuple5() = default;
    __device__ Tuple5(int t0, Union1 t1) : v0(t0), v1(t1) {}
};
struct Tuple6 {
    static_array<unsigned char,2> v1;
    int v0;
    __device__ Tuple6() = default;
    __device__ Tuple6(int t0, static_array<unsigned char,2> t1) : v0(t0), v1(t1) {}
};
struct Tuple7 {
    static_array<Tuple0,2> v1;
    int v0;
    int v2;
    __device__ Tuple7() = default;
    __device__ Tuple7(int t0, static_array<Tuple0,2> t1, int t2) : v0(t0), v1(t1), v2(t2) {}
};
struct StackMut0 {
    unsigned long long v0;
    Union3 v1;
    static_array_list<Union6,128> v2;
    static_array<Union2,2> v3;
    curandStatePhilox4_32_10_t v4;
    Union7 v5;
    __device__ StackMut0() = default;
    __device__ StackMut0(unsigned long long t0, Union3 t1, static_array_list<Union6,128> t2, static_array<Union2,2> t3, curandStatePhilox4_32_10_t t4, Union7 t5) : v0(t0), v1(t1), v2(t2), v3(t3), v4(t4), v5(t5) {}
};
struct Tuple8 {
    static_array<unsigned char,3> v0;
    unsigned long long v1;
    __device__ Tuple8() = default;
    __device__ Tuple8(static_array<unsigned char,3> t0, unsigned long long t1) : v0(t0), v1(t1) {}
};
struct Tuple9 {
    unsigned long long v1;
    int v0;
    __device__ Tuple9() = default;
    __device__ Tuple9(int t0, unsigned long long t1) : v0(t0), v1(t1) {}
};
struct Tuple10 {
    unsigned long long v1;
    unsigned char v0;
    __device__ Tuple10() = default;
    __device__ Tuple10(unsigned char t0, unsigned long long t1) : v0(t0), v1(t1) {}
};
struct Tuple11 {
    static_array<unsigned char,2> v0;
    unsigned long long v1;
    __device__ Tuple11() = default;
    __device__ Tuple11(static_array<unsigned char,2> t0, unsigned long long t1) : v0(t0), v1(t1) {}
};
struct Tuple12 {
    static_array<unsigned char,1> v0;
    unsigned long long v1;
    __device__ Tuple12() = default;
    __device__ Tuple12(static_array<unsigned char,1> t0, unsigned long long t1) : v0(t0), v1(t1) {}
};
struct Union8_0 { // None
};
struct Union8_1 { // Some
    Union1 v0;
    __device__ Union8_1(Union1 t0) : v0(t0) {}
    __device__ Union8_1() = delete;
};
struct Union8 {
    union {
        Union8_0 case0; // None
        Union8_1 case1; // Some
    };
    unsigned char tag{255};
    __device__ Union8() {}
    __device__ Union8(Union8_0 t) : tag(0), case0(t) {} // None
    __device__ Union8(Union8_1 t) : tag(1), case1(t) {} // Some
    __device__ Union8(Union8 & x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union8_0(x.case0); break; // None
            case 1: new (&this->case1) Union8_1(x.case1); break; // Some
        }
    }
    __device__ Union8(Union8 && x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union8_0(std::move(x.case0)); break; // None
            case 1: new (&this->case1) Union8_1(std::move(x.case1)); break; // Some
        }
    }
    __device__ Union8 & operator=(Union8 & x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = x.case0; break; // None
                case 1: this->case1 = x.case1; break; // Some
            }
        } else {
            this->~Union8();
            new (this) Union8{x};
        }
        return *this;
    }
    __device__ Union8 & operator=(Union8 && x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = std::move(x.case0); break; // None
                case 1: this->case1 = std::move(x.case1); break; // Some
            }
        } else {
            this->~Union8();
            new (this) Union8{std::move(x)};
        }
        return *this;
    }
    __device__ ~Union8() {
        switch(this->tag){
            case 0: this->case0.~Union8_0(); break; // None
            case 1: this->case1.~Union8_1(); break; // Some
        }
        this->tag = 255;
    }
};
struct Tuple13 {
    int v0;
    unsigned int v1;
    __device__ Tuple13() = default;
    __device__ Tuple13(int t0, unsigned int t1) : v0(t0), v1(t1) {}
};
struct Union9_0 { // None
};
struct Union9_1 { // Some
    int v0;
    __device__ Union9_1(int t0) : v0(t0) {}
    __device__ Union9_1() = delete;
};
struct Union9 {
    union {
        Union9_0 case0; // None
        Union9_1 case1; // Some
    };
    unsigned char tag{255};
    __device__ Union9() {}
    __device__ Union9(Union9_0 t) : tag(0), case0(t) {} // None
    __device__ Union9(Union9_1 t) : tag(1), case1(t) {} // Some
    __device__ Union9(Union9 & x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union9_0(x.case0); break; // None
            case 1: new (&this->case1) Union9_1(x.case1); break; // Some
        }
    }
    __device__ Union9(Union9 && x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union9_0(std::move(x.case0)); break; // None
            case 1: new (&this->case1) Union9_1(std::move(x.case1)); break; // Some
        }
    }
    __device__ Union9 & operator=(Union9 & x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = x.case0; break; // None
                case 1: this->case1 = x.case1; break; // Some
            }
        } else {
            this->~Union9();
            new (this) Union9{x};
        }
        return *this;
    }
    __device__ Union9 & operator=(Union9 && x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = std::move(x.case0); break; // None
                case 1: this->case1 = std::move(x.case1); break; // Some
            }
        } else {
            this->~Union9();
            new (this) Union9{std::move(x)};
        }
        return *this;
    }
    __device__ ~Union9() {
        switch(this->tag){
            case 0: this->case0.~Union9_0(); break; // None
            case 1: this->case1.~Union9_1(); break; // Some
        }
        this->tag = 255;
    }
};
struct Closure0 {
    __device__ unsigned int operator()(unsigned int tup0, unsigned int tup1){
        unsigned int v0 = tup0; unsigned int v1 = tup1;
        unsigned int v2;
        v2 = v0 | v1;
        return v2;
    }
};
struct Tuple14 {
    float v0;
    int v1;
    __device__ Tuple14() = default;
    __device__ Tuple14(float t0, int t1) : v0(t0), v1(t1) {}
};
struct Closure1 {
    __device__ float operator()(float tup0, float tup1){
        float v0 = tup0; float v1 = tup1;
        float v2;
        v2 = v0 + v1;
        return v2;
    }
};
struct Closure2 {
    __device__ int operator()(int tup0, int tup1){
        int v0 = tup0; int v1 = tup1;
        int v2;
        v2 = v0 + v1;
        return v2;
    }
};
struct Tuple15 {
    int v0;
    float v1;
    __device__ Tuple15() = default;
    __device__ Tuple15(int t0, float t1) : v0(t0), v1(t1) {}
};
struct Closure3 {
    __device__ float operator()(float tup0, float tup1){
        float v0 = tup0; float v1 = tup1;
        float v2;
        v2 = v0 + v1;
        return v2;
    }
};
struct Tuple16 {
    float v0;
    bool v1;
    __device__ Tuple16() = default;
    __device__ Tuple16(float t0, bool t1) : v0(t0), v1(t1) {}
};
struct Closure4 {
    __device__ Tuple16 operator()(Tuple16 tup0, Tuple16 tup1){
        float v0 = tup0.v0; bool v1 = tup0.v1; float v2 = tup1.v0; bool v3 = tup1.v1;
        if (v1){
            if (v3){
                bool v4;
                v4 = v0 >= v2;
                float v5;
                if (v4){
                    v5 = v0;
                } else {
                    v5 = v2;
                }
                return Tuple16{v5, true};
            } else {
                return Tuple16{v0, v1};
            }
        } else {
            if (v3){
                return Tuple16{v2, v3};
            } else {
                return Tuple16{v0, v1};
            }
        }
    }
};
struct Closure5 {
    __device__ Tuple14 operator()(Tuple14 tup0, Tuple14 tup1){
        float v0 = tup0.v0; int v1 = tup0.v1; float v2 = tup1.v0; int v3 = tup1.v1;
        bool v4;
        v4 = v1 < v3;
        if (v4){
            return Tuple14{v0, v1};
        } else {
            return Tuple14{v2, v3};
        }
    }
};
struct Tuple17 {
    int v0;
    bool v1;
    __device__ Tuple17() = default;
    __device__ Tuple17(int t0, bool t1) : v0(t0), v1(t1) {}
};
struct Closure6 {
    __device__ Tuple17 operator()(Tuple17 tup0, Tuple17 tup1){
        int v0 = tup0.v0; bool v1 = tup0.v1; int v2 = tup1.v0; bool v3 = tup1.v1;
        if (v1){
            if (v3){
                bool v4;
                v4 = v0 < v2;
                int v5;
                if (v4){
                    v5 = v0;
                } else {
                    v5 = v2;
                }
                return Tuple17{v5, true};
            } else {
                return Tuple17{v0, v1};
            }
        } else {
            if (v3){
                return Tuple17{v2, v3};
            } else {
                return Tuple17{v0, v1};
            }
        }
    }
};
struct Closure7 {
    int v0;
    __device__ Tuple14 operator()(Tuple14 tup0, Tuple14 tup1){
        int & v0 = this->v0;
        float v1 = tup0.v0; int v2 = tup0.v1; float v3 = tup1.v0; int v4 = tup1.v1;
        bool v5;
        v5 = v2 == v0;
        if (v5){
            return Tuple14{v1, v2};
        } else {
            bool v6;
            v6 = v4 == v0;
            if (v6){
                return Tuple14{v3, v4};
            } else {
                return Tuple14{v1, v2};
            }
        }
    }
    __device__ Closure7(int _v0) : v0(_v0) { }
};
struct Union10_0 { // AA_Call
};
struct Union10_1 { // AA_Fold
};
struct Union10_2 { // AA_Raise
    int v0;
    int v1;
    __device__ Union10_2(int t0, int t1) : v0(t0), v1(t1) {}
    __device__ Union10_2() = delete;
};
struct Union10 {
    union {
        Union10_0 case0; // AA_Call
        Union10_1 case1; // AA_Fold
        Union10_2 case2; // AA_Raise
    };
    unsigned char tag{255};
    __device__ Union10() {}
    __device__ Union10(Union10_0 t) : tag(0), case0(t) {} // AA_Call
    __device__ Union10(Union10_1 t) : tag(1), case1(t) {} // AA_Fold
    __device__ Union10(Union10_2 t) : tag(2), case2(t) {} // AA_Raise
    __device__ Union10(Union10 & x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union10_0(x.case0); break; // AA_Call
            case 1: new (&this->case1) Union10_1(x.case1); break; // AA_Fold
            case 2: new (&this->case2) Union10_2(x.case2); break; // AA_Raise
        }
    }
    __device__ Union10(Union10 && x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union10_0(std::move(x.case0)); break; // AA_Call
            case 1: new (&this->case1) Union10_1(std::move(x.case1)); break; // AA_Fold
            case 2: new (&this->case2) Union10_2(std::move(x.case2)); break; // AA_Raise
        }
    }
    __device__ Union10 & operator=(Union10 & x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = x.case0; break; // AA_Call
                case 1: this->case1 = x.case1; break; // AA_Fold
                case 2: this->case2 = x.case2; break; // AA_Raise
            }
        } else {
            this->~Union10();
            new (this) Union10{x};
        }
        return *this;
    }
    __device__ Union10 & operator=(Union10 && x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = std::move(x.case0); break; // AA_Call
                case 1: this->case1 = std::move(x.case1); break; // AA_Fold
                case 2: this->case2 = std::move(x.case2); break; // AA_Raise
            }
        } else {
            this->~Union10();
            new (this) Union10{std::move(x)};
        }
        return *this;
    }
    __device__ ~Union10() {
        switch(this->tag){
            case 0: this->case0.~Union10_0(); break; // AA_Call
            case 1: this->case1.~Union10_1(); break; // AA_Fold
            case 2: this->case2.~Union10_2(); break; // AA_Raise
        }
        this->tag = 255;
    }
};
struct Tuple18 {
    Union1 v0;
    float v1;
    __device__ Tuple18() = default;
    __device__ Tuple18(Union1 t0, float t1) : v0(t0), v1(t1) {}
};
struct Tuple19 {
    int v1;
    bool v0;
    __device__ Tuple19() = default;
    __device__ Tuple19(bool t0, int t1) : v0(t0), v1(t1) {}
};
struct Tuple20 {
    int v0;
    int v1;
    int v2;
    __device__ Tuple20() = default;
    __device__ Tuple20(int t0, int t1, int t2) : v0(t0), v1(t1), v2(t2) {}
};
struct Union11_0 { // Eq
};
struct Union11_1 { // Gt
};
struct Union11_2 { // Lt
};
struct Union11 {
    union {
        Union11_0 case0; // Eq
        Union11_1 case1; // Gt
        Union11_2 case2; // Lt
    };
    unsigned char tag{255};
    __device__ Union11() {}
    __device__ Union11(Union11_0 t) : tag(0), case0(t) {} // Eq
    __device__ Union11(Union11_1 t) : tag(1), case1(t) {} // Gt
    __device__ Union11(Union11_2 t) : tag(2), case2(t) {} // Lt
    __device__ Union11(Union11 & x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union11_0(x.case0); break; // Eq
            case 1: new (&this->case1) Union11_1(x.case1); break; // Gt
            case 2: new (&this->case2) Union11_2(x.case2); break; // Lt
        }
    }
    __device__ Union11(Union11 && x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union11_0(std::move(x.case0)); break; // Eq
            case 1: new (&this->case1) Union11_1(std::move(x.case1)); break; // Gt
            case 2: new (&this->case2) Union11_2(std::move(x.case2)); break; // Lt
        }
    }
    __device__ Union11 & operator=(Union11 & x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = x.case0; break; // Eq
                case 1: this->case1 = x.case1; break; // Gt
                case 2: this->case2 = x.case2; break; // Lt
            }
        } else {
            this->~Union11();
            new (this) Union11{x};
        }
        return *this;
    }
    __device__ Union11 & operator=(Union11 && x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = std::move(x.case0); break; // Eq
                case 1: this->case1 = std::move(x.case1); break; // Gt
                case 2: this->case2 = std::move(x.case2); break; // Lt
            }
        } else {
            this->~Union11();
            new (this) Union11{std::move(x)};
        }
        return *this;
    }
    __device__ ~Union11() {
        switch(this->tag){
            case 0: this->case0.~Union11_0(); break; // Eq
            case 1: this->case1.~Union11_1(); break; // Gt
            case 2: this->case2.~Union11_2(); break; // Lt
        }
        this->tag = 255;
    }
};
struct Tuple21 {
    int v0;
    int v1;
    unsigned char v2;
    __device__ Tuple21() = default;
    __device__ Tuple21(int t0, int t1, unsigned char t2) : v0(t0), v1(t1), v2(t2) {}
};
struct Union12_0 { // None
};
struct Union12_1 { // Some
    static_array<unsigned char,5> v0;
    __device__ Union12_1(static_array<unsigned char,5> t0) : v0(t0) {}
    __device__ Union12_1() = delete;
};
struct Union12 {
    union {
        Union12_0 case0; // None
        Union12_1 case1; // Some
    };
    unsigned char tag{255};
    __device__ Union12() {}
    __device__ Union12(Union12_0 t) : tag(0), case0(t) {} // None
    __device__ Union12(Union12_1 t) : tag(1), case1(t) {} // Some
    __device__ Union12(Union12 & x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union12_0(x.case0); break; // None
            case 1: new (&this->case1) Union12_1(x.case1); break; // Some
        }
    }
    __device__ Union12(Union12 && x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union12_0(std::move(x.case0)); break; // None
            case 1: new (&this->case1) Union12_1(std::move(x.case1)); break; // Some
        }
    }
    __device__ Union12 & operator=(Union12 & x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = x.case0; break; // None
                case 1: this->case1 = x.case1; break; // Some
            }
        } else {
            this->~Union12();
            new (this) Union12{x};
        }
        return *this;
    }
    __device__ Union12 & operator=(Union12 && x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = std::move(x.case0); break; // None
                case 1: this->case1 = std::move(x.case1); break; // Some
            }
        } else {
            this->~Union12();
            new (this) Union12{std::move(x)};
        }
        return *this;
    }
    __device__ ~Union12() {
        switch(this->tag){
            case 0: this->case0.~Union12_0(); break; // None
            case 1: this->case1.~Union12_1(); break; // Some
        }
        this->tag = 255;
    }
};
struct Tuple22 {
    Union11 v1;
    int v0;
    __device__ Tuple22() = default;
    __device__ Tuple22(int t0, Union11 t1) : v0(t0), v1(t1) {}
};
struct Tuple23 {
    int v0;
    int v1;
    int v2;
    unsigned char v3;
    __device__ Tuple23() = default;
    __device__ Tuple23(int t0, int t1, int t2, unsigned char t3) : v0(t0), v1(t1), v2(t2), v3(t3) {}
};
struct Union13_0 { // None
};
struct Union13_1 { // Some
    static_array<unsigned char,4> v0;
    static_array<unsigned char,3> v1;
    __device__ Union13_1(static_array<unsigned char,4> t0, static_array<unsigned char,3> t1) : v0(t0), v1(t1) {}
    __device__ Union13_1() = delete;
};
struct Union13 {
    union {
        Union13_0 case0; // None
        Union13_1 case1; // Some
    };
    unsigned char tag{255};
    __device__ Union13() {}
    __device__ Union13(Union13_0 t) : tag(0), case0(t) {} // None
    __device__ Union13(Union13_1 t) : tag(1), case1(t) {} // Some
    __device__ Union13(Union13 & x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union13_0(x.case0); break; // None
            case 1: new (&this->case1) Union13_1(x.case1); break; // Some
        }
    }
    __device__ Union13(Union13 && x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union13_0(std::move(x.case0)); break; // None
            case 1: new (&this->case1) Union13_1(std::move(x.case1)); break; // Some
        }
    }
    __device__ Union13 & operator=(Union13 & x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = x.case0; break; // None
                case 1: this->case1 = x.case1; break; // Some
            }
        } else {
            this->~Union13();
            new (this) Union13{x};
        }
        return *this;
    }
    __device__ Union13 & operator=(Union13 && x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = std::move(x.case0); break; // None
                case 1: this->case1 = std::move(x.case1); break; // Some
            }
        } else {
            this->~Union13();
            new (this) Union13{std::move(x)};
        }
        return *this;
    }
    __device__ ~Union13() {
        switch(this->tag){
            case 0: this->case0.~Union13_0(); break; // None
            case 1: this->case1.~Union13_1(); break; // Some
        }
        this->tag = 255;
    }
};
struct Union14_0 { // None
};
struct Union14_1 { // Some
    static_array<unsigned char,3> v0;
    static_array<unsigned char,4> v1;
    __device__ Union14_1(static_array<unsigned char,3> t0, static_array<unsigned char,4> t1) : v0(t0), v1(t1) {}
    __device__ Union14_1() = delete;
};
struct Union14 {
    union {
        Union14_0 case0; // None
        Union14_1 case1; // Some
    };
    unsigned char tag{255};
    __device__ Union14() {}
    __device__ Union14(Union14_0 t) : tag(0), case0(t) {} // None
    __device__ Union14(Union14_1 t) : tag(1), case1(t) {} // Some
    __device__ Union14(Union14 & x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union14_0(x.case0); break; // None
            case 1: new (&this->case1) Union14_1(x.case1); break; // Some
        }
    }
    __device__ Union14(Union14 && x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union14_0(std::move(x.case0)); break; // None
            case 1: new (&this->case1) Union14_1(std::move(x.case1)); break; // Some
        }
    }
    __device__ Union14 & operator=(Union14 & x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = x.case0; break; // None
                case 1: this->case1 = x.case1; break; // Some
            }
        } else {
            this->~Union14();
            new (this) Union14{x};
        }
        return *this;
    }
    __device__ Union14 & operator=(Union14 && x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = std::move(x.case0); break; // None
                case 1: this->case1 = std::move(x.case1); break; // Some
            }
        } else {
            this->~Union14();
            new (this) Union14{std::move(x)};
        }
        return *this;
    }
    __device__ ~Union14() {
        switch(this->tag){
            case 0: this->case0.~Union14_0(); break; // None
            case 1: this->case1.~Union14_1(); break; // Some
        }
        this->tag = 255;
    }
};
struct Union15_0 { // None
};
struct Union15_1 { // Some
    static_array<unsigned char,2> v0;
    static_array<unsigned char,2> v1;
    __device__ Union15_1(static_array<unsigned char,2> t0, static_array<unsigned char,2> t1) : v0(t0), v1(t1) {}
    __device__ Union15_1() = delete;
};
struct Union15 {
    union {
        Union15_0 case0; // None
        Union15_1 case1; // Some
    };
    unsigned char tag{255};
    __device__ Union15() {}
    __device__ Union15(Union15_0 t) : tag(0), case0(t) {} // None
    __device__ Union15(Union15_1 t) : tag(1), case1(t) {} // Some
    __device__ Union15(Union15 & x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union15_0(x.case0); break; // None
            case 1: new (&this->case1) Union15_1(x.case1); break; // Some
        }
    }
    __device__ Union15(Union15 && x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union15_0(std::move(x.case0)); break; // None
            case 1: new (&this->case1) Union15_1(std::move(x.case1)); break; // Some
        }
    }
    __device__ Union15 & operator=(Union15 & x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = x.case0; break; // None
                case 1: this->case1 = x.case1; break; // Some
            }
        } else {
            this->~Union15();
            new (this) Union15{x};
        }
        return *this;
    }
    __device__ Union15 & operator=(Union15 && x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = std::move(x.case0); break; // None
                case 1: this->case1 = std::move(x.case1); break; // Some
            }
        } else {
            this->~Union15();
            new (this) Union15{std::move(x)};
        }
        return *this;
    }
    __device__ ~Union15() {
        switch(this->tag){
            case 0: this->case0.~Union15_0(); break; // None
            case 1: this->case1.~Union15_1(); break; // Some
        }
        this->tag = 255;
    }
};
struct Union16_0 { // None
};
struct Union16_1 { // Some
    static_array<unsigned char,2> v0;
    static_array<unsigned char,5> v1;
    __device__ Union16_1(static_array<unsigned char,2> t0, static_array<unsigned char,5> t1) : v0(t0), v1(t1) {}
    __device__ Union16_1() = delete;
};
struct Union16 {
    union {
        Union16_0 case0; // None
        Union16_1 case1; // Some
    };
    unsigned char tag{255};
    __device__ Union16() {}
    __device__ Union16(Union16_0 t) : tag(0), case0(t) {} // None
    __device__ Union16(Union16_1 t) : tag(1), case1(t) {} // Some
    __device__ Union16(Union16 & x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union16_0(x.case0); break; // None
            case 1: new (&this->case1) Union16_1(x.case1); break; // Some
        }
    }
    __device__ Union16(Union16 && x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union16_0(std::move(x.case0)); break; // None
            case 1: new (&this->case1) Union16_1(std::move(x.case1)); break; // Some
        }
    }
    __device__ Union16 & operator=(Union16 & x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = x.case0; break; // None
                case 1: this->case1 = x.case1; break; // Some
            }
        } else {
            this->~Union16();
            new (this) Union16{x};
        }
        return *this;
    }
    __device__ Union16 & operator=(Union16 && x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = std::move(x.case0); break; // None
                case 1: this->case1 = std::move(x.case1); break; // Some
            }
        } else {
            this->~Union16();
            new (this) Union16{std::move(x)};
        }
        return *this;
    }
    __device__ ~Union16() {
        switch(this->tag){
            case 0: this->case0.~Union16_0(); break; // None
            case 1: this->case1.~Union16_1(); break; // Some
        }
        this->tag = 255;
    }
};
struct Union17_0 { // None
};
struct Union17_1 { // Some
    static_array<unsigned char,2> v0;
    static_array<unsigned char,3> v1;
    __device__ Union17_1(static_array<unsigned char,2> t0, static_array<unsigned char,3> t1) : v0(t0), v1(t1) {}
    __device__ Union17_1() = delete;
};
struct Union17 {
    union {
        Union17_0 case0; // None
        Union17_1 case1; // Some
    };
    unsigned char tag{255};
    __device__ Union17() {}
    __device__ Union17(Union17_0 t) : tag(0), case0(t) {} // None
    __device__ Union17(Union17_1 t) : tag(1), case1(t) {} // Some
    __device__ Union17(Union17 & x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union17_0(x.case0); break; // None
            case 1: new (&this->case1) Union17_1(x.case1); break; // Some
        }
    }
    __device__ Union17(Union17 && x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union17_0(std::move(x.case0)); break; // None
            case 1: new (&this->case1) Union17_1(std::move(x.case1)); break; // Some
        }
    }
    __device__ Union17 & operator=(Union17 & x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = x.case0; break; // None
                case 1: this->case1 = x.case1; break; // Some
            }
        } else {
            this->~Union17();
            new (this) Union17{x};
        }
        return *this;
    }
    __device__ Union17 & operator=(Union17 && x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = std::move(x.case0); break; // None
                case 1: this->case1 = std::move(x.case1); break; // Some
            }
        } else {
            this->~Union17();
            new (this) Union17{std::move(x)};
        }
        return *this;
    }
    __device__ ~Union17() {
        switch(this->tag){
            case 0: this->case0.~Union17_0(); break; // None
            case 1: this->case1.~Union17_1(); break; // Some
        }
        this->tag = 255;
    }
};
struct StackMut1 {
    unsigned long long v0;
    cooperative_groups::grid_group v1;
    static_array_list<Union6,128> v2;
    static_array<Union2,2> v3;
    static_array<float,2> v4;
    curandStatePhilox4_32_10_t v5;
    __device__ StackMut1() = default;
    __device__ StackMut1(unsigned long long t0, cooperative_groups::grid_group t1, static_array_list<Union6,128> t2, static_array<Union2,2> t3, static_array<float,2> t4, curandStatePhilox4_32_10_t t5) : v0(t0), v1(t1), v2(t2), v3(t3), v4(t4), v5(t5) {}
};
struct Union18_0 { // T_none
};
struct Union18_1 { // T_round
    static_array<static_array<unsigned char,2>,2> v1;
    static_array<int,2> v2;
    static_array<int,2> v4;
    Union5 v5;
    Union1 v6;
    int v0;
    int v3;
    __device__ Union18_1(int t0, static_array<static_array<unsigned char,2>,2> t1, static_array<int,2> t2, int t3, static_array<int,2> t4, Union5 t5, Union1 t6) : v0(t0), v1(t1), v2(t2), v3(t3), v4(t4), v5(t5), v6(t6) {}
    __device__ Union18_1() = delete;
};
struct Union18_2 { // T_some
    Union4 v0;
    __device__ Union18_2(Union4 t0) : v0(t0) {}
    __device__ Union18_2() = delete;
};
struct Union18 {
    union {
        Union18_0 case0; // T_none
        Union18_1 case1; // T_round
        Union18_2 case2; // T_some
    };
    unsigned char tag{255};
    __device__ Union18() {}
    __device__ Union18(Union18_0 t) : tag(0), case0(t) {} // T_none
    __device__ Union18(Union18_1 t) : tag(1), case1(t) {} // T_round
    __device__ Union18(Union18_2 t) : tag(2), case2(t) {} // T_some
    __device__ Union18(Union18 & x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union18_0(x.case0); break; // T_none
            case 1: new (&this->case1) Union18_1(x.case1); break; // T_round
            case 2: new (&this->case2) Union18_2(x.case2); break; // T_some
        }
    }
    __device__ Union18(Union18 && x) : tag(x.tag) {
        switch(x.tag){
            case 0: new (&this->case0) Union18_0(std::move(x.case0)); break; // T_none
            case 1: new (&this->case1) Union18_1(std::move(x.case1)); break; // T_round
            case 2: new (&this->case2) Union18_2(std::move(x.case2)); break; // T_some
        }
    }
    __device__ Union18 & operator=(Union18 & x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = x.case0; break; // T_none
                case 1: this->case1 = x.case1; break; // T_round
                case 2: this->case2 = x.case2; break; // T_some
            }
        } else {
            this->~Union18();
            new (this) Union18{x};
        }
        return *this;
    }
    __device__ Union18 & operator=(Union18 && x) {
        if (this->tag == x.tag) {
            switch(x.tag){
                case 0: this->case0 = std::move(x.case0); break; // T_none
                case 1: this->case1 = std::move(x.case1); break; // T_round
                case 2: this->case2 = std::move(x.case2); break; // T_some
            }
        } else {
            this->~Union18();
            new (this) Union18{std::move(x)};
        }
        return *this;
    }
    __device__ ~Union18() {
        switch(this->tag){
            case 0: this->case0.~Union18_0(); break; // T_none
            case 1: this->case1.~Union18_1(); break; // T_round
            case 2: this->case2.~Union18_2(); break; // T_some
        }
        this->tag = 255;
    }
};
struct Tuple24 {
    double v1;
    int v0;
    __device__ Tuple24() = default;
    __device__ Tuple24(int t0, double t1) : v0(t0), v1(t1) {}
};
struct Closure8 {
    __device__ bool operator()(bool tup0, bool tup1){
        bool v0 = tup0; bool v1 = tup1;
        bool v2;
        v2 = v0 || v1;
        return v2;
    }
};
__device__ int f_1(unsigned char * v0){
    int * v1;
    v1 = (int *)(v0+0ull);
    int v3;
    v3 = v1[0];
    return v3;
}
__device__ void f_3(unsigned char * v0){
    return ;
}
__device__ Union1 f_2(unsigned char * v0){
    int v1;
    v1 = f_1(v0);
    unsigned char * v2;
    v2 = (unsigned char *)(v0+4ull);
    switch (v1) {
        case 0: {
            f_3(v2);
            return Union1{Union1_0{}};
            break;
        }
        case 1: {
            f_3(v2);
            return Union1{Union1_1{}};
            break;
        }
        case 2: {
            f_3(v2);
            return Union1{Union1_2{}};
            break;
        }
        case 3: {
            int v8;
            v8 = f_1(v2);
            return Union1{Union1_3{v8}};
            break;
        }
        default: {
            printf("%s\n", "Invalid tag.");
            __trap();
        }
    }
}
__device__ inline bool while_method_0(int v0){
    bool v1;
    v1 = v0 < 2;
    return v1;
}
__device__ Union2 f_5(unsigned char * v0){
    int v1;
    v1 = f_1(v0);
    unsigned char * v2;
    v2 = (unsigned char *)(v0+4ull);
    switch (v1) {
        case 0: {
            f_3(v2);
            return Union2{Union2_0{}};
            break;
        }
        case 1: {
            f_3(v2);
            return Union2{Union2_1{}};
            break;
        }
        case 2: {
            f_3(v2);
            return Union2{Union2_2{}};
            break;
        }
        default: {
            printf("%s\n", "Invalid tag.");
            __trap();
        }
    }
}
__device__ static_array<Union2,2> f_4(unsigned char * v0){
    static_array<Union2,2> v1;
    int v3;
    v3 = 0;
    while (while_method_0(v3)){
        unsigned long long v5;
        v5 = (unsigned long long)v3;
        unsigned long long v6;
        v6 = v5 * 4ull;
        unsigned char * v7;
        v7 = (unsigned char *)(v0+v6);
        Union2 v9;
        v9 = f_5(v7);
        v1[v3] = v9;
        v3 += 1 ;
    }
    return v1;
}
__device__ Union0 f_0(unsigned char * v0){
    int v1;
    v1 = f_1(v0);
    unsigned char * v2;
    v2 = (unsigned char *)(v0+8ull);
    switch (v1) {
        case 0: {
            Union1 v5;
            v5 = f_2(v2);
            return Union0{Union0_0{v5}};
            break;
        }
        case 1: {
            static_array<Union2,2> v7;
            v7 = f_4(v2);
            return Union0{Union0_1{v7}};
            break;
        }
        case 2: {
            f_3(v2);
            return Union0{Union0_2{}};
            break;
        }
        case 3: {
            f_3(v2);
            return Union0{Union0_3{}};
            break;
        }
        case 4: {
            f_3(v2);
            return Union0{Union0_4{}};
            break;
        }
        default: {
            printf("%s\n", "Invalid tag.");
            __trap();
        }
    }
}
__device__ unsigned long long f_7(unsigned char * v0){
    unsigned long long * v1;
    v1 = (unsigned long long *)(v0+0ull);
    unsigned long long v3;
    v3 = v1[0];
    return v3;
}
__device__ int f_8(unsigned char * v0){
    int * v1;
    v1 = (int *)(v0+8ull);
    int v3;
    v3 = v1[0];
    return v3;
}
__device__ unsigned char f_13(unsigned char * v0){
    unsigned char * v1;
    v1 = (unsigned char *)(v0+0ull);
    unsigned char v3;
    v3 = v1[0];
    return v3;
}
__device__ unsigned char f_12(unsigned char * v0){
    unsigned char v1;
    v1 = f_13(v0);
    return v1;
}
__device__ static_array<unsigned char,2> f_11(unsigned char * v0){
    static_array<unsigned char,2> v1;
    int v3;
    v3 = 0;
    while (while_method_0(v3)){
        unsigned long long v5;
        v5 = (unsigned long long)v3;
        unsigned char * v6;
        v6 = (unsigned char *)(v0+v5);
        unsigned char v8;
        v8 = f_12(v6);
        v1[v3] = v8;
        v3 += 1 ;
    }
    return v1;
}
__device__ int f_14(unsigned char * v0){
    int * v1;
    v1 = (int *)(v0+28ull);
    int v3;
    v3 = v1[0];
    return v3;
}
__device__ inline bool while_method_1(int v0){
    bool v1;
    v1 = v0 < 3;
    return v1;
}
__device__ static_array<unsigned char,3> f_15(unsigned char * v0){
    static_array<unsigned char,3> v1;
    int v3;
    v3 = 0;
    while (while_method_1(v3)){
        unsigned long long v5;
        v5 = (unsigned long long)v3;
        unsigned char * v6;
        v6 = (unsigned char *)(v0+v5);
        unsigned char v8;
        v8 = f_12(v6);
        v1[v3] = v8;
        v3 += 1 ;
    }
    return v1;
}
__device__ inline bool while_method_2(int v0){
    bool v1;
    v1 = v0 < 5;
    return v1;
}
__device__ static_array<unsigned char,5> f_16(unsigned char * v0){
    static_array<unsigned char,5> v1;
    int v3;
    v3 = 0;
    while (while_method_2(v3)){
        unsigned long long v5;
        v5 = (unsigned long long)v3;
        unsigned char * v6;
        v6 = (unsigned char *)(v0+v5);
        unsigned char v8;
        v8 = f_12(v6);
        v1[v3] = v8;
        v3 += 1 ;
    }
    return v1;
}
__device__ inline bool while_method_3(int v0){
    bool v1;
    v1 = v0 < 4;
    return v1;
}
__device__ static_array<unsigned char,4> f_17(unsigned char * v0){
    static_array<unsigned char,4> v1;
    int v3;
    v3 = 0;
    while (while_method_3(v3)){
        unsigned long long v5;
        v5 = (unsigned long long)v3;
        unsigned char * v6;
        v6 = (unsigned char *)(v0+v5);
        unsigned char v8;
        v8 = f_12(v6);
        v1[v3] = v8;
        v3 += 1 ;
    }
    return v1;
}
__device__ Tuple2 f_10(unsigned char * v0){
    int * v1;
    v1 = (int *)(v0+0ull);
    int v3;
    v3 = v1[0];
    static_array<static_array<unsigned char,2>,2> v4;
    int v6;
    v6 = 0;
    while (while_method_0(v6)){
        unsigned long long v8;
        v8 = (unsigned long long)v6;
        unsigned long long v9;
        v9 = v8 * 2ull;
        unsigned long long v10;
        v10 = 4ull + v9;
        unsigned char * v11;
        v11 = (unsigned char *)(v0+v10);
        static_array<unsigned char,2> v13;
        v13 = f_11(v11);
        v4[v6] = v13;
        v6 += 1 ;
    }
    static_array<int,2> v14;
    int v16;
    v16 = 0;
    while (while_method_0(v16)){
        unsigned long long v18;
        v18 = (unsigned long long)v16;
        unsigned long long v19;
        v19 = v18 * 4ull;
        unsigned long long v20;
        v20 = 8ull + v19;
        unsigned char * v21;
        v21 = (unsigned char *)(v0+v20);
        int v23;
        v23 = f_1(v21);
        v14[v16] = v23;
        v16 += 1 ;
    }
    int * v24;
    v24 = (int *)(v0+16ull);
    int v26;
    v26 = v24[0];
    static_array<int,2> v27;
    int v29;
    v29 = 0;
    while (while_method_0(v29)){
        unsigned long long v31;
        v31 = (unsigned long long)v29;
        unsigned long long v32;
        v32 = v31 * 4ull;
        unsigned long long v33;
        v33 = 20ull + v32;
        unsigned char * v34;
        v34 = (unsigned char *)(v0+v33);
        int v36;
        v36 = f_1(v34);
        v27[v29] = v36;
        v29 += 1 ;
    }
    int v37;
    v37 = f_14(v0);
    unsigned char * v38;
    v38 = (unsigned char *)(v0+32ull);
    Union5 v48;
    switch (v37) {
        case 0: {
            static_array<unsigned char,3> v41;
            v41 = f_15(v38);
            v48 = Union5{Union5_0{v41}};
            break;
        }
        case 1: {
            f_3(v38);
            v48 = Union5{Union5_1{}};
            break;
        }
        case 2: {
            static_array<unsigned char,5> v44;
            v44 = f_16(v38);
            v48 = Union5{Union5_2{v44}};
            break;
        }
        case 3: {
            static_array<unsigned char,4> v46;
            v46 = f_17(v38);
            v48 = Union5{Union5_3{v46}};
            break;
        }
        default: {
            printf("%s\n", "Invalid tag.");
            __trap();
        }
    }
    return Tuple2{v3, v4, v14, v26, v27, v48};
}
__device__ int f_19(unsigned char * v0){
    int * v1;
    v1 = (int *)(v0+40ull);
    int v3;
    v3 = v1[0];
    return v3;
}
__device__ Tuple3 f_18(unsigned char * v0){
    int * v1;
    v1 = (int *)(v0+0ull);
    int v3;
    v3 = v1[0];
    static_array<static_array<unsigned char,2>,2> v4;
    int v6;
    v6 = 0;
    while (while_method_0(v6)){
        unsigned long long v8;
        v8 = (unsigned long long)v6;
        unsigned long long v9;
        v9 = v8 * 2ull;
        unsigned long long v10;
        v10 = 4ull + v9;
        unsigned char * v11;
        v11 = (unsigned char *)(v0+v10);
        static_array<unsigned char,2> v13;
        v13 = f_11(v11);
        v4[v6] = v13;
        v6 += 1 ;
    }
    static_array<int,2> v14;
    int v16;
    v16 = 0;
    while (while_method_0(v16)){
        unsigned long long v18;
        v18 = (unsigned long long)v16;
        unsigned long long v19;
        v19 = v18 * 4ull;
        unsigned long long v20;
        v20 = 8ull + v19;
        unsigned char * v21;
        v21 = (unsigned char *)(v0+v20);
        int v23;
        v23 = f_1(v21);
        v14[v16] = v23;
        v16 += 1 ;
    }
    int * v24;
    v24 = (int *)(v0+16ull);
    int v26;
    v26 = v24[0];
    static_array<int,2> v27;
    int v29;
    v29 = 0;
    while (while_method_0(v29)){
        unsigned long long v31;
        v31 = (unsigned long long)v29;
        unsigned long long v32;
        v32 = v31 * 4ull;
        unsigned long long v33;
        v33 = 20ull + v32;
        unsigned char * v34;
        v34 = (unsigned char *)(v0+v33);
        int v36;
        v36 = f_1(v34);
        v27[v29] = v36;
        v29 += 1 ;
    }
    int v37;
    v37 = f_14(v0);
    unsigned char * v38;
    v38 = (unsigned char *)(v0+32ull);
    Union5 v48;
    switch (v37) {
        case 0: {
            static_array<unsigned char,3> v41;
            v41 = f_15(v38);
            v48 = Union5{Union5_0{v41}};
            break;
        }
        case 1: {
            f_3(v38);
            v48 = Union5{Union5_1{}};
            break;
        }
        case 2: {
            static_array<unsigned char,5> v44;
            v44 = f_16(v38);
            v48 = Union5{Union5_2{v44}};
            break;
        }
        case 3: {
            static_array<unsigned char,4> v46;
            v46 = f_17(v38);
            v48 = Union5{Union5_3{v46}};
            break;
        }
        default: {
            printf("%s\n", "Invalid tag.");
            __trap();
        }
    }
    int v49;
    v49 = f_19(v0);
    unsigned char * v50;
    v50 = (unsigned char *)(v0+44ull);
    Union1 v58;
    switch (v49) {
        case 0: {
            f_3(v50);
            v58 = Union1{Union1_0{}};
            break;
        }
        case 1: {
            f_3(v50);
            v58 = Union1{Union1_1{}};
            break;
        }
        case 2: {
            f_3(v50);
            v58 = Union1{Union1_2{}};
            break;
        }
        case 3: {
            int v56;
            v56 = f_1(v50);
            v58 = Union1{Union1_3{v56}};
            break;
        }
        default: {
            printf("%s\n", "Invalid tag.");
            __trap();
        }
    }
    return Tuple3{v3, v4, v14, v26, v27, v48, v58};
}
__device__ Union4 f_9(unsigned char * v0){
    int v1;
    v1 = f_1(v0);
    unsigned char * v2;
    v2 = (unsigned char *)(v0+16ull);
    switch (v1) {
        case 0: {
            int v5; static_array<static_array<unsigned char,2>,2> v6; static_array<int,2> v7; int v8; static_array<int,2> v9; Union5 v10;
            Tuple2 tmp0 = f_10(v2);
            v5 = tmp0.v0; v6 = tmp0.v1; v7 = tmp0.v2; v8 = tmp0.v3; v9 = tmp0.v4; v10 = tmp0.v5;
            return Union4{Union4_0{v5, v6, v7, v8, v9, v10}};
            break;
        }
        case 1: {
            int v12; static_array<static_array<unsigned char,2>,2> v13; static_array<int,2> v14; int v15; static_array<int,2> v16; Union5 v17;
            Tuple2 tmp1 = f_10(v2);
            v12 = tmp1.v0; v13 = tmp1.v1; v14 = tmp1.v2; v15 = tmp1.v3; v16 = tmp1.v4; v17 = tmp1.v5;
            return Union4{Union4_1{v12, v13, v14, v15, v16, v17}};
            break;
        }
        case 2: {
            f_3(v2);
            return Union4{Union4_2{}};
            break;
        }
        case 3: {
            int v20; static_array<static_array<unsigned char,2>,2> v21; static_array<int,2> v22; int v23; static_array<int,2> v24; Union5 v25;
            Tuple2 tmp2 = f_10(v2);
            v20 = tmp2.v0; v21 = tmp2.v1; v22 = tmp2.v2; v23 = tmp2.v3; v24 = tmp2.v4; v25 = tmp2.v5;
            return Union4{Union4_3{v20, v21, v22, v23, v24, v25}};
            break;
        }
        case 4: {
            int v27; static_array<static_array<unsigned char,2>,2> v28; static_array<int,2> v29; int v30; static_array<int,2> v31; Union5 v32;
            Tuple2 tmp3 = f_10(v2);
            v27 = tmp3.v0; v28 = tmp3.v1; v29 = tmp3.v2; v30 = tmp3.v3; v31 = tmp3.v4; v32 = tmp3.v5;
            return Union4{Union4_4{v27, v28, v29, v30, v31, v32}};
            break;
        }
        case 5: {
            int v34; static_array<static_array<unsigned char,2>,2> v35; static_array<int,2> v36; int v37; static_array<int,2> v38; Union5 v39; Union1 v40;
            Tuple3 tmp4 = f_18(v2);
            v34 = tmp4.v0; v35 = tmp4.v1; v36 = tmp4.v2; v37 = tmp4.v3; v38 = tmp4.v4; v39 = tmp4.v5; v40 = tmp4.v6;
            return Union4{Union4_5{v34, v35, v36, v37, v38, v39, v40}};
            break;
        }
        case 6: {
            int v42; static_array<static_array<unsigned char,2>,2> v43; static_array<int,2> v44; int v45; static_array<int,2> v46; Union5 v47;
            Tuple2 tmp5 = f_10(v2);
            v42 = tmp5.v0; v43 = tmp5.v1; v44 = tmp5.v2; v45 = tmp5.v3; v46 = tmp5.v4; v47 = tmp5.v5;
            return Union4{Union4_6{v42, v43, v44, v45, v46, v47}};
            break;
        }
        case 7: {
            int v49; static_array<static_array<unsigned char,2>,2> v50; static_array<int,2> v51; int v52; static_array<int,2> v53; Union5 v54;
            Tuple2 tmp6 = f_10(v2);
            v49 = tmp6.v0; v50 = tmp6.v1; v51 = tmp6.v2; v52 = tmp6.v3; v53 = tmp6.v4; v54 = tmp6.v5;
            return Union4{Union4_7{v49, v50, v51, v52, v53, v54}};
            break;
        }
        default: {
            printf("%s\n", "Invalid tag.");
            __trap();
        }
    }
}
__device__ int f_20(unsigned char * v0){
    int * v1;
    v1 = (int *)(v0+80ull);
    int v3;
    v3 = v1[0];
    return v3;
}
__device__ inline bool while_method_4(int v0, int v1){
    bool v2;
    v2 = v1 < v0;
    return v2;
}
__device__ static_array_list<unsigned char,5> f_22(unsigned char * v0){
    static_array_list<unsigned char,5> v1;
    v1 = static_array_list<unsigned char,5>{};
    int v3;
    v3 = f_1(v0);
    v1.unsafe_set_length(v3);
    int v4;
    v4 = v1.length;
    int v5;
    v5 = 0;
    while (while_method_4(v4, v5)){
        unsigned long long v7;
        v7 = (unsigned long long)v5;
        unsigned long long v8;
        v8 = 4ull + v7;
        unsigned char * v9;
        v9 = (unsigned char *)(v0+v8);
        unsigned char v11;
        v11 = f_12(v9);
        v1[v5] = v11;
        v5 += 1 ;
    }
    return v1;
}
__device__ Tuple4 f_23(unsigned char * v0){
    int * v1;
    v1 = (int *)(v0+0ull);
    int v3;
    v3 = v1[0];
    int * v4;
    v4 = (int *)(v0+4ull);
    int v6;
    v6 = v4[0];
    return Tuple4{v3, v6};
}
__device__ int f_25(unsigned char * v0){
    int * v1;
    v1 = (int *)(v0+4ull);
    int v3;
    v3 = v1[0];
    return v3;
}
__device__ Tuple5 f_24(unsigned char * v0){
    int * v1;
    v1 = (int *)(v0+0ull);
    int v3;
    v3 = v1[0];
    int v4;
    v4 = f_25(v0);
    unsigned char * v5;
    v5 = (unsigned char *)(v0+8ull);
    Union1 v13;
    switch (v4) {
        case 0: {
            f_3(v5);
            v13 = Union1{Union1_0{}};
            break;
        }
        case 1: {
            f_3(v5);
            v13 = Union1{Union1_1{}};
            break;
        }
        case 2: {
            f_3(v5);
            v13 = Union1{Union1_2{}};
            break;
        }
        case 3: {
            int v11;
            v11 = f_1(v5);
            v13 = Union1{Union1_3{v11}};
            break;
        }
        default: {
            printf("%s\n", "Invalid tag.");
            __trap();
        }
    }
    return Tuple5{v3, v13};
}
__device__ Tuple6 f_26(unsigned char * v0){
    int * v1;
    v1 = (int *)(v0+0ull);
    int v3;
    v3 = v1[0];
    static_array<unsigned char,2> v4;
    int v6;
    v6 = 0;
    while (while_method_0(v6)){
        unsigned long long v8;
        v8 = (unsigned long long)v6;
        unsigned long long v9;
        v9 = 4ull + v8;
        unsigned char * v10;
        v10 = (unsigned char *)(v0+v9);
        unsigned char v12;
        v12 = f_12(v10);
        v4[v6] = v12;
        v6 += 1 ;
    }
    return Tuple6{v3, v4};
}
__device__ Tuple0 f_29(unsigned char * v0){
    static_array<unsigned char,5> v1;
    int v3;
    v3 = 0;
    while (while_method_2(v3)){
        unsigned long long v5;
        v5 = (unsigned long long)v3;
        unsigned char * v6;
        v6 = (unsigned char *)(v0+v5);
        unsigned char v8;
        v8 = f_12(v6);
        v1[v3] = v8;
        v3 += 1 ;
    }
    char * v9;
    v9 = (char *)(v0+5ull);
    char v11;
    v11 = v9[0];
    return Tuple0{v1, v11};
}
__device__ Tuple0 f_28(unsigned char * v0){
    static_array<unsigned char,5> v1; char v2;
    Tuple0 tmp10 = f_29(v0);
    v1 = tmp10.v0; v2 = tmp10.v1;
    return Tuple0{v1, v2};
}
__device__ Tuple7 f_27(unsigned char * v0){
    int * v1;
    v1 = (int *)(v0+0ull);
    int v3;
    v3 = v1[0];
    static_array<Tuple0,2> v4;
    int v6;
    v6 = 0;
    while (while_method_0(v6)){
        unsigned long long v8;
        v8 = (unsigned long long)v6;
        unsigned long long v9;
        v9 = v8 * 8ull;
        unsigned long long v10;
        v10 = 8ull + v9;
        unsigned char * v11;
        v11 = (unsigned char *)(v0+v10);
        static_array<unsigned char,5> v13; char v14;
        Tuple0 tmp11 = f_28(v11);
        v13 = tmp11.v0; v14 = tmp11.v1;
        v4[v6] = Tuple0{v13, v14};
        v6 += 1 ;
    }
    int * v15;
    v15 = (int *)(v0+24ull);
    int v17;
    v17 = v15[0];
    return Tuple7{v3, v4, v17};
}
__device__ Union6 f_21(unsigned char * v0){
    int v1;
    v1 = f_1(v0);
    unsigned char * v2;
    v2 = (unsigned char *)(v0+16ull);
    switch (v1) {
        case 0: {
            static_array_list<unsigned char,5> v5;
            v5 = f_22(v2);
            return Union6{Union6_0{v5}};
            break;
        }
        case 1: {
            int v7; int v8;
            Tuple4 tmp7 = f_23(v2);
            v7 = tmp7.v0; v8 = tmp7.v1;
            return Union6{Union6_1{v7, v8}};
            break;
        }
        case 2: {
            int v10; Union1 v11;
            Tuple5 tmp8 = f_24(v2);
            v10 = tmp8.v0; v11 = tmp8.v1;
            return Union6{Union6_2{v10, v11}};
            break;
        }
        case 3: {
            int v13; static_array<unsigned char,2> v14;
            Tuple6 tmp9 = f_26(v2);
            v13 = tmp9.v0; v14 = tmp9.v1;
            return Union6{Union6_3{v13, v14}};
            break;
        }
        case 4: {
            int v16; static_array<Tuple0,2> v17; int v18;
            Tuple7 tmp12 = f_27(v2);
            v16 = tmp12.v0; v17 = tmp12.v1; v18 = tmp12.v2;
            return Union6{Union6_4{v16, v17, v18}};
            break;
        }
        default: {
            printf("%s\n", "Invalid tag.");
            __trap();
        }
    }
}
__device__ int f_30(unsigned char * v0){
    int * v1;
    v1 = (int *)(v0+6248ull);
    int v3;
    v3 = v1[0];
    return v3;
}
__device__ Tuple1 f_6(unsigned char * v0){
    unsigned long long v1;
    v1 = f_7(v0);
    int v2;
    v2 = f_8(v0);
    unsigned char * v3;
    v3 = (unsigned char *)(v0+16ull);
    Union3 v9;
    switch (v2) {
        case 0: {
            f_3(v3);
            v9 = Union3{Union3_0{}};
            break;
        }
        case 1: {
            Union4 v7;
            v7 = f_9(v3);
            v9 = Union3{Union3_1{v7}};
            break;
        }
        default: {
            printf("%s\n", "Invalid tag.");
            __trap();
        }
    }
    static_array_list<Union6,128> v10;
    v10 = static_array_list<Union6,128>{};
    int v12;
    v12 = f_20(v0);
    v10.unsafe_set_length(v12);
    int v13;
    v13 = v10.length;
    int v14;
    v14 = 0;
    while (while_method_4(v13, v14)){
        unsigned long long v16;
        v16 = (unsigned long long)v14;
        unsigned long long v17;
        v17 = v16 * 48ull;
        unsigned long long v18;
        v18 = 96ull + v17;
        unsigned char * v19;
        v19 = (unsigned char *)(v0+v18);
        Union6 v21;
        v21 = f_21(v19);
        v10[v14] = v21;
        v14 += 1 ;
    }
    static_array<Union2,2> v22;
    int v24;
    v24 = 0;
    while (while_method_0(v24)){
        unsigned long long v26;
        v26 = (unsigned long long)v24;
        unsigned long long v27;
        v27 = v26 * 4ull;
        unsigned long long v28;
        v28 = 6240ull + v27;
        unsigned char * v29;
        v29 = (unsigned char *)(v0+v28);
        Union2 v31;
        v31 = f_5(v29);
        v22[v24] = v31;
        v24 += 1 ;
    }
    int v32;
    v32 = f_30(v0);
    unsigned char * v33;
    v33 = (unsigned char *)(v0+6256ull);
    Union7 v51;
    switch (v32) {
        case 0: {
            f_3(v33);
            v51 = Union7{Union7_0{}};
            break;
        }
        case 1: {
            int v37; static_array<static_array<unsigned char,2>,2> v38; static_array<int,2> v39; int v40; static_array<int,2> v41; Union5 v42;
            Tuple2 tmp13 = f_10(v33);
            v37 = tmp13.v0; v38 = tmp13.v1; v39 = tmp13.v2; v40 = tmp13.v3; v41 = tmp13.v4; v42 = tmp13.v5;
            v51 = Union7{Union7_1{v37, v38, v39, v40, v41, v42}};
            break;
        }
        case 2: {
            int v44; static_array<static_array<unsigned char,2>,2> v45; static_array<int,2> v46; int v47; static_array<int,2> v48; Union5 v49;
            Tuple2 tmp14 = f_10(v33);
            v44 = tmp14.v0; v45 = tmp14.v1; v46 = tmp14.v2; v47 = tmp14.v3; v48 = tmp14.v4; v49 = tmp14.v5;
            v51 = Union7{Union7_2{v44, v45, v46, v47, v48, v49}};
            break;
        }
        default: {
            printf("%s\n", "Invalid tag.");
            __trap();
        }
    }
    return Tuple1{v1, v9, v10, v22, v51};
}
__device__ inline bool while_method_5(Union3 v0){
    switch (v0.tag) {
        case 0: { // None
            return false;
            break;
        }
        case 1: { // Some
            Union4 v1 = v0.case1.v0;
            return true;
            break;
        }
        default: {
            assert("Invalid tag." && false); __trap();
        }
    }
}
__device__ unsigned int loop_34(unsigned int v0, curandStatePhilox4_32_10_t & v1){
    unsigned int v2;
    v2 = curand(&v1);
    unsigned int v3;
    v3 = v2 % v0;
    unsigned int v4;
    v4 = v2 - v3;
    unsigned int v5;
    v5 = 0u - v0;
    bool v6;
    v6 = v4 <= v5;
    if (v6){
        return v3;
    } else {
        return loop_34(v0, v1);
    }
}
__device__ Tuple10 draw_card_33(curandStatePhilox4_32_10_t & v0, unsigned long long v1){
    int v2;
    v2 = __popcll(v1);
    unsigned int v3;
    v3 = (unsigned int)v2;
    unsigned int v4;
    v4 = loop_34(v3, v0);
    int v5;
    v5 = (int)v4;
    unsigned int v6;
    v6 = (unsigned int)v1;
    unsigned long long v7;
    v7 = v1 >> 32;
    unsigned int v8;
    v8 = (unsigned int)v7;
    int v9;
    v9 = __popc(v6);
    bool v10;
    v10 = v5 < v9;
    unsigned int v22;
    if (v10){
        int v11;
        v11 = v5 + 1;
        unsigned int v12;
        v12 = __fns(v6,0u,v11);
        v22 = v12;
    } else {
        int v13;
        v13 = v5 - v9;
        int v14;
        v14 = __popc(v8);
        bool v15;
        v15 = v13 < v14;
        if (v15){
            int v16;
            v16 = v13 + 1;
            unsigned int v17;
            v17 = __fns(v8,0u,v16);
            unsigned int v18;
            v18 = v17 + 32u;
            v22 = v18;
        } else {
            int v19;
            v19 = v13 - v14;
            printf("%s\n", "Cannot find the n-th set bit.");
            __trap();
        }
    }
    unsigned char v23;
    v23 = (unsigned char)v22;
    int v24;
    v24 = (int)v22;
    unsigned long long v25;
    v25 = 1ull << v24;
    unsigned long long v26;
    v26 = v1 ^ v25;
    return Tuple10{v23, v26};
}
__device__ Tuple8 draw_cards_32(curandStatePhilox4_32_10_t & v0, unsigned long long v1){
    static_array<unsigned char,3> v2;
    int v4; unsigned long long v5;
    Tuple9 tmp16 = Tuple9{0, v1};
    v4 = tmp16.v0; v5 = tmp16.v1;
    while (while_method_1(v4)){
        unsigned char v7; unsigned long long v8;
        Tuple10 tmp17 = draw_card_33(v0, v5);
        v7 = tmp17.v0; v8 = tmp17.v1;
        v2[v4] = v7;
        v5 = v8;
        v4 += 1 ;
    }
    return Tuple8{v2, v5};
}
__device__ static_array_list<unsigned char,5> get_community_cards_35(Union5 v0, static_array<unsigned char,3> v1){
    static_array_list<unsigned char,5> v2;
    v2 = static_array_list<unsigned char,5>{};
    switch (v0.tag) {
        case 0: { // Flop
            static_array<unsigned char,3> v4 = v0.case0.v0;
            int v5;
            v5 = 0;
            while (while_method_1(v5)){
                unsigned char v7;
                v7 = v4[v5];
                v2.push(v7);
                v5 += 1 ;
            }
            break;
        }
        case 1: { // Preflop
            break;
        }
        case 2: { // River
            static_array<unsigned char,5> v14 = v0.case2.v0;
            int v15;
            v15 = 0;
            while (while_method_2(v15)){
                unsigned char v17;
                v17 = v14[v15];
                v2.push(v17);
                v15 += 1 ;
            }
            break;
        }
        case 3: { // Turn
            static_array<unsigned char,4> v9 = v0.case3.v0;
            int v10;
            v10 = 0;
            while (while_method_3(v10)){
                unsigned char v12;
                v12 = v9[v10];
                v2.push(v12);
                v10 += 1 ;
            }
            break;
        }
        default: {
            assert("Invalid tag." && false); __trap();
        }
    }
    int v19;
    v19 = 0;
    while (while_method_1(v19)){
        unsigned char v21;
        v21 = v1[v19];
        v2.push(v21);
        v19 += 1 ;
    }
    return v2;
}
__device__ bool player_can_act_37(int v0, static_array<static_array<unsigned char,2>,2> v1, static_array<int,2> v2, int v3, static_array<int,2> v4, Union5 v5){
    int v6;
    v6 = v3 % 2;
    int v7;
    v7 = v4[v6];
    bool v9;
    v9 = v7 > 0;
    int v10;
    v10 = v2[v6];
    int v12;
    v12 = v2[0];
    int v14; int v15;
    Tuple4 tmp19 = Tuple4{1, v12};
    v14 = tmp19.v0; v15 = tmp19.v1;
    while (while_method_0(v14)){
        int v17;
        v17 = v2[v14];
        bool v19;
        v19 = v15 >= v17;
        int v20;
        if (v19){
            v20 = v15;
        } else {
            v20 = v17;
        }
        v15 = v20;
        v14 += 1 ;
    }
    bool v21;
    v21 = v10 < v15;
    int v22; int v23;
    Tuple4 tmp20 = Tuple4{0, 0};
    v22 = tmp20.v0; v23 = tmp20.v1;
    while (while_method_0(v22)){
        int v25;
        v25 = v4[v22];
        bool v27;
        v27 = 0 < v25;
        int v28;
        if (v27){
            v28 = 1;
        } else {
            v28 = 0;
        }
        int v29;
        v29 = v23 + v28;
        v23 = v29;
        v22 += 1 ;
    }
    if (v9){
        if (v21){
            return true;
        } else {
            bool v30;
            v30 = v3 < 2;
            if (v30){
                bool v31;
                v31 = 0 < v23;
                return v31;
            } else {
                return false;
            }
        }
    } else {
        return false;
    }
}
__device__ Union4 go_next_street_38(int v0, static_array<static_array<unsigned char,2>,2> v1, static_array<int,2> v2, int v3, static_array<int,2> v4, Union5 v5){
    switch (v5.tag) {
        case 0: { // Flop
            static_array<unsigned char,3> v7 = v5.case0.v0;
            return Union4{Union4_7{v0, v1, v2, v3, v4, v5}};
            break;
        }
        case 1: { // Preflop
            return Union4{Union4_0{v0, v1, v2, v3, v4, v5}};
            break;
        }
        case 2: { // River
            static_array<unsigned char,5> v11 = v5.case2.v0;
            return Union4{Union4_6{v0, v1, v2, v3, v4, v5}};
            break;
        }
        case 3: { // Turn
            static_array<unsigned char,4> v9 = v5.case3.v0;
            return Union4{Union4_3{v0, v1, v2, v3, v4, v5}};
            break;
        }
        default: {
            assert("Invalid tag." && false); __trap();
        }
    }
}
__device__ Union4 try_round_36(int v0, static_array<static_array<unsigned char,2>,2> v1, static_array<int,2> v2, int v3, static_array<int,2> v4, Union5 v5){
    int v6;
    v6 = v3 + 1;
    bool v7;
    v7 = player_can_act_37(v0, v1, v2, v3, v4, v5);
    if (v7){
        return Union4{Union4_4{v0, v1, v2, v3, v4, v5}};
    } else {
        bool v9;
        v9 = player_can_act_37(v0, v1, v2, v6, v4, v5);
        if (v9){
            return Union4{Union4_4{v0, v1, v2, v6, v4, v5}};
        } else {
            return go_next_street_38(v0, v1, v2, v3, v4, v5);
        }
    }
}
__device__ Tuple11 draw_cards_39(curandStatePhilox4_32_10_t & v0, unsigned long long v1){
    static_array<unsigned char,2> v2;
    int v4; unsigned long long v5;
    Tuple9 tmp21 = Tuple9{0, v1};
    v4 = tmp21.v0; v5 = tmp21.v1;
    while (while_method_0(v4)){
        unsigned char v7; unsigned long long v8;
        Tuple10 tmp22 = draw_card_33(v0, v5);
        v7 = tmp22.v0; v8 = tmp22.v1;
        v2[v4] = v7;
        v5 = v8;
        v4 += 1 ;
    }
    return Tuple11{v2, v5};
}
__device__ inline bool while_method_6(int v0){
    bool v1;
    v1 = v0 < 1;
    return v1;
}
__device__ Tuple12 draw_cards_40(curandStatePhilox4_32_10_t & v0, unsigned long long v1){
    static_array<unsigned char,1> v2;
    int v4; unsigned long long v5;
    Tuple9 tmp25 = Tuple9{0, v1};
    v4 = tmp25.v0; v5 = tmp25.v1;
    while (while_method_6(v4)){
        unsigned char v7; unsigned long long v8;
        Tuple10 tmp26 = draw_card_33(v0, v5);
        v7 = tmp26.v0; v8 = tmp26.v1;
        v2[v4] = v7;
        v5 = v8;
        v4 += 1 ;
    }
    return Tuple12{v2, v5};
}
__device__ static_array_list<unsigned char,5> get_community_cards_41(Union5 v0, static_array<unsigned char,1> v1){
    static_array_list<unsigned char,5> v2;
    v2 = static_array_list<unsigned char,5>{};
    switch (v0.tag) {
        case 0: { // Flop
            static_array<unsigned char,3> v4 = v0.case0.v0;
            int v5;
            v5 = 0;
            while (while_method_1(v5)){
                unsigned char v7;
                v7 = v4[v5];
                v2.push(v7);
                v5 += 1 ;
            }
            break;
        }
        case 1: { // Preflop
            break;
        }
        case 2: { // River
            static_array<unsigned char,5> v14 = v0.case2.v0;
            int v15;
            v15 = 0;
            while (while_method_2(v15)){
                unsigned char v17;
                v17 = v14[v15];
                v2.push(v17);
                v15 += 1 ;
            }
            break;
        }
        case 3: { // Turn
            static_array<unsigned char,4> v9 = v0.case3.v0;
            int v10;
            v10 = 0;
            while (while_method_3(v10)){
                unsigned char v12;
                v12 = v9[v10];
                v2.push(v12);
                v10 += 1 ;
            }
            break;
        }
        default: {
            assert("Invalid tag." && false); __trap();
        }
    }
    int v19;
    v19 = 0;
    while (while_method_6(v19)){
        unsigned char v21;
        v21 = v1[v19];
        v2.push(v21);
        v19 += 1 ;
    }
    return v2;
}
__device__ inline bool while_method_7(int v0){
    bool v1;
    v1 = v0 < 524288;
    return v1;
}
__device__ inline bool while_method_8(int v0){
    bool v1;
    v1 = v0 < 10;
    return v1;
}
__device__ void method_42(unsigned int v0, float * v1, int v2){
    unsigned int v3;
    v3 = v0 + 1u;
    bool v4;
    v4 = v3 == 0u;
    bool v5;
    v5 = v4 != true;
    bool v6;
    v6 = v5 == false;
    if (v6){
        assert("Pickle failure. The input is too large in the binary serializer." && v5);
    } else {
    }
    int v8; unsigned int v9;
    Tuple13 tmp28 = Tuple13{0, v3};
    v8 = tmp28.v0; v9 = tmp28.v1;
    while (while_method_8(v8)){
        unsigned int v11;
        v11 = v9 & 1u;
        int v12;
        v12 = v2 + v8;
        float v13;
        v13 = (float)v11;
        v1[v12] = v13;
        unsigned int v14;
        v14 = v9 >> 1;
        v9 = v14;
        v8 += 1 ;
    }
    bool v15;
    v15 = v9 == 0u;
    bool v16;
    v16 = v15 == false;
    if (v16){
        assert("Picke failure. The remains of the input has to equal zero in the binary pickler." && v15);
        return ;
    } else {
        return ;
    }
}
__device__ inline bool while_method_9(int v0){
    bool v1;
    v1 = v0 < 11;
    return v1;
}
__device__ void method_43(unsigned int v0, float * v1, int v2){
    unsigned int v3;
    v3 = v0 + 1u;
    bool v4;
    v4 = v3 == 0u;
    bool v5;
    v5 = v4 != true;
    bool v6;
    v6 = v5 == false;
    if (v6){
        assert("Pickle failure. The input is too large in the binary serializer." && v5);
    } else {
    }
    int v8; unsigned int v9;
    Tuple13 tmp29 = Tuple13{0, v3};
    v8 = tmp29.v0; v9 = tmp29.v1;
    while (while_method_9(v8)){
        unsigned int v11;
        v11 = v9 & 1u;
        int v12;
        v12 = v2 + v8;
        float v13;
        v13 = (float)v11;
        v1[v12] = v13;
        unsigned int v14;
        v14 = v9 >> 1;
        v9 = v14;
        v8 += 1 ;
    }
    bool v15;
    v15 = v9 == 0u;
    bool v16;
    v16 = v15 == false;
    if (v16){
        assert("Picke failure. The remains of the input has to equal zero in the binary pickler." && v15);
        return ;
    } else {
        return ;
    }
}
__device__ int int_range_44(int v0, int v1, curandStatePhilox4_32_10_t & v2){
    int v3;
    v3 = v0 - v1;
    unsigned int v4;
    v4 = (unsigned int)v3;
    unsigned int v5;
    v5 = loop_34(v4, v2);
    unsigned int v6;
    v6 = (unsigned int)v1;
    unsigned int v7;
    v7 = v5 + v6;
    int v8;
    v8 = (int)v7;
    return v8;
}
__device__ inline bool while_method_10(int v0){
    bool v1;
    v1 = v0 < 8;
    return v1;
}
__device__ inline bool while_method_11(int v0){
    bool v1;
    v1 = v0 < 32;
    return v1;
}
__device__ inline bool while_method_12(int v0){
    bool v1;
    v1 = v0 < 16;
    return v1;
}
__device__ inline bool while_method_13(int v0){
    bool v1;
    v1 = v0 < 32;
    return v1;
}
__device__ void method_45(unsigned int * v0, int v1, float * v2){
    int v3;
    v3 = blockIdx.x;
    assert("Tensor range check" && 0 <= v3 && v3 < 24);
    int v4;
    v4 = 32768 * v3;
    int v5;
    v5 = blockIdx.x;
    assert("Tensor range check" && 0 <= v5 && v5 < 24);
    int v6;
    v6 = 256 * v5;
    int v7;
    v7 = v6 + v1;
    int v8;
    v8 = threadIdx.x;
    bool v9;
    v9 = 0 <= v8;
    bool v10;
    v10 = v9 == false;
    if (v10){
        assert("The index needs to be zero or positive." && v9);
    } else {
    }
    int v12;
    v12 = v8 % 32;
    int v13;
    v13 = v8 / 32;
    bool v14;
    v14 = v13 < 8;
    bool v15;
    v15 = v14 == false;
    if (v15){
        assert("The last element of the projection dimensions needs to be greater than the index remainder." && v14);
    } else {
    }
    assert("Tensor range check" && 0 <= v13 && v13 < 8);
    assert("Tensor range check" && 0 <= v12 && v12 < 32);
    int v17;
    v17 = 4 * v12;
    int v18;
    v18 = v17 + v4;
    int v19;
    v19 = 128 * v13;
    int v20;
    v20 = v19 + v18;
    assert("Tensor range check" && 0 <= v13 && v13 < 8);
    int v21;
    v21 = v13 + v7;
    int v22;
    v22 = 0;
    while (while_method_13(v22)){
        assert("Tensor range check" && 0 <= v22 && v22 < 32);
        int v24;
        v24 = 1024 * v22;
        int v25;
        v25 = v24 + v20;
        float v26[4];
        int v27[4];
        int v28;
        v28 = 0;
        while (while_method_6(v28)){
            assert("Tensor range check" && 0 <= v28 && v28 < 1);
            int v30;
            v30 = 4 * v28;
            assert("Tensor range check" && 0 <= v28 && v28 < 1);
            int v31;
            v31 = 128 * v28;
            int v32;
            v32 = v31 + v25;
            int4* v33;
            v33 = reinterpret_cast<int4*>(v2 + v32);
            int4* v34;
            v34 = reinterpret_cast<int4*>(v26 + v30);
            assert("Pointer alignment check" && (unsigned long long)(v33) % 4 == 0 && (unsigned long long)(v34) % 4 == 0);
            *v34 = *v33;
            v28 += 1 ;
        }
        int v35;
        v35 = 0;
        while (while_method_6(v35)){
            int v37;
            v37 = 0;
            while (while_method_3(v37)){
                bool v39;
                v39 = 0 <= v37;
                bool v41;
                if (v39){
                    bool v40;
                    v40 = v37 < 4;
                    v41 = v40;
                } else {
                    v41 = false;
                }
                bool v42;
                v42 = v41 == false;
                if (v42){
                    assert("The indices should be inside the range of the dimension." && v41);
                } else {
                }
                bool v44;
                v44 = 0 <= v12;
                bool v46;
                if (v44){
                    bool v45;
                    v45 = v12 < 32;
                    v46 = v45;
                } else {
                    v46 = false;
                }
                bool v47;
                v47 = v46 == false;
                if (v47){
                    assert("The indices should be inside the range of the dimension." && v46);
                } else {
                }
                int v49;
                v49 = v12 * 4;
                int v50;
                v50 = v37 + v49;
                bool v51;
                v51 = 0 <= v35;
                bool v53;
                if (v51){
                    bool v52;
                    v52 = v35 < 1;
                    v53 = v52;
                } else {
                    v53 = false;
                }
                bool v54;
                v54 = v53 == false;
                if (v54){
                    assert("The indices should be inside the range of the dimension." && v53);
                } else {
                }
                int v56;
                v56 = v35 * 128;
                int v57;
                v57 = v50 + v56;
                assert("Tensor range check" && 0 <= v35 && v35 < 1);
                assert("Tensor range check" && 0 <= v37 && v37 < 4);
                int v58;
                v58 = 4 * v35;
                int v59;
                v59 = v58 + v37;
                v27[v59] = v57;
                v37 += 1 ;
            }
            v35 += 1 ;
        }
        bool v60;
        v60 = 0 <= v13;
        bool v61;
        v61 = v60 && v14;
        bool v62;
        v62 = v61 == false;
        if (v62){
            assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v61);
        } else {
        }
        bool v64;
        v64 = 0 <= v22;
        bool v66;
        if (v64){
            bool v65;
            v65 = v22 < 32;
            v66 = v65;
        } else {
            v66 = false;
        }
        bool v67;
        v67 = v66 == false;
        if (v67){
            assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v66);
        } else {
        }
        int v69;
        v69 = v22 * 8;
        int v70;
        v70 = v69 + v13;
        unsigned int v71[4];
        int v72;
        v72 = 0;
        while (while_method_6(v72)){
            int v74;
            v74 = 0;
            while (while_method_3(v74)){
                assert("Tensor range check" && 0 <= v72 && v72 < 1);
                assert("Tensor range check" && 0 <= v74 && v74 < 4);
                int v76;
                v76 = 4 * v72;
                int v77;
                v77 = v76 + v74;
                float v78;
                v78 = v26[v77];
                int v79;
                v79 = v27[v77];
                bool v80;
                v80 = v78 <= 0.0f;
                unsigned int v82;
                if (v80){
                    v82 = 0u;
                } else {
                    unsigned int v81;
                    v81 = 1u << v79;
                    v82 = v81;
                }
                assert("Tensor range check" && 0 <= v72 && v72 < 1);
                assert("Tensor range check" && 0 <= v74 && v74 < 4);
                v71[v77] = v82;
                v74 += 1 ;
            }
            v72 += 1 ;
        }
        unsigned int v83;
        v83 = 0u;
        int v84;
        v84 = 0;
        while (while_method_6(v84)){
            int v86;
            v86 = 0;
            while (while_method_3(v86)){
                assert("Tensor range check" && 0 <= v84 && v84 < 1);
                assert("Tensor range check" && 0 <= v86 && v86 < 4);
                int v88;
                v88 = 4 * v84;
                int v89;
                v89 = v88 + v86;
                unsigned int v90;
                v90 = v71[v89];
                unsigned int v91;
                v91 = v83 | v90;
                v83 = v91;
                v86 += 1 ;
            }
            v84 += 1 ;
        }
        auto v92 = cooperative_groups::coalesced_threads();
        int v93;
        v93 = threadIdx.x;
        int v94;
        v94 = v93 / 32;
        auto v95 = cooperative_groups::labeled_partition(v92,v94);
        Closure0 v96{};
        unsigned int v97;
        v97 = cooperative_groups::reduce(v95, v83, v96);
        unsigned int v98;
        v98 = v97 % 4096u;
        assert("Tensor range check" && 0 <= v22 && v22 < 32);
        int v99;
        v99 = 8 * v22;
        int v100;
        v100 = v99 + v21;
        v0[v100] = v98;
        v22 += 1 ;
    }
    asm("barrier.cta.sync %0;" :: "r"(0));
    return ;
}
__device__ Tuple14 method_46(curandStatePhilox4_32_10_t & v0, int * v1, float * v2, float * v3, float * v4, float * v5, float * v6, float * v7, float * v8, int v9, int v10){
    assert("Tensor range check" && 0 <= v10 && v10 < 4);
    int v11;
    v11 = 65536 * v10;
    assert("Tensor range check" && 0 <= v9 && v9 < 4096);
    int v12;
    v12 = 16 * v9;
    int v13;
    v13 = v12 + v11;
    float * v14;
    v14 = v2+v13;
    float * v16;
    v16 = v3+v13;
    int v18;
    v18 = sizeof(float *);
    unsigned long long v19;
    v19 = (unsigned long long)v18;
    unsigned long long v20;
    v20 = 256ull * v19;
    unsigned long long v21;
    v21 = v20 + 16ull;
    unsigned long long v22;
    v22 = v21 - 1ull;
    unsigned long long v23;
    v23 = v22 % 16ull;
    unsigned long long v24;
    v24 = v22 - v23;
    unsigned long long v25;
    v25 = v24 + v20;
    unsigned long long v26;
    v26 = v25 + 16ull;
    unsigned long long v27;
    v27 = v26 - 1ull;
    unsigned long long v28;
    v28 = v27 % 16ull;
    unsigned long long v29;
    v29 = v27 - v28;
    unsigned long long v30;
    v30 = v29 + 1024ull;
    unsigned long long v31;
    v31 = v30 + 16ull;
    unsigned long long v32;
    v32 = v31 - 1ull;
    unsigned long long v33;
    v33 = v32 % 16ull;
    unsigned long long v34;
    v34 = v32 - v33;
    unsigned long long v35;
    v35 = v34 + 1024ull;
    bool v36;
    v36 = v35 <= 98304ull;
    bool v37;
    v37 = v36 == false;
    if (v37){
        assert("The dynamic shared memory is insufficient to allocate the tensor." && v36);
    } else {
    }
    extern __shared__ unsigned char v39[];
    bool v40;
    v40 = v35 <= v35;
    bool v41;
    v41 = v40 == false;
    if (v41){
        assert("The length of the partition has to be less than or equal to the length of the base array." && v40);
    } else {
    }
    float * * v43;
    v43 = reinterpret_cast<float * *>(&v39[0ull]);
    float * * v45;
    v45 = reinterpret_cast<float * *>(&v39[v24]);
    float * v47;
    v47 = reinterpret_cast<float *>(&v39[v29]);
    int * v49;
    v49 = reinterpret_cast<int *>(&v39[v34]);
    int v51;
    v51 = threadIdx.x;
    assert("Tensor range check" && 0 <= v51 && v51 < 256);
    v43[v51] = v14;
    v45[v51] = v16;
    asm("barrier.cta.sync %0;" :: "r"(0));
    bool v52;
    v52 = 0 <= v51;
    bool v53;
    v53 = v52 == false;
    if (v53){
        assert("The index needs to be zero or positive." && v52);
    } else {
    }
    int v55;
    v55 = v51 % 4;
    int v56;
    v56 = v51 / 4;
    bool v57;
    v57 = v56 < 64;
    bool v58;
    v58 = v57 == false;
    if (v58){
        assert("The last element of the projection dimensions needs to be greater than the index remainder." && v57);
    } else {
    }
    assert("Tensor range check" && 0 <= v56 && v56 < 64);
    int v60;
    v60 = 0;
    while (while_method_3(v60)){
        bool v62;
        v62 = 0 <= v56;
        bool v63;
        v63 = v62 && v57;
        bool v64;
        v64 = v63 == false;
        if (v64){
            assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v63);
        } else {
        }
        bool v66;
        v66 = 0 <= v60;
        bool v68;
        if (v66){
            bool v67;
            v67 = v60 < 4;
            v68 = v67;
        } else {
            v68 = false;
        }
        bool v69;
        v69 = v68 == false;
        if (v69){
            assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v68);
        } else {
        }
        int v71;
        v71 = v60 * 64;
        int v72;
        v72 = v71 + v56;
        assert("Tensor range check" && 0 <= v60 && v60 < 4);
        int v73;
        v73 = 64 * v60;
        int v74;
        v74 = v73 + v56;
        float * v75;
        v75 = v43[v74];
        float * v76;
        v76 = v45[v74];
        int v77;
        v77 = blockIdx.x;
        int v78;
        v78 = v77 * 256;
        int v79;
        v79 = v78 + v72;
        assert("Tensor range check" && 0 <= v55 && v55 < 4);
        int v80;
        v80 = 4 * v55;
        float v81[4];
        float v82[4];
        int v83[4];
        int v84;
        v84 = 0;
        while (while_method_6(v84)){
            assert("Tensor range check" && 0 <= v84 && v84 < 1);
            int v86;
            v86 = 4 * v84;
            assert("Tensor range check" && 0 <= v84 && v84 < 1);
            int v87;
            v87 = 16 * v84;
            int v88;
            v88 = v87 + v80;
            int4* v89;
            v89 = reinterpret_cast<int4*>(v75 + v88);
            int4* v90;
            v90 = reinterpret_cast<int4*>(v81 + v86);
            assert("Pointer alignment check" && (unsigned long long)(v89) % 4 == 0 && (unsigned long long)(v90) % 4 == 0);
            *v90 = *v89;
            int4* v91;
            v91 = reinterpret_cast<int4*>(v76 + v88);
            int4* v92;
            v92 = reinterpret_cast<int4*>(v82 + v86);
            assert("Pointer alignment check" && (unsigned long long)(v91) % 4 == 0 && (unsigned long long)(v92) % 4 == 0);
            *v92 = *v91;
            v84 += 1 ;
        }
        int v93;
        v93 = 0;
        while (while_method_6(v93)){
            int v95;
            v95 = 0;
            while (while_method_3(v95)){
                bool v97;
                v97 = 0 <= v95;
                bool v99;
                if (v97){
                    bool v98;
                    v98 = v95 < 4;
                    v99 = v98;
                } else {
                    v99 = false;
                }
                bool v100;
                v100 = v99 == false;
                if (v100){
                    assert("The indices should be inside the range of the dimension." && v99);
                } else {
                }
                bool v102;
                v102 = 0 <= v55;
                bool v104;
                if (v102){
                    bool v103;
                    v103 = v55 < 4;
                    v104 = v103;
                } else {
                    v104 = false;
                }
                bool v105;
                v105 = v104 == false;
                if (v105){
                    assert("The indices should be inside the range of the dimension." && v104);
                } else {
                }
                int v107;
                v107 = v55 * 4;
                int v108;
                v108 = v95 + v107;
                bool v109;
                v109 = 0 <= v93;
                bool v111;
                if (v109){
                    bool v110;
                    v110 = v93 < 1;
                    v111 = v110;
                } else {
                    v111 = false;
                }
                bool v112;
                v112 = v111 == false;
                if (v112){
                    assert("The indices should be inside the range of the dimension." && v111);
                } else {
                }
                int v114;
                v114 = v93 * 16;
                int v115;
                v115 = v108 + v114;
                assert("Tensor range check" && 0 <= v93 && v93 < 1);
                assert("Tensor range check" && 0 <= v95 && v95 < 4);
                int v116;
                v116 = 4 * v93;
                int v117;
                v117 = v116 + v95;
                v83[v117] = v115;
                v95 += 1 ;
            }
            v93 += 1 ;
        }
        bool v118[4];
        int v119;
        v119 = 0;
        while (while_method_6(v119)){
            int v121;
            v121 = 0;
            while (while_method_3(v121)){
                assert("Tensor range check" && 0 <= v119 && v119 < 1);
                assert("Tensor range check" && 0 <= v121 && v121 < 4);
                int v123;
                v123 = 4 * v119;
                int v124;
                v124 = v123 + v121;
                float v125;
                v125 = v81[v124];
                int v126;
                v126 = v83[v124];
                bool v127;
                v127 = v126 < 11;
                assert("Tensor range check" && 0 <= v119 && v119 < 1);
                assert("Tensor range check" && 0 <= v121 && v121 < 4);
                v118[v124] = v127;
                v121 += 1 ;
            }
            v119 += 1 ;
        }
        float v128[4];
        int v129;
        v129 = 0;
        while (while_method_6(v129)){
            int v131;
            v131 = 0;
            while (while_method_3(v131)){
                assert("Tensor range check" && 0 <= v129 && v129 < 1);
                assert("Tensor range check" && 0 <= v131 && v131 < 4);
                int v133;
                v133 = 4 * v129;
                int v134;
                v134 = v133 + v131;
                float v135;
                v135 = v81[v134];
                bool v136;
                v136 = v118[v134];
                float v139;
                if (v136){
                    bool v137;
                    v137 = 0.0f >= v135;
                    if (v137){
                        v139 = 0.0f;
                    } else {
                        v139 = v135;
                    }
                } else {
                    v139 = 0.0f;
                }
                assert("Tensor range check" && 0 <= v129 && v129 < 1);
                assert("Tensor range check" && 0 <= v131 && v131 < 4);
                v128[v134] = v139;
                v131 += 1 ;
            }
            v129 += 1 ;
        }
        float v140;
        v140 = 0.0f;
        int v141;
        v141 = 0;
        while (while_method_6(v141)){
            int v143;
            v143 = 0;
            while (while_method_3(v143)){
                assert("Tensor range check" && 0 <= v141 && v141 < 1);
                assert("Tensor range check" && 0 <= v143 && v143 < 4);
                int v145;
                v145 = 4 * v141;
                int v146;
                v146 = v145 + v143;
                float v147;
                v147 = v128[v146];
                float v148;
                v148 = v140 + v147;
                v140 = v148;
                v143 += 1 ;
            }
            v141 += 1 ;
        }
        auto v149 = cooperative_groups::coalesced_threads();
        int v150;
        v150 = threadIdx.x;
        int v151;
        v151 = v150 / 4;
        auto v152 = cooperative_groups::labeled_partition(v149,v151);
        Closure1 v153{};
        float v154;
        v154 = cooperative_groups::reduce(v152, v140, v153);
        int v155[4];
        int v156;
        v156 = 0;
        while (while_method_6(v156)){
            int v158;
            v158 = 0;
            while (while_method_3(v158)){
                assert("Tensor range check" && 0 <= v156 && v156 < 1);
                assert("Tensor range check" && 0 <= v158 && v158 < 4);
                int v160;
                v160 = 4 * v156;
                int v161;
                v161 = v160 + v158;
                bool v162;
                v162 = v118[v161];
                int v163;
                if (v162){
                    v163 = 1;
                } else {
                    v163 = 0;
                }
                assert("Tensor range check" && 0 <= v156 && v156 < 1);
                assert("Tensor range check" && 0 <= v158 && v158 < 4);
                v155[v161] = v163;
                v158 += 1 ;
            }
            v156 += 1 ;
        }
        int v164;
        v164 = 0;
        int v165;
        v165 = 0;
        while (while_method_6(v165)){
            int v167;
            v167 = 0;
            while (while_method_3(v167)){
                assert("Tensor range check" && 0 <= v165 && v165 < 1);
                assert("Tensor range check" && 0 <= v167 && v167 < 4);
                int v169;
                v169 = 4 * v165;
                int v170;
                v170 = v169 + v167;
                int v171;
                v171 = v155[v170];
                int v172;
                v172 = v164 + v171;
                v164 = v172;
                v167 += 1 ;
            }
            v165 += 1 ;
        }
        auto v173 = cooperative_groups::coalesced_threads();
        int v174;
        v174 = threadIdx.x;
        int v175;
        v175 = v174 / 4;
        auto v176 = cooperative_groups::labeled_partition(v173,v175);
        Closure2 v177{};
        int v178;
        v178 = cooperative_groups::reduce(v176, v164, v177);
        float v179;
        v179 = (float)v178;
        float v180;
        v180 = 1.0f / v179;
        float v181[4];
        int v182;
        v182 = 0;
        while (while_method_6(v182)){
            int v184;
            v184 = 0;
            while (while_method_3(v184)){
                assert("Tensor range check" && 0 <= v182 && v182 < 1);
                assert("Tensor range check" && 0 <= v184 && v184 < 4);
                int v186;
                v186 = 4 * v182;
                int v187;
                v187 = v186 + v184;
                float v188;
                v188 = v128[v187];
                bool v189;
                v189 = v118[v187];
                bool v190;
                v190 = v189 == false;
                float v195;
                if (v190){
                    v195 = 0.0f;
                } else {
                    bool v191;
                    v191 = v154 == 0.0f;
                    bool v192;
                    v192 = v191 != true;
                    if (v192){
                        float v193;
                        v193 = v188 / v154;
                        v195 = v193;
                    } else {
                        v195 = v180;
                    }
                }
                assert("Tensor range check" && 0 <= v182 && v182 < 1);
                assert("Tensor range check" && 0 <= v184 && v184 < 4);
                v181[v187] = v195;
                v184 += 1 ;
            }
            v182 += 1 ;
        }
        float v196[4];
        float v197;
        v197 = 0.0f;
        int v198;
        v198 = 0;
        while (while_method_6(v198)){
            assert("Tensor range check" && 0 <= v198 && v198 < 1);
            int v200;
            v200 = 4 * v198;
            assert("Tensor range check" && 0 <= v198 && v198 < 1);
            int v201; float v202;
            Tuple15 tmp30 = Tuple15{0, 0.0f};
            v201 = tmp30.v0; v202 = tmp30.v1;
            while (while_method_3(v201)){
                assert("Tensor range check" && 0 <= v201 && v201 < 4);
                int v204;
                v204 = v201 + v200;
                float v205;
                v205 = v181[v204];
                float v206;
                v206 = v202 + v205;
                v202 = v206;
                v201 += 1 ;
            }
            auto v207 = cooperative_groups::coalesced_threads();
            int v208;
            v208 = threadIdx.x;
            int v209;
            v209 = v208 / 4;
            auto v210 = cooperative_groups::labeled_partition(v207,v209);
            Closure3 v211{};
            float v212;
            v212 = cooperative_groups::inclusive_scan(v210, v202, v211);
            float v213;
            v213 = v210.shfl_up(v212,1);
            bool v214;
            v214 = v210.thread_rank() == 0;
            float v215;
            if (v214){
                v215 = 0.0f;
            } else {
                v215 = v213;
            }
            float v216;
            v216 = v210.shfl(v212,v210.num_threads()-1);
            float v217;
            v217 = v197 + v215;
            int v218; float v219;
            Tuple15 tmp31 = Tuple15{0, v217};
            v218 = tmp31.v0; v219 = tmp31.v1;
            while (while_method_3(v218)){
                assert("Tensor range check" && 0 <= v218 && v218 < 4);
                int v221;
                v221 = v218 + v200;
                float v222;
                v222 = v181[v221];
                float v223;
                v223 = v219 + v222;
                assert("Tensor range check" && 0 <= v218 && v218 < 4);
                v196[v221] = v223;
                v219 = v223;
                v218 += 1 ;
            }
            float v224;
            v224 = v197 + v216;
            v197 = v224;
            v198 += 1 ;
        }
        float v225[4];
        bool v226[4];
        int v227;
        v227 = 0;
        while (while_method_6(v227)){
            int v229;
            v229 = 0;
            while (while_method_3(v229)){
                assert("Tensor range check" && 0 <= v227 && v227 < 1);
                assert("Tensor range check" && 0 <= v229 && v229 < 4);
                int v231;
                v231 = 4 * v227;
                int v232;
                v232 = v231 + v229;
                float v233;
                v233 = v196[v232];
                float v234;
                v234 = v181[v232];
                bool v235;
                v235 = v234 > 0.0f;
                assert("Tensor range check" && 0 <= v227 && v227 < 1);
                assert("Tensor range check" && 0 <= v229 && v229 < 4);
                v225[v232] = v233;
                v226[v232] = v235;
                v229 += 1 ;
            }
            v227 += 1 ;
        }
        float v236; bool v237;
        Tuple16 tmp32 = Tuple16{-1.0f / 0.0f, false};
        v236 = tmp32.v0; v237 = tmp32.v1;
        int v238;
        v238 = 0;
        while (while_method_6(v238)){
            int v240;
            v240 = 0;
            while (while_method_3(v240)){
                assert("Tensor range check" && 0 <= v238 && v238 < 1);
                assert("Tensor range check" && 0 <= v240 && v240 < 4);
                int v242;
                v242 = 4 * v238;
                int v243;
                v243 = v242 + v240;
                float v244;
                v244 = v225[v243];
                bool v245;
                v245 = v226[v243];
                float v252; bool v253;
                if (v237){
                    if (v245){
                        bool v246;
                        v246 = v236 >= v244;
                        float v247;
                        if (v246){
                            v247 = v236;
                        } else {
                            v247 = v244;
                        }
                        v252 = v247; v253 = true;
                    } else {
                        v252 = v236; v253 = v237;
                    }
                } else {
                    if (v245){
                        v252 = v244; v253 = v245;
                    } else {
                        v252 = v236; v253 = v237;
                    }
                }
                v236 = v252;
                v237 = v253;
                v240 += 1 ;
            }
            v238 += 1 ;
        }
        auto v254 = cooperative_groups::coalesced_threads();
        int v255;
        v255 = threadIdx.x;
        int v256;
        v256 = v255 / 4;
        auto v257 = cooperative_groups::labeled_partition(v254,v256);
        Closure4 v258{};
        float v259; bool v260;
        Tuple16 tmp33 = cooperative_groups::reduce(v257, Tuple16{v236, v237}, v258);
        v259 = tmp33.v0; v260 = tmp33.v1;
        bool v261;
        v261 = v260 == false;
        if (v261){
            assert("The local reduce must be true." && v260);
        } else {
        }
        float v263[4];
        int v264[4];
        int v265;
        v265 = 0;
        while (while_method_6(v265)){
            int v267;
            v267 = 0;
            while (while_method_3(v267)){
                assert("Tensor range check" && 0 <= v265 && v265 < 1);
                assert("Tensor range check" && 0 <= v267 && v267 < 4);
                int v269;
                v269 = 4 * v265;
                int v270;
                v270 = v269 + v267;
                int v271;
                v271 = v83[v270];
                float v272;
                v272 = curand_uniform(&v0);
                assert("Tensor range check" && 0 <= v265 && v265 < 1);
                assert("Tensor range check" && 0 <= v267 && v267 < 4);
                v263[v270] = v272;
                v264[v270] = v271;
                v267 += 1 ;
            }
            v265 += 1 ;
        }
        float v273; int v274;
        Tuple14 tmp34 = Tuple14{0.0f, 2147483647};
        v273 = tmp34.v0; v274 = tmp34.v1;
        int v275;
        v275 = 0;
        while (while_method_6(v275)){
            int v277;
            v277 = 0;
            while (while_method_3(v277)){
                assert("Tensor range check" && 0 <= v275 && v275 < 1);
                assert("Tensor range check" && 0 <= v277 && v277 < 4);
                int v279;
                v279 = 4 * v275;
                int v280;
                v280 = v279 + v277;
                float v281;
                v281 = v263[v280];
                int v282;
                v282 = v264[v280];
                bool v283;
                v283 = v274 < v282;
                float v284; int v285;
                if (v283){
                    v284 = v273; v285 = v274;
                } else {
                    v284 = v281; v285 = v282;
                }
                v273 = v284;
                v274 = v285;
                v277 += 1 ;
            }
            v275 += 1 ;
        }
        auto v286 = cooperative_groups::coalesced_threads();
        int v287;
        v287 = threadIdx.x;
        int v288;
        v288 = v287 / 4;
        auto v289 = cooperative_groups::labeled_partition(v286,v288);
        Closure5 v290{};
        float v291; int v292;
        Tuple14 tmp35 = cooperative_groups::reduce(v289, Tuple14{v273, v274}, v290);
        v291 = tmp35.v0; v292 = tmp35.v1;
        float v293;
        v293 = v259 * v291;
        int v294[4];
        bool v295[4];
        int v296;
        v296 = 0;
        while (while_method_6(v296)){
            int v298;
            v298 = 0;
            while (while_method_3(v298)){
                assert("Tensor range check" && 0 <= v296 && v296 < 1);
                assert("Tensor range check" && 0 <= v298 && v298 < 4);
                int v300;
                v300 = 4 * v296;
                int v301;
                v301 = v300 + v298;
                float v302;
                v302 = v225[v301];
                bool v303;
                v303 = v226[v301];
                int v304;
                v304 = v83[v301];
                int v307; bool v308;
                if (v303){
                    float v305;
                    v305 = v302 - v293;
                    bool v306;
                    v306 = v305 >= 0.0f;
                    v307 = v304; v308 = v306;
                } else {
                    v307 = 2147483647; v308 = false;
                }
                assert("Tensor range check" && 0 <= v296 && v296 < 1);
                assert("Tensor range check" && 0 <= v298 && v298 < 4);
                v294[v301] = v307;
                v295[v301] = v308;
                v298 += 1 ;
            }
            v296 += 1 ;
        }
        int v309; bool v310;
        Tuple17 tmp36 = Tuple17{2147483647, false};
        v309 = tmp36.v0; v310 = tmp36.v1;
        int v311;
        v311 = 0;
        while (while_method_6(v311)){
            int v313;
            v313 = 0;
            while (while_method_3(v313)){
                assert("Tensor range check" && 0 <= v311 && v311 < 1);
                assert("Tensor range check" && 0 <= v313 && v313 < 4);
                int v315;
                v315 = 4 * v311;
                int v316;
                v316 = v315 + v313;
                int v317;
                v317 = v294[v316];
                bool v318;
                v318 = v295[v316];
                int v325; bool v326;
                if (v310){
                    if (v318){
                        bool v319;
                        v319 = v309 < v317;
                        int v320;
                        if (v319){
                            v320 = v309;
                        } else {
                            v320 = v317;
                        }
                        v325 = v320; v326 = true;
                    } else {
                        v325 = v309; v326 = v310;
                    }
                } else {
                    if (v318){
                        v325 = v317; v326 = v318;
                    } else {
                        v325 = v309; v326 = v310;
                    }
                }
                v309 = v325;
                v310 = v326;
                v313 += 1 ;
            }
            v311 += 1 ;
        }
        auto v327 = cooperative_groups::coalesced_threads();
        int v328;
        v328 = threadIdx.x;
        int v329;
        v329 = v328 / 4;
        auto v330 = cooperative_groups::labeled_partition(v327,v329);
        Closure6 v331{};
        int v332; bool v333;
        Tuple17 tmp37 = cooperative_groups::reduce(v330, Tuple17{v309, v310}, v331);
        v332 = tmp37.v0; v333 = tmp37.v1;
        bool v334;
        v334 = v333 == false;
        if (v334){
            assert("The local reduce must be true." && v333);
        } else {
        }
        bool v336[4];
        int v337;
        v337 = 0;
        while (while_method_6(v337)){
            int v339;
            v339 = 0;
            while (while_method_3(v339)){
                assert("Tensor range check" && 0 <= v337 && v337 < 1);
                assert("Tensor range check" && 0 <= v339 && v339 < 4);
                int v341;
                v341 = 4 * v337;
                int v342;
                v342 = v341 + v339;
                float v343;
                v343 = v82[v342];
                int v344;
                v344 = v83[v342];
                bool v345;
                v345 = v344 < 11;
                assert("Tensor range check" && 0 <= v337 && v337 < 1);
                assert("Tensor range check" && 0 <= v339 && v339 < 4);
                v336[v342] = v345;
                v339 += 1 ;
            }
            v337 += 1 ;
        }
        float v346[4];
        int v347;
        v347 = 0;
        while (while_method_6(v347)){
            int v349;
            v349 = 0;
            while (while_method_3(v349)){
                assert("Tensor range check" && 0 <= v347 && v347 < 1);
                assert("Tensor range check" && 0 <= v349 && v349 < 4);
                int v351;
                v351 = 4 * v347;
                int v352;
                v352 = v351 + v349;
                float v353;
                v353 = v82[v352];
                bool v354;
                v354 = v336[v352];
                float v357;
                if (v354){
                    bool v355;
                    v355 = 0.0f >= v353;
                    if (v355){
                        v357 = 0.0f;
                    } else {
                        v357 = v353;
                    }
                } else {
                    v357 = 0.0f;
                }
                assert("Tensor range check" && 0 <= v347 && v347 < 1);
                assert("Tensor range check" && 0 <= v349 && v349 < 4);
                v346[v352] = v357;
                v349 += 1 ;
            }
            v347 += 1 ;
        }
        float v358;
        v358 = 0.0f;
        int v359;
        v359 = 0;
        while (while_method_6(v359)){
            int v361;
            v361 = 0;
            while (while_method_3(v361)){
                assert("Tensor range check" && 0 <= v359 && v359 < 1);
                assert("Tensor range check" && 0 <= v361 && v361 < 4);
                int v363;
                v363 = 4 * v359;
                int v364;
                v364 = v363 + v361;
                float v365;
                v365 = v346[v364];
                float v366;
                v366 = v358 + v365;
                v358 = v366;
                v361 += 1 ;
            }
            v359 += 1 ;
        }
        auto v367 = cooperative_groups::coalesced_threads();
        int v368;
        v368 = threadIdx.x;
        int v369;
        v369 = v368 / 4;
        auto v370 = cooperative_groups::labeled_partition(v367,v369);
        float v371;
        v371 = cooperative_groups::reduce(v370, v358, v153);
        int v372[4];
        int v373;
        v373 = 0;
        while (while_method_6(v373)){
            int v375;
            v375 = 0;
            while (while_method_3(v375)){
                assert("Tensor range check" && 0 <= v373 && v373 < 1);
                assert("Tensor range check" && 0 <= v375 && v375 < 4);
                int v377;
                v377 = 4 * v373;
                int v378;
                v378 = v377 + v375;
                bool v379;
                v379 = v336[v378];
                int v380;
                if (v379){
                    v380 = 1;
                } else {
                    v380 = 0;
                }
                assert("Tensor range check" && 0 <= v373 && v373 < 1);
                assert("Tensor range check" && 0 <= v375 && v375 < 4);
                v372[v378] = v380;
                v375 += 1 ;
            }
            v373 += 1 ;
        }
        int v381;
        v381 = 0;
        int v382;
        v382 = 0;
        while (while_method_6(v382)){
            int v384;
            v384 = 0;
            while (while_method_3(v384)){
                assert("Tensor range check" && 0 <= v382 && v382 < 1);
                assert("Tensor range check" && 0 <= v384 && v384 < 4);
                int v386;
                v386 = 4 * v382;
                int v387;
                v387 = v386 + v384;
                int v388;
                v388 = v372[v387];
                int v389;
                v389 = v381 + v388;
                v381 = v389;
                v384 += 1 ;
            }
            v382 += 1 ;
        }
        auto v390 = cooperative_groups::coalesced_threads();
        int v391;
        v391 = threadIdx.x;
        int v392;
        v392 = v391 / 4;
        auto v393 = cooperative_groups::labeled_partition(v390,v392);
        int v394;
        v394 = cooperative_groups::reduce(v393, v381, v177);
        float v395;
        v395 = (float)v394;
        float v396;
        v396 = 1.0f / v395;
        float v397[4];
        int v398;
        v398 = 0;
        while (while_method_6(v398)){
            int v400;
            v400 = 0;
            while (while_method_3(v400)){
                assert("Tensor range check" && 0 <= v398 && v398 < 1);
                assert("Tensor range check" && 0 <= v400 && v400 < 4);
                int v402;
                v402 = 4 * v398;
                int v403;
                v403 = v402 + v400;
                float v404;
                v404 = v346[v403];
                bool v405;
                v405 = v336[v403];
                bool v406;
                v406 = v405 == false;
                float v411;
                if (v406){
                    v411 = 0.0f;
                } else {
                    bool v407;
                    v407 = v371 == 0.0f;
                    bool v408;
                    v408 = v407 != true;
                    if (v408){
                        float v409;
                        v409 = v404 / v371;
                        v411 = v409;
                    } else {
                        v411 = v396;
                    }
                }
                assert("Tensor range check" && 0 <= v398 && v398 < 1);
                assert("Tensor range check" && 0 <= v400 && v400 < 4);
                v397[v403] = v411;
                v400 += 1 ;
            }
            v398 += 1 ;
        }
        float v412; int v413;
        Tuple14 tmp38 = Tuple14{0.0f, 2147483647};
        v412 = tmp38.v0; v413 = tmp38.v1;
        int v414;
        v414 = 0;
        while (while_method_6(v414)){
            int v416;
            v416 = 0;
            while (while_method_3(v416)){
                assert("Tensor range check" && 0 <= v414 && v414 < 1);
                assert("Tensor range check" && 0 <= v416 && v416 < 4);
                int v418;
                v418 = 4 * v414;
                int v419;
                v419 = v418 + v416;
                float v420;
                v420 = v181[v419];
                int v421;
                v421 = v83[v419];
                bool v422;
                v422 = v413 == v332;
                float v426; int v427;
                if (v422){
                    v426 = v412; v427 = v413;
                } else {
                    bool v423;
                    v423 = v421 == v332;
                    if (v423){
                        v426 = v420; v427 = v421;
                    } else {
                        v426 = v412; v427 = v413;
                    }
                }
                v412 = v426;
                v413 = v427;
                v416 += 1 ;
            }
            v414 += 1 ;
        }
        auto v428 = cooperative_groups::coalesced_threads();
        int v429;
        v429 = threadIdx.x;
        int v430;
        v430 = v429 / 4;
        auto v431 = cooperative_groups::labeled_partition(v428,v430);
        Closure7 v432{v332};
        float v433; int v434;
        Tuple14 tmp39 = cooperative_groups::reduce(v431, Tuple14{v412, v413}, v432);
        v433 = tmp39.v0; v434 = tmp39.v1;
        bool v435;
        v435 = v434 == 2147483647;
        bool v436;
        v436 = v435 != true;
        bool v437;
        v437 = v436 == false;
        if (v437){
            assert("Expected a valid action id in get_action." && v436);
        } else {
        }
        int v439;
        v439 = 0;
        while (while_method_6(v439)){
            assert("Tensor range check" && 0 <= v439 && v439 < 1);
            assert("Tensor range check" && 0 <= v439 && v439 < 1);
            v439 += 1 ;
        }
        assert("Tensor range check" && 0 <= v72 && v72 < 256);
        v47[v72] = v433;
        v49[v72] = v332;
        v60 += 1 ;
    }
    asm("barrier.cta.sync %0;" :: "r"(0));
    assert("Tensor range check" && 0 <= v51 && v51 < 256);
    float v441;
    v441 = v47[v51];
    int v442;
    v442 = v49[v51];
    asm("barrier.cta.sync %0;" :: "r"(0));
    return Tuple14{v441, v442};
}
__device__ inline bool while_method_14(int v0){
    bool v1;
    v1 = v0 < 6;
    return v1;
}
__device__ inline bool while_method_15(static_array<float,6> v0, int v1){
    bool v2;
    v2 = v1 < 6;
    return v2;
}
__device__ inline bool while_method_16(int v0, int v1){
    bool v2;
    v2 = v1 > v0;
    return v2;
}
__device__ int loop_50(static_array<float,6> v0, float v1, int v2){
    bool v3;
    v3 = v2 < 6;
    if (v3){
        float v4;
        v4 = v0[v2];
        bool v6;
        v6 = v1 <= v4;
        if (v6){
            return v2;
        } else {
            int v7;
            v7 = v2 + 1;
            return loop_50(v0, v1, v7);
        }
    } else {
        return 5;
    }
}
__device__ int pick_discrete__49(static_array<float,6> v0, float v1){
    static_array<float,6> v2;
    int v4;
    v4 = 0;
    while (while_method_14(v4)){
        float v6;
        v6 = v0[v4];
        v2[v4] = v6;
        v4 += 1 ;
    }
    int v8;
    v8 = 1;
    while (while_method_15(v2, v8)){
        int v10;
        v10 = 6;
        while (while_method_16(v8, v10)){
            v10 -= 1 ;
            int v12;
            v12 = v10 - v8;
            float v13;
            v13 = v2[v12];
            float v15;
            v15 = v2[v10];
            float v17;
            v17 = v13 + v15;
            v2[v10] = v17;
        }
        int v18;
        v18 = v8 * 2;
        v8 = v18;
    }
    float v19;
    v19 = v2[5];
    float v21;
    v21 = v1 * v19;
    int v22;
    v22 = 0;
    return loop_50(v2, v21, v22);
}
__device__ int sample_discrete__48(static_array<float,6> v0, curandStatePhilox4_32_10_t & v1){
    float v2;
    v2 = curand_uniform(&v1);
    return pick_discrete__49(v0, v2);
}
__device__ Union1 sample_discrete_47(static_array<Tuple18,6> v0, curandStatePhilox4_32_10_t & v1){
    static_array<float,6> v2;
    int v4;
    v4 = 0;
    while (while_method_14(v4)){
        Union1 v6; float v7;
        Tuple18 tmp49 = v0[v4];
        v6 = tmp49.v0; v7 = tmp49.v1;
        v2[v4] = v7;
        v4 += 1 ;
    }
    int v10;
    v10 = sample_discrete__48(v2, v1);
    Union1 v11; float v12;
    Tuple18 tmp50 = v0[v10];
    v11 = tmp50.v0; v12 = tmp50.v1;
    return v11;
}
__device__ inline bool while_method_17(int v0){
    bool v1;
    v1 = v0 < 7;
    return v1;
}
__device__ inline bool while_method_18(static_array<unsigned char,7> v0, bool v1, int v2){
    bool v3;
    v3 = v2 < 7;
    return v3;
}
__device__ inline bool while_method_19(static_array<unsigned char,7> v0, int v1){
    bool v2;
    v2 = v1 < 7;
    return v2;
}
__device__ inline bool while_method_20(int v0, int v1, int v2, int v3){
    bool v4;
    v4 = v3 < v0;
    return v4;
}
__device__ Tuple0 score_51(static_array<unsigned char,7> v0){
    static_array<unsigned char,7> v1;
    int v3;
    v3 = 0;
    while (while_method_17(v3)){
        unsigned char v5;
        v5 = v0[v3];
        v1[v3] = v5;
        v3 += 1 ;
    }
    static_array<unsigned char,7> v7;
    bool v9; int v10;
    Tuple19 tmp57 = Tuple19{true, 1};
    v9 = tmp57.v0; v10 = tmp57.v1;
    while (while_method_18(v1, v9, v10)){
        int v12;
        v12 = 0;
        while (while_method_19(v1, v12)){
            int v14;
            v14 = v12 + v10;
            bool v15;
            v15 = v14 < 7;
            int v16;
            if (v15){
                v16 = v14;
            } else {
                v16 = 7;
            }
            int v17;
            v17 = v10 * 2;
            int v18;
            v18 = v12 + v17;
            bool v19;
            v19 = v18 < 7;
            int v20;
            if (v19){
                v20 = v18;
            } else {
                v20 = 7;
            }
            int v21; int v22; int v23;
            Tuple20 tmp58 = Tuple20{v12, v16, v12};
            v21 = tmp58.v0; v22 = tmp58.v1; v23 = tmp58.v2;
            while (while_method_20(v20, v21, v22, v23)){
                bool v25;
                v25 = v21 < v16;
                bool v27;
                if (v25){
                    bool v26;
                    v26 = v22 < v20;
                    v27 = v26;
                } else {
                    v27 = false;
                }
                unsigned char v77; int v78; int v79;
                if (v27){
                    unsigned char v32;
                    if (v9){
                        unsigned char v28;
                        v28 = v1[v21];
                        v32 = v28;
                    } else {
                        unsigned char v30;
                        v30 = v7[v21];
                        v32 = v30;
                    }
                    unsigned char v37;
                    if (v9){
                        unsigned char v33;
                        v33 = v1[v22];
                        v37 = v33;
                    } else {
                        unsigned char v35;
                        v35 = v7[v22];
                        v37 = v35;
                    }
                    unsigned char v38;
                    v38 = v37 / 4u;
                    unsigned char v39;
                    v39 = v32 / 4u;
                    bool v40;
                    v40 = v38 < v39;
                    Union11 v46;
                    if (v40){
                        v46 = Union11{Union11_2{}};
                    } else {
                        bool v42;
                        v42 = v38 > v39;
                        if (v42){
                            v46 = Union11{Union11_1{}};
                        } else {
                            v46 = Union11{Union11_0{}};
                        }
                    }
                    Union11 v56;
                    switch (v46.tag) {
                        case 0: { // Eq
                            unsigned char v47;
                            v47 = v32 % 4u;
                            unsigned char v48;
                            v48 = v37 % 4u;
                            bool v49;
                            v49 = v47 < v48;
                            if (v49){
                                v56 = Union11{Union11_2{}};
                            } else {
                                bool v51;
                                v51 = v47 > v48;
                                if (v51){
                                    v56 = Union11{Union11_1{}};
                                } else {
                                    v56 = Union11{Union11_0{}};
                                }
                            }
                            break;
                        }
                        default: {
                            v56 = v46;
                        }
                    }
                    switch (v56.tag) {
                        case 1: { // Gt
                            int v57;
                            v57 = v22 + 1;
                            v77 = v37; v78 = v21; v79 = v57;
                            break;
                        }
                        default: {
                            int v58;
                            v58 = v21 + 1;
                            v77 = v32; v78 = v58; v79 = v22;
                        }
                    }
                } else {
                    if (v25){
                        unsigned char v66;
                        if (v9){
                            unsigned char v62;
                            v62 = v1[v21];
                            v66 = v62;
                        } else {
                            unsigned char v64;
                            v64 = v7[v21];
                            v66 = v64;
                        }
                        int v67;
                        v67 = v21 + 1;
                        v77 = v66; v78 = v67; v79 = v22;
                    } else {
                        unsigned char v72;
                        if (v9){
                            unsigned char v68;
                            v68 = v1[v22];
                            v72 = v68;
                        } else {
                            unsigned char v70;
                            v70 = v7[v22];
                            v72 = v70;
                        }
                        int v73;
                        v73 = v22 + 1;
                        v77 = v72; v78 = v21; v79 = v73;
                    }
                }
                if (v9){
                    v7[v23] = v77;
                } else {
                    v1[v23] = v77;
                }
                int v80;
                v80 = v23 + 1;
                v21 = v78;
                v22 = v79;
                v23 = v80;
            }
            v12 = v18;
        }
        bool v81;
        v81 = v9 == false;
        int v82;
        v82 = v10 * 2;
        v9 = v81;
        v10 = v82;
    }
    bool v83;
    v83 = v9 == false;
    static_array<unsigned char,7> v84;
    if (v83){
        v84 = v7;
    } else {
        v84 = v1;
    }
    static_array<unsigned char,5> v85;
    int v87; int v88; unsigned char v89;
    Tuple21 tmp59 = Tuple21{0, 0, 12u};
    v87 = tmp59.v0; v88 = tmp59.v1; v89 = tmp59.v2;
    while (while_method_17(v87)){
        unsigned char v91;
        v91 = v84[v87];
        bool v93;
        v93 = v88 < 5;
        int v105; unsigned char v106;
        if (v93){
            unsigned char v94;
            v94 = v91 % 4u;
            bool v95;
            v95 = 0u == v94;
            if (v95){
                unsigned char v96;
                v96 = v91 / 4u;
                bool v97;
                v97 = v89 == v96;
                int v98;
                if (v97){
                    v98 = v88;
                } else {
                    v98 = 0;
                }
                v85[v98] = v91;
                int v99;
                v99 = v98 + 1;
                unsigned char v100;
                v100 = v96 - 1u;
                v105 = v99; v106 = v100;
            } else {
                v105 = v88; v106 = v89;
            }
        } else {
            break;
        }
        v88 = v105;
        v89 = v106;
        v87 += 1 ;
    }
    bool v107;
    v107 = v88 == 4;
    bool v146;
    if (v107){
        unsigned char v108;
        v108 = v89 + 1u;
        bool v109;
        v109 = v108 == 0u;
        if (v109){
            unsigned char v110;
            v110 = v84[0];
            unsigned char v112;
            v112 = v110 % 4u;
            bool v113;
            v113 = 0u == v112;
            bool v117;
            if (v113){
                unsigned char v114;
                v114 = v110 / 4u;
                bool v115;
                v115 = v114 == 12u;
                if (v115){
                    v85[4] = v110;
                    v117 = true;
                } else {
                    v117 = false;
                }
            } else {
                v117 = false;
            }
            if (v117){
                v146 = true;
            } else {
                unsigned char v118;
                v118 = v84[1];
                unsigned char v120;
                v120 = v118 % 4u;
                bool v121;
                v121 = 0u == v120;
                bool v125;
                if (v121){
                    unsigned char v122;
                    v122 = v118 / 4u;
                    bool v123;
                    v123 = v122 == 12u;
                    if (v123){
                        v85[4] = v118;
                        v125 = true;
                    } else {
                        v125 = false;
                    }
                } else {
                    v125 = false;
                }
                if (v125){
                    v146 = true;
                } else {
                    unsigned char v126;
                    v126 = v84[2];
                    unsigned char v128;
                    v128 = v126 % 4u;
                    bool v129;
                    v129 = 0u == v128;
                    bool v133;
                    if (v129){
                        unsigned char v130;
                        v130 = v126 / 4u;
                        bool v131;
                        v131 = v130 == 12u;
                        if (v131){
                            v85[4] = v126;
                            v133 = true;
                        } else {
                            v133 = false;
                        }
                    } else {
                        v133 = false;
                    }
                    if (v133){
                        v146 = true;
                    } else {
                        unsigned char v134;
                        v134 = v84[3];
                        unsigned char v136;
                        v136 = v134 % 4u;
                        bool v137;
                        v137 = 0u == v136;
                        if (v137){
                            unsigned char v138;
                            v138 = v134 / 4u;
                            bool v139;
                            v139 = v138 == 12u;
                            if (v139){
                                v85[4] = v134;
                                v146 = true;
                            } else {
                                v146 = false;
                            }
                        } else {
                            v146 = false;
                        }
                    }
                }
            }
        } else {
            v146 = false;
        }
    } else {
        v146 = false;
    }
    Union12 v152;
    if (v146){
        v152 = Union12{Union12_1{v85}};
    } else {
        bool v148;
        v148 = v88 == 5;
        if (v148){
            v152 = Union12{Union12_1{v85}};
        } else {
            v152 = Union12{Union12_0{}};
        }
    }
    static_array<unsigned char,5> v153;
    int v155; int v156; unsigned char v157;
    Tuple21 tmp60 = Tuple21{0, 0, 12u};
    v155 = tmp60.v0; v156 = tmp60.v1; v157 = tmp60.v2;
    while (while_method_17(v155)){
        unsigned char v159;
        v159 = v84[v155];
        bool v161;
        v161 = v156 < 5;
        int v173; unsigned char v174;
        if (v161){
            unsigned char v162;
            v162 = v159 % 4u;
            bool v163;
            v163 = 1u == v162;
            if (v163){
                unsigned char v164;
                v164 = v159 / 4u;
                bool v165;
                v165 = v157 == v164;
                int v166;
                if (v165){
                    v166 = v156;
                } else {
                    v166 = 0;
                }
                v153[v166] = v159;
                int v167;
                v167 = v166 + 1;
                unsigned char v168;
                v168 = v164 - 1u;
                v173 = v167; v174 = v168;
            } else {
                v173 = v156; v174 = v157;
            }
        } else {
            break;
        }
        v156 = v173;
        v157 = v174;
        v155 += 1 ;
    }
    bool v175;
    v175 = v156 == 4;
    bool v214;
    if (v175){
        unsigned char v176;
        v176 = v157 + 1u;
        bool v177;
        v177 = v176 == 0u;
        if (v177){
            unsigned char v178;
            v178 = v84[0];
            unsigned char v180;
            v180 = v178 % 4u;
            bool v181;
            v181 = 1u == v180;
            bool v185;
            if (v181){
                unsigned char v182;
                v182 = v178 / 4u;
                bool v183;
                v183 = v182 == 12u;
                if (v183){
                    v153[4] = v178;
                    v185 = true;
                } else {
                    v185 = false;
                }
            } else {
                v185 = false;
            }
            if (v185){
                v214 = true;
            } else {
                unsigned char v186;
                v186 = v84[1];
                unsigned char v188;
                v188 = v186 % 4u;
                bool v189;
                v189 = 1u == v188;
                bool v193;
                if (v189){
                    unsigned char v190;
                    v190 = v186 / 4u;
                    bool v191;
                    v191 = v190 == 12u;
                    if (v191){
                        v153[4] = v186;
                        v193 = true;
                    } else {
                        v193 = false;
                    }
                } else {
                    v193 = false;
                }
                if (v193){
                    v214 = true;
                } else {
                    unsigned char v194;
                    v194 = v84[2];
                    unsigned char v196;
                    v196 = v194 % 4u;
                    bool v197;
                    v197 = 1u == v196;
                    bool v201;
                    if (v197){
                        unsigned char v198;
                        v198 = v194 / 4u;
                        bool v199;
                        v199 = v198 == 12u;
                        if (v199){
                            v153[4] = v194;
                            v201 = true;
                        } else {
                            v201 = false;
                        }
                    } else {
                        v201 = false;
                    }
                    if (v201){
                        v214 = true;
                    } else {
                        unsigned char v202;
                        v202 = v84[3];
                        unsigned char v204;
                        v204 = v202 % 4u;
                        bool v205;
                        v205 = 1u == v204;
                        if (v205){
                            unsigned char v206;
                            v206 = v202 / 4u;
                            bool v207;
                            v207 = v206 == 12u;
                            if (v207){
                                v153[4] = v202;
                                v214 = true;
                            } else {
                                v214 = false;
                            }
                        } else {
                            v214 = false;
                        }
                    }
                }
            }
        } else {
            v214 = false;
        }
    } else {
        v214 = false;
    }
    Union12 v220;
    if (v214){
        v220 = Union12{Union12_1{v153}};
    } else {
        bool v216;
        v216 = v156 == 5;
        if (v216){
            v220 = Union12{Union12_1{v153}};
        } else {
            v220 = Union12{Union12_0{}};
        }
    }
    Union12 v248;
    switch (v152.tag) {
        case 0: { // None
            v248 = v220;
            break;
        }
        case 1: { // Some
            static_array<unsigned char,5> v221 = v152.case1.v0;
            switch (v220.tag) {
                case 0: { // None
                    v248 = v152;
                    break;
                }
                case 1: { // Some
                    static_array<unsigned char,5> v222 = v220.case1.v0;
                    Union11 v223;
                    v223 = Union11{Union11_0{}};
                    int v224; Union11 v225;
                    Tuple22 tmp61 = Tuple22{0, v223};
                    v224 = tmp61.v0; v225 = tmp61.v1;
                    while (while_method_2(v224)){
                        unsigned char v227;
                        v227 = v221[v224];
                        unsigned char v229;
                        v229 = v222[v224];
                        Union11 v241;
                        switch (v225.tag) {
                            case 0: { // Eq
                                unsigned char v231;
                                v231 = v227 / 4u;
                                unsigned char v232;
                                v232 = v229 / 4u;
                                bool v233;
                                v233 = v231 < v232;
                                if (v233){
                                    v241 = Union11{Union11_2{}};
                                } else {
                                    bool v235;
                                    v235 = v231 > v232;
                                    if (v235){
                                        v241 = Union11{Union11_1{}};
                                    } else {
                                        v241 = Union11{Union11_0{}};
                                    }
                                }
                                break;
                            }
                            default: {
                                break;
                            }
                        }
                        v225 = v241;
                        v224 += 1 ;
                    }
                    bool v242;
                    switch (v225.tag) {
                        case 1: { // Gt
                            v242 = true;
                            break;
                        }
                        default: {
                            v242 = false;
                        }
                    }
                    static_array<unsigned char,5> v243;
                    if (v242){
                        v243 = v221;
                    } else {
                        v243 = v222;
                    }
                    v248 = Union12{Union12_1{v243}};
                    break;
                }
                default: {
                    assert("Invalid tag." && false); __trap();
                }
            }
            break;
        }
        default: {
            assert("Invalid tag." && false); __trap();
        }
    }
    static_array<unsigned char,5> v249;
    int v251; int v252; unsigned char v253;
    Tuple21 tmp62 = Tuple21{0, 0, 12u};
    v251 = tmp62.v0; v252 = tmp62.v1; v253 = tmp62.v2;
    while (while_method_17(v251)){
        unsigned char v255;
        v255 = v84[v251];
        bool v257;
        v257 = v252 < 5;
        int v269; unsigned char v270;
        if (v257){
            unsigned char v258;
            v258 = v255 % 4u;
            bool v259;
            v259 = 2u == v258;
            if (v259){
                unsigned char v260;
                v260 = v255 / 4u;
                bool v261;
                v261 = v253 == v260;
                int v262;
                if (v261){
                    v262 = v252;
                } else {
                    v262 = 0;
                }
                v249[v262] = v255;
                int v263;
                v263 = v262 + 1;
                unsigned char v264;
                v264 = v260 - 1u;
                v269 = v263; v270 = v264;
            } else {
                v269 = v252; v270 = v253;
            }
        } else {
            break;
        }
        v252 = v269;
        v253 = v270;
        v251 += 1 ;
    }
    bool v271;
    v271 = v252 == 4;
    bool v310;
    if (v271){
        unsigned char v272;
        v272 = v253 + 1u;
        bool v273;
        v273 = v272 == 0u;
        if (v273){
            unsigned char v274;
            v274 = v84[0];
            unsigned char v276;
            v276 = v274 % 4u;
            bool v277;
            v277 = 2u == v276;
            bool v281;
            if (v277){
                unsigned char v278;
                v278 = v274 / 4u;
                bool v279;
                v279 = v278 == 12u;
                if (v279){
                    v249[4] = v274;
                    v281 = true;
                } else {
                    v281 = false;
                }
            } else {
                v281 = false;
            }
            if (v281){
                v310 = true;
            } else {
                unsigned char v282;
                v282 = v84[1];
                unsigned char v284;
                v284 = v282 % 4u;
                bool v285;
                v285 = 2u == v284;
                bool v289;
                if (v285){
                    unsigned char v286;
                    v286 = v282 / 4u;
                    bool v287;
                    v287 = v286 == 12u;
                    if (v287){
                        v249[4] = v282;
                        v289 = true;
                    } else {
                        v289 = false;
                    }
                } else {
                    v289 = false;
                }
                if (v289){
                    v310 = true;
                } else {
                    unsigned char v290;
                    v290 = v84[2];
                    unsigned char v292;
                    v292 = v290 % 4u;
                    bool v293;
                    v293 = 2u == v292;
                    bool v297;
                    if (v293){
                        unsigned char v294;
                        v294 = v290 / 4u;
                        bool v295;
                        v295 = v294 == 12u;
                        if (v295){
                            v249[4] = v290;
                            v297 = true;
                        } else {
                            v297 = false;
                        }
                    } else {
                        v297 = false;
                    }
                    if (v297){
                        v310 = true;
                    } else {
                        unsigned char v298;
                        v298 = v84[3];
                        unsigned char v300;
                        v300 = v298 % 4u;
                        bool v301;
                        v301 = 2u == v300;
                        if (v301){
                            unsigned char v302;
                            v302 = v298 / 4u;
                            bool v303;
                            v303 = v302 == 12u;
                            if (v303){
                                v249[4] = v298;
                                v310 = true;
                            } else {
                                v310 = false;
                            }
                        } else {
                            v310 = false;
                        }
                    }
                }
            }
        } else {
            v310 = false;
        }
    } else {
        v310 = false;
    }
    Union12 v316;
    if (v310){
        v316 = Union12{Union12_1{v249}};
    } else {
        bool v312;
        v312 = v252 == 5;
        if (v312){
            v316 = Union12{Union12_1{v249}};
        } else {
            v316 = Union12{Union12_0{}};
        }
    }
    Union12 v344;
    switch (v248.tag) {
        case 0: { // None
            v344 = v316;
            break;
        }
        case 1: { // Some
            static_array<unsigned char,5> v317 = v248.case1.v0;
            switch (v316.tag) {
                case 0: { // None
                    v344 = v248;
                    break;
                }
                case 1: { // Some
                    static_array<unsigned char,5> v318 = v316.case1.v0;
                    Union11 v319;
                    v319 = Union11{Union11_0{}};
                    int v320; Union11 v321;
                    Tuple22 tmp63 = Tuple22{0, v319};
                    v320 = tmp63.v0; v321 = tmp63.v1;
                    while (while_method_2(v320)){
                        unsigned char v323;
                        v323 = v317[v320];
                        unsigned char v325;
                        v325 = v318[v320];
                        Union11 v337;
                        switch (v321.tag) {
                            case 0: { // Eq
                                unsigned char v327;
                                v327 = v323 / 4u;
                                unsigned char v328;
                                v328 = v325 / 4u;
                                bool v329;
                                v329 = v327 < v328;
                                if (v329){
                                    v337 = Union11{Union11_2{}};
                                } else {
                                    bool v331;
                                    v331 = v327 > v328;
                                    if (v331){
                                        v337 = Union11{Union11_1{}};
                                    } else {
                                        v337 = Union11{Union11_0{}};
                                    }
                                }
                                break;
                            }
                            default: {
                                break;
                            }
                        }
                        v321 = v337;
                        v320 += 1 ;
                    }
                    bool v338;
                    switch (v321.tag) {
                        case 1: { // Gt
                            v338 = true;
                            break;
                        }
                        default: {
                            v338 = false;
                        }
                    }
                    static_array<unsigned char,5> v339;
                    if (v338){
                        v339 = v317;
                    } else {
                        v339 = v318;
                    }
                    v344 = Union12{Union12_1{v339}};
                    break;
                }
                default: {
                    assert("Invalid tag." && false); __trap();
                }
            }
            break;
        }
        default: {
            assert("Invalid tag." && false); __trap();
        }
    }
    static_array<unsigned char,5> v345;
    int v347; int v348; unsigned char v349;
    Tuple21 tmp64 = Tuple21{0, 0, 12u};
    v347 = tmp64.v0; v348 = tmp64.v1; v349 = tmp64.v2;
    while (while_method_17(v347)){
        unsigned char v351;
        v351 = v84[v347];
        bool v353;
        v353 = v348 < 5;
        int v365; unsigned char v366;
        if (v353){
            unsigned char v354;
            v354 = v351 % 4u;
            bool v355;
            v355 = 3u == v354;
            if (v355){
                unsigned char v356;
                v356 = v351 / 4u;
                bool v357;
                v357 = v349 == v356;
                int v358;
                if (v357){
                    v358 = v348;
                } else {
                    v358 = 0;
                }
                v345[v358] = v351;
                int v359;
                v359 = v358 + 1;
                unsigned char v360;
                v360 = v356 - 1u;
                v365 = v359; v366 = v360;
            } else {
                v365 = v348; v366 = v349;
            }
        } else {
            break;
        }
        v348 = v365;
        v349 = v366;
        v347 += 1 ;
    }
    bool v367;
    v367 = v348 == 4;
    bool v406;
    if (v367){
        unsigned char v368;
        v368 = v349 + 1u;
        bool v369;
        v369 = v368 == 0u;
        if (v369){
            unsigned char v370;
            v370 = v84[0];
            unsigned char v372;
            v372 = v370 % 4u;
            bool v373;
            v373 = 3u == v372;
            bool v377;
            if (v373){
                unsigned char v374;
                v374 = v370 / 4u;
                bool v375;
                v375 = v374 == 12u;
                if (v375){
                    v345[4] = v370;
                    v377 = true;
                } else {
                    v377 = false;
                }
            } else {
                v377 = false;
            }
            if (v377){
                v406 = true;
            } else {
                unsigned char v378;
                v378 = v84[1];
                unsigned char v380;
                v380 = v378 % 4u;
                bool v381;
                v381 = 3u == v380;
                bool v385;
                if (v381){
                    unsigned char v382;
                    v382 = v378 / 4u;
                    bool v383;
                    v383 = v382 == 12u;
                    if (v383){
                        v345[4] = v378;
                        v385 = true;
                    } else {
                        v385 = false;
                    }
                } else {
                    v385 = false;
                }
                if (v385){
                    v406 = true;
                } else {
                    unsigned char v386;
                    v386 = v84[2];
                    unsigned char v388;
                    v388 = v386 % 4u;
                    bool v389;
                    v389 = 3u == v388;
                    bool v393;
                    if (v389){
                        unsigned char v390;
                        v390 = v386 / 4u;
                        bool v391;
                        v391 = v390 == 12u;
                        if (v391){
                            v345[4] = v386;
                            v393 = true;
                        } else {
                            v393 = false;
                        }
                    } else {
                        v393 = false;
                    }
                    if (v393){
                        v406 = true;
                    } else {
                        unsigned char v394;
                        v394 = v84[3];
                        unsigned char v396;
                        v396 = v394 % 4u;
                        bool v397;
                        v397 = 3u == v396;
                        if (v397){
                            unsigned char v398;
                            v398 = v394 / 4u;
                            bool v399;
                            v399 = v398 == 12u;
                            if (v399){
                                v345[4] = v394;
                                v406 = true;
                            } else {
                                v406 = false;
                            }
                        } else {
                            v406 = false;
                        }
                    }
                }
            }
        } else {
            v406 = false;
        }
    } else {
        v406 = false;
    }
    Union12 v412;
    if (v406){
        v412 = Union12{Union12_1{v345}};
    } else {
        bool v408;
        v408 = v348 == 5;
        if (v408){
            v412 = Union12{Union12_1{v345}};
        } else {
            v412 = Union12{Union12_0{}};
        }
    }
    Union12 v440;
    switch (v344.tag) {
        case 0: { // None
            v440 = v412;
            break;
        }
        case 1: { // Some
            static_array<unsigned char,5> v413 = v344.case1.v0;
            switch (v412.tag) {
                case 0: { // None
                    v440 = v344;
                    break;
                }
                case 1: { // Some
                    static_array<unsigned char,5> v414 = v412.case1.v0;
                    Union11 v415;
                    v415 = Union11{Union11_0{}};
                    int v416; Union11 v417;
                    Tuple22 tmp65 = Tuple22{0, v415};
                    v416 = tmp65.v0; v417 = tmp65.v1;
                    while (while_method_2(v416)){
                        unsigned char v419;
                        v419 = v413[v416];
                        unsigned char v421;
                        v421 = v414[v416];
                        Union11 v433;
                        switch (v417.tag) {
                            case 0: { // Eq
                                unsigned char v423;
                                v423 = v419 / 4u;
                                unsigned char v424;
                                v424 = v421 / 4u;
                                bool v425;
                                v425 = v423 < v424;
                                if (v425){
                                    v433 = Union11{Union11_2{}};
                                } else {
                                    bool v427;
                                    v427 = v423 > v424;
                                    if (v427){
                                        v433 = Union11{Union11_1{}};
                                    } else {
                                        v433 = Union11{Union11_0{}};
                                    }
                                }
                                break;
                            }
                            default: {
                                break;
                            }
                        }
                        v417 = v433;
                        v416 += 1 ;
                    }
                    bool v434;
                    switch (v417.tag) {
                        case 1: { // Gt
                            v434 = true;
                            break;
                        }
                        default: {
                            v434 = false;
                        }
                    }
                    static_array<unsigned char,5> v435;
                    if (v434){
                        v435 = v413;
                    } else {
                        v435 = v414;
                    }
                    v440 = Union12{Union12_1{v435}};
                    break;
                }
                default: {
                    assert("Invalid tag." && false); __trap();
                }
            }
            break;
        }
        default: {
            assert("Invalid tag." && false); __trap();
        }
    }
    static_array<unsigned char,5> v1037; char v1038;
    switch (v440.tag) {
        case 0: { // None
            static_array<unsigned char,4> v442;
            static_array<unsigned char,3> v444;
            int v446; int v447; int v448; unsigned char v449;
            Tuple23 tmp66 = Tuple23{0, 0, 0, 12u};
            v446 = tmp66.v0; v447 = tmp66.v1; v448 = tmp66.v2; v449 = tmp66.v3;
            while (while_method_17(v446)){
                unsigned char v451;
                v451 = v84[v446];
                bool v453;
                v453 = v448 < 4;
                int v461; int v462; unsigned char v463;
                if (v453){
                    unsigned char v454;
                    v454 = v451 / 4u;
                    bool v455;
                    v455 = v449 == v454;
                    int v456;
                    if (v455){
                        v456 = v448;
                    } else {
                        v456 = 0;
                    }
                    v442[v456] = v451;
                    int v457;
                    v457 = v456 + 1;
                    v461 = v446; v462 = v457; v463 = v454;
                } else {
                    break;
                }
                v447 = v461;
                v448 = v462;
                v449 = v463;
                v446 += 1 ;
            }
            bool v464;
            v464 = v448 == 4;
            Union13 v475;
            if (v464){
                int v465;
                v465 = 0;
                while (while_method_1(v465)){
                    int v467;
                    v467 = v447 + -3;
                    bool v468;
                    v468 = v465 < v467;
                    int v469;
                    if (v468){
                        v469 = 0;
                    } else {
                        v469 = 4;
                    }
                    int v470;
                    v470 = v469 + v465;
                    unsigned char v471;
                    v471 = v84[v470];
                    v444[v465] = v471;
                    v465 += 1 ;
                }
                v475 = Union13{Union13_1{v442, v444}};
            } else {
                v475 = Union13{Union13_0{}};
            }
            Union12 v498;
            switch (v475.tag) {
                case 0: { // None
                    v498 = Union12{Union12_0{}};
                    break;
                }
                case 1: { // Some
                    static_array<unsigned char,4> v476 = v475.case1.v0; static_array<unsigned char,3> v477 = v475.case1.v1;
                    static_array<unsigned char,1> v478;
                    int v480;
                    v480 = 0;
                    while (while_method_6(v480)){
                        unsigned char v482;
                        v482 = v477[v480];
                        v478[v480] = v482;
                        v480 += 1 ;
                    }
                    static_array<unsigned char,5> v484;
                    int v486;
                    v486 = 0;
                    while (while_method_3(v486)){
                        unsigned char v488;
                        v488 = v476[v486];
                        v484[v486] = v488;
                        v486 += 1 ;
                    }
                    int v490;
                    v490 = 0;
                    while (while_method_6(v490)){
                        unsigned char v492;
                        v492 = v478[v490];
                        int v494;
                        v494 = 4 + v490;
                        v484[v494] = v492;
                        v490 += 1 ;
                    }
                    v498 = Union12{Union12_1{v484}};
                    break;
                }
                default: {
                    assert("Invalid tag." && false); __trap();
                }
            }
            switch (v498.tag) {
                case 0: { // None
                    static_array<unsigned char,3> v500;
                    static_array<unsigned char,4> v502;
                    int v504; int v505; int v506; unsigned char v507;
                    Tuple23 tmp67 = Tuple23{0, 0, 0, 12u};
                    v504 = tmp67.v0; v505 = tmp67.v1; v506 = tmp67.v2; v507 = tmp67.v3;
                    while (while_method_17(v504)){
                        unsigned char v509;
                        v509 = v84[v504];
                        bool v511;
                        v511 = v506 < 3;
                        int v519; int v520; unsigned char v521;
                        if (v511){
                            unsigned char v512;
                            v512 = v509 / 4u;
                            bool v513;
                            v513 = v507 == v512;
                            int v514;
                            if (v513){
                                v514 = v506;
                            } else {
                                v514 = 0;
                            }
                            v500[v514] = v509;
                            int v515;
                            v515 = v514 + 1;
                            v519 = v504; v520 = v515; v521 = v512;
                        } else {
                            break;
                        }
                        v505 = v519;
                        v506 = v520;
                        v507 = v521;
                        v504 += 1 ;
                    }
                    bool v522;
                    v522 = v506 == 3;
                    Union14 v533;
                    if (v522){
                        int v523;
                        v523 = 0;
                        while (while_method_3(v523)){
                            int v525;
                            v525 = v505 + -2;
                            bool v526;
                            v526 = v523 < v525;
                            int v527;
                            if (v526){
                                v527 = 0;
                            } else {
                                v527 = 3;
                            }
                            int v528;
                            v528 = v527 + v523;
                            unsigned char v529;
                            v529 = v84[v528];
                            v502[v523] = v529;
                            v523 += 1 ;
                        }
                        v533 = Union14{Union14_1{v500, v502}};
                    } else {
                        v533 = Union14{Union14_0{}};
                    }
                    Union12 v589;
                    switch (v533.tag) {
                        case 0: { // None
                            v589 = Union12{Union12_0{}};
                            break;
                        }
                        case 1: { // Some
                            static_array<unsigned char,3> v534 = v533.case1.v0; static_array<unsigned char,4> v535 = v533.case1.v1;
                            static_array<unsigned char,2> v536;
                            static_array<unsigned char,2> v538;
                            int v540; int v541; int v542; unsigned char v543;
                            Tuple23 tmp68 = Tuple23{0, 0, 0, 12u};
                            v540 = tmp68.v0; v541 = tmp68.v1; v542 = tmp68.v2; v543 = tmp68.v3;
                            while (while_method_3(v540)){
                                unsigned char v545;
                                v545 = v535[v540];
                                bool v547;
                                v547 = v542 < 2;
                                int v555; int v556; unsigned char v557;
                                if (v547){
                                    unsigned char v548;
                                    v548 = v545 / 4u;
                                    bool v549;
                                    v549 = v543 == v548;
                                    int v550;
                                    if (v549){
                                        v550 = v542;
                                    } else {
                                        v550 = 0;
                                    }
                                    v536[v550] = v545;
                                    int v551;
                                    v551 = v550 + 1;
                                    v555 = v540; v556 = v551; v557 = v548;
                                } else {
                                    break;
                                }
                                v541 = v555;
                                v542 = v556;
                                v543 = v557;
                                v540 += 1 ;
                            }
                            bool v558;
                            v558 = v542 == 2;
                            Union15 v569;
                            if (v558){
                                int v559;
                                v559 = 0;
                                while (while_method_0(v559)){
                                    int v561;
                                    v561 = v541 + -1;
                                    bool v562;
                                    v562 = v559 < v561;
                                    int v563;
                                    if (v562){
                                        v563 = 0;
                                    } else {
                                        v563 = 2;
                                    }
                                    int v564;
                                    v564 = v563 + v559;
                                    unsigned char v565;
                                    v565 = v535[v564];
                                    v538[v559] = v565;
                                    v559 += 1 ;
                                }
                                v569 = Union15{Union15_1{v536, v538}};
                            } else {
                                v569 = Union15{Union15_0{}};
                            }
                            switch (v569.tag) {
                                case 0: { // None
                                    v589 = Union12{Union12_0{}};
                                    break;
                                }
                                case 1: { // Some
                                    static_array<unsigned char,2> v570 = v569.case1.v0; static_array<unsigned char,2> v571 = v569.case1.v1;
                                    static_array<unsigned char,5> v572;
                                    int v574;
                                    v574 = 0;
                                    while (while_method_1(v574)){
                                        unsigned char v576;
                                        v576 = v534[v574];
                                        v572[v574] = v576;
                                        v574 += 1 ;
                                    }
                                    int v578;
                                    v578 = 0;
                                    while (while_method_0(v578)){
                                        unsigned char v580;
                                        v580 = v570[v578];
                                        int v582;
                                        v582 = 3 + v578;
                                        v572[v582] = v580;
                                        v578 += 1 ;
                                    }
                                    v589 = Union12{Union12_1{v572}};
                                    break;
                                }
                                default: {
                                    assert("Invalid tag." && false); __trap();
                                }
                            }
                            break;
                        }
                        default: {
                            assert("Invalid tag." && false); __trap();
                        }
                    }
                    switch (v589.tag) {
                        case 0: { // None
                            static_array<unsigned char,5> v591;
                            int v593; int v594;
                            Tuple4 tmp69 = Tuple4{0, 0};
                            v593 = tmp69.v0; v594 = tmp69.v1;
                            while (while_method_17(v593)){
                                unsigned char v596;
                                v596 = v84[v593];
                                unsigned char v598;
                                v598 = v596 % 4u;
                                bool v599;
                                v599 = v598 == 0u;
                                bool v601;
                                if (v599){
                                    bool v600;
                                    v600 = v594 < 5;
                                    v601 = v600;
                                } else {
                                    v601 = false;
                                }
                                int v603;
                                if (v601){
                                    v591[v594] = v596;
                                    int v602;
                                    v602 = v594 + 1;
                                    v603 = v602;
                                } else {
                                    v603 = v594;
                                }
                                v594 = v603;
                                v593 += 1 ;
                            }
                            bool v604;
                            v604 = v594 == 5;
                            Union12 v607;
                            if (v604){
                                v607 = Union12{Union12_1{v591}};
                            } else {
                                v607 = Union12{Union12_0{}};
                            }
                            static_array<unsigned char,5> v608;
                            int v610; int v611;
                            Tuple4 tmp70 = Tuple4{0, 0};
                            v610 = tmp70.v0; v611 = tmp70.v1;
                            while (while_method_17(v610)){
                                unsigned char v613;
                                v613 = v84[v610];
                                unsigned char v615;
                                v615 = v613 % 4u;
                                bool v616;
                                v616 = v615 == 1u;
                                bool v618;
                                if (v616){
                                    bool v617;
                                    v617 = v611 < 5;
                                    v618 = v617;
                                } else {
                                    v618 = false;
                                }
                                int v620;
                                if (v618){
                                    v608[v611] = v613;
                                    int v619;
                                    v619 = v611 + 1;
                                    v620 = v619;
                                } else {
                                    v620 = v611;
                                }
                                v611 = v620;
                                v610 += 1 ;
                            }
                            bool v621;
                            v621 = v611 == 5;
                            Union12 v624;
                            if (v621){
                                v624 = Union12{Union12_1{v608}};
                            } else {
                                v624 = Union12{Union12_0{}};
                            }
                            Union12 v652;
                            switch (v607.tag) {
                                case 0: { // None
                                    v652 = v624;
                                    break;
                                }
                                case 1: { // Some
                                    static_array<unsigned char,5> v625 = v607.case1.v0;
                                    switch (v624.tag) {
                                        case 0: { // None
                                            v652 = v607;
                                            break;
                                        }
                                        case 1: { // Some
                                            static_array<unsigned char,5> v626 = v624.case1.v0;
                                            Union11 v627;
                                            v627 = Union11{Union11_0{}};
                                            int v628; Union11 v629;
                                            Tuple22 tmp71 = Tuple22{0, v627};
                                            v628 = tmp71.v0; v629 = tmp71.v1;
                                            while (while_method_2(v628)){
                                                unsigned char v631;
                                                v631 = v625[v628];
                                                unsigned char v633;
                                                v633 = v626[v628];
                                                Union11 v645;
                                                switch (v629.tag) {
                                                    case 0: { // Eq
                                                        unsigned char v635;
                                                        v635 = v631 / 4u;
                                                        unsigned char v636;
                                                        v636 = v633 / 4u;
                                                        bool v637;
                                                        v637 = v635 < v636;
                                                        if (v637){
                                                            v645 = Union11{Union11_2{}};
                                                        } else {
                                                            bool v639;
                                                            v639 = v635 > v636;
                                                            if (v639){
                                                                v645 = Union11{Union11_1{}};
                                                            } else {
                                                                v645 = Union11{Union11_0{}};
                                                            }
                                                        }
                                                        break;
                                                    }
                                                    default: {
                                                        break;
                                                    }
                                                }
                                                v629 = v645;
                                                v628 += 1 ;
                                            }
                                            bool v646;
                                            switch (v629.tag) {
                                                case 1: { // Gt
                                                    v646 = true;
                                                    break;
                                                }
                                                default: {
                                                    v646 = false;
                                                }
                                            }
                                            static_array<unsigned char,5> v647;
                                            if (v646){
                                                v647 = v625;
                                            } else {
                                                v647 = v626;
                                            }
                                            v652 = Union12{Union12_1{v647}};
                                            break;
                                        }
                                        default: {
                                            assert("Invalid tag." && false); __trap();
                                        }
                                    }
                                    break;
                                }
                                default: {
                                    assert("Invalid tag." && false); __trap();
                                }
                            }
                            static_array<unsigned char,5> v653;
                            int v655; int v656;
                            Tuple4 tmp72 = Tuple4{0, 0};
                            v655 = tmp72.v0; v656 = tmp72.v1;
                            while (while_method_17(v655)){
                                unsigned char v658;
                                v658 = v84[v655];
                                unsigned char v660;
                                v660 = v658 % 4u;
                                bool v661;
                                v661 = v660 == 2u;
                                bool v663;
                                if (v661){
                                    bool v662;
                                    v662 = v656 < 5;
                                    v663 = v662;
                                } else {
                                    v663 = false;
                                }
                                int v665;
                                if (v663){
                                    v653[v656] = v658;
                                    int v664;
                                    v664 = v656 + 1;
                                    v665 = v664;
                                } else {
                                    v665 = v656;
                                }
                                v656 = v665;
                                v655 += 1 ;
                            }
                            bool v666;
                            v666 = v656 == 5;
                            Union12 v669;
                            if (v666){
                                v669 = Union12{Union12_1{v653}};
                            } else {
                                v669 = Union12{Union12_0{}};
                            }
                            Union12 v697;
                            switch (v652.tag) {
                                case 0: { // None
                                    v697 = v669;
                                    break;
                                }
                                case 1: { // Some
                                    static_array<unsigned char,5> v670 = v652.case1.v0;
                                    switch (v669.tag) {
                                        case 0: { // None
                                            v697 = v652;
                                            break;
                                        }
                                        case 1: { // Some
                                            static_array<unsigned char,5> v671 = v669.case1.v0;
                                            Union11 v672;
                                            v672 = Union11{Union11_0{}};
                                            int v673; Union11 v674;
                                            Tuple22 tmp73 = Tuple22{0, v672};
                                            v673 = tmp73.v0; v674 = tmp73.v1;
                                            while (while_method_2(v673)){
                                                unsigned char v676;
                                                v676 = v670[v673];
                                                unsigned char v678;
                                                v678 = v671[v673];
                                                Union11 v690;
                                                switch (v674.tag) {
                                                    case 0: { // Eq
                                                        unsigned char v680;
                                                        v680 = v676 / 4u;
                                                        unsigned char v681;
                                                        v681 = v678 / 4u;
                                                        bool v682;
                                                        v682 = v680 < v681;
                                                        if (v682){
                                                            v690 = Union11{Union11_2{}};
                                                        } else {
                                                            bool v684;
                                                            v684 = v680 > v681;
                                                            if (v684){
                                                                v690 = Union11{Union11_1{}};
                                                            } else {
                                                                v690 = Union11{Union11_0{}};
                                                            }
                                                        }
                                                        break;
                                                    }
                                                    default: {
                                                        break;
                                                    }
                                                }
                                                v674 = v690;
                                                v673 += 1 ;
                                            }
                                            bool v691;
                                            switch (v674.tag) {
                                                case 1: { // Gt
                                                    v691 = true;
                                                    break;
                                                }
                                                default: {
                                                    v691 = false;
                                                }
                                            }
                                            static_array<unsigned char,5> v692;
                                            if (v691){
                                                v692 = v670;
                                            } else {
                                                v692 = v671;
                                            }
                                            v697 = Union12{Union12_1{v692}};
                                            break;
                                        }
                                        default: {
                                            assert("Invalid tag." && false); __trap();
                                        }
                                    }
                                    break;
                                }
                                default: {
                                    assert("Invalid tag." && false); __trap();
                                }
                            }
                            static_array<unsigned char,5> v698;
                            int v700; int v701;
                            Tuple4 tmp74 = Tuple4{0, 0};
                            v700 = tmp74.v0; v701 = tmp74.v1;
                            while (while_method_17(v700)){
                                unsigned char v703;
                                v703 = v84[v700];
                                unsigned char v705;
                                v705 = v703 % 4u;
                                bool v706;
                                v706 = v705 == 3u;
                                bool v708;
                                if (v706){
                                    bool v707;
                                    v707 = v701 < 5;
                                    v708 = v707;
                                } else {
                                    v708 = false;
                                }
                                int v710;
                                if (v708){
                                    v698[v701] = v703;
                                    int v709;
                                    v709 = v701 + 1;
                                    v710 = v709;
                                } else {
                                    v710 = v701;
                                }
                                v701 = v710;
                                v700 += 1 ;
                            }
                            bool v711;
                            v711 = v701 == 5;
                            Union12 v714;
                            if (v711){
                                v714 = Union12{Union12_1{v698}};
                            } else {
                                v714 = Union12{Union12_0{}};
                            }
                            Union12 v742;
                            switch (v697.tag) {
                                case 0: { // None
                                    v742 = v714;
                                    break;
                                }
                                case 1: { // Some
                                    static_array<unsigned char,5> v715 = v697.case1.v0;
                                    switch (v714.tag) {
                                        case 0: { // None
                                            v742 = v697;
                                            break;
                                        }
                                        case 1: { // Some
                                            static_array<unsigned char,5> v716 = v714.case1.v0;
                                            Union11 v717;
                                            v717 = Union11{Union11_0{}};
                                            int v718; Union11 v719;
                                            Tuple22 tmp75 = Tuple22{0, v717};
                                            v718 = tmp75.v0; v719 = tmp75.v1;
                                            while (while_method_2(v718)){
                                                unsigned char v721;
                                                v721 = v715[v718];
                                                unsigned char v723;
                                                v723 = v716[v718];
                                                Union11 v735;
                                                switch (v719.tag) {
                                                    case 0: { // Eq
                                                        unsigned char v725;
                                                        v725 = v721 / 4u;
                                                        unsigned char v726;
                                                        v726 = v723 / 4u;
                                                        bool v727;
                                                        v727 = v725 < v726;
                                                        if (v727){
                                                            v735 = Union11{Union11_2{}};
                                                        } else {
                                                            bool v729;
                                                            v729 = v725 > v726;
                                                            if (v729){
                                                                v735 = Union11{Union11_1{}};
                                                            } else {
                                                                v735 = Union11{Union11_0{}};
                                                            }
                                                        }
                                                        break;
                                                    }
                                                    default: {
                                                        break;
                                                    }
                                                }
                                                v719 = v735;
                                                v718 += 1 ;
                                            }
                                            bool v736;
                                            switch (v719.tag) {
                                                case 1: { // Gt
                                                    v736 = true;
                                                    break;
                                                }
                                                default: {
                                                    v736 = false;
                                                }
                                            }
                                            static_array<unsigned char,5> v737;
                                            if (v736){
                                                v737 = v715;
                                            } else {
                                                v737 = v716;
                                            }
                                            v742 = Union12{Union12_1{v737}};
                                            break;
                                        }
                                        default: {
                                            assert("Invalid tag." && false); __trap();
                                        }
                                    }
                                    break;
                                }
                                default: {
                                    assert("Invalid tag." && false); __trap();
                                }
                            }
                            switch (v742.tag) {
                                case 0: { // None
                                    static_array<unsigned char,5> v744;
                                    int v746; int v747; unsigned char v748;
                                    Tuple21 tmp76 = Tuple21{0, 0, 12u};
                                    v746 = tmp76.v0; v747 = tmp76.v1; v748 = tmp76.v2;
                                    while (while_method_17(v746)){
                                        unsigned char v750;
                                        v750 = v84[v746];
                                        bool v752;
                                        v752 = v747 < 5;
                                        int v764; unsigned char v765;
                                        if (v752){
                                            unsigned char v753;
                                            v753 = v750 / 4u;
                                            unsigned char v754;
                                            v754 = v753 - 1u;
                                            bool v755;
                                            v755 = v748 == v754;
                                            bool v756;
                                            v756 = v755 != true;
                                            if (v756){
                                                bool v757;
                                                v757 = v748 == v753;
                                                int v758;
                                                if (v757){
                                                    v758 = v747;
                                                } else {
                                                    v758 = 0;
                                                }
                                                v744[v758] = v750;
                                                int v759;
                                                v759 = v758 + 1;
                                                v764 = v759; v765 = v754;
                                            } else {
                                                v764 = v747; v765 = v748;
                                            }
                                        } else {
                                            break;
                                        }
                                        v747 = v764;
                                        v748 = v765;
                                        v746 += 1 ;
                                    }
                                    bool v766;
                                    v766 = v747 == 4;
                                    bool v775;
                                    if (v766){
                                        unsigned char v767;
                                        v767 = v748 + 1u;
                                        bool v768;
                                        v768 = v767 == 0u;
                                        if (v768){
                                            unsigned char v769;
                                            v769 = v84[0];
                                            unsigned char v771;
                                            v771 = v769 / 4u;
                                            bool v772;
                                            v772 = v771 == 12u;
                                            if (v772){
                                                v744[4] = v769;
                                                v775 = true;
                                            } else {
                                                v775 = false;
                                            }
                                        } else {
                                            v775 = false;
                                        }
                                    } else {
                                        v775 = false;
                                    }
                                    Union12 v781;
                                    if (v775){
                                        v781 = Union12{Union12_1{v744}};
                                    } else {
                                        bool v777;
                                        v777 = v747 == 5;
                                        if (v777){
                                            v781 = Union12{Union12_1{v744}};
                                        } else {
                                            v781 = Union12{Union12_0{}};
                                        }
                                    }
                                    switch (v781.tag) {
                                        case 0: { // None
                                            static_array<unsigned char,3> v783;
                                            static_array<unsigned char,4> v785;
                                            int v787; int v788; int v789; unsigned char v790;
                                            Tuple23 tmp77 = Tuple23{0, 0, 0, 12u};
                                            v787 = tmp77.v0; v788 = tmp77.v1; v789 = tmp77.v2; v790 = tmp77.v3;
                                            while (while_method_17(v787)){
                                                unsigned char v792;
                                                v792 = v84[v787];
                                                bool v794;
                                                v794 = v789 < 3;
                                                int v802; int v803; unsigned char v804;
                                                if (v794){
                                                    unsigned char v795;
                                                    v795 = v792 / 4u;
                                                    bool v796;
                                                    v796 = v790 == v795;
                                                    int v797;
                                                    if (v796){
                                                        v797 = v789;
                                                    } else {
                                                        v797 = 0;
                                                    }
                                                    v783[v797] = v792;
                                                    int v798;
                                                    v798 = v797 + 1;
                                                    v802 = v787; v803 = v798; v804 = v795;
                                                } else {
                                                    break;
                                                }
                                                v788 = v802;
                                                v789 = v803;
                                                v790 = v804;
                                                v787 += 1 ;
                                            }
                                            bool v805;
                                            v805 = v789 == 3;
                                            Union14 v816;
                                            if (v805){
                                                int v806;
                                                v806 = 0;
                                                while (while_method_3(v806)){
                                                    int v808;
                                                    v808 = v788 + -2;
                                                    bool v809;
                                                    v809 = v806 < v808;
                                                    int v810;
                                                    if (v809){
                                                        v810 = 0;
                                                    } else {
                                                        v810 = 3;
                                                    }
                                                    int v811;
                                                    v811 = v810 + v806;
                                                    unsigned char v812;
                                                    v812 = v84[v811];
                                                    v785[v806] = v812;
                                                    v806 += 1 ;
                                                }
                                                v816 = Union14{Union14_1{v783, v785}};
                                            } else {
                                                v816 = Union14{Union14_0{}};
                                            }
                                            Union12 v839;
                                            switch (v816.tag) {
                                                case 0: { // None
                                                    v839 = Union12{Union12_0{}};
                                                    break;
                                                }
                                                case 1: { // Some
                                                    static_array<unsigned char,3> v817 = v816.case1.v0; static_array<unsigned char,4> v818 = v816.case1.v1;
                                                    static_array<unsigned char,2> v819;
                                                    int v821;
                                                    v821 = 0;
                                                    while (while_method_0(v821)){
                                                        unsigned char v823;
                                                        v823 = v818[v821];
                                                        v819[v821] = v823;
                                                        v821 += 1 ;
                                                    }
                                                    static_array<unsigned char,5> v825;
                                                    int v827;
                                                    v827 = 0;
                                                    while (while_method_1(v827)){
                                                        unsigned char v829;
                                                        v829 = v817[v827];
                                                        v825[v827] = v829;
                                                        v827 += 1 ;
                                                    }
                                                    int v831;
                                                    v831 = 0;
                                                    while (while_method_0(v831)){
                                                        unsigned char v833;
                                                        v833 = v819[v831];
                                                        int v835;
                                                        v835 = 3 + v831;
                                                        v825[v835] = v833;
                                                        v831 += 1 ;
                                                    }
                                                    v839 = Union12{Union12_1{v825}};
                                                    break;
                                                }
                                                default: {
                                                    assert("Invalid tag." && false); __trap();
                                                }
                                            }
                                            switch (v839.tag) {
                                                case 0: { // None
                                                    static_array<unsigned char,2> v841;
                                                    static_array<unsigned char,5> v843;
                                                    int v845; int v846; int v847; unsigned char v848;
                                                    Tuple23 tmp78 = Tuple23{0, 0, 0, 12u};
                                                    v845 = tmp78.v0; v846 = tmp78.v1; v847 = tmp78.v2; v848 = tmp78.v3;
                                                    while (while_method_17(v845)){
                                                        unsigned char v850;
                                                        v850 = v84[v845];
                                                        bool v852;
                                                        v852 = v847 < 2;
                                                        int v860; int v861; unsigned char v862;
                                                        if (v852){
                                                            unsigned char v853;
                                                            v853 = v850 / 4u;
                                                            bool v854;
                                                            v854 = v848 == v853;
                                                            int v855;
                                                            if (v854){
                                                                v855 = v847;
                                                            } else {
                                                                v855 = 0;
                                                            }
                                                            v841[v855] = v850;
                                                            int v856;
                                                            v856 = v855 + 1;
                                                            v860 = v845; v861 = v856; v862 = v853;
                                                        } else {
                                                            break;
                                                        }
                                                        v846 = v860;
                                                        v847 = v861;
                                                        v848 = v862;
                                                        v845 += 1 ;
                                                    }
                                                    bool v863;
                                                    v863 = v847 == 2;
                                                    Union16 v874;
                                                    if (v863){
                                                        int v864;
                                                        v864 = 0;
                                                        while (while_method_2(v864)){
                                                            int v866;
                                                            v866 = v846 + -1;
                                                            bool v867;
                                                            v867 = v864 < v866;
                                                            int v868;
                                                            if (v867){
                                                                v868 = 0;
                                                            } else {
                                                                v868 = 2;
                                                            }
                                                            int v869;
                                                            v869 = v868 + v864;
                                                            unsigned char v870;
                                                            v870 = v84[v869];
                                                            v843[v864] = v870;
                                                            v864 += 1 ;
                                                        }
                                                        v874 = Union16{Union16_1{v841, v843}};
                                                    } else {
                                                        v874 = Union16{Union16_0{}};
                                                    }
                                                    Union12 v941;
                                                    switch (v874.tag) {
                                                        case 0: { // None
                                                            v941 = Union12{Union12_0{}};
                                                            break;
                                                        }
                                                        case 1: { // Some
                                                            static_array<unsigned char,2> v875 = v874.case1.v0; static_array<unsigned char,5> v876 = v874.case1.v1;
                                                            static_array<unsigned char,2> v877;
                                                            static_array<unsigned char,3> v879;
                                                            int v881; int v882; int v883; unsigned char v884;
                                                            Tuple23 tmp79 = Tuple23{0, 0, 0, 12u};
                                                            v881 = tmp79.v0; v882 = tmp79.v1; v883 = tmp79.v2; v884 = tmp79.v3;
                                                            while (while_method_2(v881)){
                                                                unsigned char v886;
                                                                v886 = v876[v881];
                                                                bool v888;
                                                                v888 = v883 < 2;
                                                                int v896; int v897; unsigned char v898;
                                                                if (v888){
                                                                    unsigned char v889;
                                                                    v889 = v886 / 4u;
                                                                    bool v890;
                                                                    v890 = v884 == v889;
                                                                    int v891;
                                                                    if (v890){
                                                                        v891 = v883;
                                                                    } else {
                                                                        v891 = 0;
                                                                    }
                                                                    v877[v891] = v886;
                                                                    int v892;
                                                                    v892 = v891 + 1;
                                                                    v896 = v881; v897 = v892; v898 = v889;
                                                                } else {
                                                                    break;
                                                                }
                                                                v882 = v896;
                                                                v883 = v897;
                                                                v884 = v898;
                                                                v881 += 1 ;
                                                            }
                                                            bool v899;
                                                            v899 = v883 == 2;
                                                            Union17 v910;
                                                            if (v899){
                                                                int v900;
                                                                v900 = 0;
                                                                while (while_method_1(v900)){
                                                                    int v902;
                                                                    v902 = v882 + -1;
                                                                    bool v903;
                                                                    v903 = v900 < v902;
                                                                    int v904;
                                                                    if (v903){
                                                                        v904 = 0;
                                                                    } else {
                                                                        v904 = 2;
                                                                    }
                                                                    int v905;
                                                                    v905 = v904 + v900;
                                                                    unsigned char v906;
                                                                    v906 = v876[v905];
                                                                    v879[v900] = v906;
                                                                    v900 += 1 ;
                                                                }
                                                                v910 = Union17{Union17_1{v877, v879}};
                                                            } else {
                                                                v910 = Union17{Union17_0{}};
                                                            }
                                                            switch (v910.tag) {
                                                                case 0: { // None
                                                                    v941 = Union12{Union12_0{}};
                                                                    break;
                                                                }
                                                                case 1: { // Some
                                                                    static_array<unsigned char,2> v911 = v910.case1.v0; static_array<unsigned char,3> v912 = v910.case1.v1;
                                                                    static_array<unsigned char,1> v913;
                                                                    int v915;
                                                                    v915 = 0;
                                                                    while (while_method_6(v915)){
                                                                        unsigned char v917;
                                                                        v917 = v912[v915];
                                                                        v913[v915] = v917;
                                                                        v915 += 1 ;
                                                                    }
                                                                    static_array<unsigned char,5> v919;
                                                                    int v921;
                                                                    v921 = 0;
                                                                    while (while_method_0(v921)){
                                                                        unsigned char v923;
                                                                        v923 = v875[v921];
                                                                        v919[v921] = v923;
                                                                        v921 += 1 ;
                                                                    }
                                                                    int v925;
                                                                    v925 = 0;
                                                                    while (while_method_0(v925)){
                                                                        unsigned char v927;
                                                                        v927 = v911[v925];
                                                                        int v929;
                                                                        v929 = 2 + v925;
                                                                        v919[v929] = v927;
                                                                        v925 += 1 ;
                                                                    }
                                                                    int v930;
                                                                    v930 = 0;
                                                                    while (while_method_6(v930)){
                                                                        unsigned char v932;
                                                                        v932 = v913[v930];
                                                                        int v934;
                                                                        v934 = 4 + v930;
                                                                        v919[v934] = v932;
                                                                        v930 += 1 ;
                                                                    }
                                                                    v941 = Union12{Union12_1{v919}};
                                                                    break;
                                                                }
                                                                default: {
                                                                    assert("Invalid tag." && false); __trap();
                                                                }
                                                            }
                                                            break;
                                                        }
                                                        default: {
                                                            assert("Invalid tag." && false); __trap();
                                                        }
                                                    }
                                                    switch (v941.tag) {
                                                        case 0: { // None
                                                            static_array<unsigned char,2> v943;
                                                            static_array<unsigned char,5> v945;
                                                            int v947; int v948; int v949; unsigned char v950;
                                                            Tuple23 tmp80 = Tuple23{0, 0, 0, 12u};
                                                            v947 = tmp80.v0; v948 = tmp80.v1; v949 = tmp80.v2; v950 = tmp80.v3;
                                                            while (while_method_17(v947)){
                                                                unsigned char v952;
                                                                v952 = v84[v947];
                                                                bool v954;
                                                                v954 = v949 < 2;
                                                                int v962; int v963; unsigned char v964;
                                                                if (v954){
                                                                    unsigned char v955;
                                                                    v955 = v952 / 4u;
                                                                    bool v956;
                                                                    v956 = v950 == v955;
                                                                    int v957;
                                                                    if (v956){
                                                                        v957 = v949;
                                                                    } else {
                                                                        v957 = 0;
                                                                    }
                                                                    v943[v957] = v952;
                                                                    int v958;
                                                                    v958 = v957 + 1;
                                                                    v962 = v947; v963 = v958; v964 = v955;
                                                                } else {
                                                                    break;
                                                                }
                                                                v948 = v962;
                                                                v949 = v963;
                                                                v950 = v964;
                                                                v947 += 1 ;
                                                            }
                                                            bool v965;
                                                            v965 = v949 == 2;
                                                            Union16 v976;
                                                            if (v965){
                                                                int v966;
                                                                v966 = 0;
                                                                while (while_method_2(v966)){
                                                                    int v968;
                                                                    v968 = v948 + -1;
                                                                    bool v969;
                                                                    v969 = v966 < v968;
                                                                    int v970;
                                                                    if (v969){
                                                                        v970 = 0;
                                                                    } else {
                                                                        v970 = 2;
                                                                    }
                                                                    int v971;
                                                                    v971 = v970 + v966;
                                                                    unsigned char v972;
                                                                    v972 = v84[v971];
                                                                    v945[v966] = v972;
                                                                    v966 += 1 ;
                                                                }
                                                                v976 = Union16{Union16_1{v943, v945}};
                                                            } else {
                                                                v976 = Union16{Union16_0{}};
                                                            }
                                                            Union12 v999;
                                                            switch (v976.tag) {
                                                                case 0: { // None
                                                                    v999 = Union12{Union12_0{}};
                                                                    break;
                                                                }
                                                                case 1: { // Some
                                                                    static_array<unsigned char,2> v977 = v976.case1.v0; static_array<unsigned char,5> v978 = v976.case1.v1;
                                                                    static_array<unsigned char,3> v979;
                                                                    int v981;
                                                                    v981 = 0;
                                                                    while (while_method_1(v981)){
                                                                        unsigned char v983;
                                                                        v983 = v978[v981];
                                                                        v979[v981] = v983;
                                                                        v981 += 1 ;
                                                                    }
                                                                    static_array<unsigned char,5> v985;
                                                                    int v987;
                                                                    v987 = 0;
                                                                    while (while_method_0(v987)){
                                                                        unsigned char v989;
                                                                        v989 = v977[v987];
                                                                        v985[v987] = v989;
                                                                        v987 += 1 ;
                                                                    }
                                                                    int v991;
                                                                    v991 = 0;
                                                                    while (while_method_1(v991)){
                                                                        unsigned char v993;
                                                                        v993 = v979[v991];
                                                                        int v995;
                                                                        v995 = 2 + v991;
                                                                        v985[v995] = v993;
                                                                        v991 += 1 ;
                                                                    }
                                                                    v999 = Union12{Union12_1{v985}};
                                                                    break;
                                                                }
                                                                default: {
                                                                    assert("Invalid tag." && false); __trap();
                                                                }
                                                            }
                                                            switch (v999.tag) {
                                                                case 0: { // None
                                                                    static_array<unsigned char,5> v1001;
                                                                    int v1003;
                                                                    v1003 = 0;
                                                                    while (while_method_2(v1003)){
                                                                        unsigned char v1005;
                                                                        v1005 = v84[v1003];
                                                                        v1001[v1003] = v1005;
                                                                        v1003 += 1 ;
                                                                    }
                                                                    v1037 = v1001; v1038 = 0;
                                                                    break;
                                                                }
                                                                case 1: { // Some
                                                                    static_array<unsigned char,5> v1000 = v999.case1.v0;
                                                                    v1037 = v1000; v1038 = 1;
                                                                    break;
                                                                }
                                                                default: {
                                                                    assert("Invalid tag." && false); __trap();
                                                                }
                                                            }
                                                            break;
                                                        }
                                                        case 1: { // Some
                                                            static_array<unsigned char,5> v942 = v941.case1.v0;
                                                            v1037 = v942; v1038 = 2;
                                                            break;
                                                        }
                                                        default: {
                                                            assert("Invalid tag." && false); __trap();
                                                        }
                                                    }
                                                    break;
                                                }
                                                case 1: { // Some
                                                    static_array<unsigned char,5> v840 = v839.case1.v0;
                                                    v1037 = v840; v1038 = 3;
                                                    break;
                                                }
                                                default: {
                                                    assert("Invalid tag." && false); __trap();
                                                }
                                            }
                                            break;
                                        }
                                        case 1: { // Some
                                            static_array<unsigned char,5> v782 = v781.case1.v0;
                                            v1037 = v782; v1038 = 4;
                                            break;
                                        }
                                        default: {
                                            assert("Invalid tag." && false); __trap();
                                        }
                                    }
                                    break;
                                }
                                case 1: { // Some
                                    static_array<unsigned char,5> v743 = v742.case1.v0;
                                    v1037 = v743; v1038 = 5;
                                    break;
                                }
                                default: {
                                    assert("Invalid tag." && false); __trap();
                                }
                            }
                            break;
                        }
                        case 1: { // Some
                            static_array<unsigned char,5> v590 = v589.case1.v0;
                            v1037 = v590; v1038 = 6;
                            break;
                        }
                        default: {
                            assert("Invalid tag." && false); __trap();
                        }
                    }
                    break;
                }
                case 1: { // Some
                    static_array<unsigned char,5> v499 = v498.case1.v0;
                    v1037 = v499; v1038 = 7;
                    break;
                }
                default: {
                    assert("Invalid tag." && false); __trap();
                }
            }
            break;
        }
        case 1: { // Some
            static_array<unsigned char,5> v441 = v440.case1.v0;
            v1037 = v441; v1038 = 8;
            break;
        }
        default: {
            assert("Invalid tag." && false); __trap();
        }
    }
    return Tuple0{v1037, v1038};
}
__device__ void play_loop_31(unsigned char * v0, unsigned long long v1, unsigned char * v2, unsigned long long v3, StackMut0 & v4, Union4 v5){
    static_array_list<Union6,128> & v6 = v4.v2;
    unsigned long long & v7 = v4.v0;
    Union3 v8;
    v8 = Union3{Union3_1{v5}};
    Union3 v9;
    v9 = v8;
    while (while_method_5(v9)){
        Union3 v1621;
        switch (v9.tag) {
            case 0: { // None
                v1621 = Union3{Union3_0{}};
                break;
            }
            case 1: { // Some
                Union4 v11 = v9.case1.v0;
                switch (v11.tag) {
                    case 0: { // G_Flop
                        int v1504 = v11.case0.v0; static_array<static_array<unsigned char,2>,2> v1505 = v11.case0.v1; static_array<int,2> v1506 = v11.case0.v2; int v1507 = v11.case0.v3; static_array<int,2> v1508 = v11.case0.v4; Union5 v1509 = v11.case0.v5;
                        curandStatePhilox4_32_10_t & v1510 = v4.v4;
                        curandStatePhilox4_32_10_t & v1511 = v1510;
                        static_array<unsigned char,3> v1512; unsigned long long v1513;
                        Tuple8 tmp18 = draw_cards_32(v1511, v7);
                        v1512 = tmp18.v0; v1513 = tmp18.v1;
                        v4.v0 = v1513;
                        static_array_list<unsigned char,5> v1514;
                        v1514 = get_community_cards_35(v1509, v1512);
                        Union6 v1515;
                        v1515 = Union6{Union6_0{v1514}};
                        v6.push(v1515);
                        Union5 v1518;
                        switch (v1509.tag) {
                            case 1: { // Preflop
                                v1518 = Union5{Union5_0{v1512}};
                                break;
                            }
                            default: {
                                printf("%s\n", "Invalid street in flop.");
                                __trap();
                            }
                        }
                        int v1519;
                        v1519 = 2;
                        int v1520;
                        v1520 = 0;
                        Union4 v1521;
                        v1521 = try_round_36(v1519, v1505, v1506, v1520, v1508, v1518);
                        v1621 = Union3{Union3_1{v1521}};
                        break;
                    }
                    case 1: { // G_Fold
                        int v12 = v11.case1.v0; static_array<static_array<unsigned char,2>,2> v13 = v11.case1.v1; static_array<int,2> v14 = v11.case1.v2; int v15 = v11.case1.v3; static_array<int,2> v16 = v11.case1.v4; Union5 v17 = v11.case1.v5;
                        int v18;
                        v18 = v15 % 2;
                        int v19;
                        v19 = v14[v18];
                        int v21;
                        v21 = v15 + 1;
                        int v22;
                        v22 = v21 % 2;
                        Union6 v23;
                        v23 = Union6{Union6_1{v19, v22}};
                        v6.push(v23);
                        Union7 v24;
                        v24 = Union7{Union7_1{v12, v13, v14, v15, v16, v17}};
                        v4.v5 = v24;
                        Union3 v25;
                        v25 = Union3{Union3_0{}};
                        v4.v1 = v25;
                        v1621 = Union3{Union3_0{}};
                        break;
                    }
                    case 2: { // G_Preflop
                        curandStatePhilox4_32_10_t & v1585 = v4.v4;
                        curandStatePhilox4_32_10_t & v1586 = v1585;
                        static_array<unsigned char,2> v1587; unsigned long long v1588;
                        Tuple11 tmp23 = draw_cards_39(v1586, v7);
                        v1587 = tmp23.v0; v1588 = tmp23.v1;
                        v4.v0 = v1588;
                        curandStatePhilox4_32_10_t & v1589 = v4.v4;
                        curandStatePhilox4_32_10_t & v1590 = v1589;
                        static_array<unsigned char,2> v1591; unsigned long long v1592;
                        Tuple11 tmp24 = draw_cards_39(v1590, v7);
                        v1591 = tmp24.v0; v1592 = tmp24.v1;
                        v4.v0 = v1592;
                        Union6 v1593;
                        v1593 = Union6{Union6_3{0, v1587}};
                        v6.push(v1593);
                        Union6 v1594;
                        v1594 = Union6{Union6_3{1, v1591}};
                        v6.push(v1594);
                        static_array<static_array<unsigned char,2>,2> v1595;
                        v1595[0] = v1587;
                        v1595[1] = v1591;
                        static_array<int,2> v1597;
                        v1597[0] = 2;
                        v1597[1] = 1;
                        static_array<int,2> v1599;
                        int v1601;
                        v1601 = 0;
                        while (while_method_0(v1601)){
                            int v1603;
                            v1603 = v1597[v1601];
                            int v1605;
                            v1605 = 100 - v1603;
                            v1599[v1601] = v1605;
                            v1601 += 1 ;
                        }
                        int v1606;
                        v1606 = 2;
                        int v1607;
                        v1607 = 0;
                        Union5 v1608;
                        v1608 = Union5{Union5_1{}};
                        Union4 v1609;
                        v1609 = try_round_36(v1606, v1595, v1597, v1607, v1599, v1608);
                        v1621 = Union3{Union3_1{v1609}};
                        break;
                    }
                    case 3: { // G_River
                        int v1554 = v11.case3.v0; static_array<static_array<unsigned char,2>,2> v1555 = v11.case3.v1; static_array<int,2> v1556 = v11.case3.v2; int v1557 = v11.case3.v3; static_array<int,2> v1558 = v11.case3.v4; Union5 v1559 = v11.case3.v5;
                        curandStatePhilox4_32_10_t & v1560 = v4.v4;
                        curandStatePhilox4_32_10_t & v1561 = v1560;
                        static_array<unsigned char,1> v1562; unsigned long long v1563;
                        Tuple12 tmp27 = draw_cards_40(v1561, v7);
                        v1562 = tmp27.v0; v1563 = tmp27.v1;
                        v4.v0 = v1563;
                        static_array_list<unsigned char,5> v1564;
                        v1564 = get_community_cards_41(v1559, v1562);
                        Union6 v1565;
                        v1565 = Union6{Union6_0{v1564}};
                        v6.push(v1565);
                        Union5 v1580;
                        switch (v1559.tag) {
                            case 3: { // Turn
                                static_array<unsigned char,4> v1566 = v1559.case3.v0;
                                static_array<unsigned char,5> v1567;
                                int v1569;
                                v1569 = 0;
                                while (while_method_3(v1569)){
                                    unsigned char v1571;
                                    v1571 = v1566[v1569];
                                    v1567[v1569] = v1571;
                                    v1569 += 1 ;
                                }
                                int v1573;
                                v1573 = 0;
                                while (while_method_6(v1573)){
                                    unsigned char v1575;
                                    v1575 = v1562[v1573];
                                    int v1577;
                                    v1577 = 4 + v1573;
                                    v1567[v1577] = v1575;
                                    v1573 += 1 ;
                                }
                                v1580 = Union5{Union5_2{v1567}};
                                break;
                            }
                            default: {
                                printf("%s\n", "Invalid street in river.");
                                __trap();
                            }
                        }
                        int v1581;
                        v1581 = 2;
                        int v1582;
                        v1582 = 0;
                        Union4 v1583;
                        v1583 = try_round_36(v1581, v1555, v1556, v1582, v1558, v1580);
                        v1621 = Union3{Union3_1{v1583}};
                        break;
                    }
                    case 4: { // G_Round
                        int v107 = v11.case4.v0; static_array<static_array<unsigned char,2>,2> v108 = v11.case4.v1; static_array<int,2> v109 = v11.case4.v2; int v110 = v11.case4.v3; static_array<int,2> v111 = v11.case4.v4; Union5 v112 = v11.case4.v5;
                        int v113;
                        v113 = v110 % 2;
                        static_array<Union2,2> & v114 = v4.v3;
                        Union2 v115;
                        v115 = v114[v113];
                        switch (v115.tag) {
                            case 0: { // Computer
                                bool v117;
                                v117 = 12419088ull == v3;
                                bool v118;
                                v118 = v117 == false;
                                if (v118){
                                    assert("The params needs to have matching offsets." && v117);
                                } else {
                                }
                                bool v120;
                                v120 = 204570624ull == v1;
                                bool v121;
                                v121 = v120 == false;
                                if (v121){
                                    assert("The outputs needs to have matching offsets." && v120);
                                } else {
                                }
                                static_array_list<Union6,128> & v123 = v4.v2;
                                curandStatePhilox4_32_10_t & v124 = v4.v4;
                                curandStatePhilox4_32_10_t & v125 = v124;
                                unsigned int * v126;
                                v126 = reinterpret_cast<unsigned int *>(&v0[53477376ull]);
                                float * v128;
                                v128 = reinterpret_cast<float *>(&v0[0ull]);
                                int v130;
                                v130 = threadIdx.x;
                                int v131;
                                v131 = blockIdx.x;
                                int v132;
                                v132 = v131 * 256;
                                int v133;
                                v133 = v130 + v132;
                                unsigned long long v134;
                                v134 = (unsigned long long)v133;
                                curandStatePhilox4_32_10_t v135;
                                curand_init(12344321ull,v134,0ull,&v135);
                                float * v136;
                                v136 = reinterpret_cast<float *>(&v0[0ull]);
                                int v138;
                                v138 = blockIdx.x;
                                assert("Tensor range check" && 0 <= v138 && v138 < 24);
                                int v139;
                                v139 = 524288 * v138;
                                int v140;
                                v140 = threadIdx.x;
                                int v141;
                                v141 = blockIdx.x;
                                int v142;
                                v142 = v141 * 256;
                                int v143;
                                v143 = v140 + v142;
                                unsigned long long v144;
                                v144 = (unsigned long long)v143;
                                curandStatePhilox4_32_10_t v145;
                                curand_init(12344321ull,v144,0ull,&v145);
                                int v146;
                                v146 = threadIdx.x;
                                int v147;
                                v147 = v146;
                                while (while_method_7(v147)){
                                    bool v149;
                                    v149 = 0 <= v147;
                                    bool v150;
                                    v150 = v149 == false;
                                    if (v150){
                                        assert("The index needs to be zero or positive." && v149);
                                    } else {
                                    }
                                    int v152;
                                    v152 = v147 % 2048;
                                    int v153;
                                    v153 = v147 / 2048;
                                    bool v154;
                                    v154 = v153 < 256;
                                    bool v155;
                                    v155 = v154 == false;
                                    if (v155){
                                        assert("The last element of the projection dimensions needs to be greater than the index remainder." && v154);
                                    } else {
                                    }
                                    assert("Tensor range check" && 0 <= v153 && v153 < 256);
                                    assert("Tensor range check" && 0 <= v152 && v152 < 2048);
                                    int v157;
                                    v157 = v152 + v139;
                                    int v158;
                                    v158 = 2048 * v153;
                                    int v159;
                                    v159 = v158 + v157;
                                    v136[v159] = 0.0f;
                                    v147 += 256 ;
                                }
                                asm("barrier.cta.sync %0;" :: "r"(0));
                                int v160;
                                v160 = threadIdx.x;
                                assert("Tensor range check" && 0 <= v160 && v160 < 256);
                                int v161;
                                v161 = 2048 * v160;
                                int v162;
                                v162 = v161 + v139;
                                int v163;
                                v163 = v123.length;
                                bool v164;
                                v164 = 128 >= v163;
                                bool v165;
                                v165 = v164 == false;
                                if (v165){
                                    assert("The type level dimension has to equal the value passed at runtime into create." && v164);
                                } else {
                                }
                                static_array_list<Union8,128> v167;
                                v167 = static_array_list<Union8,128>{};
                                v167.unsafe_set_length(v163);
                                int v169;
                                v169 = 0;
                                while (while_method_4(v163, v169)){
                                    Union6 v171;
                                    v171 = v123[v169];
                                    Union8 v177;
                                    switch (v171.tag) {
                                        case 2: { // PlayerAction
                                            int v173 = v171.case2.v0; Union1 v174 = v171.case2.v1;
                                            v177 = Union8{Union8_1{v174}};
                                            break;
                                        }
                                        default: {
                                            v177 = Union8{Union8_0{}};
                                        }
                                    }
                                    v167[v169] = v177;
                                    v169 += 1 ;
                                }
                                static_array<int,2> v178;
                                int v180;
                                v180 = 0;
                                while (while_method_0(v180)){
                                    int v182;
                                    v182 = v180 + v113;
                                    int v183;
                                    v183 = v109[v182];
                                    v178[v180] = v183;
                                    v180 += 1 ;
                                }
                                static_array<int,2> v185;
                                int v187;
                                v187 = 0;
                                while (while_method_0(v187)){
                                    int v189;
                                    v189 = v187 + v113;
                                    int v190;
                                    v190 = v111[v189];
                                    v185[v187] = v190;
                                    v187 += 1 ;
                                }
                                static_array<unsigned char,2> v192;
                                v192 = v108[v113];
                                static_array_list<unsigned char,5> v194;
                                v194 = static_array_list<unsigned char,5>{};
                                switch (v112.tag) {
                                    case 0: { // Flop
                                        static_array<unsigned char,3> v196 = v112.case0.v0;
                                        int v197;
                                        v197 = 0;
                                        while (while_method_1(v197)){
                                            unsigned char v199;
                                            v199 = v196[v197];
                                            v194.push(v199);
                                            v197 += 1 ;
                                        }
                                        break;
                                    }
                                    case 1: { // Preflop
                                        break;
                                    }
                                    case 2: { // River
                                        static_array<unsigned char,5> v206 = v112.case2.v0;
                                        int v207;
                                        v207 = 0;
                                        while (while_method_2(v207)){
                                            unsigned char v209;
                                            v209 = v206[v207];
                                            v194.push(v209);
                                            v207 += 1 ;
                                        }
                                        break;
                                    }
                                    case 3: { // Turn
                                        static_array<unsigned char,4> v201 = v112.case3.v0;
                                        int v202;
                                        v202 = 0;
                                        while (while_method_3(v202)){
                                            unsigned char v204;
                                            v204 = v201[v202];
                                            v194.push(v204);
                                            v202 += 1 ;
                                        }
                                        break;
                                    }
                                    default: {
                                        assert("Invalid tag." && false); __trap();
                                    }
                                }
                                float * v211;
                                v211 = v136+v162;
                                int v213;
                                v213 = v167.length;
                                bool v214;
                                v214 = v213 == 0;
                                if (v214){
                                    v211[0] = 1.0f;
                                } else {
                                }
                                int v215;
                                v215 = v167.length;
                                int v216;
                                v216 = 0;
                                while (while_method_4(v215, v216)){
                                    Union8 v218;
                                    v218 = v167[v216];
                                    int v220;
                                    v220 = v216 * 14;
                                    int v221;
                                    v221 = 1 + v220;
                                    switch (v218.tag) {
                                        case 0: { // None
                                            v211[v221] = 1.0f;
                                            break;
                                        }
                                        case 1: { // Some
                                            Union1 v222 = v218.case1.v0;
                                            int v223;
                                            v223 = v221 + 1;
                                            switch (v222.tag) {
                                                case 0: { // A_All_In
                                                    v211[v223] = 1.0f;
                                                    break;
                                                }
                                                case 1: { // A_Call
                                                    int v224;
                                                    v224 = v223 + 1;
                                                    v211[v224] = 1.0f;
                                                    break;
                                                }
                                                case 2: { // A_Fold
                                                    int v225;
                                                    v225 = v223 + 2;
                                                    v211[v225] = 1.0f;
                                                    break;
                                                }
                                                case 3: { // A_Raise
                                                    int v226 = v222.case3.v0;
                                                    int v227;
                                                    v227 = v223 + 3;
                                                    bool v228;
                                                    v228 = 1 <= v226;
                                                    bool v230;
                                                    if (v228){
                                                        bool v229;
                                                        v229 = v226 < 1023;
                                                        v230 = v229;
                                                    } else {
                                                        v230 = false;
                                                    }
                                                    bool v231;
                                                    v231 = v230 == false;
                                                    if (v231){
                                                        assert("Pickle failure. The input is out of the bounds of the given range." && v230);
                                                    } else {
                                                    }
                                                    int v233;
                                                    v233 = v226 - 1;
                                                    unsigned int v234;
                                                    v234 = (unsigned int)v233;
                                                    method_42(v234, v211, v227);
                                                    break;
                                                }
                                                default: {
                                                    assert("Invalid tag." && false); __trap();
                                                }
                                            }
                                            break;
                                        }
                                        default: {
                                            assert("Invalid tag." && false); __trap();
                                        }
                                    }
                                    v216 += 1 ;
                                }
                                int v235;
                                v235 = 0;
                                while (while_method_0(v235)){
                                    int v237;
                                    v237 = v178[v235];
                                    int v239;
                                    v239 = v235 * 11;
                                    int v240;
                                    v240 = 1794 + v239;
                                    bool v241;
                                    v241 = 0 <= v237;
                                    bool v243;
                                    if (v241){
                                        bool v242;
                                        v242 = v237 < 1023;
                                        v243 = v242;
                                    } else {
                                        v243 = false;
                                    }
                                    bool v244;
                                    v244 = v243 == false;
                                    if (v244){
                                        assert("Pickle failure. The input is out of the bounds of the given range." && v243);
                                    } else {
                                    }
                                    unsigned int v246;
                                    v246 = (unsigned int)v237;
                                    method_43(v246, v211, v240);
                                    v235 += 1 ;
                                }
                                int v247;
                                v247 = 0;
                                while (while_method_0(v247)){
                                    int v249;
                                    v249 = v185[v247];
                                    int v251;
                                    v251 = v247 * 11;
                                    int v252;
                                    v252 = 1817 + v251;
                                    bool v253;
                                    v253 = 0 <= v249;
                                    bool v255;
                                    if (v253){
                                        bool v254;
                                        v254 = v249 < 1023;
                                        v255 = v254;
                                    } else {
                                        v255 = false;
                                    }
                                    bool v256;
                                    v256 = v255 == false;
                                    if (v256){
                                        assert("Pickle failure. The input is out of the bounds of the given range." && v255);
                                    } else {
                                    }
                                    unsigned int v258;
                                    v258 = (unsigned int)v249;
                                    method_43(v258, v211, v252);
                                    v247 += 1 ;
                                }
                                int v259;
                                v259 = 0;
                                while (while_method_0(v259)){
                                    unsigned char v261;
                                    v261 = v192[v259];
                                    int v263;
                                    v263 = v259 * 17;
                                    int v264;
                                    v264 = 1840 + v263;
                                    unsigned char v265;
                                    v265 = v261 % 4u;
                                    int v266;
                                    v266 = (int)v265;
                                    unsigned char v267;
                                    v267 = v261 / 4u;
                                    int v268;
                                    v268 = (int)v267;
                                    unsigned int v269;
                                    v269 = (unsigned int)v266;
                                    int v270;
                                    v270 = (int)v269;
                                    bool v271;
                                    v271 = v270 < 4;
                                    bool v272;
                                    v272 = v271 == false;
                                    if (v272){
                                        assert("Pickle failure. Int value out of bounds." && v271);
                                    } else {
                                    }
                                    int v274;
                                    v274 = v264 + v270;
                                    v211[v274] = 1.0f;
                                    int v275;
                                    v275 = v264 + 4;
                                    unsigned int v276;
                                    v276 = (unsigned int)v268;
                                    int v277;
                                    v277 = (int)v276;
                                    bool v278;
                                    v278 = v277 < 13;
                                    bool v279;
                                    v279 = v278 == false;
                                    if (v279){
                                        assert("Pickle failure. Int value out of bounds." && v278);
                                    } else {
                                    }
                                    int v281;
                                    v281 = v275 + v277;
                                    v211[v281] = 1.0f;
                                    v259 += 1 ;
                                }
                                int v282;
                                v282 = v194.length;
                                bool v283;
                                v283 = v282 == 0;
                                if (v283){
                                    v211[1874] = 1.0f;
                                } else {
                                }
                                int v284;
                                v284 = v194.length;
                                int v285;
                                v285 = 0;
                                while (while_method_4(v284, v285)){
                                    unsigned char v287;
                                    v287 = v194[v285];
                                    int v289;
                                    v289 = v285 * 17;
                                    int v290;
                                    v290 = 1875 + v289;
                                    unsigned char v291;
                                    v291 = v287 % 4u;
                                    int v292;
                                    v292 = (int)v291;
                                    unsigned char v293;
                                    v293 = v287 / 4u;
                                    int v294;
                                    v294 = (int)v293;
                                    unsigned int v295;
                                    v295 = (unsigned int)v292;
                                    int v296;
                                    v296 = (int)v295;
                                    bool v297;
                                    v297 = v296 < 4;
                                    bool v298;
                                    v298 = v297 == false;
                                    if (v298){
                                        assert("Pickle failure. Int value out of bounds." && v297);
                                    } else {
                                    }
                                    int v300;
                                    v300 = v290 + v296;
                                    v211[v300] = 1.0f;
                                    int v301;
                                    v301 = v290 + 4;
                                    unsigned int v302;
                                    v302 = (unsigned int)v294;
                                    int v303;
                                    v303 = (int)v302;
                                    bool v304;
                                    v304 = v303 < 13;
                                    bool v305;
                                    v305 = v304 == false;
                                    if (v305){
                                        assert("Pickle failure. Int value out of bounds." && v304);
                                    } else {
                                    }
                                    int v307;
                                    v307 = v301 + v303;
                                    v211[v307] = 1.0f;
                                    v285 += 1 ;
                                }
                                asm("barrier.cta.sync %0;" :: "r"(0));
                                int v308;
                                v308 = 0;
                                int v309;
                                v309 = 4;
                                int v310;
                                v310 = int_range_44(v309, v308, v145);
                                extern __shared__ unsigned char v311[];
                                int * v312;
                                v312 = reinterpret_cast<int *>(&v311[0ull]);
                                int v314;
                                v314 = threadIdx.x;
                                bool v315;
                                v315 = v314 == 0;
                                if (v315){
                                    v312[0] = v310;
                                } else {
                                }
                                asm("barrier.cta.sync %0;" :: "r"(0));
                                int v316;
                                v316 = v312[0];
                                asm("barrier.cta.sync %0;" :: "r"(0));
                                float * v317;
                                v317 = reinterpret_cast<float *>(&v0[0ull]);
                                float * v319;
                                v319 = reinterpret_cast<float *>(&v2[0ull]);
                                assert("Tensor range check" && 0 <= v316 && v316 < 4);
                                int v321;
                                v321 = 262144 * v316;
                                float * v322;
                                v322 = reinterpret_cast<float *>(&v0[50331648ull]);
                                int v324;
                                v324 = blockIdx.x;
                                assert("Tensor range check" && 0 <= v324 && v324 < 24);
                                int v325;
                                v325 = 524288 * v324;
                                int v326;
                                v326 = blockIdx.x;
                                assert("Tensor range check" && 0 <= v326 && v326 < 24);
                                int v327;
                                v327 = 32768 * v326;
                                cuda::pipeline<cuda::thread_scope_thread> v328 = cuda::make_pipeline();
                                extern __shared__ unsigned char v329[];
                                float * v330;
                                v330 = reinterpret_cast<float *>(&v329[0ull]);
                                float * v332;
                                v332 = reinterpret_cast<float *>(&v329[34816ull]);
                                float * v334;
                                v334 = reinterpret_cast<float *>(&v329[0ull]);
                                int v336;
                                v336 = threadIdx.x;
                                int v337;
                                v337 = v336 / 32;
                                bool v338;
                                v338 = 0 <= v337;
                                bool v339;
                                v339 = v338 == false;
                                if (v339){
                                    assert("The index needs to be zero or positive." && v338);
                                } else {
                                }
                                int v341;
                                v341 = v337 % 8;
                                int v342;
                                v342 = v337 / 8;
                                bool v343;
                                v343 = v342 < 1;
                                bool v344;
                                v344 = v343 == false;
                                if (v344){
                                    assert("The last element of the projection dimensions needs to be greater than the index remainder." && v343);
                                } else {
                                }
                                assert("Tensor range check" && 0 <= v342 && v342 < 1);
                                assert("Tensor range check" && 0 <= v341 && v341 < 8);
                                int v346;
                                v346 = 16 * v341;
                                int v347;
                                v347 = 17408 * v342;
                                int v348;
                                v348 = v347 + v346;
                                float * v349;
                                v349 = v334+v348;
                                assert("Tensor range check" && 0 <= v342 && v342 < 1);
                                int v351;
                                v351 = 8704 * v342;
                                int v352;
                                v352 = threadIdx.x;
                                int v353;
                                v353 = v352 % 32;
                                bool v354;
                                v354 = 0 <= v353;
                                bool v355;
                                v355 = v354 == false;
                                if (v355){
                                    assert("The index needs to be zero or positive." && v354);
                                } else {
                                }
                                int v357;
                                v357 = v353 % 4;
                                int v358;
                                v358 = v353 / 4;
                                bool v359;
                                v359 = v358 < 8;
                                bool v360;
                                v360 = v359 == false;
                                if (v360){
                                    assert("The last element of the projection dimensions needs to be greater than the index remainder." && v359);
                                } else {
                                }
                                assert("Tensor range check" && 0 <= v358 && v358 < 8);
                                assert("Tensor range check" && 0 <= v357 && v357 < 4);
                                int v362;
                                v362 = v357 + v351;
                                int v363;
                                v363 = 68 * v358;
                                int v364;
                                v364 = v363 + v362;
                                float * v365;
                                v365 = v330+v364;
                                assert("Tensor range check" && 0 <= v341 && v341 < 8);
                                int v367;
                                v367 = 1088 * v341;
                                int v368;
                                v368 = threadIdx.x;
                                int v369;
                                v369 = v368 % 32;
                                bool v370;
                                v370 = 0 <= v369;
                                bool v371;
                                v371 = v370 == false;
                                if (v371){
                                    assert("The index needs to be zero or positive." && v370);
                                } else {
                                }
                                int v373;
                                v373 = v369 % 4;
                                int v374;
                                v374 = v369 / 4;
                                bool v375;
                                v375 = v374 < 8;
                                bool v376;
                                v376 = v375 == false;
                                if (v376){
                                    assert("The last element of the projection dimensions needs to be greater than the index remainder." && v375);
                                } else {
                                }
                                assert("Tensor range check" && 0 <= v374 && v374 < 8);
                                assert("Tensor range check" && 0 <= v373 && v373 < 4);
                                int v378;
                                v378 = v373 + v367;
                                int v379;
                                v379 = 68 * v374;
                                int v380;
                                v380 = v379 + v378;
                                float * v381;
                                v381 = v332+v380;
                                wmma::fragment<wmma::accumulator, 16, 16, 8, float> v383[8];
                                int v384;
                                v384 = 0;
                                while (while_method_0(v384)){
                                    int v386;
                                    v386 = 0;
                                    while (while_method_6(v386)){
                                        assert("Tensor range check" && 0 <= v384 && v384 < 2);
                                        assert("Tensor range check" && 0 <= v386 && v386 < 1);
                                        int v388;
                                        v388 = 128 * v386;
                                        int v389;
                                        v389 = v388 + v327;
                                        int v390;
                                        v390 = 16384 * v384;
                                        int v391;
                                        v391 = v390 + v389;
                                        float * v392;
                                        v392 = v322+v391;
                                        // Pushing the loop unrolling to: 0
                                        int v394;
                                        v394 = 0;
                                        #pragma unroll
                                        while (while_method_10(v394)){
                                            int v396;
                                            v396 = 0;
                                            #pragma unroll
                                            while (while_method_6(v396)){
                                                assert("Tensor range check" && 0 <= v394 && v394 < 8);
                                                assert("Tensor range check" && 0 <= v396 && v396 < 1);
                                                int v398;
                                                v398 = v394 + v396;
                                                wmma::fragment<wmma::accumulator, 16, 16, 8, float> & v399 = v383[v398];
                                                wmma::fill_fragment(v399, 0.0f);
                                                v396 += 1 ;
                                            }
                                            v394 += 1 ;
                                        }
                                        // Poping the loop unrolling to: 0
                                        int v400;
                                        v400 = 0;
                                        while (while_method_11(v400)){
                                            int v402;
                                            v402 = v400 + 1;
                                            bool v403;
                                            v403 = v400 == 0;
                                            int v404;
                                            v404 = v400 % 2;
                                            bool v405;
                                            v405 = 0 <= v400;
                                            bool v406;
                                            v406 = v405 == false;
                                            if (v406){
                                                assert("The index needs to be zero or positive." && v405);
                                            } else {
                                            }
                                            bool v408;
                                            v408 = v400 < 32;
                                            bool v409;
                                            v409 = v408 == false;
                                            if (v409){
                                                assert("The last element of the projection dimensions needs to be greater than the index remainder." && v408);
                                            } else {
                                            }
                                            bool v411;
                                            v411 = v402 < 32;
                                            Union9 v417;
                                            if (v411){
                                                bool v412;
                                                v412 = 0 <= v402;
                                                bool v413;
                                                v413 = v412 == false;
                                                if (v413){
                                                    assert("The index needs to be zero or positive." && v412);
                                                } else {
                                                }
                                                v417 = Union9{Union9_1{v402}};
                                            } else {
                                                v417 = Union9{Union9_0{}};
                                            }
                                            assert("Tensor range check" && 0 <= v384 && v384 < 2);
                                            int v418;
                                            v418 = 262144 * v384;
                                            int v419;
                                            v419 = v418 + v325;
                                            assert("Tensor range check" && 0 <= v400 && v400 < 32);
                                            int v420;
                                            v420 = 64 * v400;
                                            int v421;
                                            v421 = v420 + v419;
                                            float * v422;
                                            v422 = v317+v421;
                                            assert("Tensor range check" && 0 <= v386 && v386 < 1);
                                            int v424;
                                            v424 = 262144 * v386;
                                            int v425;
                                            v425 = v424 + v321;
                                            if (v403){
                                                assert("Tensor range check" && 0 <= v400 && v400 < 32);
                                                int v426;
                                                v426 = v420 + v425;
                                                float * v427;
                                                v427 = v319+v426;
                                                // Pushing the loop unrolling to: 0
                                                v328.producer_acquire();
                                                int v429;
                                                v429 = threadIdx.x;
                                                bool v430;
                                                v430 = 0 <= v429;
                                                bool v431;
                                                v431 = v430 == false;
                                                if (v431){
                                                    assert("The index needs to be zero or positive." && v430);
                                                } else {
                                                }
                                                int v433;
                                                v433 = v429 % 16;
                                                int v434;
                                                v434 = v429 / 16;
                                                bool v435;
                                                v435 = v434 < 16;
                                                bool v436;
                                                v436 = v435 == false;
                                                if (v436){
                                                    assert("The last element of the projection dimensions needs to be greater than the index remainder." && v435);
                                                } else {
                                                }
                                                assert("Tensor range check" && 0 <= v434 && v434 < 16);
                                                assert("Tensor range check" && 0 <= v433 && v433 < 16);
                                                int v438;
                                                v438 = 4 * v433;
                                                int v439;
                                                v439 = 68 * v434;
                                                int v440;
                                                v440 = v439 + v438;
                                                int v441;
                                                v441 = 2048 * v434;
                                                int v442;
                                                v442 = v441 + v438;
                                                float * v443;
                                                v443 = v332+v440;
                                                float * v445;
                                                v445 = v427+v442;
                                                int v447;
                                                v447 = 0;
                                                #pragma unroll
                                                while (while_method_10(v447)){
                                                    int v449;
                                                    v449 = 0;
                                                    #pragma unroll
                                                    while (while_method_6(v449)){
                                                        assert("Tensor range check" && 0 <= v447 && v447 < 8);
                                                        assert("Tensor range check" && 0 <= v449 && v449 < 1);
                                                        int v451;
                                                        v451 = 64 * v449;
                                                        int v452;
                                                        v452 = 1088 * v447;
                                                        int v453;
                                                        v453 = v452 + v451;
                                                        int v454;
                                                        v454 = 32768 * v447;
                                                        int v455;
                                                        v455 = v454 + v451;
                                                        constexpr int v456 = sizeof(float) * 4;
                                                        assert("Pointer alignment check" && (unsigned long long)(v445 + v455) % v456 == 0 && (unsigned long long)(v443 + v453) % v456 == 0);
                                                        cuda::memcpy_async(v443 + v453, v445 + v455, cuda::aligned_size_t<v456>(v456), v328);
                                                        v449 += 1 ;
                                                    }
                                                    v447 += 1 ;
                                                }
                                                v328.producer_commit();
                                                // Poping the loop unrolling to: 0
                                            } else {
                                            }
                                            // Pushing the loop unrolling to: 0
                                            int v457;
                                            v457 = threadIdx.x;
                                            bool v458;
                                            v458 = 0 <= v457;
                                            bool v459;
                                            v459 = v458 == false;
                                            if (v459){
                                                assert("The index needs to be zero or positive." && v458);
                                            } else {
                                            }
                                            int v461;
                                            v461 = v457 % 16;
                                            int v462;
                                            v462 = v457 / 16;
                                            bool v463;
                                            v463 = v462 < 16;
                                            bool v464;
                                            v464 = v463 == false;
                                            if (v464){
                                                assert("The last element of the projection dimensions needs to be greater than the index remainder." && v463);
                                            } else {
                                            }
                                            assert("Tensor range check" && 0 <= v462 && v462 < 16);
                                            assert("Tensor range check" && 0 <= v461 && v461 < 16);
                                            int v466;
                                            v466 = 4 * v461;
                                            int v467;
                                            v467 = 68 * v462;
                                            int v468;
                                            v468 = v467 + v466;
                                            int v469;
                                            v469 = 2048 * v462;
                                            int v470;
                                            v470 = v469 + v466;
                                            float * v471;
                                            v471 = v330+v468;
                                            float * v473;
                                            v473 = v422+v470;
                                            int v475;
                                            v475 = 0;
                                            #pragma unroll
                                            while (while_method_10(v475)){
                                                int v477;
                                                v477 = 0;
                                                #pragma unroll
                                                while (while_method_6(v477)){
                                                    assert("Tensor range check" && 0 <= v475 && v475 < 8);
                                                    assert("Tensor range check" && 0 <= v477 && v477 < 1);
                                                    int v479;
                                                    v479 = 64 * v477;
                                                    int v480;
                                                    v480 = 1088 * v475;
                                                    int v481;
                                                    v481 = v480 + v479;
                                                    int v482;
                                                    v482 = 32768 * v475;
                                                    int v483;
                                                    v483 = v482 + v479;
                                                    int4* v484;
                                                    v484 = reinterpret_cast<int4*>(v473 + v483);
                                                    int4* v485;
                                                    v485 = reinterpret_cast<int4*>(v471 + v481);
                                                    assert("Pointer alignment check" && (unsigned long long)(v484) % 4 == 0 && (unsigned long long)(v485) % 4 == 0);
                                                    *v485 = *v484;
                                                    v477 += 1 ;
                                                }
                                                v475 += 1 ;
                                            }
                                            // Poping the loop unrolling to: 0
                                            wmma::fragment<wmma::matrix_a, 16, 16, 8, wmma::precision::tf32, wmma::row_major> v486[1];
                                            wmma::fragment<wmma::matrix_b, 16, 16, 8, wmma::precision::tf32, wmma::col_major> v487[8];
                                            cuda::pipeline_consumer_wait_prior<0>(v328);;
                                            asm("barrier.cta.sync %0;" :: "r"(0));
                                            // Pushing the loop unrolling to: 0
                                            int v488;
                                            v488 = 0;
                                            #pragma unroll
                                            while (while_method_6(v488)){
                                                int v490;
                                                v490 = 0;
                                                #pragma unroll
                                                while (while_method_10(v490)){
                                                    assert("Tensor range check" && 0 <= v488 && v488 < 1);
                                                    assert("Tensor range check" && 0 <= v490 && v490 < 8);
                                                    int v492;
                                                    v492 = 8 * v488;
                                                    int v493;
                                                    v493 = v492 + v490;
                                                    wmma::fragment<wmma::matrix_b, 16, 16, 8, wmma::precision::tf32, wmma::col_major> & v494 = v487[v493];
                                                    assert("Tensor range check" && 0 <= v488 && v488 < 1);
                                                    int v495;
                                                    v495 = 1088 * v488;
                                                    assert("Tensor range check" && 0 <= v490 && v490 < 8);
                                                    int v496;
                                                    v496 = 8 * v490;
                                                    int v497;
                                                    v497 = v496 + v495;
                                                    int v498;
                                                    v498 = 0;
                                                    #pragma unroll
                                                    while (while_method_0(v498)){
                                                        int v500;
                                                        v500 = 0;
                                                        #pragma unroll
                                                        while (while_method_0(v500)){
                                                            assert("Tensor range check" && 0 <= v498 && v498 < 2);
                                                            assert("Tensor range check" && 0 <= v500 && v500 < 2);
                                                            int v502;
                                                            v502 = 4 * v500;
                                                            int v503;
                                                            v503 = v502 + v497;
                                                            int v504;
                                                            v504 = 544 * v498;
                                                            int v505;
                                                            v505 = v504 + v503;
                                                            float v506;
                                                            v506 = v381[v505];
                                                            bool v507;
                                                            v507 = 0 <= v500;
                                                            bool v509;
                                                            if (v507){
                                                                bool v508;
                                                                v508 = v500 < 2;
                                                                v509 = v508;
                                                            } else {
                                                                v509 = false;
                                                            }
                                                            bool v510;
                                                            v510 = v509 == false;
                                                            if (v510){
                                                                assert("The indices should be inside the range of the dimension." && v509);
                                                            } else {
                                                            }
                                                            bool v512;
                                                            v512 = 0 <= v498;
                                                            bool v514;
                                                            if (v512){
                                                                bool v513;
                                                                v513 = v498 < 2;
                                                                v514 = v513;
                                                            } else {
                                                                v514 = false;
                                                            }
                                                            bool v515;
                                                            v515 = v514 == false;
                                                            if (v515){
                                                                assert("The indices should be inside the range of the dimension." && v514);
                                                            } else {
                                                            }
                                                            int v517;
                                                            v517 = v498 * 2;
                                                            int v518;
                                                            v518 = v500 + v517;
                                                            v494.x[v518] = wmma::__float_to_tf32(v506);
                                                            v500 += 1 ;
                                                        }
                                                        v498 += 1 ;
                                                    }
                                                    v490 += 1 ;
                                                }
                                                v488 += 1 ;
                                            }
                                            // Poping the loop unrolling to: 0
                                            v328.consumer_release();
                                            switch (v417.tag) {
                                                case 0: { // None
                                                    break;
                                                }
                                                case 1: { // Some
                                                    int v519 = v417.case1.v0;
                                                    assert("Tensor range check" && 0 <= v519 && v519 < 32);
                                                    int v520;
                                                    v520 = 64 * v519;
                                                    int v521;
                                                    v521 = v520 + v425;
                                                    float * v522;
                                                    v522 = v319+v521;
                                                    asm("barrier.cta.sync %0;" :: "r"(0));
                                                    // Pushing the loop unrolling to: 0
                                                    v328.producer_acquire();
                                                    int v524;
                                                    v524 = threadIdx.x;
                                                    bool v525;
                                                    v525 = 0 <= v524;
                                                    bool v526;
                                                    v526 = v525 == false;
                                                    if (v526){
                                                        assert("The index needs to be zero or positive." && v525);
                                                    } else {
                                                    }
                                                    int v528;
                                                    v528 = v524 % 16;
                                                    int v529;
                                                    v529 = v524 / 16;
                                                    bool v530;
                                                    v530 = v529 < 16;
                                                    bool v531;
                                                    v531 = v530 == false;
                                                    if (v531){
                                                        assert("The last element of the projection dimensions needs to be greater than the index remainder." && v530);
                                                    } else {
                                                    }
                                                    assert("Tensor range check" && 0 <= v529 && v529 < 16);
                                                    assert("Tensor range check" && 0 <= v528 && v528 < 16);
                                                    int v533;
                                                    v533 = 4 * v528;
                                                    int v534;
                                                    v534 = 68 * v529;
                                                    int v535;
                                                    v535 = v534 + v533;
                                                    int v536;
                                                    v536 = 2048 * v529;
                                                    int v537;
                                                    v537 = v536 + v533;
                                                    float * v538;
                                                    v538 = v332+v535;
                                                    float * v540;
                                                    v540 = v522+v537;
                                                    int v542;
                                                    v542 = 0;
                                                    #pragma unroll
                                                    while (while_method_10(v542)){
                                                        int v544;
                                                        v544 = 0;
                                                        #pragma unroll
                                                        while (while_method_6(v544)){
                                                            assert("Tensor range check" && 0 <= v542 && v542 < 8);
                                                            assert("Tensor range check" && 0 <= v544 && v544 < 1);
                                                            int v546;
                                                            v546 = 64 * v544;
                                                            int v547;
                                                            v547 = 1088 * v542;
                                                            int v548;
                                                            v548 = v547 + v546;
                                                            int v549;
                                                            v549 = 32768 * v542;
                                                            int v550;
                                                            v550 = v549 + v546;
                                                            constexpr int v551 = sizeof(float) * 4;
                                                            assert("Pointer alignment check" && (unsigned long long)(v540 + v550) % v551 == 0 && (unsigned long long)(v538 + v548) % v551 == 0);
                                                            cuda::memcpy_async(v538 + v548, v540 + v550, cuda::aligned_size_t<v551>(v551), v328);
                                                            v544 += 1 ;
                                                        }
                                                        v542 += 1 ;
                                                    }
                                                    v328.producer_commit();
                                                    // Poping the loop unrolling to: 0
                                                    break;
                                                }
                                                default: {
                                                    assert("Invalid tag." && false); __trap();
                                                }
                                            }
                                            // Pushing the loop unrolling to: 0
                                            int v552;
                                            v552 = 0;
                                            #pragma unroll
                                            while (while_method_10(v552)){
                                                int v554;
                                                v554 = 0;
                                                #pragma unroll
                                                while (while_method_10(v554)){
                                                    wmma::fragment<wmma::matrix_a, 16, 16, 8, wmma::precision::tf32, wmma::row_major> & v556 = v486[0];
                                                    assert("Tensor range check" && 0 <= v552 && v552 < 8);
                                                    int v557;
                                                    v557 = 1088 * v552;
                                                    assert("Tensor range check" && 0 <= v554 && v554 < 8);
                                                    int v558;
                                                    v558 = 8 * v554;
                                                    int v559;
                                                    v559 = v558 + v557;
                                                    int v560;
                                                    v560 = 0;
                                                    #pragma unroll
                                                    while (while_method_0(v560)){
                                                        int v562;
                                                        v562 = 0;
                                                        #pragma unroll
                                                        while (while_method_0(v562)){
                                                            assert("Tensor range check" && 0 <= v560 && v560 < 2);
                                                            assert("Tensor range check" && 0 <= v562 && v562 < 2);
                                                            int v564;
                                                            v564 = 544 * v562;
                                                            int v565;
                                                            v565 = v564 + v559;
                                                            int v566;
                                                            v566 = 4 * v560;
                                                            int v567;
                                                            v567 = v566 + v565;
                                                            float v568;
                                                            v568 = v365[v567];
                                                            bool v569;
                                                            v569 = 0 <= v562;
                                                            bool v571;
                                                            if (v569){
                                                                bool v570;
                                                                v570 = v562 < 2;
                                                                v571 = v570;
                                                            } else {
                                                                v571 = false;
                                                            }
                                                            bool v572;
                                                            v572 = v571 == false;
                                                            if (v572){
                                                                assert("The indices should be inside the range of the dimension." && v571);
                                                            } else {
                                                            }
                                                            bool v574;
                                                            v574 = 0 <= v560;
                                                            bool v576;
                                                            if (v574){
                                                                bool v575;
                                                                v575 = v560 < 2;
                                                                v576 = v575;
                                                            } else {
                                                                v576 = false;
                                                            }
                                                            bool v577;
                                                            v577 = v576 == false;
                                                            if (v577){
                                                                assert("The indices should be inside the range of the dimension." && v576);
                                                            } else {
                                                            }
                                                            int v579;
                                                            v579 = v560 * 2;
                                                            int v580;
                                                            v580 = v562 + v579;
                                                            v556.x[v580] = wmma::__float_to_tf32(v568);
                                                            v562 += 1 ;
                                                        }
                                                        v560 += 1 ;
                                                    }
                                                    int v581;
                                                    v581 = 0;
                                                    #pragma unroll
                                                    while (while_method_6(v581)){
                                                        assert("Tensor range check" && 0 <= v552 && v552 < 8);
                                                        assert("Tensor range check" && 0 <= v581 && v581 < 1);
                                                        int v583;
                                                        v583 = v552 + v581;
                                                        wmma::fragment<wmma::accumulator, 16, 16, 8, float> & v584 = v383[v583];
                                                        assert("Tensor range check" && 0 <= v581 && v581 < 1);
                                                        assert("Tensor range check" && 0 <= v554 && v554 < 8);
                                                        int v585;
                                                        v585 = 8 * v581;
                                                        int v586;
                                                        v586 = v585 + v554;
                                                        wmma::fragment<wmma::matrix_b, 16, 16, 8, wmma::precision::tf32, wmma::col_major> & v587 = v487[v586];
                                                        wmma::mma_sync(v584, v556, v587, v584);
                                                        v581 += 1 ;
                                                    }
                                                    v554 += 1 ;
                                                }
                                                v552 += 1 ;
                                            }
                                            // Poping the loop unrolling to: 0
                                            asm("barrier.cta.sync %0;" :: "r"(0));
                                            v400 = v402;
                                        }
                                        // Pushing the loop unrolling to: 0
                                        int v588;
                                        v588 = 0;
                                        #pragma unroll
                                        while (while_method_10(v588)){
                                            int v590;
                                            v590 = 0;
                                            #pragma unroll
                                            while (while_method_6(v590)){
                                                assert("Tensor range check" && 0 <= v588 && v588 < 8);
                                                assert("Tensor range check" && 0 <= v590 && v590 < 1);
                                                int v592;
                                                v592 = v588 + v590;
                                                wmma::fragment<wmma::accumulator, 16, 16, 8, float> & v593 = v383[v592];
                                                assert("Tensor range check" && 0 <= v588 && v588 < 8);
                                                assert("Tensor range check" && 0 <= v590 && v590 < 1);
                                                int v594;
                                                v594 = 16 * v590;
                                                int v595;
                                                v595 = 2176 * v588;
                                                int v596;
                                                v596 = v595 + v594;
                                                float * v597;
                                                v597 = v349+v596;
                                                wmma::store_matrix_sync(v597, v593, 136, wmma::mem_row_major);
                                                v590 += 1 ;
                                            }
                                            v588 += 1 ;
                                        }
                                        // Poping the loop unrolling to: 0
                                        asm("barrier.cta.sync %0;" :: "r"(0));
                                        // Pushing the loop unrolling to: 0
                                        int v599;
                                        v599 = threadIdx.x;
                                        bool v600;
                                        v600 = 0 <= v599;
                                        bool v601;
                                        v601 = v600 == false;
                                        if (v601){
                                            assert("The index needs to be zero or positive." && v600);
                                        } else {
                                        }
                                        int v603;
                                        v603 = v599 % 32;
                                        int v604;
                                        v604 = v599 / 32;
                                        bool v605;
                                        v605 = v604 < 8;
                                        bool v606;
                                        v606 = v605 == false;
                                        if (v606){
                                            assert("The last element of the projection dimensions needs to be greater than the index remainder." && v605);
                                        } else {
                                        }
                                        assert("Tensor range check" && 0 <= v604 && v604 < 8);
                                        assert("Tensor range check" && 0 <= v603 && v603 < 32);
                                        int v608;
                                        v608 = 4 * v603;
                                        int v609;
                                        v609 = 128 * v604;
                                        int v610;
                                        v610 = v609 + v608;
                                        int v611;
                                        v611 = 136 * v604;
                                        int v612;
                                        v612 = v611 + v608;
                                        float * v613;
                                        v613 = v392+v610;
                                        float * v615;
                                        v615 = v334+v612;
                                        int v617;
                                        v617 = 0;
                                        #pragma unroll
                                        while (while_method_12(v617)){
                                            int v619;
                                            v619 = 0;
                                            #pragma unroll
                                            while (while_method_6(v619)){
                                                assert("Tensor range check" && 0 <= v617 && v617 < 16);
                                                assert("Tensor range check" && 0 <= v619 && v619 < 1);
                                                int v621;
                                                v621 = 128 * v619;
                                                int v622;
                                                v622 = 1024 * v617;
                                                int v623;
                                                v623 = v622 + v621;
                                                int v624;
                                                v624 = 1088 * v617;
                                                int v625;
                                                v625 = v624 + v621;
                                                int4* v626;
                                                v626 = reinterpret_cast<int4*>(v615 + v625);
                                                int4* v627;
                                                v627 = reinterpret_cast<int4*>(v613 + v623);
                                                assert("Pointer alignment check" && (unsigned long long)(v626) % 4 == 0 && (unsigned long long)(v627) % 4 == 0);
                                                *v627 = *v626;
                                                v619 += 1 ;
                                            }
                                            v617 += 1 ;
                                        }
                                        // Poping the loop unrolling to: 0
                                        asm("barrier.cta.sync %0;" :: "r"(0));
                                        v386 += 1 ;
                                    }
                                    v384 += 1 ;
                                }
                                unsigned int * v628;
                                v628 = reinterpret_cast<unsigned int *>(&v0[53477376ull]);
                                assert("Tensor range check" && 0 <= v316 && v316 < 4);
                                int v630;
                                v630 = 6144 * v316;
                                method_45(v628, v630, v322);
                                int * v631;
                                v631 = reinterpret_cast<int *>(&v2[4194304ull]);
                                float * v633;
                                v633 = reinterpret_cast<float *>(&v2[4194320ull]);
                                float * v635;
                                v635 = reinterpret_cast<float *>(&v2[5242896ull]);
                                float * v637;
                                v637 = reinterpret_cast<float *>(&v2[6291472ull]);
                                float * v639;
                                v639 = reinterpret_cast<float *>(&v2[7340048ull]);
                                float * v641;
                                v641 = reinterpret_cast<float *>(&v2[8388624ull]);
                                float * v643;
                                v643 = reinterpret_cast<float *>(&v2[9437200ull]);
                                float * v645;
                                v645 = reinterpret_cast<float *>(&v2[10485776ull]);
                                int * v647;
                                v647 = reinterpret_cast<int *>(&v0[53575680ull]);
                                float * v649;
                                v649 = reinterpret_cast<float *>(&v0[66158592ull]);
                                int * v651;
                                v651 = reinterpret_cast<int *>(&v0[78741504ull]);
                                int * v653;
                                v653 = reinterpret_cast<int *>(&v0[91324416ull]);
                                double * v655;
                                v655 = reinterpret_cast<double *>(&v0[103907328ull]);
                                double * v657;
                                v657 = reinterpret_cast<double *>(&v0[154238976ull]);
                                double * v659;
                                v659 = reinterpret_cast<double *>(&v2[11534352ull]);
                                double * v661;
                                v661 = reinterpret_cast<double *>(&v2[11927568ull]);
                                int * v663;
                                v663 = reinterpret_cast<int *>(&v2[12320784ull]);
                                asm("barrier.cta.sync %0;" :: "r"(0));
                                unsigned int * v665;
                                v665 = reinterpret_cast<unsigned int *>(&v0[53477376ull]);
                                int v667;
                                v667 = blockIdx.x;
                                int v668;
                                v668 = threadIdx.x;
                                assert("Tensor range check" && 0 <= v316 && v316 < 4);
                                assert("Tensor range check" && 0 <= v667 && v667 < 24);
                                assert("Tensor range check" && 0 <= v668 && v668 < 256);
                                int v669;
                                v669 = 256 * v667;
                                int v670;
                                v670 = v669 + v668;
                                int v671;
                                v671 = v630 + v670;
                                unsigned int v672;
                                v672 = v665[v671];
                                int * v673;
                                v673 = reinterpret_cast<int *>(&v2[4194304ull]);
                                float * v675;
                                v675 = reinterpret_cast<float *>(&v2[4194320ull]);
                                float * v677;
                                v677 = reinterpret_cast<float *>(&v2[5242896ull]);
                                float * v679;
                                v679 = reinterpret_cast<float *>(&v2[6291472ull]);
                                float * v681;
                                v681 = reinterpret_cast<float *>(&v2[7340048ull]);
                                float * v683;
                                v683 = reinterpret_cast<float *>(&v2[8388624ull]);
                                float * v685;
                                v685 = reinterpret_cast<float *>(&v2[9437200ull]);
                                float * v687;
                                v687 = reinterpret_cast<float *>(&v2[10485776ull]);
                                int v689;
                                v689 = (int)v672;
                                float v690; int v691;
                                Tuple14 tmp40 = method_46(v125, v673, v675, v677, v679, v681, v683, v685, v687, v689, v316);
                                v690 = tmp40.v0; v691 = tmp40.v1;
                                bool v692;
                                v692 = 0 == v691;
                                Union10 v725;
                                if (v692){
                                    v725 = Union10{Union10_1{}};
                                } else {
                                    bool v694;
                                    v694 = 1 == v691;
                                    if (v694){
                                        v725 = Union10{Union10_0{}};
                                    } else {
                                        bool v696;
                                        v696 = 2 == v691;
                                        if (v696){
                                            v725 = Union10{Union10_2{1, 3}};
                                        } else {
                                            bool v698;
                                            v698 = 3 == v691;
                                            if (v698){
                                                v725 = Union10{Union10_2{1, 2}};
                                            } else {
                                                bool v700;
                                                v700 = 4 == v691;
                                                if (v700){
                                                    v725 = Union10{Union10_2{2, 3}};
                                                } else {
                                                    bool v702;
                                                    v702 = 5 == v691;
                                                    if (v702){
                                                        v725 = Union10{Union10_2{3, 4}};
                                                    } else {
                                                        bool v704;
                                                        v704 = 6 == v691;
                                                        if (v704){
                                                            v725 = Union10{Union10_2{1, 1}};
                                                        } else {
                                                            bool v706;
                                                            v706 = 7 == v691;
                                                            if (v706){
                                                                v725 = Union10{Union10_2{3, 2}};
                                                            } else {
                                                                bool v708;
                                                                v708 = 8 == v691;
                                                                if (v708){
                                                                    v725 = Union10{Union10_2{2, 1}};
                                                                } else {
                                                                    bool v710;
                                                                    v710 = 9 == v691;
                                                                    if (v710){
                                                                        v725 = Union10{Union10_2{3, 1}};
                                                                    } else {
                                                                        bool v712;
                                                                        v712 = 10 == v691;
                                                                        if (v712){
                                                                            v725 = Union10{Union10_2{2147483647, 1}};
                                                                        } else {
                                                                            printf("%s\n", "Invalid output id in the NL Holdem model.");
                                                                            __trap();
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                Union1 v803;
                                switch (v725.tag) {
                                    case 0: { // AA_Call
                                        v803 = Union1{Union1_1{}};
                                        break;
                                    }
                                    case 1: { // AA_Fold
                                        int v726;
                                        v726 = v109[0];
                                        int v728; int v729;
                                        Tuple4 tmp41 = Tuple4{1, v726};
                                        v728 = tmp41.v0; v729 = tmp41.v1;
                                        while (while_method_0(v728)){
                                            int v731;
                                            v731 = v109[v728];
                                            bool v733;
                                            v733 = v729 >= v731;
                                            int v734;
                                            if (v733){
                                                v734 = v729;
                                            } else {
                                                v734 = v731;
                                            }
                                            v729 = v734;
                                            v728 += 1 ;
                                        }
                                        int v735;
                                        v735 = v109[v113];
                                        bool v737;
                                        v737 = v735 == v729;
                                        if (v737){
                                            v803 = Union1{Union1_1{}};
                                        } else {
                                            v803 = Union1{Union1_2{}};
                                        }
                                        break;
                                    }
                                    case 2: { // AA_Raise
                                        int v742 = v725.case2.v0; int v743 = v725.case2.v1;
                                        static_array<int,2> v744;
                                        int v746;
                                        v746 = 0;
                                        while (while_method_0(v746)){
                                            int v748;
                                            v748 = v111[v746];
                                            int v750;
                                            v750 = v109[v746];
                                            int v752;
                                            v752 = v748 + v750;
                                            v744[v746] = v752;
                                            v746 += 1 ;
                                        }
                                        int v753;
                                        v753 = v109[0];
                                        int v755; int v756;
                                        Tuple4 tmp42 = Tuple4{1, v753};
                                        v755 = tmp42.v0; v756 = tmp42.v1;
                                        while (while_method_0(v755)){
                                            int v758;
                                            v758 = v109[v755];
                                            bool v760;
                                            v760 = v756 >= v758;
                                            int v761;
                                            if (v760){
                                                v761 = v756;
                                            } else {
                                                v761 = v758;
                                            }
                                            v756 = v761;
                                            v755 += 1 ;
                                        }
                                        int v762;
                                        v762 = v744[v113];
                                        bool v764;
                                        v764 = v756 < v762;
                                        int v765;
                                        if (v764){
                                            v765 = v756;
                                        } else {
                                            v765 = v762;
                                        }
                                        static_array<int,2> v766;
                                        int v768;
                                        v768 = 0;
                                        while (while_method_0(v768)){
                                            int v770;
                                            v770 = v109[v768];
                                            bool v772;
                                            v772 = v113 == v768;
                                            int v773;
                                            if (v772){
                                                v773 = v765;
                                            } else {
                                                v773 = v770;
                                            }
                                            v766[v768] = v773;
                                            v768 += 1 ;
                                        }
                                        int v774;
                                        v774 = v766[0];
                                        int v776; int v777;
                                        Tuple4 tmp43 = Tuple4{1, v774};
                                        v776 = tmp43.v0; v777 = tmp43.v1;
                                        while (while_method_0(v776)){
                                            int v779;
                                            v779 = v766[v776];
                                            int v781;
                                            v781 = v777 + v779;
                                            v777 = v781;
                                            v776 += 1 ;
                                        }
                                        static_array<int,2> v782;
                                        int v784;
                                        v784 = 0;
                                        while (while_method_0(v784)){
                                            int v786;
                                            v786 = v744[v784];
                                            int v788;
                                            v788 = v766[v784];
                                            int v790;
                                            v790 = v786 - v788;
                                            v782[v784] = v790;
                                            v784 += 1 ;
                                        }
                                        int v791;
                                        v791 = v742 * v777;
                                        int v792;
                                        v792 = v791 / v743;
                                        bool v793;
                                        v793 = v107 >= v792;
                                        int v794;
                                        if (v793){
                                            v794 = v107;
                                        } else {
                                            v794 = v792;
                                        }
                                        int v795;
                                        v795 = v782[v113];
                                        bool v797;
                                        v797 = v794 >= v795;
                                        if (v797){
                                            v803 = Union1{Union1_0{}};
                                        } else {
                                            v803 = Union1{Union1_3{v794}};
                                        }
                                        break;
                                    }
                                    default: {
                                        assert("Invalid tag." && false); __trap();
                                    }
                                }
                                int v804;
                                v804 = sizeof(Union1);
                                unsigned long long v805;
                                v805 = (unsigned long long)v804;
                                bool v806;
                                v806 = v805 <= 98304ull;
                                bool v807;
                                v807 = v806 == false;
                                if (v807){
                                    assert("The dynamic shared memory is insufficient to allocate the tensor." && v806);
                                } else {
                                }
                                extern __shared__ unsigned char v809[];
                                bool v810;
                                v810 = v805 <= v805;
                                bool v811;
                                v811 = v810 == false;
                                if (v811){
                                    assert("The length of the partition has to be less than or equal to the length of the base array." && v810);
                                } else {
                                }
                                Union1 * v813;
                                v813 = reinterpret_cast<Union1 *>(&v809[0ull]);
                                int v815;
                                v815 = threadIdx.x;
                                bool v816;
                                v816 = v815 == 0;
                                if (v816){
                                    v813[0] = v803;
                                } else {
                                }
                                asm("barrier.cta.sync %0;" :: "r"(0));
                                Union1 v817;
                                v817 = v813[0];
                                asm("barrier.cta.sync %0;" :: "r"(0));
                                Union6 v818;
                                v818 = Union6{Union6_2{v113, v817}};
                                v6.push(v818);
                                Union4 v1006;
                                switch (v817.tag) {
                                    case 0: { // A_All_In
                                        static_array<int,2> v936;
                                        int v938;
                                        v938 = 0;
                                        while (while_method_0(v938)){
                                            int v940;
                                            v940 = v111[v938];
                                            int v942;
                                            v942 = v109[v938];
                                            int v944;
                                            v944 = v940 + v942;
                                            v936[v938] = v944;
                                            v938 += 1 ;
                                        }
                                        int v945;
                                        v945 = v109[0];
                                        int v947; int v948;
                                        Tuple4 tmp44 = Tuple4{1, v945};
                                        v947 = tmp44.v0; v948 = tmp44.v1;
                                        while (while_method_0(v947)){
                                            int v950;
                                            v950 = v109[v947];
                                            bool v952;
                                            v952 = v948 >= v950;
                                            int v953;
                                            if (v952){
                                                v953 = v948;
                                            } else {
                                                v953 = v950;
                                            }
                                            v948 = v953;
                                            v947 += 1 ;
                                        }
                                        int v954;
                                        v954 = v936[v113];
                                        bool v956;
                                        v956 = v948 < v954;
                                        int v957;
                                        if (v956){
                                            v957 = v948;
                                        } else {
                                            v957 = v954;
                                        }
                                        static_array<int,2> v958;
                                        int v960;
                                        v960 = 0;
                                        while (while_method_0(v960)){
                                            int v962;
                                            v962 = v109[v960];
                                            bool v964;
                                            v964 = v113 == v960;
                                            int v965;
                                            if (v964){
                                                v965 = v957;
                                            } else {
                                                v965 = v962;
                                            }
                                            v958[v960] = v965;
                                            v960 += 1 ;
                                        }
                                        static_array<int,2> v966;
                                        int v968;
                                        v968 = 0;
                                        while (while_method_0(v968)){
                                            int v970;
                                            v970 = v936[v968];
                                            int v972;
                                            v972 = v958[v968];
                                            int v974;
                                            v974 = v970 - v972;
                                            v966[v968] = v974;
                                            v968 += 1 ;
                                        }
                                        int v975;
                                        v975 = v966[v113];
                                        int v977;
                                        v977 = v948 + v975;
                                        int v978;
                                        v978 = v936[v113];
                                        bool v980;
                                        v980 = v977 < v978;
                                        int v981;
                                        if (v980){
                                            v981 = v977;
                                        } else {
                                            v981 = v978;
                                        }
                                        static_array<int,2> v982;
                                        int v984;
                                        v984 = 0;
                                        while (while_method_0(v984)){
                                            int v986;
                                            v986 = v109[v984];
                                            bool v988;
                                            v988 = v113 == v984;
                                            int v989;
                                            if (v988){
                                                v989 = v981;
                                            } else {
                                                v989 = v986;
                                            }
                                            v982[v984] = v989;
                                            v984 += 1 ;
                                        }
                                        static_array<int,2> v990;
                                        int v992;
                                        v992 = 0;
                                        while (while_method_0(v992)){
                                            int v994;
                                            v994 = v936[v992];
                                            int v996;
                                            v996 = v982[v992];
                                            int v998;
                                            v998 = v994 - v996;
                                            v990[v992] = v998;
                                            v992 += 1 ;
                                        }
                                        bool v999;
                                        v999 = v975 >= v107;
                                        int v1000;
                                        if (v999){
                                            v1000 = v975;
                                        } else {
                                            v1000 = v107;
                                        }
                                        int v1001;
                                        v1001 = v110 + 1;
                                        v1006 = try_round_36(v1000, v108, v982, v1001, v990, v112);
                                        break;
                                    }
                                    case 1: { // A_Call
                                        static_array<int,2> v820;
                                        int v822;
                                        v822 = 0;
                                        while (while_method_0(v822)){
                                            int v824;
                                            v824 = v111[v822];
                                            int v826;
                                            v826 = v109[v822];
                                            int v828;
                                            v828 = v824 + v826;
                                            v820[v822] = v828;
                                            v822 += 1 ;
                                        }
                                        int v829;
                                        v829 = v109[0];
                                        int v831; int v832;
                                        Tuple4 tmp45 = Tuple4{1, v829};
                                        v831 = tmp45.v0; v832 = tmp45.v1;
                                        while (while_method_0(v831)){
                                            int v834;
                                            v834 = v109[v831];
                                            bool v836;
                                            v836 = v832 >= v834;
                                            int v837;
                                            if (v836){
                                                v837 = v832;
                                            } else {
                                                v837 = v834;
                                            }
                                            v832 = v837;
                                            v831 += 1 ;
                                        }
                                        int v838;
                                        v838 = v820[v113];
                                        bool v840;
                                        v840 = v832 < v838;
                                        int v841;
                                        if (v840){
                                            v841 = v832;
                                        } else {
                                            v841 = v838;
                                        }
                                        static_array<int,2> v842;
                                        int v844;
                                        v844 = 0;
                                        while (while_method_0(v844)){
                                            int v846;
                                            v846 = v109[v844];
                                            bool v848;
                                            v848 = v113 == v844;
                                            int v849;
                                            if (v848){
                                                v849 = v841;
                                            } else {
                                                v849 = v846;
                                            }
                                            v842[v844] = v849;
                                            v844 += 1 ;
                                        }
                                        static_array<int,2> v850;
                                        int v852;
                                        v852 = 0;
                                        while (while_method_0(v852)){
                                            int v854;
                                            v854 = v820[v852];
                                            int v856;
                                            v856 = v842[v852];
                                            int v858;
                                            v858 = v854 - v856;
                                            v850[v852] = v858;
                                            v852 += 1 ;
                                        }
                                        bool v859;
                                        v859 = v113 < 2;
                                        if (v859){
                                            int v860;
                                            v860 = v110 + 1;
                                            v1006 = try_round_36(v107, v108, v842, v860, v850, v112);
                                        } else {
                                            v1006 = go_next_street_38(v107, v108, v842, v110, v850, v112);
                                        }
                                        break;
                                    }
                                    case 2: { // A_Fold
                                        v1006 = Union4{Union4_1{v107, v108, v109, v110, v111, v112}};
                                        break;
                                    }
                                    case 3: { // A_Raise
                                        int v864 = v817.case3.v0;
                                        bool v865;
                                        v865 = v107 <= v864;
                                        bool v866;
                                        v866 = v865 == false;
                                        if (v866){
                                            assert("The raise amount must match the minimum." && v865);
                                        } else {
                                        }
                                        static_array<int,2> v868;
                                        int v870;
                                        v870 = 0;
                                        while (while_method_0(v870)){
                                            int v872;
                                            v872 = v111[v870];
                                            int v874;
                                            v874 = v109[v870];
                                            int v876;
                                            v876 = v872 + v874;
                                            v868[v870] = v876;
                                            v870 += 1 ;
                                        }
                                        int v877;
                                        v877 = v109[0];
                                        int v879; int v880;
                                        Tuple4 tmp46 = Tuple4{1, v877};
                                        v879 = tmp46.v0; v880 = tmp46.v1;
                                        while (while_method_0(v879)){
                                            int v882;
                                            v882 = v109[v879];
                                            bool v884;
                                            v884 = v880 >= v882;
                                            int v885;
                                            if (v884){
                                                v885 = v880;
                                            } else {
                                                v885 = v882;
                                            }
                                            v880 = v885;
                                            v879 += 1 ;
                                        }
                                        int v886;
                                        v886 = v868[v113];
                                        bool v888;
                                        v888 = v880 < v886;
                                        int v889;
                                        if (v888){
                                            v889 = v880;
                                        } else {
                                            v889 = v886;
                                        }
                                        static_array<int,2> v890;
                                        int v892;
                                        v892 = 0;
                                        while (while_method_0(v892)){
                                            int v894;
                                            v894 = v109[v892];
                                            bool v896;
                                            v896 = v113 == v892;
                                            int v897;
                                            if (v896){
                                                v897 = v889;
                                            } else {
                                                v897 = v894;
                                            }
                                            v890[v892] = v897;
                                            v892 += 1 ;
                                        }
                                        static_array<int,2> v898;
                                        int v900;
                                        v900 = 0;
                                        while (while_method_0(v900)){
                                            int v902;
                                            v902 = v868[v900];
                                            int v904;
                                            v904 = v890[v900];
                                            int v906;
                                            v906 = v902 - v904;
                                            v898[v900] = v906;
                                            v900 += 1 ;
                                        }
                                        int v907;
                                        v907 = v898[v113];
                                        bool v909;
                                        v909 = v864 < v907;
                                        bool v910;
                                        v910 = v909 == false;
                                        if (v910){
                                            assert("The raise amount must be less than the stack size after calling." && v909);
                                        } else {
                                        }
                                        int v912;
                                        v912 = v880 + v864;
                                        int v913;
                                        v913 = v868[v113];
                                        bool v915;
                                        v915 = v912 < v913;
                                        int v916;
                                        if (v915){
                                            v916 = v912;
                                        } else {
                                            v916 = v913;
                                        }
                                        static_array<int,2> v917;
                                        int v919;
                                        v919 = 0;
                                        while (while_method_0(v919)){
                                            int v921;
                                            v921 = v109[v919];
                                            bool v923;
                                            v923 = v113 == v919;
                                            int v924;
                                            if (v923){
                                                v924 = v916;
                                            } else {
                                                v924 = v921;
                                            }
                                            v917[v919] = v924;
                                            v919 += 1 ;
                                        }
                                        static_array<int,2> v925;
                                        int v927;
                                        v927 = 0;
                                        while (while_method_0(v927)){
                                            int v929;
                                            v929 = v868[v927];
                                            int v931;
                                            v931 = v917[v927];
                                            int v933;
                                            v933 = v929 - v931;
                                            v925[v927] = v933;
                                            v927 += 1 ;
                                        }
                                        int v934;
                                        v934 = v110 + 1;
                                        v1006 = try_round_36(v864, v108, v917, v934, v925, v112);
                                        break;
                                    }
                                    default: {
                                        assert("Invalid tag." && false); __trap();
                                    }
                                }
                                v1621 = Union3{Union3_1{v1006}};
                                break;
                            }
                            case 1: { // Human
                                Union7 v1008;
                                v1008 = Union7{Union7_2{v107, v108, v109, v110, v111, v112}};
                                v4.v5 = v1008;
                                Union3 v1009;
                                v1009 = Union3{Union3_1{v11}};
                                v4.v1 = v1009;
                                v1621 = Union3{Union3_0{}};
                                break;
                            }
                            case 2: { // Random
                                curandStatePhilox4_32_10_t & v1011 = v4.v4;
                                curandStatePhilox4_32_10_t & v1012 = v1011;
                                static_array<int,2> v1013;
                                int v1015;
                                v1015 = 0;
                                while (while_method_0(v1015)){
                                    int v1017;
                                    v1017 = v111[v1015];
                                    int v1019;
                                    v1019 = v109[v1015];
                                    int v1021;
                                    v1021 = v1017 + v1019;
                                    v1013[v1015] = v1021;
                                    v1015 += 1 ;
                                }
                                int v1022;
                                v1022 = v109[0];
                                int v1024; int v1025;
                                Tuple4 tmp47 = Tuple4{1, v1022};
                                v1024 = tmp47.v0; v1025 = tmp47.v1;
                                while (while_method_0(v1024)){
                                    int v1027;
                                    v1027 = v109[v1024];
                                    bool v1029;
                                    v1029 = v1025 >= v1027;
                                    int v1030;
                                    if (v1029){
                                        v1030 = v1025;
                                    } else {
                                        v1030 = v1027;
                                    }
                                    v1025 = v1030;
                                    v1024 += 1 ;
                                }
                                int v1031;
                                v1031 = v1013[v113];
                                bool v1033;
                                v1033 = v1025 < v1031;
                                int v1034;
                                if (v1033){
                                    v1034 = v1025;
                                } else {
                                    v1034 = v1031;
                                }
                                static_array<int,2> v1035;
                                int v1037;
                                v1037 = 0;
                                while (while_method_0(v1037)){
                                    int v1039;
                                    v1039 = v109[v1037];
                                    bool v1041;
                                    v1041 = v113 == v1037;
                                    int v1042;
                                    if (v1041){
                                        v1042 = v1034;
                                    } else {
                                        v1042 = v1039;
                                    }
                                    v1035[v1037] = v1042;
                                    v1037 += 1 ;
                                }
                                int v1043;
                                v1043 = v1035[0];
                                int v1045; int v1046;
                                Tuple4 tmp48 = Tuple4{1, v1043};
                                v1045 = tmp48.v0; v1046 = tmp48.v1;
                                while (while_method_0(v1045)){
                                    int v1048;
                                    v1048 = v1035[v1045];
                                    int v1050;
                                    v1050 = v1046 + v1048;
                                    v1046 = v1050;
                                    v1045 += 1 ;
                                }
                                static_array<int,2> v1051;
                                int v1053;
                                v1053 = 0;
                                while (while_method_0(v1053)){
                                    int v1055;
                                    v1055 = v1013[v1053];
                                    int v1057;
                                    v1057 = v1035[v1053];
                                    int v1059;
                                    v1059 = v1055 - v1057;
                                    v1051[v1053] = v1059;
                                    v1053 += 1 ;
                                }
                                int v1060;
                                v1060 = v109[v113];
                                bool v1062;
                                v1062 = v1060 < v1025;
                                float v1063;
                                if (v1062){
                                    v1063 = 1.0f;
                                } else {
                                    v1063 = 0.0f;
                                }
                                int v1064;
                                v1064 = v1046 / 3;
                                bool v1065;
                                v1065 = v107 <= v1064;
                                bool v1069;
                                if (v1065){
                                    int v1066;
                                    v1066 = v1051[v113];
                                    bool v1068;
                                    v1068 = v1064 < v1066;
                                    v1069 = v1068;
                                } else {
                                    v1069 = false;
                                }
                                float v1070;
                                if (v1069){
                                    v1070 = 1.0f;
                                } else {
                                    v1070 = 0.0f;
                                }
                                int v1071;
                                v1071 = v1046 / 2;
                                bool v1072;
                                v1072 = v107 <= v1071;
                                bool v1076;
                                if (v1072){
                                    int v1073;
                                    v1073 = v1051[v113];
                                    bool v1075;
                                    v1075 = v1071 < v1073;
                                    v1076 = v1075;
                                } else {
                                    v1076 = false;
                                }
                                float v1077;
                                if (v1076){
                                    v1077 = 1.0f;
                                } else {
                                    v1077 = 0.0f;
                                }
                                bool v1078;
                                v1078 = v107 <= v1046;
                                bool v1082;
                                if (v1078){
                                    int v1079;
                                    v1079 = v1051[v113];
                                    bool v1081;
                                    v1081 = v1046 < v1079;
                                    v1082 = v1081;
                                } else {
                                    v1082 = false;
                                }
                                float v1083;
                                if (v1082){
                                    v1083 = 1.0f;
                                } else {
                                    v1083 = 0.0f;
                                }
                                static_array<Tuple18,6> v1084;
                                Union1 v1086;
                                v1086 = Union1{Union1_2{}};
                                v1084[0] = Tuple18{v1086, v1063};
                                Union1 v1088;
                                v1088 = Union1{Union1_1{}};
                                v1084[1] = Tuple18{v1088, 4.0f};
                                Union1 v1090;
                                v1090 = Union1{Union1_3{v1064}};
                                v1084[2] = Tuple18{v1090, v1070};
                                Union1 v1092;
                                v1092 = Union1{Union1_3{v1071}};
                                v1084[3] = Tuple18{v1092, v1077};
                                Union1 v1094;
                                v1094 = Union1{Union1_3{v1046}};
                                v1084[4] = Tuple18{v1094, v1083};
                                Union1 v1096;
                                v1096 = Union1{Union1_0{}};
                                v1084[5] = Tuple18{v1096, 1.0f};
                                Union1 v1098;
                                v1098 = sample_discrete_47(v1084, v1012);
                                int v1099;
                                v1099 = sizeof(Union1);
                                unsigned long long v1100;
                                v1100 = (unsigned long long)v1099;
                                bool v1101;
                                v1101 = v1100 <= 98304ull;
                                bool v1102;
                                v1102 = v1101 == false;
                                if (v1102){
                                    assert("The dynamic shared memory is insufficient to allocate the tensor." && v1101);
                                } else {
                                }
                                extern __shared__ unsigned char v1104[];
                                bool v1105;
                                v1105 = v1100 <= v1100;
                                bool v1106;
                                v1106 = v1105 == false;
                                if (v1106){
                                    assert("The length of the partition has to be less than or equal to the length of the base array." && v1105);
                                } else {
                                }
                                Union1 * v1108;
                                v1108 = reinterpret_cast<Union1 *>(&v1104[0ull]);
                                int v1110;
                                v1110 = threadIdx.x;
                                bool v1111;
                                v1111 = v1110 == 0;
                                if (v1111){
                                    v1108[0] = v1098;
                                } else {
                                }
                                asm("barrier.cta.sync %0;" :: "r"(0));
                                Union1 v1112;
                                v1112 = v1108[0];
                                asm("barrier.cta.sync %0;" :: "r"(0));
                                Union6 v1113;
                                v1113 = Union6{Union6_2{v113, v1112}};
                                v6.push(v1113);
                                Union4 v1301;
                                switch (v1112.tag) {
                                    case 0: { // A_All_In
                                        static_array<int,2> v1231;
                                        int v1233;
                                        v1233 = 0;
                                        while (while_method_0(v1233)){
                                            int v1235;
                                            v1235 = v111[v1233];
                                            int v1237;
                                            v1237 = v109[v1233];
                                            int v1239;
                                            v1239 = v1235 + v1237;
                                            v1231[v1233] = v1239;
                                            v1233 += 1 ;
                                        }
                                        int v1240;
                                        v1240 = v109[0];
                                        int v1242; int v1243;
                                        Tuple4 tmp51 = Tuple4{1, v1240};
                                        v1242 = tmp51.v0; v1243 = tmp51.v1;
                                        while (while_method_0(v1242)){
                                            int v1245;
                                            v1245 = v109[v1242];
                                            bool v1247;
                                            v1247 = v1243 >= v1245;
                                            int v1248;
                                            if (v1247){
                                                v1248 = v1243;
                                            } else {
                                                v1248 = v1245;
                                            }
                                            v1243 = v1248;
                                            v1242 += 1 ;
                                        }
                                        int v1249;
                                        v1249 = v1231[v113];
                                        bool v1251;
                                        v1251 = v1243 < v1249;
                                        int v1252;
                                        if (v1251){
                                            v1252 = v1243;
                                        } else {
                                            v1252 = v1249;
                                        }
                                        static_array<int,2> v1253;
                                        int v1255;
                                        v1255 = 0;
                                        while (while_method_0(v1255)){
                                            int v1257;
                                            v1257 = v109[v1255];
                                            bool v1259;
                                            v1259 = v113 == v1255;
                                            int v1260;
                                            if (v1259){
                                                v1260 = v1252;
                                            } else {
                                                v1260 = v1257;
                                            }
                                            v1253[v1255] = v1260;
                                            v1255 += 1 ;
                                        }
                                        static_array<int,2> v1261;
                                        int v1263;
                                        v1263 = 0;
                                        while (while_method_0(v1263)){
                                            int v1265;
                                            v1265 = v1231[v1263];
                                            int v1267;
                                            v1267 = v1253[v1263];
                                            int v1269;
                                            v1269 = v1265 - v1267;
                                            v1261[v1263] = v1269;
                                            v1263 += 1 ;
                                        }
                                        int v1270;
                                        v1270 = v1261[v113];
                                        int v1272;
                                        v1272 = v1243 + v1270;
                                        int v1273;
                                        v1273 = v1231[v113];
                                        bool v1275;
                                        v1275 = v1272 < v1273;
                                        int v1276;
                                        if (v1275){
                                            v1276 = v1272;
                                        } else {
                                            v1276 = v1273;
                                        }
                                        static_array<int,2> v1277;
                                        int v1279;
                                        v1279 = 0;
                                        while (while_method_0(v1279)){
                                            int v1281;
                                            v1281 = v109[v1279];
                                            bool v1283;
                                            v1283 = v113 == v1279;
                                            int v1284;
                                            if (v1283){
                                                v1284 = v1276;
                                            } else {
                                                v1284 = v1281;
                                            }
                                            v1277[v1279] = v1284;
                                            v1279 += 1 ;
                                        }
                                        static_array<int,2> v1285;
                                        int v1287;
                                        v1287 = 0;
                                        while (while_method_0(v1287)){
                                            int v1289;
                                            v1289 = v1231[v1287];
                                            int v1291;
                                            v1291 = v1277[v1287];
                                            int v1293;
                                            v1293 = v1289 - v1291;
                                            v1285[v1287] = v1293;
                                            v1287 += 1 ;
                                        }
                                        bool v1294;
                                        v1294 = v1270 >= v107;
                                        int v1295;
                                        if (v1294){
                                            v1295 = v1270;
                                        } else {
                                            v1295 = v107;
                                        }
                                        int v1296;
                                        v1296 = v110 + 1;
                                        v1301 = try_round_36(v1295, v108, v1277, v1296, v1285, v112);
                                        break;
                                    }
                                    case 1: { // A_Call
                                        static_array<int,2> v1115;
                                        int v1117;
                                        v1117 = 0;
                                        while (while_method_0(v1117)){
                                            int v1119;
                                            v1119 = v111[v1117];
                                            int v1121;
                                            v1121 = v109[v1117];
                                            int v1123;
                                            v1123 = v1119 + v1121;
                                            v1115[v1117] = v1123;
                                            v1117 += 1 ;
                                        }
                                        int v1124;
                                        v1124 = v109[0];
                                        int v1126; int v1127;
                                        Tuple4 tmp52 = Tuple4{1, v1124};
                                        v1126 = tmp52.v0; v1127 = tmp52.v1;
                                        while (while_method_0(v1126)){
                                            int v1129;
                                            v1129 = v109[v1126];
                                            bool v1131;
                                            v1131 = v1127 >= v1129;
                                            int v1132;
                                            if (v1131){
                                                v1132 = v1127;
                                            } else {
                                                v1132 = v1129;
                                            }
                                            v1127 = v1132;
                                            v1126 += 1 ;
                                        }
                                        int v1133;
                                        v1133 = v1115[v113];
                                        bool v1135;
                                        v1135 = v1127 < v1133;
                                        int v1136;
                                        if (v1135){
                                            v1136 = v1127;
                                        } else {
                                            v1136 = v1133;
                                        }
                                        static_array<int,2> v1137;
                                        int v1139;
                                        v1139 = 0;
                                        while (while_method_0(v1139)){
                                            int v1141;
                                            v1141 = v109[v1139];
                                            bool v1143;
                                            v1143 = v113 == v1139;
                                            int v1144;
                                            if (v1143){
                                                v1144 = v1136;
                                            } else {
                                                v1144 = v1141;
                                            }
                                            v1137[v1139] = v1144;
                                            v1139 += 1 ;
                                        }
                                        static_array<int,2> v1145;
                                        int v1147;
                                        v1147 = 0;
                                        while (while_method_0(v1147)){
                                            int v1149;
                                            v1149 = v1115[v1147];
                                            int v1151;
                                            v1151 = v1137[v1147];
                                            int v1153;
                                            v1153 = v1149 - v1151;
                                            v1145[v1147] = v1153;
                                            v1147 += 1 ;
                                        }
                                        bool v1154;
                                        v1154 = v113 < 2;
                                        if (v1154){
                                            int v1155;
                                            v1155 = v110 + 1;
                                            v1301 = try_round_36(v107, v108, v1137, v1155, v1145, v112);
                                        } else {
                                            v1301 = go_next_street_38(v107, v108, v1137, v110, v1145, v112);
                                        }
                                        break;
                                    }
                                    case 2: { // A_Fold
                                        v1301 = Union4{Union4_1{v107, v108, v109, v110, v111, v112}};
                                        break;
                                    }
                                    case 3: { // A_Raise
                                        int v1159 = v1112.case3.v0;
                                        bool v1160;
                                        v1160 = v107 <= v1159;
                                        bool v1161;
                                        v1161 = v1160 == false;
                                        if (v1161){
                                            assert("The raise amount must match the minimum." && v1160);
                                        } else {
                                        }
                                        static_array<int,2> v1163;
                                        int v1165;
                                        v1165 = 0;
                                        while (while_method_0(v1165)){
                                            int v1167;
                                            v1167 = v111[v1165];
                                            int v1169;
                                            v1169 = v109[v1165];
                                            int v1171;
                                            v1171 = v1167 + v1169;
                                            v1163[v1165] = v1171;
                                            v1165 += 1 ;
                                        }
                                        int v1172;
                                        v1172 = v109[0];
                                        int v1174; int v1175;
                                        Tuple4 tmp53 = Tuple4{1, v1172};
                                        v1174 = tmp53.v0; v1175 = tmp53.v1;
                                        while (while_method_0(v1174)){
                                            int v1177;
                                            v1177 = v109[v1174];
                                            bool v1179;
                                            v1179 = v1175 >= v1177;
                                            int v1180;
                                            if (v1179){
                                                v1180 = v1175;
                                            } else {
                                                v1180 = v1177;
                                            }
                                            v1175 = v1180;
                                            v1174 += 1 ;
                                        }
                                        int v1181;
                                        v1181 = v1163[v113];
                                        bool v1183;
                                        v1183 = v1175 < v1181;
                                        int v1184;
                                        if (v1183){
                                            v1184 = v1175;
                                        } else {
                                            v1184 = v1181;
                                        }
                                        static_array<int,2> v1185;
                                        int v1187;
                                        v1187 = 0;
                                        while (while_method_0(v1187)){
                                            int v1189;
                                            v1189 = v109[v1187];
                                            bool v1191;
                                            v1191 = v113 == v1187;
                                            int v1192;
                                            if (v1191){
                                                v1192 = v1184;
                                            } else {
                                                v1192 = v1189;
                                            }
                                            v1185[v1187] = v1192;
                                            v1187 += 1 ;
                                        }
                                        static_array<int,2> v1193;
                                        int v1195;
                                        v1195 = 0;
                                        while (while_method_0(v1195)){
                                            int v1197;
                                            v1197 = v1163[v1195];
                                            int v1199;
                                            v1199 = v1185[v1195];
                                            int v1201;
                                            v1201 = v1197 - v1199;
                                            v1193[v1195] = v1201;
                                            v1195 += 1 ;
                                        }
                                        int v1202;
                                        v1202 = v1193[v113];
                                        bool v1204;
                                        v1204 = v1159 < v1202;
                                        bool v1205;
                                        v1205 = v1204 == false;
                                        if (v1205){
                                            assert("The raise amount must be less than the stack size after calling." && v1204);
                                        } else {
                                        }
                                        int v1207;
                                        v1207 = v1175 + v1159;
                                        int v1208;
                                        v1208 = v1163[v113];
                                        bool v1210;
                                        v1210 = v1207 < v1208;
                                        int v1211;
                                        if (v1210){
                                            v1211 = v1207;
                                        } else {
                                            v1211 = v1208;
                                        }
                                        static_array<int,2> v1212;
                                        int v1214;
                                        v1214 = 0;
                                        while (while_method_0(v1214)){
                                            int v1216;
                                            v1216 = v109[v1214];
                                            bool v1218;
                                            v1218 = v113 == v1214;
                                            int v1219;
                                            if (v1218){
                                                v1219 = v1211;
                                            } else {
                                                v1219 = v1216;
                                            }
                                            v1212[v1214] = v1219;
                                            v1214 += 1 ;
                                        }
                                        static_array<int,2> v1220;
                                        int v1222;
                                        v1222 = 0;
                                        while (while_method_0(v1222)){
                                            int v1224;
                                            v1224 = v1163[v1222];
                                            int v1226;
                                            v1226 = v1212[v1222];
                                            int v1228;
                                            v1228 = v1224 - v1226;
                                            v1220[v1222] = v1228;
                                            v1222 += 1 ;
                                        }
                                        int v1229;
                                        v1229 = v110 + 1;
                                        v1301 = try_round_36(v1159, v108, v1212, v1229, v1220, v112);
                                        break;
                                    }
                                    default: {
                                        assert("Invalid tag." && false); __trap();
                                    }
                                }
                                v1621 = Union3{Union3_1{v1301}};
                                break;
                            }
                            default: {
                                assert("Invalid tag." && false); __trap();
                            }
                        }
                        break;
                    }
                    case 5: { // G_Round'
                        int v1306 = v11.case5.v0; static_array<static_array<unsigned char,2>,2> v1307 = v11.case5.v1; static_array<int,2> v1308 = v11.case5.v2; int v1309 = v11.case5.v3; static_array<int,2> v1310 = v11.case5.v4; Union5 v1311 = v11.case5.v5; Union1 v1312 = v11.case5.v6;
                        int v1313;
                        v1313 = v1309 % 2;
                        Union6 v1314;
                        v1314 = Union6{Union6_2{v1313, v1312}};
                        v6.push(v1314);
                        Union4 v1502;
                        switch (v1312.tag) {
                            case 0: { // A_All_In
                                static_array<int,2> v1432;
                                int v1434;
                                v1434 = 0;
                                while (while_method_0(v1434)){
                                    int v1436;
                                    v1436 = v1310[v1434];
                                    int v1438;
                                    v1438 = v1308[v1434];
                                    int v1440;
                                    v1440 = v1436 + v1438;
                                    v1432[v1434] = v1440;
                                    v1434 += 1 ;
                                }
                                int v1441;
                                v1441 = v1308[0];
                                int v1443; int v1444;
                                Tuple4 tmp54 = Tuple4{1, v1441};
                                v1443 = tmp54.v0; v1444 = tmp54.v1;
                                while (while_method_0(v1443)){
                                    int v1446;
                                    v1446 = v1308[v1443];
                                    bool v1448;
                                    v1448 = v1444 >= v1446;
                                    int v1449;
                                    if (v1448){
                                        v1449 = v1444;
                                    } else {
                                        v1449 = v1446;
                                    }
                                    v1444 = v1449;
                                    v1443 += 1 ;
                                }
                                int v1450;
                                v1450 = v1432[v1313];
                                bool v1452;
                                v1452 = v1444 < v1450;
                                int v1453;
                                if (v1452){
                                    v1453 = v1444;
                                } else {
                                    v1453 = v1450;
                                }
                                static_array<int,2> v1454;
                                int v1456;
                                v1456 = 0;
                                while (while_method_0(v1456)){
                                    int v1458;
                                    v1458 = v1308[v1456];
                                    bool v1460;
                                    v1460 = v1313 == v1456;
                                    int v1461;
                                    if (v1460){
                                        v1461 = v1453;
                                    } else {
                                        v1461 = v1458;
                                    }
                                    v1454[v1456] = v1461;
                                    v1456 += 1 ;
                                }
                                static_array<int,2> v1462;
                                int v1464;
                                v1464 = 0;
                                while (while_method_0(v1464)){
                                    int v1466;
                                    v1466 = v1432[v1464];
                                    int v1468;
                                    v1468 = v1454[v1464];
                                    int v1470;
                                    v1470 = v1466 - v1468;
                                    v1462[v1464] = v1470;
                                    v1464 += 1 ;
                                }
                                int v1471;
                                v1471 = v1462[v1313];
                                int v1473;
                                v1473 = v1444 + v1471;
                                int v1474;
                                v1474 = v1432[v1313];
                                bool v1476;
                                v1476 = v1473 < v1474;
                                int v1477;
                                if (v1476){
                                    v1477 = v1473;
                                } else {
                                    v1477 = v1474;
                                }
                                static_array<int,2> v1478;
                                int v1480;
                                v1480 = 0;
                                while (while_method_0(v1480)){
                                    int v1482;
                                    v1482 = v1308[v1480];
                                    bool v1484;
                                    v1484 = v1313 == v1480;
                                    int v1485;
                                    if (v1484){
                                        v1485 = v1477;
                                    } else {
                                        v1485 = v1482;
                                    }
                                    v1478[v1480] = v1485;
                                    v1480 += 1 ;
                                }
                                static_array<int,2> v1486;
                                int v1488;
                                v1488 = 0;
                                while (while_method_0(v1488)){
                                    int v1490;
                                    v1490 = v1432[v1488];
                                    int v1492;
                                    v1492 = v1478[v1488];
                                    int v1494;
                                    v1494 = v1490 - v1492;
                                    v1486[v1488] = v1494;
                                    v1488 += 1 ;
                                }
                                bool v1495;
                                v1495 = v1471 >= v1306;
                                int v1496;
                                if (v1495){
                                    v1496 = v1471;
                                } else {
                                    v1496 = v1306;
                                }
                                int v1497;
                                v1497 = v1309 + 1;
                                v1502 = try_round_36(v1496, v1307, v1478, v1497, v1486, v1311);
                                break;
                            }
                            case 1: { // A_Call
                                static_array<int,2> v1316;
                                int v1318;
                                v1318 = 0;
                                while (while_method_0(v1318)){
                                    int v1320;
                                    v1320 = v1310[v1318];
                                    int v1322;
                                    v1322 = v1308[v1318];
                                    int v1324;
                                    v1324 = v1320 + v1322;
                                    v1316[v1318] = v1324;
                                    v1318 += 1 ;
                                }
                                int v1325;
                                v1325 = v1308[0];
                                int v1327; int v1328;
                                Tuple4 tmp55 = Tuple4{1, v1325};
                                v1327 = tmp55.v0; v1328 = tmp55.v1;
                                while (while_method_0(v1327)){
                                    int v1330;
                                    v1330 = v1308[v1327];
                                    bool v1332;
                                    v1332 = v1328 >= v1330;
                                    int v1333;
                                    if (v1332){
                                        v1333 = v1328;
                                    } else {
                                        v1333 = v1330;
                                    }
                                    v1328 = v1333;
                                    v1327 += 1 ;
                                }
                                int v1334;
                                v1334 = v1316[v1313];
                                bool v1336;
                                v1336 = v1328 < v1334;
                                int v1337;
                                if (v1336){
                                    v1337 = v1328;
                                } else {
                                    v1337 = v1334;
                                }
                                static_array<int,2> v1338;
                                int v1340;
                                v1340 = 0;
                                while (while_method_0(v1340)){
                                    int v1342;
                                    v1342 = v1308[v1340];
                                    bool v1344;
                                    v1344 = v1313 == v1340;
                                    int v1345;
                                    if (v1344){
                                        v1345 = v1337;
                                    } else {
                                        v1345 = v1342;
                                    }
                                    v1338[v1340] = v1345;
                                    v1340 += 1 ;
                                }
                                static_array<int,2> v1346;
                                int v1348;
                                v1348 = 0;
                                while (while_method_0(v1348)){
                                    int v1350;
                                    v1350 = v1316[v1348];
                                    int v1352;
                                    v1352 = v1338[v1348];
                                    int v1354;
                                    v1354 = v1350 - v1352;
                                    v1346[v1348] = v1354;
                                    v1348 += 1 ;
                                }
                                bool v1355;
                                v1355 = v1313 < 2;
                                if (v1355){
                                    int v1356;
                                    v1356 = v1309 + 1;
                                    v1502 = try_round_36(v1306, v1307, v1338, v1356, v1346, v1311);
                                } else {
                                    v1502 = go_next_street_38(v1306, v1307, v1338, v1309, v1346, v1311);
                                }
                                break;
                            }
                            case 2: { // A_Fold
                                v1502 = Union4{Union4_1{v1306, v1307, v1308, v1309, v1310, v1311}};
                                break;
                            }
                            case 3: { // A_Raise
                                int v1360 = v1312.case3.v0;
                                bool v1361;
                                v1361 = v1306 <= v1360;
                                bool v1362;
                                v1362 = v1361 == false;
                                if (v1362){
                                    assert("The raise amount must match the minimum." && v1361);
                                } else {
                                }
                                static_array<int,2> v1364;
                                int v1366;
                                v1366 = 0;
                                while (while_method_0(v1366)){
                                    int v1368;
                                    v1368 = v1310[v1366];
                                    int v1370;
                                    v1370 = v1308[v1366];
                                    int v1372;
                                    v1372 = v1368 + v1370;
                                    v1364[v1366] = v1372;
                                    v1366 += 1 ;
                                }
                                int v1373;
                                v1373 = v1308[0];
                                int v1375; int v1376;
                                Tuple4 tmp56 = Tuple4{1, v1373};
                                v1375 = tmp56.v0; v1376 = tmp56.v1;
                                while (while_method_0(v1375)){
                                    int v1378;
                                    v1378 = v1308[v1375];
                                    bool v1380;
                                    v1380 = v1376 >= v1378;
                                    int v1381;
                                    if (v1380){
                                        v1381 = v1376;
                                    } else {
                                        v1381 = v1378;
                                    }
                                    v1376 = v1381;
                                    v1375 += 1 ;
                                }
                                int v1382;
                                v1382 = v1364[v1313];
                                bool v1384;
                                v1384 = v1376 < v1382;
                                int v1385;
                                if (v1384){
                                    v1385 = v1376;
                                } else {
                                    v1385 = v1382;
                                }
                                static_array<int,2> v1386;
                                int v1388;
                                v1388 = 0;
                                while (while_method_0(v1388)){
                                    int v1390;
                                    v1390 = v1308[v1388];
                                    bool v1392;
                                    v1392 = v1313 == v1388;
                                    int v1393;
                                    if (v1392){
                                        v1393 = v1385;
                                    } else {
                                        v1393 = v1390;
                                    }
                                    v1386[v1388] = v1393;
                                    v1388 += 1 ;
                                }
                                static_array<int,2> v1394;
                                int v1396;
                                v1396 = 0;
                                while (while_method_0(v1396)){
                                    int v1398;
                                    v1398 = v1364[v1396];
                                    int v1400;
                                    v1400 = v1386[v1396];
                                    int v1402;
                                    v1402 = v1398 - v1400;
                                    v1394[v1396] = v1402;
                                    v1396 += 1 ;
                                }
                                int v1403;
                                v1403 = v1394[v1313];
                                bool v1405;
                                v1405 = v1360 < v1403;
                                bool v1406;
                                v1406 = v1405 == false;
                                if (v1406){
                                    assert("The raise amount must be less than the stack size after calling." && v1405);
                                } else {
                                }
                                int v1408;
                                v1408 = v1376 + v1360;
                                int v1409;
                                v1409 = v1364[v1313];
                                bool v1411;
                                v1411 = v1408 < v1409;
                                int v1412;
                                if (v1411){
                                    v1412 = v1408;
                                } else {
                                    v1412 = v1409;
                                }
                                static_array<int,2> v1413;
                                int v1415;
                                v1415 = 0;
                                while (while_method_0(v1415)){
                                    int v1417;
                                    v1417 = v1308[v1415];
                                    bool v1419;
                                    v1419 = v1313 == v1415;
                                    int v1420;
                                    if (v1419){
                                        v1420 = v1412;
                                    } else {
                                        v1420 = v1417;
                                    }
                                    v1413[v1415] = v1420;
                                    v1415 += 1 ;
                                }
                                static_array<int,2> v1421;
                                int v1423;
                                v1423 = 0;
                                while (while_method_0(v1423)){
                                    int v1425;
                                    v1425 = v1364[v1423];
                                    int v1427;
                                    v1427 = v1413[v1423];
                                    int v1429;
                                    v1429 = v1425 - v1427;
                                    v1421[v1423] = v1429;
                                    v1423 += 1 ;
                                }
                                int v1430;
                                v1430 = v1309 + 1;
                                v1502 = try_round_36(v1360, v1307, v1413, v1430, v1421, v1311);
                                break;
                            }
                            default: {
                                assert("Invalid tag." && false); __trap();
                            }
                        }
                        v1621 = Union3{Union3_1{v1502}};
                        break;
                    }
                    case 6: { // G_Showdown
                        int v27 = v11.case6.v0; static_array<static_array<unsigned char,2>,2> v28 = v11.case6.v1; static_array<int,2> v29 = v11.case6.v2; int v30 = v11.case6.v3; static_array<int,2> v31 = v11.case6.v4; Union5 v32 = v11.case6.v5;
                        static_array<unsigned char,5> v35;
                        switch (v32.tag) {
                            case 2: { // River
                                static_array<unsigned char,5> v33 = v32.case2.v0;
                                v35 = v33;
                                break;
                            }
                            default: {
                                printf("%s\n", "Invalid street in showdown.");
                                __trap();
                            }
                        }
                        static_array<unsigned char,2> v36;
                        v36 = v28[0];
                        static_array<unsigned char,7> v38;
                        int v40;
                        v40 = 0;
                        while (while_method_0(v40)){
                            unsigned char v42;
                            v42 = v36[v40];
                            v38[v40] = v42;
                            v40 += 1 ;
                        }
                        int v44;
                        v44 = 0;
                        while (while_method_2(v44)){
                            unsigned char v46;
                            v46 = v35[v44];
                            int v48;
                            v48 = 2 + v44;
                            v38[v48] = v46;
                            v44 += 1 ;
                        }
                        static_array<unsigned char,5> v49; char v50;
                        Tuple0 tmp81 = score_51(v38);
                        v49 = tmp81.v0; v50 = tmp81.v1;
                        static_array<unsigned char,2> v51;
                        v51 = v28[1];
                        static_array<unsigned char,7> v53;
                        int v55;
                        v55 = 0;
                        while (while_method_0(v55)){
                            unsigned char v57;
                            v57 = v51[v55];
                            v53[v55] = v57;
                            v55 += 1 ;
                        }
                        int v59;
                        v59 = 0;
                        while (while_method_2(v59)){
                            unsigned char v61;
                            v61 = v35[v59];
                            int v63;
                            v63 = 2 + v59;
                            v53[v63] = v61;
                            v59 += 1 ;
                        }
                        static_array<unsigned char,5> v64; char v65;
                        Tuple0 tmp82 = score_51(v53);
                        v64 = tmp82.v0; v65 = tmp82.v1;
                        int v66;
                        v66 = v30 % 2;
                        int v67;
                        v67 = v29[v66];
                        bool v69;
                        v69 = v50 < v65;
                        Union11 v75;
                        if (v69){
                            v75 = Union11{Union11_2{}};
                        } else {
                            bool v71;
                            v71 = v50 > v65;
                            if (v71){
                                v75 = Union11{Union11_1{}};
                            } else {
                                v75 = Union11{Union11_0{}};
                            }
                        }
                        Union11 v94;
                        switch (v75.tag) {
                            case 0: { // Eq
                                Union11 v76;
                                v76 = Union11{Union11_0{}};
                                int v77;
                                v77 = 0;
                                while (while_method_2(v77)){
                                    unsigned char v79;
                                    v79 = v49[v77];
                                    unsigned char v81;
                                    v81 = v64[v77];
                                    unsigned char v83;
                                    v83 = v79 / 4u;
                                    unsigned char v84;
                                    v84 = v81 / 4u;
                                    bool v85;
                                    v85 = v83 < v84;
                                    Union11 v91;
                                    if (v85){
                                        v91 = Union11{Union11_2{}};
                                    } else {
                                        bool v87;
                                        v87 = v83 > v84;
                                        if (v87){
                                            v91 = Union11{Union11_1{}};
                                        } else {
                                            v91 = Union11{Union11_0{}};
                                        }
                                    }
                                    bool v92;
                                    switch (v91.tag) {
                                        case 0: { // Eq
                                            v92 = true;
                                            break;
                                        }
                                        default: {
                                            v92 = false;
                                        }
                                    }
                                    bool v93;
                                    v93 = v92 == false;
                                    if (v93){
                                        v76 = v91;
                                        break;
                                    } else {
                                    }
                                    v77 += 1 ;
                                }
                                v94 = v76;
                                break;
                            }
                            default: {
                                v94 = v75;
                            }
                        }
                        int v99; int v100;
                        switch (v94.tag) {
                            case 0: { // Eq
                                v99 = 0; v100 = -1;
                                break;
                            }
                            case 1: { // Gt
                                v99 = v67; v100 = 0;
                                break;
                            }
                            case 2: { // Lt
                                v99 = v67; v100 = 1;
                                break;
                            }
                            default: {
                                assert("Invalid tag." && false); __trap();
                            }
                        }
                        static_array<Tuple0,2> v101;
                        v101[0] = Tuple0{v49, v50};
                        v101[1] = Tuple0{v64, v65};
                        Union6 v103;
                        v103 = Union6{Union6_4{v99, v101, v100}};
                        v6.push(v103);
                        Union7 v104;
                        v104 = Union7{Union7_1{v27, v28, v29, v30, v31, v32}};
                        v4.v5 = v104;
                        Union3 v105;
                        v105 = Union3{Union3_0{}};
                        v4.v1 = v105;
                        v1621 = Union3{Union3_0{}};
                        break;
                    }
                    case 7: { // G_Turn
                        int v1523 = v11.case7.v0; static_array<static_array<unsigned char,2>,2> v1524 = v11.case7.v1; static_array<int,2> v1525 = v11.case7.v2; int v1526 = v11.case7.v3; static_array<int,2> v1527 = v11.case7.v4; Union5 v1528 = v11.case7.v5;
                        curandStatePhilox4_32_10_t & v1529 = v4.v4;
                        curandStatePhilox4_32_10_t & v1530 = v1529;
                        static_array<unsigned char,1> v1531; unsigned long long v1532;
                        Tuple12 tmp83 = draw_cards_40(v1530, v7);
                        v1531 = tmp83.v0; v1532 = tmp83.v1;
                        v4.v0 = v1532;
                        static_array_list<unsigned char,5> v1533;
                        v1533 = get_community_cards_41(v1528, v1531);
                        Union6 v1534;
                        v1534 = Union6{Union6_0{v1533}};
                        v6.push(v1534);
                        Union5 v1549;
                        switch (v1528.tag) {
                            case 0: { // Flop
                                static_array<unsigned char,3> v1535 = v1528.case0.v0;
                                static_array<unsigned char,4> v1536;
                                int v1538;
                                v1538 = 0;
                                while (while_method_1(v1538)){
                                    unsigned char v1540;
                                    v1540 = v1535[v1538];
                                    v1536[v1538] = v1540;
                                    v1538 += 1 ;
                                }
                                int v1542;
                                v1542 = 0;
                                while (while_method_6(v1542)){
                                    unsigned char v1544;
                                    v1544 = v1531[v1542];
                                    int v1546;
                                    v1546 = 3 + v1542;
                                    v1536[v1546] = v1544;
                                    v1542 += 1 ;
                                }
                                v1549 = Union5{Union5_3{v1536}};
                                break;
                            }
                            default: {
                                printf("%s\n", "Invalid street in turn.");
                                __trap();
                            }
                        }
                        int v1550;
                        v1550 = 2;
                        int v1551;
                        v1551 = 0;
                        Union4 v1552;
                        v1552 = try_round_36(v1550, v1524, v1525, v1551, v1527, v1549);
                        v1621 = Union3{Union3_1{v1552}};
                        break;
                    }
                    default: {
                        assert("Invalid tag." && false); __trap();
                    }
                }
                break;
            }
            default: {
                assert("Invalid tag." && false); __trap();
            }
        }
        v9 = v1621;
    }
    return ;
}
__device__ void f_53(unsigned char * v0, unsigned long long v1){
    unsigned long long * v2;
    v2 = (unsigned long long *)(v0+0ull);
    v2[0] = v1;
    return ;
}
__device__ void f_54(unsigned char * v0, int v1){
    int * v2;
    v2 = (int *)(v0+8ull);
    v2[0] = v1;
    return ;
}
__device__ void f_55(unsigned char * v0){
    return ;
}
__device__ void f_57(unsigned char * v0, int v1){
    int * v2;
    v2 = (int *)(v0+0ull);
    v2[0] = v1;
    return ;
}
__device__ void f_61(unsigned char * v0, unsigned char v1){
    unsigned char * v2;
    v2 = (unsigned char *)(v0+0ull);
    v2[0] = v1;
    return ;
}
__device__ void f_60(unsigned char * v0, unsigned char v1){
    return f_61(v0, v1);
}
__device__ void f_59(unsigned char * v0, static_array<unsigned char,2> v1){
    int v2;
    v2 = 0;
    while (while_method_0(v2)){
        unsigned long long v4;
        v4 = (unsigned long long)v2;
        unsigned char * v5;
        v5 = (unsigned char *)(v0+v4);
        unsigned char v7;
        v7 = v1[v2];
        f_60(v5, v7);
        v2 += 1 ;
    }
    return ;
}
__device__ void f_62(unsigned char * v0, int v1){
    int * v2;
    v2 = (int *)(v0+28ull);
    v2[0] = v1;
    return ;
}
__device__ void f_63(unsigned char * v0, static_array<unsigned char,3> v1){
    int v2;
    v2 = 0;
    while (while_method_1(v2)){
        unsigned long long v4;
        v4 = (unsigned long long)v2;
        unsigned char * v5;
        v5 = (unsigned char *)(v0+v4);
        unsigned char v7;
        v7 = v1[v2];
        f_60(v5, v7);
        v2 += 1 ;
    }
    return ;
}
__device__ void f_64(unsigned char * v0, static_array<unsigned char,5> v1){
    int v2;
    v2 = 0;
    while (while_method_2(v2)){
        unsigned long long v4;
        v4 = (unsigned long long)v2;
        unsigned char * v5;
        v5 = (unsigned char *)(v0+v4);
        unsigned char v7;
        v7 = v1[v2];
        f_60(v5, v7);
        v2 += 1 ;
    }
    return ;
}
__device__ void f_65(unsigned char * v0, static_array<unsigned char,4> v1){
    int v2;
    v2 = 0;
    while (while_method_3(v2)){
        unsigned long long v4;
        v4 = (unsigned long long)v2;
        unsigned char * v5;
        v5 = (unsigned char *)(v0+v4);
        unsigned char v7;
        v7 = v1[v2];
        f_60(v5, v7);
        v2 += 1 ;
    }
    return ;
}
__device__ void f_58(unsigned char * v0, int v1, static_array<static_array<unsigned char,2>,2> v2, static_array<int,2> v3, int v4, static_array<int,2> v5, Union5 v6){
    int * v7;
    v7 = (int *)(v0+0ull);
    v7[0] = v1;
    int v9;
    v9 = 0;
    while (while_method_0(v9)){
        unsigned long long v11;
        v11 = (unsigned long long)v9;
        unsigned long long v12;
        v12 = v11 * 2ull;
        unsigned long long v13;
        v13 = 4ull + v12;
        unsigned char * v14;
        v14 = (unsigned char *)(v0+v13);
        static_array<unsigned char,2> v16;
        v16 = v2[v9];
        f_59(v14, v16);
        v9 += 1 ;
    }
    int v18;
    v18 = 0;
    while (while_method_0(v18)){
        unsigned long long v20;
        v20 = (unsigned long long)v18;
        unsigned long long v21;
        v21 = v20 * 4ull;
        unsigned long long v22;
        v22 = 8ull + v21;
        unsigned char * v23;
        v23 = (unsigned char *)(v0+v22);
        int v25;
        v25 = v3[v18];
        f_57(v23, v25);
        v18 += 1 ;
    }
    int * v27;
    v27 = (int *)(v0+16ull);
    v27[0] = v4;
    int v29;
    v29 = 0;
    while (while_method_0(v29)){
        unsigned long long v31;
        v31 = (unsigned long long)v29;
        unsigned long long v32;
        v32 = v31 * 4ull;
        unsigned long long v33;
        v33 = 20ull + v32;
        unsigned char * v34;
        v34 = (unsigned char *)(v0+v33);
        int v36;
        v36 = v5[v29];
        f_57(v34, v36);
        v29 += 1 ;
    }
    int v38;
    v38 = v6.tag;
    f_62(v0, v38);
    unsigned char * v39;
    v39 = (unsigned char *)(v0+32ull);
    switch (v6.tag) {
        case 0: { // Flop
            static_array<unsigned char,3> v41 = v6.case0.v0;
            return f_63(v39, v41);
            break;
        }
        case 1: { // Preflop
            return f_55(v39);
            break;
        }
        case 2: { // River
            static_array<unsigned char,5> v42 = v6.case2.v0;
            return f_64(v39, v42);
            break;
        }
        case 3: { // Turn
            static_array<unsigned char,4> v43 = v6.case3.v0;
            return f_65(v39, v43);
            break;
        }
        default: {
            assert("Invalid tag." && false); __trap();
        }
    }
}
__device__ void f_67(unsigned char * v0, int v1){
    int * v2;
    v2 = (int *)(v0+40ull);
    v2[0] = v1;
    return ;
}
__device__ void f_66(unsigned char * v0, int v1, static_array<static_array<unsigned char,2>,2> v2, static_array<int,2> v3, int v4, static_array<int,2> v5, Union5 v6, Union1 v7){
    int * v8;
    v8 = (int *)(v0+0ull);
    v8[0] = v1;
    int v10;
    v10 = 0;
    while (while_method_0(v10)){
        unsigned long long v12;
        v12 = (unsigned long long)v10;
        unsigned long long v13;
        v13 = v12 * 2ull;
        unsigned long long v14;
        v14 = 4ull + v13;
        unsigned char * v15;
        v15 = (unsigned char *)(v0+v14);
        static_array<unsigned char,2> v17;
        v17 = v2[v10];
        f_59(v15, v17);
        v10 += 1 ;
    }
    int v19;
    v19 = 0;
    while (while_method_0(v19)){
        unsigned long long v21;
        v21 = (unsigned long long)v19;
        unsigned long long v22;
        v22 = v21 * 4ull;
        unsigned long long v23;
        v23 = 8ull + v22;
        unsigned char * v24;
        v24 = (unsigned char *)(v0+v23);
        int v26;
        v26 = v3[v19];
        f_57(v24, v26);
        v19 += 1 ;
    }
    int * v28;
    v28 = (int *)(v0+16ull);
    v28[0] = v4;
    int v30;
    v30 = 0;
    while (while_method_0(v30)){
        unsigned long long v32;
        v32 = (unsigned long long)v30;
        unsigned long long v33;
        v33 = v32 * 4ull;
        unsigned long long v34;
        v34 = 20ull + v33;
        unsigned char * v35;
        v35 = (unsigned char *)(v0+v34);
        int v37;
        v37 = v5[v30];
        f_57(v35, v37);
        v30 += 1 ;
    }
    int v39;
    v39 = v6.tag;
    f_62(v0, v39);
    unsigned char * v40;
    v40 = (unsigned char *)(v0+32ull);
    switch (v6.tag) {
        case 0: { // Flop
            static_array<unsigned char,3> v42 = v6.case0.v0;
            f_63(v40, v42);
            break;
        }
        case 1: { // Preflop
            f_55(v40);
            break;
        }
        case 2: { // River
            static_array<unsigned char,5> v43 = v6.case2.v0;
            f_64(v40, v43);
            break;
        }
        case 3: { // Turn
            static_array<unsigned char,4> v44 = v6.case3.v0;
            f_65(v40, v44);
            break;
        }
        default: {
            assert("Invalid tag." && false); __trap();
        }
    }
    int v45;
    v45 = v7.tag;
    f_67(v0, v45);
    unsigned char * v46;
    v46 = (unsigned char *)(v0+44ull);
    switch (v7.tag) {
        case 0: { // A_All_In
            return f_55(v46);
            break;
        }
        case 1: { // A_Call
            return f_55(v46);
            break;
        }
        case 2: { // A_Fold
            return f_55(v46);
            break;
        }
        case 3: { // A_Raise
            int v48 = v7.case3.v0;
            return f_57(v46, v48);
            break;
        }
        default: {
            assert("Invalid tag." && false); __trap();
        }
    }
}
__device__ void f_56(unsigned char * v0, Union4 v1){
    int v2;
    v2 = v1.tag;
    f_57(v0, v2);
    unsigned char * v3;
    v3 = (unsigned char *)(v0+16ull);
    switch (v1.tag) {
        case 0: { // G_Flop
            int v5 = v1.case0.v0; static_array<static_array<unsigned char,2>,2> v6 = v1.case0.v1; static_array<int,2> v7 = v1.case0.v2; int v8 = v1.case0.v3; static_array<int,2> v9 = v1.case0.v4; Union5 v10 = v1.case0.v5;
            return f_58(v3, v5, v6, v7, v8, v9, v10);
            break;
        }
        case 1: { // G_Fold
            int v11 = v1.case1.v0; static_array<static_array<unsigned char,2>,2> v12 = v1.case1.v1; static_array<int,2> v13 = v1.case1.v2; int v14 = v1.case1.v3; static_array<int,2> v15 = v1.case1.v4; Union5 v16 = v1.case1.v5;
            return f_58(v3, v11, v12, v13, v14, v15, v16);
            break;
        }
        case 2: { // G_Preflop
            return f_55(v3);
            break;
        }
        case 3: { // G_River
            int v17 = v1.case3.v0; static_array<static_array<unsigned char,2>,2> v18 = v1.case3.v1; static_array<int,2> v19 = v1.case3.v2; int v20 = v1.case3.v3; static_array<int,2> v21 = v1.case3.v4; Union5 v22 = v1.case3.v5;
            return f_58(v3, v17, v18, v19, v20, v21, v22);
            break;
        }
        case 4: { // G_Round
            int v23 = v1.case4.v0; static_array<static_array<unsigned char,2>,2> v24 = v1.case4.v1; static_array<int,2> v25 = v1.case4.v2; int v26 = v1.case4.v3; static_array<int,2> v27 = v1.case4.v4; Union5 v28 = v1.case4.v5;
            return f_58(v3, v23, v24, v25, v26, v27, v28);
            break;
        }
        case 5: { // G_Round'
            int v29 = v1.case5.v0; static_array<static_array<unsigned char,2>,2> v30 = v1.case5.v1; static_array<int,2> v31 = v1.case5.v2; int v32 = v1.case5.v3; static_array<int,2> v33 = v1.case5.v4; Union5 v34 = v1.case5.v5; Union1 v35 = v1.case5.v6;
            return f_66(v3, v29, v30, v31, v32, v33, v34, v35);
            break;
        }
        case 6: { // G_Showdown
            int v36 = v1.case6.v0; static_array<static_array<unsigned char,2>,2> v37 = v1.case6.v1; static_array<int,2> v38 = v1.case6.v2; int v39 = v1.case6.v3; static_array<int,2> v40 = v1.case6.v4; Union5 v41 = v1.case6.v5;
            return f_58(v3, v36, v37, v38, v39, v40, v41);
            break;
        }
        case 7: { // G_Turn
            int v42 = v1.case7.v0; static_array<static_array<unsigned char,2>,2> v43 = v1.case7.v1; static_array<int,2> v44 = v1.case7.v2; int v45 = v1.case7.v3; static_array<int,2> v46 = v1.case7.v4; Union5 v47 = v1.case7.v5;
            return f_58(v3, v42, v43, v44, v45, v46, v47);
            break;
        }
        default: {
            assert("Invalid tag." && false); __trap();
        }
    }
}
__device__ void f_68(unsigned char * v0, int v1){
    int * v2;
    v2 = (int *)(v0+80ull);
    v2[0] = v1;
    return ;
}
__device__ void f_70(unsigned char * v0, static_array_list<unsigned char,5> v1){
    int v2;
    v2 = v1.length;
    f_57(v0, v2);
    int v3;
    v3 = v1.length;
    int v4;
    v4 = 0;
    while (while_method_4(v3, v4)){
        unsigned long long v6;
        v6 = (unsigned long long)v4;
        unsigned long long v7;
        v7 = 4ull + v6;
        unsigned char * v8;
        v8 = (unsigned char *)(v0+v7);
        unsigned char v10;
        v10 = v1[v4];
        f_60(v8, v10);
        v4 += 1 ;
    }
    return ;
}
__device__ void f_71(unsigned char * v0, int v1, int v2){
    int * v3;
    v3 = (int *)(v0+0ull);
    v3[0] = v1;
    int * v5;
    v5 = (int *)(v0+4ull);
    v5[0] = v2;
    return ;
}
__device__ void f_73(unsigned char * v0, int v1){
    int * v2;
    v2 = (int *)(v0+4ull);
    v2[0] = v1;
    return ;
}
__device__ void f_72(unsigned char * v0, int v1, Union1 v2){
    int * v3;
    v3 = (int *)(v0+0ull);
    v3[0] = v1;
    int v5;
    v5 = v2.tag;
    f_73(v0, v5);
    unsigned char * v6;
    v6 = (unsigned char *)(v0+8ull);
    switch (v2.tag) {
        case 0: { // A_All_In
            return f_55(v6);
            break;
        }
        case 1: { // A_Call
            return f_55(v6);
            break;
        }
        case 2: { // A_Fold
            return f_55(v6);
            break;
        }
        case 3: { // A_Raise
            int v8 = v2.case3.v0;
            return f_57(v6, v8);
            break;
        }
        default: {
            assert("Invalid tag." && false); __trap();
        }
    }
}
__device__ void f_74(unsigned char * v0, int v1, static_array<unsigned char,2> v2){
    int * v3;
    v3 = (int *)(v0+0ull);
    v3[0] = v1;
    int v5;
    v5 = 0;
    while (while_method_0(v5)){
        unsigned long long v7;
        v7 = (unsigned long long)v5;
        unsigned long long v8;
        v8 = 4ull + v7;
        unsigned char * v9;
        v9 = (unsigned char *)(v0+v8);
        unsigned char v11;
        v11 = v2[v5];
        f_60(v9, v11);
        v5 += 1 ;
    }
    return ;
}
__device__ void f_77(unsigned char * v0, static_array<unsigned char,5> v1, char v2){
    int v3;
    v3 = 0;
    while (while_method_2(v3)){
        unsigned long long v5;
        v5 = (unsigned long long)v3;
        unsigned char * v6;
        v6 = (unsigned char *)(v0+v5);
        unsigned char v8;
        v8 = v1[v3];
        f_60(v6, v8);
        v3 += 1 ;
    }
    char * v10;
    v10 = (char *)(v0+5ull);
    v10[0] = v2;
    return ;
}
__device__ void f_76(unsigned char * v0, static_array<unsigned char,5> v1, char v2){
    return f_77(v0, v1, v2);
}
__device__ void f_75(unsigned char * v0, int v1, static_array<Tuple0,2> v2, int v3){
    int * v4;
    v4 = (int *)(v0+0ull);
    v4[0] = v1;
    int v6;
    v6 = 0;
    while (while_method_0(v6)){
        unsigned long long v8;
        v8 = (unsigned long long)v6;
        unsigned long long v9;
        v9 = v8 * 8ull;
        unsigned long long v10;
        v10 = 8ull + v9;
        unsigned char * v11;
        v11 = (unsigned char *)(v0+v10);
        static_array<unsigned char,5> v13; char v14;
        Tuple0 tmp84 = v2[v6];
        v13 = tmp84.v0; v14 = tmp84.v1;
        f_76(v11, v13, v14);
        v6 += 1 ;
    }
    int * v17;
    v17 = (int *)(v0+24ull);
    v17[0] = v3;
    return ;
}
__device__ void f_69(unsigned char * v0, Union6 v1){
    int v2;
    v2 = v1.tag;
    f_57(v0, v2);
    unsigned char * v3;
    v3 = (unsigned char *)(v0+16ull);
    switch (v1.tag) {
        case 0: { // CommunityCardsAre
            static_array_list<unsigned char,5> v5 = v1.case0.v0;
            return f_70(v3, v5);
            break;
        }
        case 1: { // Fold
            int v6 = v1.case1.v0; int v7 = v1.case1.v1;
            return f_71(v3, v6, v7);
            break;
        }
        case 2: { // PlayerAction
            int v8 = v1.case2.v0; Union1 v9 = v1.case2.v1;
            return f_72(v3, v8, v9);
            break;
        }
        case 3: { // PlayerGotCards
            int v10 = v1.case3.v0; static_array<unsigned char,2> v11 = v1.case3.v1;
            return f_74(v3, v10, v11);
            break;
        }
        case 4: { // Showdown
            int v12 = v1.case4.v0; static_array<Tuple0,2> v13 = v1.case4.v1; int v14 = v1.case4.v2;
            return f_75(v3, v12, v13, v14);
            break;
        }
        default: {
            assert("Invalid tag." && false); __trap();
        }
    }
}
__device__ void f_78(unsigned char * v0, Union2 v1){
    int v2;
    v2 = v1.tag;
    f_57(v0, v2);
    unsigned char * v3;
    v3 = (unsigned char *)(v0+4ull);
    switch (v1.tag) {
        case 0: { // Computer
            return f_55(v3);
            break;
        }
        case 1: { // Human
            return f_55(v3);
            break;
        }
        case 2: { // Random
            return f_55(v3);
            break;
        }
        default: {
            assert("Invalid tag." && false); __trap();
        }
    }
}
__device__ void f_79(unsigned char * v0, int v1){
    int * v2;
    v2 = (int *)(v0+6248ull);
    v2[0] = v1;
    return ;
}
__device__ void f_52(unsigned char * v0, unsigned long long v1, Union3 v2, static_array_list<Union6,128> v3, static_array<Union2,2> v4, Union7 v5){
    f_53(v0, v1);
    int v6;
    v6 = v2.tag;
    f_54(v0, v6);
    unsigned char * v7;
    v7 = (unsigned char *)(v0+16ull);
    switch (v2.tag) {
        case 0: { // None
            f_55(v7);
            break;
        }
        case 1: { // Some
            Union4 v9 = v2.case1.v0;
            f_56(v7, v9);
            break;
        }
        default: {
            assert("Invalid tag." && false); __trap();
        }
    }
    int v10;
    v10 = v3.length;
    f_68(v0, v10);
    int v11;
    v11 = v3.length;
    int v12;
    v12 = 0;
    while (while_method_4(v11, v12)){
        unsigned long long v14;
        v14 = (unsigned long long)v12;
        unsigned long long v15;
        v15 = v14 * 48ull;
        unsigned long long v16;
        v16 = 96ull + v15;
        unsigned char * v17;
        v17 = (unsigned char *)(v0+v16);
        Union6 v19;
        v19 = v3[v12];
        f_69(v17, v19);
        v12 += 1 ;
    }
    int v21;
    v21 = 0;
    while (while_method_0(v21)){
        unsigned long long v23;
        v23 = (unsigned long long)v21;
        unsigned long long v24;
        v24 = v23 * 4ull;
        unsigned long long v25;
        v25 = 6240ull + v24;
        unsigned char * v26;
        v26 = (unsigned char *)(v0+v25);
        Union2 v28;
        v28 = v4[v21];
        f_78(v26, v28);
        v21 += 1 ;
    }
    int v30;
    v30 = v5.tag;
    f_79(v0, v30);
    unsigned char * v31;
    v31 = (unsigned char *)(v0+6256ull);
    switch (v5.tag) {
        case 0: { // GameNotStarted
            return f_55(v31);
            break;
        }
        case 1: { // GameOver
            int v33 = v5.case1.v0; static_array<static_array<unsigned char,2>,2> v34 = v5.case1.v1; static_array<int,2> v35 = v5.case1.v2; int v36 = v5.case1.v3; static_array<int,2> v37 = v5.case1.v4; Union5 v38 = v5.case1.v5;
            return f_58(v31, v33, v34, v35, v36, v37, v38);
            break;
        }
        case 2: { // WaitingForActionFromPlayerId
            int v39 = v5.case2.v0; static_array<static_array<unsigned char,2>,2> v40 = v5.case2.v1; static_array<int,2> v41 = v5.case2.v2; int v42 = v5.case2.v3; static_array<int,2> v43 = v5.case2.v4; Union5 v44 = v5.case2.v5;
            return f_58(v31, v39, v40, v41, v42, v43, v44);
            break;
        }
        default: {
            assert("Invalid tag." && false); __trap();
        }
    }
}
__device__ inline bool while_method_21(Union3 v0){
    switch (v0.tag) {
        case 0: { // None
            return false;
            break;
        }
        case 1: { // Some
            Union4 v1 = v0.case1.v0;
            return true;
            break;
        }
        default: {
            assert("Invalid tag." && false); __trap();
        }
    }
}
__device__ static_array_list<unsigned char,5> get_community_cards_81(Union5 v0, static_array<unsigned char,3> v1){
    static_array_list<unsigned char,5> v2;
    v2 = static_array_list<unsigned char,5>{};
    switch (v0.tag) {
        case 0: { // Flop
            static_array<unsigned char,3> v4 = v0.case0.v0;
            int v5;
            v5 = 0;
            while (while_method_1(v5)){
                unsigned char v7;
                v7 = v4[v5];
                v2.push(v7);
                v5 += 1 ;
            }
            break;
        }
        case 1: { // Preflop
            break;
        }
        case 2: { // River
            static_array<unsigned char,5> v14 = v0.case2.v0;
            int v15;
            v15 = 0;
            while (while_method_2(v15)){
                unsigned char v17;
                v17 = v14[v15];
                v2.push(v17);
                v15 += 1 ;
            }
            break;
        }
        case 3: { // Turn
            static_array<unsigned char,4> v9 = v0.case3.v0;
            int v10;
            v10 = 0;
            while (while_method_3(v10)){
                unsigned char v12;
                v12 = v9[v10];
                v2.push(v12);
                v10 += 1 ;
            }
            break;
        }
        default: {
            assert("Invalid tag." && false); __trap();
        }
    }
    int v19;
    v19 = 0;
    while (while_method_1(v19)){
        unsigned char v21;
        v21 = v1[v19];
        v2.push(v21);
        v19 += 1 ;
    }
    return v2;
}
__device__ static_array_list<unsigned char,5> get_community_cards_82(Union5 v0, static_array<unsigned char,1> v1){
    static_array_list<unsigned char,5> v2;
    v2 = static_array_list<unsigned char,5>{};
    switch (v0.tag) {
        case 0: { // Flop
            static_array<unsigned char,3> v4 = v0.case0.v0;
            int v5;
            v5 = 0;
            while (while_method_1(v5)){
                unsigned char v7;
                v7 = v4[v5];
                v2.push(v7);
                v5 += 1 ;
            }
            break;
        }
        case 1: { // Preflop
            break;
        }
        case 2: { // River
            static_array<unsigned char,5> v14 = v0.case2.v0;
            int v15;
            v15 = 0;
            while (while_method_2(v15)){
                unsigned char v17;
                v17 = v14[v15];
                v2.push(v17);
                v15 += 1 ;
            }
            break;
        }
        case 3: { // Turn
            static_array<unsigned char,4> v9 = v0.case3.v0;
            int v10;
            v10 = 0;
            while (while_method_3(v10)){
                unsigned char v12;
                v12 = v9[v10];
                v2.push(v12);
                v10 += 1 ;
            }
            break;
        }
        default: {
            assert("Invalid tag." && false); __trap();
        }
    }
    int v19;
    v19 = 0;
    while (while_method_6(v19)){
        unsigned char v21;
        v21 = v1[v19];
        v2.push(v21);
        v19 += 1 ;
    }
    return v2;
}
__device__ float method_83(int * v0, float * v1, float * v2, float * v3, float * v4, float * v5, float * v6, float * v7, int v8, int v9, int v10){
    assert("Tensor range check" && 0 <= v9 && v9 < 4);
    int v11;
    v11 = 65536 * v9;
    assert("Tensor range check" && 0 <= v8 && v8 < 4096);
    int v12;
    v12 = 16 * v8;
    int v13;
    v13 = v12 + v11;
    float * v14;
    v14 = v2+v13;
    int v16;
    v16 = sizeof(float *);
    unsigned long long v17;
    v17 = (unsigned long long)v16;
    unsigned long long v18;
    v18 = 256ull * v17;
    unsigned long long v19;
    v19 = 1024ull + v18;
    unsigned long long v20;
    v20 = v19 + 16ull;
    unsigned long long v21;
    v21 = v20 - 1ull;
    unsigned long long v22;
    v22 = v21 % 16ull;
    unsigned long long v23;
    v23 = v21 - v22;
    unsigned long long v24;
    v24 = v23 + 1024ull;
    bool v25;
    v25 = v24 <= 98304ull;
    bool v26;
    v26 = v25 == false;
    if (v26){
        assert("The dynamic shared memory is insufficient to allocate the tensor." && v25);
    } else {
    }
    extern __shared__ unsigned char v28[];
    bool v29;
    v29 = v24 <= v24;
    bool v30;
    v30 = v29 == false;
    if (v30){
        assert("The length of the partition has to be less than or equal to the length of the base array." && v29);
    } else {
    }
    int * v32;
    v32 = reinterpret_cast<int *>(&v28[0ull]);
    float * * v34;
    v34 = reinterpret_cast<float * *>(&v28[1024ull]);
    float * v36;
    v36 = reinterpret_cast<float *>(&v28[v23]);
    int v38;
    v38 = threadIdx.x;
    assert("Tensor range check" && 0 <= v38 && v38 < 256);
    v32[v38] = v10;
    v34[v38] = v14;
    asm("barrier.cta.sync %0;" :: "r"(0));
    bool v39;
    v39 = 0 <= v38;
    bool v40;
    v40 = v39 == false;
    if (v40){
        assert("The index needs to be zero or positive." && v39);
    } else {
    }
    int v42;
    v42 = v38 % 4;
    int v43;
    v43 = v38 / 4;
    bool v44;
    v44 = v43 < 64;
    bool v45;
    v45 = v44 == false;
    if (v45){
        assert("The last element of the projection dimensions needs to be greater than the index remainder." && v44);
    } else {
    }
    assert("Tensor range check" && 0 <= v43 && v43 < 64);
    int v47;
    v47 = 0;
    while (while_method_3(v47)){
        bool v49;
        v49 = 0 <= v43;
        bool v50;
        v50 = v49 && v44;
        bool v51;
        v51 = v50 == false;
        if (v51){
            assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v50);
        } else {
        }
        bool v53;
        v53 = 0 <= v47;
        bool v55;
        if (v53){
            bool v54;
            v54 = v47 < 4;
            v55 = v54;
        } else {
            v55 = false;
        }
        bool v56;
        v56 = v55 == false;
        if (v56){
            assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v55);
        } else {
        }
        int v58;
        v58 = v47 * 64;
        int v59;
        v59 = v58 + v43;
        assert("Tensor range check" && 0 <= v47 && v47 < 4);
        int v60;
        v60 = 64 * v47;
        int v61;
        v61 = v60 + v43;
        int v62;
        v62 = v32[v61];
        float * v63;
        v63 = v34[v61];
        int v64;
        v64 = blockIdx.x;
        int v65;
        v65 = v64 * 256;
        int v66;
        v66 = v65 + v59;
        assert("Tensor range check" && 0 <= v42 && v42 < 4);
        int v67;
        v67 = 4 * v42;
        float v68[4];
        int v69[4];
        int v70;
        v70 = 0;
        while (while_method_6(v70)){
            assert("Tensor range check" && 0 <= v70 && v70 < 1);
            int v72;
            v72 = 4 * v70;
            assert("Tensor range check" && 0 <= v70 && v70 < 1);
            int v73;
            v73 = 16 * v70;
            int v74;
            v74 = v73 + v67;
            int4* v75;
            v75 = reinterpret_cast<int4*>(v63 + v74);
            int4* v76;
            v76 = reinterpret_cast<int4*>(v68 + v72);
            assert("Pointer alignment check" && (unsigned long long)(v75) % 4 == 0 && (unsigned long long)(v76) % 4 == 0);
            *v76 = *v75;
            v70 += 1 ;
        }
        int v77;
        v77 = 0;
        while (while_method_6(v77)){
            int v79;
            v79 = 0;
            while (while_method_3(v79)){
                bool v81;
                v81 = 0 <= v79;
                bool v83;
                if (v81){
                    bool v82;
                    v82 = v79 < 4;
                    v83 = v82;
                } else {
                    v83 = false;
                }
                bool v84;
                v84 = v83 == false;
                if (v84){
                    assert("The indices should be inside the range of the dimension." && v83);
                } else {
                }
                bool v86;
                v86 = 0 <= v42;
                bool v88;
                if (v86){
                    bool v87;
                    v87 = v42 < 4;
                    v88 = v87;
                } else {
                    v88 = false;
                }
                bool v89;
                v89 = v88 == false;
                if (v89){
                    assert("The indices should be inside the range of the dimension." && v88);
                } else {
                }
                int v91;
                v91 = v42 * 4;
                int v92;
                v92 = v79 + v91;
                bool v93;
                v93 = 0 <= v77;
                bool v95;
                if (v93){
                    bool v94;
                    v94 = v77 < 1;
                    v95 = v94;
                } else {
                    v95 = false;
                }
                bool v96;
                v96 = v95 == false;
                if (v96){
                    assert("The indices should be inside the range of the dimension." && v95);
                } else {
                }
                int v98;
                v98 = v77 * 16;
                int v99;
                v99 = v92 + v98;
                assert("Tensor range check" && 0 <= v77 && v77 < 1);
                assert("Tensor range check" && 0 <= v79 && v79 < 4);
                int v100;
                v100 = 4 * v77;
                int v101;
                v101 = v100 + v79;
                v69[v101] = v99;
                v79 += 1 ;
            }
            v77 += 1 ;
        }
        bool v102[4];
        int v103;
        v103 = 0;
        while (while_method_6(v103)){
            int v105;
            v105 = 0;
            while (while_method_3(v105)){
                assert("Tensor range check" && 0 <= v103 && v103 < 1);
                assert("Tensor range check" && 0 <= v105 && v105 < 4);
                int v107;
                v107 = 4 * v103;
                int v108;
                v108 = v107 + v105;
                float v109;
                v109 = v68[v108];
                int v110;
                v110 = v69[v108];
                bool v111;
                v111 = v110 < 11;
                assert("Tensor range check" && 0 <= v103 && v103 < 1);
                assert("Tensor range check" && 0 <= v105 && v105 < 4);
                v102[v108] = v111;
                v105 += 1 ;
            }
            v103 += 1 ;
        }
        float v112[4];
        int v113;
        v113 = 0;
        while (while_method_6(v113)){
            int v115;
            v115 = 0;
            while (while_method_3(v115)){
                assert("Tensor range check" && 0 <= v113 && v113 < 1);
                assert("Tensor range check" && 0 <= v115 && v115 < 4);
                int v117;
                v117 = 4 * v113;
                int v118;
                v118 = v117 + v115;
                float v119;
                v119 = v68[v118];
                bool v120;
                v120 = v102[v118];
                float v123;
                if (v120){
                    bool v121;
                    v121 = 0.0f >= v119;
                    if (v121){
                        v123 = 0.0f;
                    } else {
                        v123 = v119;
                    }
                } else {
                    v123 = 0.0f;
                }
                assert("Tensor range check" && 0 <= v113 && v113 < 1);
                assert("Tensor range check" && 0 <= v115 && v115 < 4);
                v112[v118] = v123;
                v115 += 1 ;
            }
            v113 += 1 ;
        }
        float v124;
        v124 = 0.0f;
        int v125;
        v125 = 0;
        while (while_method_6(v125)){
            int v127;
            v127 = 0;
            while (while_method_3(v127)){
                assert("Tensor range check" && 0 <= v125 && v125 < 1);
                assert("Tensor range check" && 0 <= v127 && v127 < 4);
                int v129;
                v129 = 4 * v125;
                int v130;
                v130 = v129 + v127;
                float v131;
                v131 = v112[v130];
                float v132;
                v132 = v124 + v131;
                v124 = v132;
                v127 += 1 ;
            }
            v125 += 1 ;
        }
        auto v133 = cooperative_groups::coalesced_threads();
        int v134;
        v134 = threadIdx.x;
        int v135;
        v135 = v134 / 4;
        auto v136 = cooperative_groups::labeled_partition(v133,v135);
        Closure1 v137{};
        float v138;
        v138 = cooperative_groups::reduce(v136, v124, v137);
        int v139[4];
        int v140;
        v140 = 0;
        while (while_method_6(v140)){
            int v142;
            v142 = 0;
            while (while_method_3(v142)){
                assert("Tensor range check" && 0 <= v140 && v140 < 1);
                assert("Tensor range check" && 0 <= v142 && v142 < 4);
                int v144;
                v144 = 4 * v140;
                int v145;
                v145 = v144 + v142;
                bool v146;
                v146 = v102[v145];
                int v147;
                if (v146){
                    v147 = 1;
                } else {
                    v147 = 0;
                }
                assert("Tensor range check" && 0 <= v140 && v140 < 1);
                assert("Tensor range check" && 0 <= v142 && v142 < 4);
                v139[v145] = v147;
                v142 += 1 ;
            }
            v140 += 1 ;
        }
        int v148;
        v148 = 0;
        int v149;
        v149 = 0;
        while (while_method_6(v149)){
            int v151;
            v151 = 0;
            while (while_method_3(v151)){
                assert("Tensor range check" && 0 <= v149 && v149 < 1);
                assert("Tensor range check" && 0 <= v151 && v151 < 4);
                int v153;
                v153 = 4 * v149;
                int v154;
                v154 = v153 + v151;
                int v155;
                v155 = v139[v154];
                int v156;
                v156 = v148 + v155;
                v148 = v156;
                v151 += 1 ;
            }
            v149 += 1 ;
        }
        auto v157 = cooperative_groups::coalesced_threads();
        int v158;
        v158 = threadIdx.x;
        int v159;
        v159 = v158 / 4;
        auto v160 = cooperative_groups::labeled_partition(v157,v159);
        Closure2 v161{};
        int v162;
        v162 = cooperative_groups::reduce(v160, v148, v161);
        float v163;
        v163 = (float)v162;
        float v164;
        v164 = 1.0f / v163;
        float v165[4];
        int v166;
        v166 = 0;
        while (while_method_6(v166)){
            int v168;
            v168 = 0;
            while (while_method_3(v168)){
                assert("Tensor range check" && 0 <= v166 && v166 < 1);
                assert("Tensor range check" && 0 <= v168 && v168 < 4);
                int v170;
                v170 = 4 * v166;
                int v171;
                v171 = v170 + v168;
                float v172;
                v172 = v112[v171];
                bool v173;
                v173 = v102[v171];
                bool v174;
                v174 = v173 == false;
                float v179;
                if (v174){
                    v179 = 0.0f;
                } else {
                    bool v175;
                    v175 = v138 == 0.0f;
                    bool v176;
                    v176 = v175 != true;
                    if (v176){
                        float v177;
                        v177 = v172 / v138;
                        v179 = v177;
                    } else {
                        v179 = v164;
                    }
                }
                assert("Tensor range check" && 0 <= v166 && v166 < 1);
                assert("Tensor range check" && 0 <= v168 && v168 < 4);
                v165[v171] = v179;
                v168 += 1 ;
            }
            v166 += 1 ;
        }
        float v180; int v181;
        Tuple14 tmp90 = Tuple14{0.0f, 2147483647};
        v180 = tmp90.v0; v181 = tmp90.v1;
        int v182;
        v182 = 0;
        while (while_method_6(v182)){
            int v184;
            v184 = 0;
            while (while_method_3(v184)){
                assert("Tensor range check" && 0 <= v182 && v182 < 1);
                assert("Tensor range check" && 0 <= v184 && v184 < 4);
                int v186;
                v186 = 4 * v182;
                int v187;
                v187 = v186 + v184;
                float v188;
                v188 = v165[v187];
                int v189;
                v189 = v69[v187];
                bool v190;
                v190 = v181 == v62;
                float v194; int v195;
                if (v190){
                    v194 = v180; v195 = v181;
                } else {
                    bool v191;
                    v191 = v189 == v62;
                    if (v191){
                        v194 = v188; v195 = v189;
                    } else {
                        v194 = v180; v195 = v181;
                    }
                }
                v180 = v194;
                v181 = v195;
                v184 += 1 ;
            }
            v182 += 1 ;
        }
        auto v196 = cooperative_groups::coalesced_threads();
        int v197;
        v197 = threadIdx.x;
        int v198;
        v198 = v197 / 4;
        auto v199 = cooperative_groups::labeled_partition(v196,v198);
        Closure7 v200{v62};
        float v201; int v202;
        Tuple14 tmp91 = cooperative_groups::reduce(v199, Tuple14{v180, v181}, v200);
        v201 = tmp91.v0; v202 = tmp91.v1;
        bool v203;
        v203 = v202 == 2147483647;
        bool v204;
        v204 = v203 != true;
        bool v205;
        v205 = v204 == false;
        if (v205){
            assert("Expected a valid action id in get_action." && v204);
        } else {
        }
        int v207;
        v207 = 0;
        while (while_method_6(v207)){
            assert("Tensor range check" && 0 <= v207 && v207 < 1);
            assert("Tensor range check" && 0 <= v207 && v207 < 1);
            v207 += 1 ;
        }
        assert("Tensor range check" && 0 <= v59 && v59 < 256);
        v36[v59] = v201;
        v47 += 1 ;
    }
    asm("barrier.cta.sync %0;" :: "r"(0));
    assert("Tensor range check" && 0 <= v38 && v38 < 256);
    float v209;
    v209 = v36[v38];
    asm("barrier.cta.sync %0;" :: "r"(0));
    return v209;
}
__device__ void method_80(unsigned char * v0, unsigned char * v1, StackMut1 & v2, int v3, Union4 v4){
    v2.v0 = 4503599627370495ull;
    static_array<float,2> v5;
    v5[0] = 0.0f;
    v5[1] = 0.0f;
    v2.v4 = v5;
    static_array_list<Union6,128> & v7 = v2.v2;
    v7.unsafe_set_length(0);
    static_array<Union2,2> v8;
    Union2 v10;
    v10 = Union2{Union2_0{}};
    v8[0] = v10;
    Union2 v12;
    v12 = Union2{Union2_0{}};
    v8[1] = v12;
    int v14;
    v14 = v3 ^ 1;
    Union2 v15;
    v15 = Union2{Union2_2{}};
    v8[v14] = v15;
    v2.v3 = v8;
    static_array_list<Union6,128> & v17 = v2.v2;
    unsigned long long & v18 = v2.v0;
    Union3 v19;
    v19 = Union3{Union3_1{v4}};
    Union3 v20;
    v20 = v19;
    while (while_method_21(v20)){
        Union3 v1421;
        switch (v20.tag) {
            case 0: { // None
                v1421 = Union3{Union3_0{}};
                break;
            }
            case 1: { // Some
                Union4 v22 = v20.case1.v0;
                Union18 v1215;
                switch (v22.tag) {
                    case 0: { // G_Flop
                        int v1101 = v22.case0.v0; static_array<static_array<unsigned char,2>,2> v1102 = v22.case0.v1; static_array<int,2> v1103 = v22.case0.v2; int v1104 = v22.case0.v3; static_array<int,2> v1105 = v22.case0.v4; Union5 v1106 = v22.case0.v5;
                        curandStatePhilox4_32_10_t & v1107 = v2.v5;
                        curandStatePhilox4_32_10_t & v1108 = v1107;
                        static_array<unsigned char,3> v1109; unsigned long long v1110;
                        Tuple8 tmp85 = draw_cards_32(v1108, v18);
                        v1109 = tmp85.v0; v1110 = tmp85.v1;
                        v2.v0 = v1110;
                        static_array_list<unsigned char,5> v1111;
                        v1111 = get_community_cards_81(v1106, v1109);
                        Union6 v1112;
                        v1112 = Union6{Union6_0{v1111}};
                        v17.push(v1112);
                        Union5 v1115;
                        switch (v1106.tag) {
                            case 1: { // Preflop
                                v1115 = Union5{Union5_0{v1109}};
                                break;
                            }
                            default: {
                                printf("%s\n", "Invalid street in flop.");
                                __trap();
                            }
                        }
                        int v1116;
                        v1116 = 2;
                        int v1117;
                        v1117 = 0;
                        Union4 v1118;
                        v1118 = try_round_36(v1116, v1102, v1103, v1117, v1105, v1115);
                        v1215 = Union18{Union18_2{v1118}};
                        break;
                    }
                    case 1: { // G_Fold
                        int v23 = v22.case1.v0; static_array<static_array<unsigned char,2>,2> v24 = v22.case1.v1; static_array<int,2> v25 = v22.case1.v2; int v26 = v22.case1.v3; static_array<int,2> v27 = v22.case1.v4; Union5 v28 = v22.case1.v5;
                        int v29;
                        v29 = v26 % 2;
                        int v30;
                        v30 = v25[v29];
                        int v32;
                        v32 = v26 + 1;
                        int v33;
                        v33 = v32 % 2;
                        Union6 v34;
                        v34 = Union6{Union6_1{v30, v33}};
                        v17.push(v34);
                        v1215 = Union18{Union18_0{}};
                        break;
                    }
                    case 2: { // G_Preflop
                        curandStatePhilox4_32_10_t & v1182 = v2.v5;
                        curandStatePhilox4_32_10_t & v1183 = v1182;
                        static_array<unsigned char,2> v1184; unsigned long long v1185;
                        Tuple11 tmp86 = draw_cards_39(v1183, v18);
                        v1184 = tmp86.v0; v1185 = tmp86.v1;
                        v2.v0 = v1185;
                        curandStatePhilox4_32_10_t & v1186 = v2.v5;
                        curandStatePhilox4_32_10_t & v1187 = v1186;
                        static_array<unsigned char,2> v1188; unsigned long long v1189;
                        Tuple11 tmp87 = draw_cards_39(v1187, v18);
                        v1188 = tmp87.v0; v1189 = tmp87.v1;
                        v2.v0 = v1189;
                        Union6 v1190;
                        v1190 = Union6{Union6_3{0, v1184}};
                        v17.push(v1190);
                        Union6 v1191;
                        v1191 = Union6{Union6_3{1, v1188}};
                        v17.push(v1191);
                        static_array<static_array<unsigned char,2>,2> v1192;
                        v1192[0] = v1184;
                        v1192[1] = v1188;
                        static_array<int,2> v1194;
                        v1194[0] = 2;
                        v1194[1] = 1;
                        static_array<int,2> v1196;
                        int v1198;
                        v1198 = 0;
                        while (while_method_0(v1198)){
                            int v1200;
                            v1200 = v1194[v1198];
                            int v1202;
                            v1202 = 100 - v1200;
                            v1196[v1198] = v1202;
                            v1198 += 1 ;
                        }
                        int v1203;
                        v1203 = 2;
                        int v1204;
                        v1204 = 0;
                        Union5 v1205;
                        v1205 = Union5{Union5_1{}};
                        Union4 v1206;
                        v1206 = try_round_36(v1203, v1192, v1194, v1204, v1196, v1205);
                        v1215 = Union18{Union18_2{v1206}};
                        break;
                    }
                    case 3: { // G_River
                        int v1151 = v22.case3.v0; static_array<static_array<unsigned char,2>,2> v1152 = v22.case3.v1; static_array<int,2> v1153 = v22.case3.v2; int v1154 = v22.case3.v3; static_array<int,2> v1155 = v22.case3.v4; Union5 v1156 = v22.case3.v5;
                        curandStatePhilox4_32_10_t & v1157 = v2.v5;
                        curandStatePhilox4_32_10_t & v1158 = v1157;
                        static_array<unsigned char,1> v1159; unsigned long long v1160;
                        Tuple12 tmp88 = draw_cards_40(v1158, v18);
                        v1159 = tmp88.v0; v1160 = tmp88.v1;
                        v2.v0 = v1160;
                        static_array_list<unsigned char,5> v1161;
                        v1161 = get_community_cards_82(v1156, v1159);
                        Union6 v1162;
                        v1162 = Union6{Union6_0{v1161}};
                        v17.push(v1162);
                        Union5 v1177;
                        switch (v1156.tag) {
                            case 3: { // Turn
                                static_array<unsigned char,4> v1163 = v1156.case3.v0;
                                static_array<unsigned char,5> v1164;
                                int v1166;
                                v1166 = 0;
                                while (while_method_3(v1166)){
                                    unsigned char v1168;
                                    v1168 = v1163[v1166];
                                    v1164[v1166] = v1168;
                                    v1166 += 1 ;
                                }
                                int v1170;
                                v1170 = 0;
                                while (while_method_6(v1170)){
                                    unsigned char v1172;
                                    v1172 = v1159[v1170];
                                    int v1174;
                                    v1174 = 4 + v1170;
                                    v1164[v1174] = v1172;
                                    v1170 += 1 ;
                                }
                                v1177 = Union5{Union5_2{v1164}};
                                break;
                            }
                            default: {
                                printf("%s\n", "Invalid street in river.");
                                __trap();
                            }
                        }
                        int v1178;
                        v1178 = 2;
                        int v1179;
                        v1179 = 0;
                        Union4 v1180;
                        v1180 = try_round_36(v1178, v1152, v1153, v1179, v1155, v1177);
                        v1215 = Union18{Union18_2{v1180}};
                        break;
                    }
                    case 4: { // G_Round
                        int v114 = v22.case4.v0; static_array<static_array<unsigned char,2>,2> v115 = v22.case4.v1; static_array<int,2> v116 = v22.case4.v2; int v117 = v22.case4.v3; static_array<int,2> v118 = v22.case4.v4; Union5 v119 = v22.case4.v5;
                        int v120;
                        v120 = v117 % 2;
                        static_array<Union2,2> & v121 = v2.v3;
                        Union2 v122;
                        v122 = v121[v120];
                        Union1 v1088;
                        switch (v122.tag) {
                            case 0: { // Computer
                                static_array_list<Union6,128> & v125 = v2.v2;
                                curandStatePhilox4_32_10_t & v126 = v2.v5;
                                curandStatePhilox4_32_10_t & v127 = v126;
                                unsigned int * v128;
                                v128 = reinterpret_cast<unsigned int *>(&v0[53477376ull]);
                                float * v130;
                                v130 = reinterpret_cast<float *>(&v0[0ull]);
                                int v132;
                                v132 = threadIdx.x;
                                int v133;
                                v133 = blockIdx.x;
                                int v134;
                                v134 = v133 * 256;
                                int v135;
                                v135 = v132 + v134;
                                unsigned long long v136;
                                v136 = (unsigned long long)v135;
                                curandStatePhilox4_32_10_t v137;
                                curand_init(12344321ull,v136,0ull,&v137);
                                float * v138;
                                v138 = reinterpret_cast<float *>(&v0[0ull]);
                                int v140;
                                v140 = blockIdx.x;
                                assert("Tensor range check" && 0 <= v140 && v140 < 24);
                                int v141;
                                v141 = 524288 * v140;
                                int v142;
                                v142 = threadIdx.x;
                                int v143;
                                v143 = blockIdx.x;
                                int v144;
                                v144 = v143 * 256;
                                int v145;
                                v145 = v142 + v144;
                                unsigned long long v146;
                                v146 = (unsigned long long)v145;
                                curandStatePhilox4_32_10_t v147;
                                curand_init(12344321ull,v146,0ull,&v147);
                                int v148;
                                v148 = threadIdx.x;
                                int v149;
                                v149 = v148;
                                while (while_method_7(v149)){
                                    bool v151;
                                    v151 = 0 <= v149;
                                    bool v152;
                                    v152 = v151 == false;
                                    if (v152){
                                        assert("The index needs to be zero or positive." && v151);
                                    } else {
                                    }
                                    int v154;
                                    v154 = v149 % 2048;
                                    int v155;
                                    v155 = v149 / 2048;
                                    bool v156;
                                    v156 = v155 < 256;
                                    bool v157;
                                    v157 = v156 == false;
                                    if (v157){
                                        assert("The last element of the projection dimensions needs to be greater than the index remainder." && v156);
                                    } else {
                                    }
                                    assert("Tensor range check" && 0 <= v155 && v155 < 256);
                                    assert("Tensor range check" && 0 <= v154 && v154 < 2048);
                                    int v159;
                                    v159 = v154 + v141;
                                    int v160;
                                    v160 = 2048 * v155;
                                    int v161;
                                    v161 = v160 + v159;
                                    v138[v161] = 0.0f;
                                    v149 += 256 ;
                                }
                                asm("barrier.cta.sync %0;" :: "r"(0));
                                int v162;
                                v162 = threadIdx.x;
                                assert("Tensor range check" && 0 <= v162 && v162 < 256);
                                int v163;
                                v163 = 2048 * v162;
                                int v164;
                                v164 = v163 + v141;
                                int v165;
                                v165 = v125.length;
                                bool v166;
                                v166 = 128 >= v165;
                                bool v167;
                                v167 = v166 == false;
                                if (v167){
                                    assert("The type level dimension has to equal the value passed at runtime into create." && v166);
                                } else {
                                }
                                static_array_list<Union8,128> v169;
                                v169 = static_array_list<Union8,128>{};
                                v169.unsafe_set_length(v165);
                                int v171;
                                v171 = 0;
                                while (while_method_4(v165, v171)){
                                    Union6 v173;
                                    v173 = v125[v171];
                                    Union8 v179;
                                    switch (v173.tag) {
                                        case 2: { // PlayerAction
                                            int v175 = v173.case2.v0; Union1 v176 = v173.case2.v1;
                                            v179 = Union8{Union8_1{v176}};
                                            break;
                                        }
                                        default: {
                                            v179 = Union8{Union8_0{}};
                                        }
                                    }
                                    v169[v171] = v179;
                                    v171 += 1 ;
                                }
                                static_array<int,2> v180;
                                int v182;
                                v182 = 0;
                                while (while_method_0(v182)){
                                    int v184;
                                    v184 = v182 + v120;
                                    int v185;
                                    v185 = v116[v184];
                                    v180[v182] = v185;
                                    v182 += 1 ;
                                }
                                static_array<int,2> v187;
                                int v189;
                                v189 = 0;
                                while (while_method_0(v189)){
                                    int v191;
                                    v191 = v189 + v120;
                                    int v192;
                                    v192 = v118[v191];
                                    v187[v189] = v192;
                                    v189 += 1 ;
                                }
                                static_array<unsigned char,2> v194;
                                v194 = v115[v120];
                                static_array_list<unsigned char,5> v196;
                                v196 = static_array_list<unsigned char,5>{};
                                switch (v119.tag) {
                                    case 0: { // Flop
                                        static_array<unsigned char,3> v198 = v119.case0.v0;
                                        int v199;
                                        v199 = 0;
                                        while (while_method_1(v199)){
                                            unsigned char v201;
                                            v201 = v198[v199];
                                            v196.push(v201);
                                            v199 += 1 ;
                                        }
                                        break;
                                    }
                                    case 1: { // Preflop
                                        break;
                                    }
                                    case 2: { // River
                                        static_array<unsigned char,5> v208 = v119.case2.v0;
                                        int v209;
                                        v209 = 0;
                                        while (while_method_2(v209)){
                                            unsigned char v211;
                                            v211 = v208[v209];
                                            v196.push(v211);
                                            v209 += 1 ;
                                        }
                                        break;
                                    }
                                    case 3: { // Turn
                                        static_array<unsigned char,4> v203 = v119.case3.v0;
                                        int v204;
                                        v204 = 0;
                                        while (while_method_3(v204)){
                                            unsigned char v206;
                                            v206 = v203[v204];
                                            v196.push(v206);
                                            v204 += 1 ;
                                        }
                                        break;
                                    }
                                    default: {
                                        assert("Invalid tag." && false); __trap();
                                    }
                                }
                                float * v213;
                                v213 = v138+v164;
                                int v215;
                                v215 = v169.length;
                                bool v216;
                                v216 = v215 == 0;
                                if (v216){
                                    v213[0] = 1.0f;
                                } else {
                                }
                                int v217;
                                v217 = v169.length;
                                int v218;
                                v218 = 0;
                                while (while_method_4(v217, v218)){
                                    Union8 v220;
                                    v220 = v169[v218];
                                    int v222;
                                    v222 = v218 * 14;
                                    int v223;
                                    v223 = 1 + v222;
                                    switch (v220.tag) {
                                        case 0: { // None
                                            v213[v223] = 1.0f;
                                            break;
                                        }
                                        case 1: { // Some
                                            Union1 v224 = v220.case1.v0;
                                            int v225;
                                            v225 = v223 + 1;
                                            switch (v224.tag) {
                                                case 0: { // A_All_In
                                                    v213[v225] = 1.0f;
                                                    break;
                                                }
                                                case 1: { // A_Call
                                                    int v226;
                                                    v226 = v225 + 1;
                                                    v213[v226] = 1.0f;
                                                    break;
                                                }
                                                case 2: { // A_Fold
                                                    int v227;
                                                    v227 = v225 + 2;
                                                    v213[v227] = 1.0f;
                                                    break;
                                                }
                                                case 3: { // A_Raise
                                                    int v228 = v224.case3.v0;
                                                    int v229;
                                                    v229 = v225 + 3;
                                                    bool v230;
                                                    v230 = 1 <= v228;
                                                    bool v232;
                                                    if (v230){
                                                        bool v231;
                                                        v231 = v228 < 1023;
                                                        v232 = v231;
                                                    } else {
                                                        v232 = false;
                                                    }
                                                    bool v233;
                                                    v233 = v232 == false;
                                                    if (v233){
                                                        assert("Pickle failure. The input is out of the bounds of the given range." && v232);
                                                    } else {
                                                    }
                                                    int v235;
                                                    v235 = v228 - 1;
                                                    unsigned int v236;
                                                    v236 = (unsigned int)v235;
                                                    method_42(v236, v213, v229);
                                                    break;
                                                }
                                                default: {
                                                    assert("Invalid tag." && false); __trap();
                                                }
                                            }
                                            break;
                                        }
                                        default: {
                                            assert("Invalid tag." && false); __trap();
                                        }
                                    }
                                    v218 += 1 ;
                                }
                                int v237;
                                v237 = 0;
                                while (while_method_0(v237)){
                                    int v239;
                                    v239 = v180[v237];
                                    int v241;
                                    v241 = v237 * 11;
                                    int v242;
                                    v242 = 1794 + v241;
                                    bool v243;
                                    v243 = 0 <= v239;
                                    bool v245;
                                    if (v243){
                                        bool v244;
                                        v244 = v239 < 1023;
                                        v245 = v244;
                                    } else {
                                        v245 = false;
                                    }
                                    bool v246;
                                    v246 = v245 == false;
                                    if (v246){
                                        assert("Pickle failure. The input is out of the bounds of the given range." && v245);
                                    } else {
                                    }
                                    unsigned int v248;
                                    v248 = (unsigned int)v239;
                                    method_43(v248, v213, v242);
                                    v237 += 1 ;
                                }
                                int v249;
                                v249 = 0;
                                while (while_method_0(v249)){
                                    int v251;
                                    v251 = v187[v249];
                                    int v253;
                                    v253 = v249 * 11;
                                    int v254;
                                    v254 = 1817 + v253;
                                    bool v255;
                                    v255 = 0 <= v251;
                                    bool v257;
                                    if (v255){
                                        bool v256;
                                        v256 = v251 < 1023;
                                        v257 = v256;
                                    } else {
                                        v257 = false;
                                    }
                                    bool v258;
                                    v258 = v257 == false;
                                    if (v258){
                                        assert("Pickle failure. The input is out of the bounds of the given range." && v257);
                                    } else {
                                    }
                                    unsigned int v260;
                                    v260 = (unsigned int)v251;
                                    method_43(v260, v213, v254);
                                    v249 += 1 ;
                                }
                                int v261;
                                v261 = 0;
                                while (while_method_0(v261)){
                                    unsigned char v263;
                                    v263 = v194[v261];
                                    int v265;
                                    v265 = v261 * 17;
                                    int v266;
                                    v266 = 1840 + v265;
                                    unsigned char v267;
                                    v267 = v263 % 4u;
                                    int v268;
                                    v268 = (int)v267;
                                    unsigned char v269;
                                    v269 = v263 / 4u;
                                    int v270;
                                    v270 = (int)v269;
                                    unsigned int v271;
                                    v271 = (unsigned int)v268;
                                    int v272;
                                    v272 = (int)v271;
                                    bool v273;
                                    v273 = v272 < 4;
                                    bool v274;
                                    v274 = v273 == false;
                                    if (v274){
                                        assert("Pickle failure. Int value out of bounds." && v273);
                                    } else {
                                    }
                                    int v276;
                                    v276 = v266 + v272;
                                    v213[v276] = 1.0f;
                                    int v277;
                                    v277 = v266 + 4;
                                    unsigned int v278;
                                    v278 = (unsigned int)v270;
                                    int v279;
                                    v279 = (int)v278;
                                    bool v280;
                                    v280 = v279 < 13;
                                    bool v281;
                                    v281 = v280 == false;
                                    if (v281){
                                        assert("Pickle failure. Int value out of bounds." && v280);
                                    } else {
                                    }
                                    int v283;
                                    v283 = v277 + v279;
                                    v213[v283] = 1.0f;
                                    v261 += 1 ;
                                }
                                int v284;
                                v284 = v196.length;
                                bool v285;
                                v285 = v284 == 0;
                                if (v285){
                                    v213[1874] = 1.0f;
                                } else {
                                }
                                int v286;
                                v286 = v196.length;
                                int v287;
                                v287 = 0;
                                while (while_method_4(v286, v287)){
                                    unsigned char v289;
                                    v289 = v196[v287];
                                    int v291;
                                    v291 = v287 * 17;
                                    int v292;
                                    v292 = 1875 + v291;
                                    unsigned char v293;
                                    v293 = v289 % 4u;
                                    int v294;
                                    v294 = (int)v293;
                                    unsigned char v295;
                                    v295 = v289 / 4u;
                                    int v296;
                                    v296 = (int)v295;
                                    unsigned int v297;
                                    v297 = (unsigned int)v294;
                                    int v298;
                                    v298 = (int)v297;
                                    bool v299;
                                    v299 = v298 < 4;
                                    bool v300;
                                    v300 = v299 == false;
                                    if (v300){
                                        assert("Pickle failure. Int value out of bounds." && v299);
                                    } else {
                                    }
                                    int v302;
                                    v302 = v292 + v298;
                                    v213[v302] = 1.0f;
                                    int v303;
                                    v303 = v292 + 4;
                                    unsigned int v304;
                                    v304 = (unsigned int)v296;
                                    int v305;
                                    v305 = (int)v304;
                                    bool v306;
                                    v306 = v305 < 13;
                                    bool v307;
                                    v307 = v306 == false;
                                    if (v307){
                                        assert("Pickle failure. Int value out of bounds." && v306);
                                    } else {
                                    }
                                    int v309;
                                    v309 = v303 + v305;
                                    v213[v309] = 1.0f;
                                    v287 += 1 ;
                                }
                                asm("barrier.cta.sync %0;" :: "r"(0));
                                int v310;
                                v310 = 0;
                                while (while_method_3(v310)){
                                    float * v312;
                                    v312 = reinterpret_cast<float *>(&v0[0ull]);
                                    float * v314;
                                    v314 = reinterpret_cast<float *>(&v1[0ull]);
                                    assert("Tensor range check" && 0 <= v310 && v310 < 4);
                                    int v316;
                                    v316 = 262144 * v310;
                                    float * v317;
                                    v317 = reinterpret_cast<float *>(&v0[50331648ull]);
                                    int v319;
                                    v319 = blockIdx.x;
                                    assert("Tensor range check" && 0 <= v319 && v319 < 24);
                                    int v320;
                                    v320 = 524288 * v319;
                                    int v321;
                                    v321 = blockIdx.x;
                                    assert("Tensor range check" && 0 <= v321 && v321 < 24);
                                    int v322;
                                    v322 = 32768 * v321;
                                    cuda::pipeline<cuda::thread_scope_thread> v323 = cuda::make_pipeline();
                                    extern __shared__ unsigned char v324[];
                                    float * v325;
                                    v325 = reinterpret_cast<float *>(&v324[0ull]);
                                    float * v327;
                                    v327 = reinterpret_cast<float *>(&v324[34816ull]);
                                    float * v329;
                                    v329 = reinterpret_cast<float *>(&v324[0ull]);
                                    int v331;
                                    v331 = threadIdx.x;
                                    int v332;
                                    v332 = v331 / 32;
                                    bool v333;
                                    v333 = 0 <= v332;
                                    bool v334;
                                    v334 = v333 == false;
                                    if (v334){
                                        assert("The index needs to be zero or positive." && v333);
                                    } else {
                                    }
                                    int v336;
                                    v336 = v332 % 8;
                                    int v337;
                                    v337 = v332 / 8;
                                    bool v338;
                                    v338 = v337 < 1;
                                    bool v339;
                                    v339 = v338 == false;
                                    if (v339){
                                        assert("The last element of the projection dimensions needs to be greater than the index remainder." && v338);
                                    } else {
                                    }
                                    assert("Tensor range check" && 0 <= v337 && v337 < 1);
                                    assert("Tensor range check" && 0 <= v336 && v336 < 8);
                                    int v341;
                                    v341 = 16 * v336;
                                    int v342;
                                    v342 = 17408 * v337;
                                    int v343;
                                    v343 = v342 + v341;
                                    float * v344;
                                    v344 = v329+v343;
                                    assert("Tensor range check" && 0 <= v337 && v337 < 1);
                                    int v346;
                                    v346 = 8704 * v337;
                                    int v347;
                                    v347 = threadIdx.x;
                                    int v348;
                                    v348 = v347 % 32;
                                    bool v349;
                                    v349 = 0 <= v348;
                                    bool v350;
                                    v350 = v349 == false;
                                    if (v350){
                                        assert("The index needs to be zero or positive." && v349);
                                    } else {
                                    }
                                    int v352;
                                    v352 = v348 % 4;
                                    int v353;
                                    v353 = v348 / 4;
                                    bool v354;
                                    v354 = v353 < 8;
                                    bool v355;
                                    v355 = v354 == false;
                                    if (v355){
                                        assert("The last element of the projection dimensions needs to be greater than the index remainder." && v354);
                                    } else {
                                    }
                                    assert("Tensor range check" && 0 <= v353 && v353 < 8);
                                    assert("Tensor range check" && 0 <= v352 && v352 < 4);
                                    int v357;
                                    v357 = v352 + v346;
                                    int v358;
                                    v358 = 68 * v353;
                                    int v359;
                                    v359 = v358 + v357;
                                    float * v360;
                                    v360 = v325+v359;
                                    assert("Tensor range check" && 0 <= v336 && v336 < 8);
                                    int v362;
                                    v362 = 1088 * v336;
                                    int v363;
                                    v363 = threadIdx.x;
                                    int v364;
                                    v364 = v363 % 32;
                                    bool v365;
                                    v365 = 0 <= v364;
                                    bool v366;
                                    v366 = v365 == false;
                                    if (v366){
                                        assert("The index needs to be zero or positive." && v365);
                                    } else {
                                    }
                                    int v368;
                                    v368 = v364 % 4;
                                    int v369;
                                    v369 = v364 / 4;
                                    bool v370;
                                    v370 = v369 < 8;
                                    bool v371;
                                    v371 = v370 == false;
                                    if (v371){
                                        assert("The last element of the projection dimensions needs to be greater than the index remainder." && v370);
                                    } else {
                                    }
                                    assert("Tensor range check" && 0 <= v369 && v369 < 8);
                                    assert("Tensor range check" && 0 <= v368 && v368 < 4);
                                    int v373;
                                    v373 = v368 + v362;
                                    int v374;
                                    v374 = 68 * v369;
                                    int v375;
                                    v375 = v374 + v373;
                                    float * v376;
                                    v376 = v327+v375;
                                    wmma::fragment<wmma::accumulator, 16, 16, 8, float> v378[8];
                                    int v379;
                                    v379 = 0;
                                    while (while_method_0(v379)){
                                        int v381;
                                        v381 = 0;
                                        while (while_method_6(v381)){
                                            assert("Tensor range check" && 0 <= v379 && v379 < 2);
                                            assert("Tensor range check" && 0 <= v381 && v381 < 1);
                                            int v383;
                                            v383 = 128 * v381;
                                            int v384;
                                            v384 = v383 + v322;
                                            int v385;
                                            v385 = 16384 * v379;
                                            int v386;
                                            v386 = v385 + v384;
                                            float * v387;
                                            v387 = v317+v386;
                                            // Pushing the loop unrolling to: 0
                                            int v389;
                                            v389 = 0;
                                            #pragma unroll
                                            while (while_method_10(v389)){
                                                int v391;
                                                v391 = 0;
                                                #pragma unroll
                                                while (while_method_6(v391)){
                                                    assert("Tensor range check" && 0 <= v389 && v389 < 8);
                                                    assert("Tensor range check" && 0 <= v391 && v391 < 1);
                                                    int v393;
                                                    v393 = v389 + v391;
                                                    wmma::fragment<wmma::accumulator, 16, 16, 8, float> & v394 = v378[v393];
                                                    wmma::fill_fragment(v394, 0.0f);
                                                    v391 += 1 ;
                                                }
                                                v389 += 1 ;
                                            }
                                            // Poping the loop unrolling to: 0
                                            int v395;
                                            v395 = 0;
                                            while (while_method_11(v395)){
                                                int v397;
                                                v397 = v395 + 1;
                                                bool v398;
                                                v398 = v395 == 0;
                                                int v399;
                                                v399 = v395 % 2;
                                                bool v400;
                                                v400 = 0 <= v395;
                                                bool v401;
                                                v401 = v400 == false;
                                                if (v401){
                                                    assert("The index needs to be zero or positive." && v400);
                                                } else {
                                                }
                                                bool v403;
                                                v403 = v395 < 32;
                                                bool v404;
                                                v404 = v403 == false;
                                                if (v404){
                                                    assert("The last element of the projection dimensions needs to be greater than the index remainder." && v403);
                                                } else {
                                                }
                                                bool v406;
                                                v406 = v397 < 32;
                                                Union9 v412;
                                                if (v406){
                                                    bool v407;
                                                    v407 = 0 <= v397;
                                                    bool v408;
                                                    v408 = v407 == false;
                                                    if (v408){
                                                        assert("The index needs to be zero or positive." && v407);
                                                    } else {
                                                    }
                                                    v412 = Union9{Union9_1{v397}};
                                                } else {
                                                    v412 = Union9{Union9_0{}};
                                                }
                                                assert("Tensor range check" && 0 <= v379 && v379 < 2);
                                                int v413;
                                                v413 = 262144 * v379;
                                                int v414;
                                                v414 = v413 + v320;
                                                assert("Tensor range check" && 0 <= v395 && v395 < 32);
                                                int v415;
                                                v415 = 64 * v395;
                                                int v416;
                                                v416 = v415 + v414;
                                                float * v417;
                                                v417 = v312+v416;
                                                assert("Tensor range check" && 0 <= v381 && v381 < 1);
                                                int v419;
                                                v419 = 262144 * v381;
                                                int v420;
                                                v420 = v419 + v316;
                                                if (v398){
                                                    assert("Tensor range check" && 0 <= v395 && v395 < 32);
                                                    int v421;
                                                    v421 = v415 + v420;
                                                    float * v422;
                                                    v422 = v314+v421;
                                                    // Pushing the loop unrolling to: 0
                                                    v323.producer_acquire();
                                                    int v424;
                                                    v424 = threadIdx.x;
                                                    bool v425;
                                                    v425 = 0 <= v424;
                                                    bool v426;
                                                    v426 = v425 == false;
                                                    if (v426){
                                                        assert("The index needs to be zero or positive." && v425);
                                                    } else {
                                                    }
                                                    int v428;
                                                    v428 = v424 % 16;
                                                    int v429;
                                                    v429 = v424 / 16;
                                                    bool v430;
                                                    v430 = v429 < 16;
                                                    bool v431;
                                                    v431 = v430 == false;
                                                    if (v431){
                                                        assert("The last element of the projection dimensions needs to be greater than the index remainder." && v430);
                                                    } else {
                                                    }
                                                    assert("Tensor range check" && 0 <= v429 && v429 < 16);
                                                    assert("Tensor range check" && 0 <= v428 && v428 < 16);
                                                    int v433;
                                                    v433 = 4 * v428;
                                                    int v434;
                                                    v434 = 68 * v429;
                                                    int v435;
                                                    v435 = v434 + v433;
                                                    int v436;
                                                    v436 = 2048 * v429;
                                                    int v437;
                                                    v437 = v436 + v433;
                                                    float * v438;
                                                    v438 = v327+v435;
                                                    float * v440;
                                                    v440 = v422+v437;
                                                    int v442;
                                                    v442 = 0;
                                                    #pragma unroll
                                                    while (while_method_10(v442)){
                                                        int v444;
                                                        v444 = 0;
                                                        #pragma unroll
                                                        while (while_method_6(v444)){
                                                            assert("Tensor range check" && 0 <= v442 && v442 < 8);
                                                            assert("Tensor range check" && 0 <= v444 && v444 < 1);
                                                            int v446;
                                                            v446 = 64 * v444;
                                                            int v447;
                                                            v447 = 1088 * v442;
                                                            int v448;
                                                            v448 = v447 + v446;
                                                            int v449;
                                                            v449 = 32768 * v442;
                                                            int v450;
                                                            v450 = v449 + v446;
                                                            constexpr int v451 = sizeof(float) * 4;
                                                            assert("Pointer alignment check" && (unsigned long long)(v440 + v450) % v451 == 0 && (unsigned long long)(v438 + v448) % v451 == 0);
                                                            cuda::memcpy_async(v438 + v448, v440 + v450, cuda::aligned_size_t<v451>(v451), v323);
                                                            v444 += 1 ;
                                                        }
                                                        v442 += 1 ;
                                                    }
                                                    v323.producer_commit();
                                                    // Poping the loop unrolling to: 0
                                                } else {
                                                }
                                                // Pushing the loop unrolling to: 0
                                                int v452;
                                                v452 = threadIdx.x;
                                                bool v453;
                                                v453 = 0 <= v452;
                                                bool v454;
                                                v454 = v453 == false;
                                                if (v454){
                                                    assert("The index needs to be zero or positive." && v453);
                                                } else {
                                                }
                                                int v456;
                                                v456 = v452 % 16;
                                                int v457;
                                                v457 = v452 / 16;
                                                bool v458;
                                                v458 = v457 < 16;
                                                bool v459;
                                                v459 = v458 == false;
                                                if (v459){
                                                    assert("The last element of the projection dimensions needs to be greater than the index remainder." && v458);
                                                } else {
                                                }
                                                assert("Tensor range check" && 0 <= v457 && v457 < 16);
                                                assert("Tensor range check" && 0 <= v456 && v456 < 16);
                                                int v461;
                                                v461 = 4 * v456;
                                                int v462;
                                                v462 = 68 * v457;
                                                int v463;
                                                v463 = v462 + v461;
                                                int v464;
                                                v464 = 2048 * v457;
                                                int v465;
                                                v465 = v464 + v461;
                                                float * v466;
                                                v466 = v325+v463;
                                                float * v468;
                                                v468 = v417+v465;
                                                int v470;
                                                v470 = 0;
                                                #pragma unroll
                                                while (while_method_10(v470)){
                                                    int v472;
                                                    v472 = 0;
                                                    #pragma unroll
                                                    while (while_method_6(v472)){
                                                        assert("Tensor range check" && 0 <= v470 && v470 < 8);
                                                        assert("Tensor range check" && 0 <= v472 && v472 < 1);
                                                        int v474;
                                                        v474 = 64 * v472;
                                                        int v475;
                                                        v475 = 1088 * v470;
                                                        int v476;
                                                        v476 = v475 + v474;
                                                        int v477;
                                                        v477 = 32768 * v470;
                                                        int v478;
                                                        v478 = v477 + v474;
                                                        int4* v479;
                                                        v479 = reinterpret_cast<int4*>(v468 + v478);
                                                        int4* v480;
                                                        v480 = reinterpret_cast<int4*>(v466 + v476);
                                                        assert("Pointer alignment check" && (unsigned long long)(v479) % 4 == 0 && (unsigned long long)(v480) % 4 == 0);
                                                        *v480 = *v479;
                                                        v472 += 1 ;
                                                    }
                                                    v470 += 1 ;
                                                }
                                                // Poping the loop unrolling to: 0
                                                wmma::fragment<wmma::matrix_a, 16, 16, 8, wmma::precision::tf32, wmma::row_major> v481[1];
                                                wmma::fragment<wmma::matrix_b, 16, 16, 8, wmma::precision::tf32, wmma::col_major> v482[8];
                                                cuda::pipeline_consumer_wait_prior<0>(v323);;
                                                asm("barrier.cta.sync %0;" :: "r"(0));
                                                // Pushing the loop unrolling to: 0
                                                int v483;
                                                v483 = 0;
                                                #pragma unroll
                                                while (while_method_6(v483)){
                                                    int v485;
                                                    v485 = 0;
                                                    #pragma unroll
                                                    while (while_method_10(v485)){
                                                        assert("Tensor range check" && 0 <= v483 && v483 < 1);
                                                        assert("Tensor range check" && 0 <= v485 && v485 < 8);
                                                        int v487;
                                                        v487 = 8 * v483;
                                                        int v488;
                                                        v488 = v487 + v485;
                                                        wmma::fragment<wmma::matrix_b, 16, 16, 8, wmma::precision::tf32, wmma::col_major> & v489 = v482[v488];
                                                        assert("Tensor range check" && 0 <= v483 && v483 < 1);
                                                        int v490;
                                                        v490 = 1088 * v483;
                                                        assert("Tensor range check" && 0 <= v485 && v485 < 8);
                                                        int v491;
                                                        v491 = 8 * v485;
                                                        int v492;
                                                        v492 = v491 + v490;
                                                        int v493;
                                                        v493 = 0;
                                                        #pragma unroll
                                                        while (while_method_0(v493)){
                                                            int v495;
                                                            v495 = 0;
                                                            #pragma unroll
                                                            while (while_method_0(v495)){
                                                                assert("Tensor range check" && 0 <= v493 && v493 < 2);
                                                                assert("Tensor range check" && 0 <= v495 && v495 < 2);
                                                                int v497;
                                                                v497 = 4 * v495;
                                                                int v498;
                                                                v498 = v497 + v492;
                                                                int v499;
                                                                v499 = 544 * v493;
                                                                int v500;
                                                                v500 = v499 + v498;
                                                                float v501;
                                                                v501 = v376[v500];
                                                                bool v502;
                                                                v502 = 0 <= v495;
                                                                bool v504;
                                                                if (v502){
                                                                    bool v503;
                                                                    v503 = v495 < 2;
                                                                    v504 = v503;
                                                                } else {
                                                                    v504 = false;
                                                                }
                                                                bool v505;
                                                                v505 = v504 == false;
                                                                if (v505){
                                                                    assert("The indices should be inside the range of the dimension." && v504);
                                                                } else {
                                                                }
                                                                bool v507;
                                                                v507 = 0 <= v493;
                                                                bool v509;
                                                                if (v507){
                                                                    bool v508;
                                                                    v508 = v493 < 2;
                                                                    v509 = v508;
                                                                } else {
                                                                    v509 = false;
                                                                }
                                                                bool v510;
                                                                v510 = v509 == false;
                                                                if (v510){
                                                                    assert("The indices should be inside the range of the dimension." && v509);
                                                                } else {
                                                                }
                                                                int v512;
                                                                v512 = v493 * 2;
                                                                int v513;
                                                                v513 = v495 + v512;
                                                                v489.x[v513] = wmma::__float_to_tf32(v501);
                                                                v495 += 1 ;
                                                            }
                                                            v493 += 1 ;
                                                        }
                                                        v485 += 1 ;
                                                    }
                                                    v483 += 1 ;
                                                }
                                                // Poping the loop unrolling to: 0
                                                v323.consumer_release();
                                                switch (v412.tag) {
                                                    case 0: { // None
                                                        break;
                                                    }
                                                    case 1: { // Some
                                                        int v514 = v412.case1.v0;
                                                        assert("Tensor range check" && 0 <= v514 && v514 < 32);
                                                        int v515;
                                                        v515 = 64 * v514;
                                                        int v516;
                                                        v516 = v515 + v420;
                                                        float * v517;
                                                        v517 = v314+v516;
                                                        asm("barrier.cta.sync %0;" :: "r"(0));
                                                        // Pushing the loop unrolling to: 0
                                                        v323.producer_acquire();
                                                        int v519;
                                                        v519 = threadIdx.x;
                                                        bool v520;
                                                        v520 = 0 <= v519;
                                                        bool v521;
                                                        v521 = v520 == false;
                                                        if (v521){
                                                            assert("The index needs to be zero or positive." && v520);
                                                        } else {
                                                        }
                                                        int v523;
                                                        v523 = v519 % 16;
                                                        int v524;
                                                        v524 = v519 / 16;
                                                        bool v525;
                                                        v525 = v524 < 16;
                                                        bool v526;
                                                        v526 = v525 == false;
                                                        if (v526){
                                                            assert("The last element of the projection dimensions needs to be greater than the index remainder." && v525);
                                                        } else {
                                                        }
                                                        assert("Tensor range check" && 0 <= v524 && v524 < 16);
                                                        assert("Tensor range check" && 0 <= v523 && v523 < 16);
                                                        int v528;
                                                        v528 = 4 * v523;
                                                        int v529;
                                                        v529 = 68 * v524;
                                                        int v530;
                                                        v530 = v529 + v528;
                                                        int v531;
                                                        v531 = 2048 * v524;
                                                        int v532;
                                                        v532 = v531 + v528;
                                                        float * v533;
                                                        v533 = v327+v530;
                                                        float * v535;
                                                        v535 = v517+v532;
                                                        int v537;
                                                        v537 = 0;
                                                        #pragma unroll
                                                        while (while_method_10(v537)){
                                                            int v539;
                                                            v539 = 0;
                                                            #pragma unroll
                                                            while (while_method_6(v539)){
                                                                assert("Tensor range check" && 0 <= v537 && v537 < 8);
                                                                assert("Tensor range check" && 0 <= v539 && v539 < 1);
                                                                int v541;
                                                                v541 = 64 * v539;
                                                                int v542;
                                                                v542 = 1088 * v537;
                                                                int v543;
                                                                v543 = v542 + v541;
                                                                int v544;
                                                                v544 = 32768 * v537;
                                                                int v545;
                                                                v545 = v544 + v541;
                                                                constexpr int v546 = sizeof(float) * 4;
                                                                assert("Pointer alignment check" && (unsigned long long)(v535 + v545) % v546 == 0 && (unsigned long long)(v533 + v543) % v546 == 0);
                                                                cuda::memcpy_async(v533 + v543, v535 + v545, cuda::aligned_size_t<v546>(v546), v323);
                                                                v539 += 1 ;
                                                            }
                                                            v537 += 1 ;
                                                        }
                                                        v323.producer_commit();
                                                        // Poping the loop unrolling to: 0
                                                        break;
                                                    }
                                                    default: {
                                                        assert("Invalid tag." && false); __trap();
                                                    }
                                                }
                                                // Pushing the loop unrolling to: 0
                                                int v547;
                                                v547 = 0;
                                                #pragma unroll
                                                while (while_method_10(v547)){
                                                    int v549;
                                                    v549 = 0;
                                                    #pragma unroll
                                                    while (while_method_10(v549)){
                                                        wmma::fragment<wmma::matrix_a, 16, 16, 8, wmma::precision::tf32, wmma::row_major> & v551 = v481[0];
                                                        assert("Tensor range check" && 0 <= v547 && v547 < 8);
                                                        int v552;
                                                        v552 = 1088 * v547;
                                                        assert("Tensor range check" && 0 <= v549 && v549 < 8);
                                                        int v553;
                                                        v553 = 8 * v549;
                                                        int v554;
                                                        v554 = v553 + v552;
                                                        int v555;
                                                        v555 = 0;
                                                        #pragma unroll
                                                        while (while_method_0(v555)){
                                                            int v557;
                                                            v557 = 0;
                                                            #pragma unroll
                                                            while (while_method_0(v557)){
                                                                assert("Tensor range check" && 0 <= v555 && v555 < 2);
                                                                assert("Tensor range check" && 0 <= v557 && v557 < 2);
                                                                int v559;
                                                                v559 = 544 * v557;
                                                                int v560;
                                                                v560 = v559 + v554;
                                                                int v561;
                                                                v561 = 4 * v555;
                                                                int v562;
                                                                v562 = v561 + v560;
                                                                float v563;
                                                                v563 = v360[v562];
                                                                bool v564;
                                                                v564 = 0 <= v557;
                                                                bool v566;
                                                                if (v564){
                                                                    bool v565;
                                                                    v565 = v557 < 2;
                                                                    v566 = v565;
                                                                } else {
                                                                    v566 = false;
                                                                }
                                                                bool v567;
                                                                v567 = v566 == false;
                                                                if (v567){
                                                                    assert("The indices should be inside the range of the dimension." && v566);
                                                                } else {
                                                                }
                                                                bool v569;
                                                                v569 = 0 <= v555;
                                                                bool v571;
                                                                if (v569){
                                                                    bool v570;
                                                                    v570 = v555 < 2;
                                                                    v571 = v570;
                                                                } else {
                                                                    v571 = false;
                                                                }
                                                                bool v572;
                                                                v572 = v571 == false;
                                                                if (v572){
                                                                    assert("The indices should be inside the range of the dimension." && v571);
                                                                } else {
                                                                }
                                                                int v574;
                                                                v574 = v555 * 2;
                                                                int v575;
                                                                v575 = v557 + v574;
                                                                v551.x[v575] = wmma::__float_to_tf32(v563);
                                                                v557 += 1 ;
                                                            }
                                                            v555 += 1 ;
                                                        }
                                                        int v576;
                                                        v576 = 0;
                                                        #pragma unroll
                                                        while (while_method_6(v576)){
                                                            assert("Tensor range check" && 0 <= v547 && v547 < 8);
                                                            assert("Tensor range check" && 0 <= v576 && v576 < 1);
                                                            int v578;
                                                            v578 = v547 + v576;
                                                            wmma::fragment<wmma::accumulator, 16, 16, 8, float> & v579 = v378[v578];
                                                            assert("Tensor range check" && 0 <= v576 && v576 < 1);
                                                            assert("Tensor range check" && 0 <= v549 && v549 < 8);
                                                            int v580;
                                                            v580 = 8 * v576;
                                                            int v581;
                                                            v581 = v580 + v549;
                                                            wmma::fragment<wmma::matrix_b, 16, 16, 8, wmma::precision::tf32, wmma::col_major> & v582 = v482[v581];
                                                            wmma::mma_sync(v579, v551, v582, v579);
                                                            v576 += 1 ;
                                                        }
                                                        v549 += 1 ;
                                                    }
                                                    v547 += 1 ;
                                                }
                                                // Poping the loop unrolling to: 0
                                                asm("barrier.cta.sync %0;" :: "r"(0));
                                                v395 = v397;
                                            }
                                            // Pushing the loop unrolling to: 0
                                            int v583;
                                            v583 = 0;
                                            #pragma unroll
                                            while (while_method_10(v583)){
                                                int v585;
                                                v585 = 0;
                                                #pragma unroll
                                                while (while_method_6(v585)){
                                                    assert("Tensor range check" && 0 <= v583 && v583 < 8);
                                                    assert("Tensor range check" && 0 <= v585 && v585 < 1);
                                                    int v587;
                                                    v587 = v583 + v585;
                                                    wmma::fragment<wmma::accumulator, 16, 16, 8, float> & v588 = v378[v587];
                                                    assert("Tensor range check" && 0 <= v583 && v583 < 8);
                                                    assert("Tensor range check" && 0 <= v585 && v585 < 1);
                                                    int v589;
                                                    v589 = 16 * v585;
                                                    int v590;
                                                    v590 = 2176 * v583;
                                                    int v591;
                                                    v591 = v590 + v589;
                                                    float * v592;
                                                    v592 = v344+v591;
                                                    wmma::store_matrix_sync(v592, v588, 136, wmma::mem_row_major);
                                                    v585 += 1 ;
                                                }
                                                v583 += 1 ;
                                            }
                                            // Poping the loop unrolling to: 0
                                            asm("barrier.cta.sync %0;" :: "r"(0));
                                            // Pushing the loop unrolling to: 0
                                            int v594;
                                            v594 = threadIdx.x;
                                            bool v595;
                                            v595 = 0 <= v594;
                                            bool v596;
                                            v596 = v595 == false;
                                            if (v596){
                                                assert("The index needs to be zero or positive." && v595);
                                            } else {
                                            }
                                            int v598;
                                            v598 = v594 % 32;
                                            int v599;
                                            v599 = v594 / 32;
                                            bool v600;
                                            v600 = v599 < 8;
                                            bool v601;
                                            v601 = v600 == false;
                                            if (v601){
                                                assert("The last element of the projection dimensions needs to be greater than the index remainder." && v600);
                                            } else {
                                            }
                                            assert("Tensor range check" && 0 <= v599 && v599 < 8);
                                            assert("Tensor range check" && 0 <= v598 && v598 < 32);
                                            int v603;
                                            v603 = 4 * v598;
                                            int v604;
                                            v604 = 128 * v599;
                                            int v605;
                                            v605 = v604 + v603;
                                            int v606;
                                            v606 = 136 * v599;
                                            int v607;
                                            v607 = v606 + v603;
                                            float * v608;
                                            v608 = v387+v605;
                                            float * v610;
                                            v610 = v329+v607;
                                            int v612;
                                            v612 = 0;
                                            #pragma unroll
                                            while (while_method_12(v612)){
                                                int v614;
                                                v614 = 0;
                                                #pragma unroll
                                                while (while_method_6(v614)){
                                                    assert("Tensor range check" && 0 <= v612 && v612 < 16);
                                                    assert("Tensor range check" && 0 <= v614 && v614 < 1);
                                                    int v616;
                                                    v616 = 128 * v614;
                                                    int v617;
                                                    v617 = 1024 * v612;
                                                    int v618;
                                                    v618 = v617 + v616;
                                                    int v619;
                                                    v619 = 1088 * v612;
                                                    int v620;
                                                    v620 = v619 + v616;
                                                    int4* v621;
                                                    v621 = reinterpret_cast<int4*>(v610 + v620);
                                                    int4* v622;
                                                    v622 = reinterpret_cast<int4*>(v608 + v618);
                                                    assert("Pointer alignment check" && (unsigned long long)(v621) % 4 == 0 && (unsigned long long)(v622) % 4 == 0);
                                                    *v622 = *v621;
                                                    v614 += 1 ;
                                                }
                                                v612 += 1 ;
                                            }
                                            // Poping the loop unrolling to: 0
                                            asm("barrier.cta.sync %0;" :: "r"(0));
                                            v381 += 1 ;
                                        }
                                        v379 += 1 ;
                                    }
                                    unsigned int * v623;
                                    v623 = reinterpret_cast<unsigned int *>(&v0[53477376ull]);
                                    assert("Tensor range check" && 0 <= v310 && v310 < 4);
                                    int v625;
                                    v625 = 6144 * v310;
                                    method_45(v623, v625, v317);
                                    int * v626;
                                    v626 = reinterpret_cast<int *>(&v1[4194304ull]);
                                    float * v628;
                                    v628 = reinterpret_cast<float *>(&v1[4194320ull]);
                                    float * v630;
                                    v630 = reinterpret_cast<float *>(&v1[5242896ull]);
                                    float * v632;
                                    v632 = reinterpret_cast<float *>(&v1[6291472ull]);
                                    float * v634;
                                    v634 = reinterpret_cast<float *>(&v1[7340048ull]);
                                    float * v636;
                                    v636 = reinterpret_cast<float *>(&v1[8388624ull]);
                                    float * v638;
                                    v638 = reinterpret_cast<float *>(&v1[9437200ull]);
                                    float * v640;
                                    v640 = reinterpret_cast<float *>(&v1[10485776ull]);
                                    int * v642;
                                    v642 = reinterpret_cast<int *>(&v0[53575680ull]);
                                    float * v644;
                                    v644 = reinterpret_cast<float *>(&v0[66158592ull]);
                                    int * v646;
                                    v646 = reinterpret_cast<int *>(&v0[78741504ull]);
                                    int * v648;
                                    v648 = reinterpret_cast<int *>(&v0[91324416ull]);
                                    double * v650;
                                    v650 = reinterpret_cast<double *>(&v0[103907328ull]);
                                    double * v652;
                                    v652 = reinterpret_cast<double *>(&v0[154238976ull]);
                                    double * v654;
                                    v654 = reinterpret_cast<double *>(&v1[11534352ull]);
                                    double * v656;
                                    v656 = reinterpret_cast<double *>(&v1[11927568ull]);
                                    int * v658;
                                    v658 = reinterpret_cast<int *>(&v1[12320784ull]);
                                    v310 += 1 ;
                                }
                                asm("barrier.cta.sync %0;" :: "r"(0));
                                int * v660;
                                v660 = reinterpret_cast<int *>(&v1[4194304ull]);
                                float * v662;
                                v662 = reinterpret_cast<float *>(&v1[4194320ull]);
                                float * v664;
                                v664 = reinterpret_cast<float *>(&v1[5242896ull]);
                                float * v666;
                                v666 = reinterpret_cast<float *>(&v1[6291472ull]);
                                float * v668;
                                v668 = reinterpret_cast<float *>(&v1[7340048ull]);
                                float * v670;
                                v670 = reinterpret_cast<float *>(&v1[8388624ull]);
                                float * v672;
                                v672 = reinterpret_cast<float *>(&v1[9437200ull]);
                                float * v674;
                                v674 = reinterpret_cast<float *>(&v1[10485776ull]);
                                int v676;
                                v676 = v660[0];
                                unsigned int * v677;
                                v677 = reinterpret_cast<unsigned int *>(&v0[53477376ull]);
                                int v679;
                                v679 = blockIdx.x;
                                int v680;
                                v680 = threadIdx.x;
                                assert("Tensor range check" && 0 <= v676 && v676 < 4);
                                assert("Tensor range check" && 0 <= v679 && v679 < 24);
                                assert("Tensor range check" && 0 <= v680 && v680 < 256);
                                int v681;
                                v681 = 256 * v679;
                                int v682;
                                v682 = v681 + v680;
                                int v683;
                                v683 = 6144 * v676;
                                int v684;
                                v684 = v683 + v682;
                                unsigned int v685;
                                v685 = v677[v684];
                                int v686;
                                v686 = (int)v685;
                                float v687; int v688;
                                Tuple14 tmp89 = method_46(v127, v660, v662, v664, v666, v668, v670, v672, v674, v686, v676);
                                v687 = tmp89.v0; v688 = tmp89.v1;
                                extern __shared__ unsigned char v689[];
                                float * v690;
                                v690 = reinterpret_cast<float *>(&v689[0ull]);
                                int * v692;
                                v692 = reinterpret_cast<int *>(&v689[16ull]);
                                int v694;
                                v694 = threadIdx.x;
                                bool v695;
                                v695 = v694 == 0;
                                if (v695){
                                    v690[0] = v687;
                                    v692[0] = v688;
                                } else {
                                }
                                asm("barrier.cta.sync %0;" :: "r"(0));
                                float v696;
                                v696 = v690[0];
                                int v697;
                                v697 = v692[0];
                                asm("barrier.cta.sync %0;" :: "r"(0));
                                double * v698;
                                v698 = reinterpret_cast<double *>(&v1[11534352ull]);
                                double * v700;
                                v700 = reinterpret_cast<double *>(&v1[11927568ull]);
                                int * v702;
                                v702 = reinterpret_cast<int *>(&v1[12320784ull]);
                                int * v704;
                                v704 = reinterpret_cast<int *>(&v0[53575680ull]);
                                float * v706;
                                v706 = reinterpret_cast<float *>(&v0[66158592ull]);
                                int * v708;
                                v708 = reinterpret_cast<int *>(&v0[78741504ull]);
                                int * v710;
                                v710 = reinterpret_cast<int *>(&v0[91324416ull]);
                                double * v712;
                                v712 = reinterpret_cast<double *>(&v0[103907328ull]);
                                double * v714;
                                v714 = reinterpret_cast<double *>(&v0[154238976ull]);
                                int v716;
                                v716 = threadIdx.x;
                                int v717;
                                v717 = blockIdx.x;
                                int v718;
                                v718 = v717 * 256;
                                int v719;
                                v719 = v716 + v718;
                                int v720;
                                v720 = 0;
                                while (while_method_3(v720)){
                                    unsigned int * v722;
                                    v722 = reinterpret_cast<unsigned int *>(&v0[53477376ull]);
                                    int v724;
                                    v724 = blockIdx.x;
                                    int v725;
                                    v725 = threadIdx.x;
                                    assert("Tensor range check" && 0 <= v720 && v720 < 4);
                                    assert("Tensor range check" && 0 <= v724 && v724 < 24);
                                    assert("Tensor range check" && 0 <= v725 && v725 < 256);
                                    int v726;
                                    v726 = 256 * v724;
                                    int v727;
                                    v727 = v726 + v725;
                                    int v728;
                                    v728 = 6144 * v720;
                                    int v729;
                                    v729 = v728 + v727;
                                    unsigned int v730;
                                    v730 = v722[v729];
                                    int v731;
                                    v731 = (int)v730;
                                    float v732;
                                    v732 = method_83(v660, v662, v664, v666, v668, v670, v672, v674, v731, v720, v697);
                                    assert("Tensor range check" && 0 <= v720 && v720 < 4);
                                    assert("Tensor range check" && 0 <= v719 && v719 < 6144);
                                    int v733;
                                    v733 = v728 + v719;
                                    int v734;
                                    v734 = v702[v733];
                                    int v735;
                                    v735 = v734 + 1;
                                    assert("Tensor range check" && 0 <= v720 && v720 < 4);
                                    assert("Tensor range check" && 0 <= v719 && v719 < 6144);
                                    v702[v733] = v735;
                                    assert("Tensor range check" && 0 <= v720 && v720 < 4);
                                    assert("Tensor range check" && 0 <= v734 && v734 < 128);
                                    assert("Tensor range check" && 0 <= v719 && v719 < 6144);
                                    int v736;
                                    v736 = 6144 * v734;
                                    int v737;
                                    v737 = v736 + v719;
                                    int v738;
                                    v738 = 786432 * v720;
                                    int v739;
                                    v739 = v738 + v737;
                                    v704[v739] = v697;
                                    v706[v739] = v696;
                                    v708[v739] = v120;
                                    v710[v739] = v731;
                                    assert("Tensor range check" && 0 <= v720 && v720 < 4);
                                    int v740;
                                    v740 = 12288 * v720;
                                    assert("Tensor range check" && 0 <= v719 && v719 < 6144);
                                    int v741;
                                    v741 = 2 * v719;
                                    int v742;
                                    v742 = v741 + v740;
                                    assert("Tensor range check" && 0 <= v720 && v720 < 4);
                                    int v743;
                                    v743 = 1572864 * v720;
                                    assert("Tensor range check" && 0 <= v734 && v734 < 128);
                                    int v744;
                                    v744 = 12288 * v734;
                                    int v745;
                                    v745 = v744 + v743;
                                    assert("Tensor range check" && 0 <= v719 && v719 < 6144);
                                    int v746;
                                    v746 = v741 + v745;
                                    double * v747;
                                    v747 = v698+v742;
                                    double * v749;
                                    v749 = v700+v742;
                                    double * v751;
                                    v751 = v712+v746;
                                    double * v753;
                                    v753 = v714+v746;
                                    int v755;
                                    v755 = sizeof(double *);
                                    unsigned long long v756;
                                    v756 = (unsigned long long)v755;
                                    unsigned long long v757;
                                    v757 = 256ull * v756;
                                    unsigned long long v758;
                                    v758 = v757 + 16ull;
                                    unsigned long long v759;
                                    v759 = v758 - 1ull;
                                    unsigned long long v760;
                                    v760 = v759 % 16ull;
                                    unsigned long long v761;
                                    v761 = v759 - v760;
                                    unsigned long long v762;
                                    v762 = v761 + v757;
                                    unsigned long long v763;
                                    v763 = v762 + 16ull;
                                    unsigned long long v764;
                                    v764 = v763 - 1ull;
                                    unsigned long long v765;
                                    v765 = v764 % 16ull;
                                    unsigned long long v766;
                                    v766 = v764 - v765;
                                    unsigned long long v767;
                                    v767 = v766 + v757;
                                    unsigned long long v768;
                                    v768 = v767 + 16ull;
                                    unsigned long long v769;
                                    v769 = v768 - 1ull;
                                    unsigned long long v770;
                                    v770 = v769 % 16ull;
                                    unsigned long long v771;
                                    v771 = v769 - v770;
                                    unsigned long long v772;
                                    v772 = v771 + v757;
                                    bool v773;
                                    v773 = v772 <= 98304ull;
                                    bool v774;
                                    v774 = v773 == false;
                                    if (v774){
                                        assert("The dynamic shared memory is insufficient to allocate the tensor." && v773);
                                    } else {
                                    }
                                    extern __shared__ unsigned char v776[];
                                    bool v777;
                                    v777 = v772 <= v772;
                                    bool v778;
                                    v778 = v777 == false;
                                    if (v778){
                                        assert("The length of the partition has to be less than or equal to the length of the base array." && v777);
                                    } else {
                                    }
                                    double * * v780;
                                    v780 = reinterpret_cast<double * *>(&v776[0ull]);
                                    double * * v782;
                                    v782 = reinterpret_cast<double * *>(&v776[v761]);
                                    double * * v784;
                                    v784 = reinterpret_cast<double * *>(&v776[v766]);
                                    double * * v786;
                                    v786 = reinterpret_cast<double * *>(&v776[v771]);
                                    int v788;
                                    v788 = threadIdx.x;
                                    assert("Tensor range check" && 0 <= v788 && v788 < 256);
                                    v780[v788] = v747;
                                    v782[v788] = v749;
                                    v784[v788] = v751;
                                    v786[v788] = v753;
                                    asm("barrier.cta.sync %0;" :: "r"(0));
                                    bool v789;
                                    v789 = 0 <= v788;
                                    bool v790;
                                    v790 = v789 == false;
                                    if (v790){
                                        assert("The index needs to be zero or positive." && v789);
                                    } else {
                                    }
                                    int v792;
                                    v792 = v788 % 1;
                                    bool v793;
                                    v793 = v788 < 256;
                                    bool v794;
                                    v794 = v793 == false;
                                    if (v794){
                                        assert("The last element of the projection dimensions needs to be greater than the index remainder." && v793);
                                    } else {
                                    }
                                    assert("Tensor range check" && 0 <= v788 && v788 < 256);
                                    int v796;
                                    v796 = 0;
                                    while (while_method_6(v796)){
                                        bool v798;
                                        v798 = v789 && v793;
                                        bool v799;
                                        v799 = v798 == false;
                                        if (v799){
                                            assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v798);
                                        } else {
                                        }
                                        bool v801;
                                        v801 = 0 <= v796;
                                        bool v803;
                                        if (v801){
                                            bool v802;
                                            v802 = v796 < 1;
                                            v803 = v802;
                                        } else {
                                            v803 = false;
                                        }
                                        bool v804;
                                        v804 = v803 == false;
                                        if (v804){
                                            assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v803);
                                        } else {
                                        }
                                        int v806;
                                        v806 = v796 * 256;
                                        int v807;
                                        v807 = v806 + v788;
                                        assert("Tensor range check" && 0 <= v796 && v796 < 1);
                                        int v808;
                                        v808 = 256 * v796;
                                        int v809;
                                        v809 = v808 + v788;
                                        double * v810;
                                        v810 = v780[v809];
                                        double * v811;
                                        v811 = v782[v809];
                                        double * v812;
                                        v812 = v784[v809];
                                        double * v813;
                                        v813 = v786[v809];
                                        int v814;
                                        v814 = blockIdx.x;
                                        int v815;
                                        v815 = v814 * 256;
                                        int v816;
                                        v816 = v815 + v807;
                                        assert("Tensor range check" && 0 <= v792 && v792 < 1);
                                        int v817;
                                        v817 = 2 * v792;
                                        double v818[2];
                                        double v819[2];
                                        int v820[2];
                                        int v821;
                                        v821 = 0;
                                        while (while_method_6(v821)){
                                            assert("Tensor range check" && 0 <= v821 && v821 < 1);
                                            int v823;
                                            v823 = 2 * v821;
                                            assert("Tensor range check" && 0 <= v821 && v821 < 1);
                                            int v824;
                                            v824 = v823 + v817;
                                            int4* v825;
                                            v825 = reinterpret_cast<int4*>(v810 + v824);
                                            int4* v826;
                                            v826 = reinterpret_cast<int4*>(v818 + v823);
                                            assert("Pointer alignment check" && (unsigned long long)(v825) % 2 == 0 && (unsigned long long)(v826) % 2 == 0);
                                            *v826 = *v825;
                                            int4* v827;
                                            v827 = reinterpret_cast<int4*>(v811 + v824);
                                            int4* v828;
                                            v828 = reinterpret_cast<int4*>(v819 + v823);
                                            assert("Pointer alignment check" && (unsigned long long)(v827) % 2 == 0 && (unsigned long long)(v828) % 2 == 0);
                                            *v828 = *v827;
                                            v821 += 1 ;
                                        }
                                        int v829;
                                        v829 = 0;
                                        while (while_method_6(v829)){
                                            int v831;
                                            v831 = 0;
                                            while (while_method_0(v831)){
                                                bool v833;
                                                v833 = 0 <= v831;
                                                bool v835;
                                                if (v833){
                                                    bool v834;
                                                    v834 = v831 < 2;
                                                    v835 = v834;
                                                } else {
                                                    v835 = false;
                                                }
                                                bool v836;
                                                v836 = v835 == false;
                                                if (v836){
                                                    assert("The indices should be inside the range of the dimension." && v835);
                                                } else {
                                                }
                                                bool v838;
                                                v838 = 0 <= v792;
                                                bool v840;
                                                if (v838){
                                                    bool v839;
                                                    v839 = v792 < 1;
                                                    v840 = v839;
                                                } else {
                                                    v840 = false;
                                                }
                                                bool v841;
                                                v841 = v840 == false;
                                                if (v841){
                                                    assert("The indices should be inside the range of the dimension." && v840);
                                                } else {
                                                }
                                                int v843;
                                                v843 = v792 * 2;
                                                int v844;
                                                v844 = v831 + v843;
                                                bool v845;
                                                v845 = 0 <= v829;
                                                bool v847;
                                                if (v845){
                                                    bool v846;
                                                    v846 = v829 < 1;
                                                    v847 = v846;
                                                } else {
                                                    v847 = false;
                                                }
                                                bool v848;
                                                v848 = v847 == false;
                                                if (v848){
                                                    assert("The indices should be inside the range of the dimension." && v847);
                                                } else {
                                                }
                                                int v850;
                                                v850 = v829 * 2;
                                                int v851;
                                                v851 = v844 + v850;
                                                assert("Tensor range check" && 0 <= v829 && v829 < 1);
                                                assert("Tensor range check" && 0 <= v831 && v831 < 2);
                                                int v852;
                                                v852 = 2 * v829;
                                                int v853;
                                                v853 = v852 + v831;
                                                v820[v853] = v851;
                                                v831 += 1 ;
                                            }
                                            v829 += 1 ;
                                        }
                                        int v854;
                                        v854 = 0;
                                        while (while_method_6(v854)){
                                            assert("Tensor range check" && 0 <= v854 && v854 < 1);
                                            int v856;
                                            v856 = 2 * v854;
                                            int v857;
                                            v857 = v856 + v817;
                                            assert("Tensor range check" && 0 <= v854 && v854 < 1);
                                            int4* v858;
                                            v858 = reinterpret_cast<int4*>(v818 + v856);
                                            int4* v859;
                                            v859 = reinterpret_cast<int4*>(v812 + v857);
                                            assert("Pointer alignment check" && (unsigned long long)(v858) % 2 == 0 && (unsigned long long)(v859) % 2 == 0);
                                            *v859 = *v858;
                                            int4* v860;
                                            v860 = reinterpret_cast<int4*>(v819 + v856);
                                            int4* v861;
                                            v861 = reinterpret_cast<int4*>(v813 + v857);
                                            assert("Pointer alignment check" && (unsigned long long)(v860) % 2 == 0 && (unsigned long long)(v861) % 2 == 0);
                                            *v861 = *v860;
                                            v854 += 1 ;
                                        }
                                        assert("Tensor range check" && 0 <= v807 && v807 < 256);
                                        v796 += 1 ;
                                    }
                                    asm("barrier.cta.sync %0;" :: "r"(0));
                                    assert("Tensor range check" && 0 <= v788 && v788 < 256);
                                    asm("barrier.cta.sync %0;" :: "r"(0));
                                    double v862;
                                    v862 = (double)v696;
                                    double v863;
                                    v863 = log(v862);
                                    double v864;
                                    v864 = (double)v732;
                                    double v865;
                                    v865 = log(v864);
                                    assert("Tensor range check" && 0 <= v720 && v720 < 4);
                                    assert("Tensor range check" && 0 <= v719 && v719 < 6144);
                                    assert("Tensor range check" && 0 <= v120 && v120 < 2);
                                    int v866;
                                    v866 = v741 + v120;
                                    int v867;
                                    v867 = v740 + v866;
                                    double v868;
                                    v868 = v698[v867];
                                    double v869;
                                    v869 = v700[v867];
                                    double v870;
                                    v870 = v865 + v868;
                                    double v871;
                                    v871 = v863 + v869;
                                    assert("Tensor range check" && 0 <= v720 && v720 < 4);
                                    assert("Tensor range check" && 0 <= v719 && v719 < 6144);
                                    assert("Tensor range check" && 0 <= v120 && v120 < 2);
                                    v698[v867] = v870;
                                    v700[v867] = v871;
                                    v720 += 1 ;
                                }
                                bool v872;
                                v872 = 0 == v697;
                                Union10 v905;
                                if (v872){
                                    v905 = Union10{Union10_1{}};
                                } else {
                                    bool v874;
                                    v874 = 1 == v697;
                                    if (v874){
                                        v905 = Union10{Union10_0{}};
                                    } else {
                                        bool v876;
                                        v876 = 2 == v697;
                                        if (v876){
                                            v905 = Union10{Union10_2{1, 3}};
                                        } else {
                                            bool v878;
                                            v878 = 3 == v697;
                                            if (v878){
                                                v905 = Union10{Union10_2{1, 2}};
                                            } else {
                                                bool v880;
                                                v880 = 4 == v697;
                                                if (v880){
                                                    v905 = Union10{Union10_2{2, 3}};
                                                } else {
                                                    bool v882;
                                                    v882 = 5 == v697;
                                                    if (v882){
                                                        v905 = Union10{Union10_2{3, 4}};
                                                    } else {
                                                        bool v884;
                                                        v884 = 6 == v697;
                                                        if (v884){
                                                            v905 = Union10{Union10_2{1, 1}};
                                                        } else {
                                                            bool v886;
                                                            v886 = 7 == v697;
                                                            if (v886){
                                                                v905 = Union10{Union10_2{3, 2}};
                                                            } else {
                                                                bool v888;
                                                                v888 = 8 == v697;
                                                                if (v888){
                                                                    v905 = Union10{Union10_2{2, 1}};
                                                                } else {
                                                                    bool v890;
                                                                    v890 = 9 == v697;
                                                                    if (v890){
                                                                        v905 = Union10{Union10_2{3, 1}};
                                                                    } else {
                                                                        bool v892;
                                                                        v892 = 10 == v697;
                                                                        if (v892){
                                                                            v905 = Union10{Union10_2{2147483647, 1}};
                                                                        } else {
                                                                            printf("%s\n", "Invalid output id in the NL Holdem model.");
                                                                            __trap();
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                switch (v905.tag) {
                                    case 0: { // AA_Call
                                        v1088 = Union1{Union1_1{}};
                                        break;
                                    }
                                    case 1: { // AA_Fold
                                        int v906;
                                        v906 = v116[0];
                                        int v908; int v909;
                                        Tuple4 tmp92 = Tuple4{1, v906};
                                        v908 = tmp92.v0; v909 = tmp92.v1;
                                        while (while_method_0(v908)){
                                            int v911;
                                            v911 = v116[v908];
                                            bool v913;
                                            v913 = v909 >= v911;
                                            int v914;
                                            if (v913){
                                                v914 = v909;
                                            } else {
                                                v914 = v911;
                                            }
                                            v909 = v914;
                                            v908 += 1 ;
                                        }
                                        int v915;
                                        v915 = v116[v120];
                                        bool v917;
                                        v917 = v915 == v909;
                                        if (v917){
                                            v1088 = Union1{Union1_1{}};
                                        } else {
                                            v1088 = Union1{Union1_2{}};
                                        }
                                        break;
                                    }
                                    case 2: { // AA_Raise
                                        int v922 = v905.case2.v0; int v923 = v905.case2.v1;
                                        static_array<int,2> v924;
                                        int v926;
                                        v926 = 0;
                                        while (while_method_0(v926)){
                                            int v928;
                                            v928 = v118[v926];
                                            int v930;
                                            v930 = v116[v926];
                                            int v932;
                                            v932 = v928 + v930;
                                            v924[v926] = v932;
                                            v926 += 1 ;
                                        }
                                        int v933;
                                        v933 = v116[0];
                                        int v935; int v936;
                                        Tuple4 tmp93 = Tuple4{1, v933};
                                        v935 = tmp93.v0; v936 = tmp93.v1;
                                        while (while_method_0(v935)){
                                            int v938;
                                            v938 = v116[v935];
                                            bool v940;
                                            v940 = v936 >= v938;
                                            int v941;
                                            if (v940){
                                                v941 = v936;
                                            } else {
                                                v941 = v938;
                                            }
                                            v936 = v941;
                                            v935 += 1 ;
                                        }
                                        int v942;
                                        v942 = v924[v120];
                                        bool v944;
                                        v944 = v936 < v942;
                                        int v945;
                                        if (v944){
                                            v945 = v936;
                                        } else {
                                            v945 = v942;
                                        }
                                        static_array<int,2> v946;
                                        int v948;
                                        v948 = 0;
                                        while (while_method_0(v948)){
                                            int v950;
                                            v950 = v116[v948];
                                            bool v952;
                                            v952 = v120 == v948;
                                            int v953;
                                            if (v952){
                                                v953 = v945;
                                            } else {
                                                v953 = v950;
                                            }
                                            v946[v948] = v953;
                                            v948 += 1 ;
                                        }
                                        int v954;
                                        v954 = v946[0];
                                        int v956; int v957;
                                        Tuple4 tmp94 = Tuple4{1, v954};
                                        v956 = tmp94.v0; v957 = tmp94.v1;
                                        while (while_method_0(v956)){
                                            int v959;
                                            v959 = v946[v956];
                                            int v961;
                                            v961 = v957 + v959;
                                            v957 = v961;
                                            v956 += 1 ;
                                        }
                                        static_array<int,2> v962;
                                        int v964;
                                        v964 = 0;
                                        while (while_method_0(v964)){
                                            int v966;
                                            v966 = v924[v964];
                                            int v968;
                                            v968 = v946[v964];
                                            int v970;
                                            v970 = v966 - v968;
                                            v962[v964] = v970;
                                            v964 += 1 ;
                                        }
                                        int v971;
                                        v971 = v922 * v957;
                                        int v972;
                                        v972 = v971 / v923;
                                        bool v973;
                                        v973 = v114 >= v972;
                                        int v974;
                                        if (v973){
                                            v974 = v114;
                                        } else {
                                            v974 = v972;
                                        }
                                        int v975;
                                        v975 = v962[v120];
                                        bool v977;
                                        v977 = v974 >= v975;
                                        if (v977){
                                            v1088 = Union1{Union1_0{}};
                                        } else {
                                            v1088 = Union1{Union1_3{v974}};
                                        }
                                        break;
                                    }
                                    default: {
                                        assert("Invalid tag." && false); __trap();
                                    }
                                }
                                break;
                            }
                            case 1: { // Human
                                printf("%s\n", "Humans aren't allowed during training.");
                                __trap();
                                break;
                            }
                            case 2: { // Random
                                curandStatePhilox4_32_10_t & v984 = v2.v5;
                                curandStatePhilox4_32_10_t & v985 = v984;
                                static_array<int,2> v986;
                                int v988;
                                v988 = 0;
                                while (while_method_0(v988)){
                                    int v990;
                                    v990 = v118[v988];
                                    int v992;
                                    v992 = v116[v988];
                                    int v994;
                                    v994 = v990 + v992;
                                    v986[v988] = v994;
                                    v988 += 1 ;
                                }
                                int v995;
                                v995 = v116[0];
                                int v997; int v998;
                                Tuple4 tmp95 = Tuple4{1, v995};
                                v997 = tmp95.v0; v998 = tmp95.v1;
                                while (while_method_0(v997)){
                                    int v1000;
                                    v1000 = v116[v997];
                                    bool v1002;
                                    v1002 = v998 >= v1000;
                                    int v1003;
                                    if (v1002){
                                        v1003 = v998;
                                    } else {
                                        v1003 = v1000;
                                    }
                                    v998 = v1003;
                                    v997 += 1 ;
                                }
                                int v1004;
                                v1004 = v986[v120];
                                bool v1006;
                                v1006 = v998 < v1004;
                                int v1007;
                                if (v1006){
                                    v1007 = v998;
                                } else {
                                    v1007 = v1004;
                                }
                                static_array<int,2> v1008;
                                int v1010;
                                v1010 = 0;
                                while (while_method_0(v1010)){
                                    int v1012;
                                    v1012 = v116[v1010];
                                    bool v1014;
                                    v1014 = v120 == v1010;
                                    int v1015;
                                    if (v1014){
                                        v1015 = v1007;
                                    } else {
                                        v1015 = v1012;
                                    }
                                    v1008[v1010] = v1015;
                                    v1010 += 1 ;
                                }
                                int v1016;
                                v1016 = v1008[0];
                                int v1018; int v1019;
                                Tuple4 tmp96 = Tuple4{1, v1016};
                                v1018 = tmp96.v0; v1019 = tmp96.v1;
                                while (while_method_0(v1018)){
                                    int v1021;
                                    v1021 = v1008[v1018];
                                    int v1023;
                                    v1023 = v1019 + v1021;
                                    v1019 = v1023;
                                    v1018 += 1 ;
                                }
                                static_array<int,2> v1024;
                                int v1026;
                                v1026 = 0;
                                while (while_method_0(v1026)){
                                    int v1028;
                                    v1028 = v986[v1026];
                                    int v1030;
                                    v1030 = v1008[v1026];
                                    int v1032;
                                    v1032 = v1028 - v1030;
                                    v1024[v1026] = v1032;
                                    v1026 += 1 ;
                                }
                                int v1033;
                                v1033 = v116[v120];
                                bool v1035;
                                v1035 = v1033 < v998;
                                float v1036;
                                if (v1035){
                                    v1036 = 1.0f;
                                } else {
                                    v1036 = 0.0f;
                                }
                                int v1037;
                                v1037 = v1019 / 3;
                                bool v1038;
                                v1038 = v114 <= v1037;
                                bool v1042;
                                if (v1038){
                                    int v1039;
                                    v1039 = v1024[v120];
                                    bool v1041;
                                    v1041 = v1037 < v1039;
                                    v1042 = v1041;
                                } else {
                                    v1042 = false;
                                }
                                float v1043;
                                if (v1042){
                                    v1043 = 1.0f;
                                } else {
                                    v1043 = 0.0f;
                                }
                                int v1044;
                                v1044 = v1019 / 2;
                                bool v1045;
                                v1045 = v114 <= v1044;
                                bool v1049;
                                if (v1045){
                                    int v1046;
                                    v1046 = v1024[v120];
                                    bool v1048;
                                    v1048 = v1044 < v1046;
                                    v1049 = v1048;
                                } else {
                                    v1049 = false;
                                }
                                float v1050;
                                if (v1049){
                                    v1050 = 1.0f;
                                } else {
                                    v1050 = 0.0f;
                                }
                                bool v1051;
                                v1051 = v114 <= v1019;
                                bool v1055;
                                if (v1051){
                                    int v1052;
                                    v1052 = v1024[v120];
                                    bool v1054;
                                    v1054 = v1019 < v1052;
                                    v1055 = v1054;
                                } else {
                                    v1055 = false;
                                }
                                float v1056;
                                if (v1055){
                                    v1056 = 1.0f;
                                } else {
                                    v1056 = 0.0f;
                                }
                                static_array<Tuple18,6> v1057;
                                Union1 v1059;
                                v1059 = Union1{Union1_2{}};
                                v1057[0] = Tuple18{v1059, v1036};
                                Union1 v1061;
                                v1061 = Union1{Union1_1{}};
                                v1057[1] = Tuple18{v1061, 4.0f};
                                Union1 v1063;
                                v1063 = Union1{Union1_3{v1037}};
                                v1057[2] = Tuple18{v1063, v1043};
                                Union1 v1065;
                                v1065 = Union1{Union1_3{v1044}};
                                v1057[3] = Tuple18{v1065, v1050};
                                Union1 v1067;
                                v1067 = Union1{Union1_3{v1019}};
                                v1057[4] = Tuple18{v1067, v1056};
                                Union1 v1069;
                                v1069 = Union1{Union1_0{}};
                                v1057[5] = Tuple18{v1069, 1.0f};
                                Union1 v1071;
                                v1071 = sample_discrete_47(v1057, v985);
                                int v1072;
                                v1072 = sizeof(Union1);
                                unsigned long long v1073;
                                v1073 = (unsigned long long)v1072;
                                bool v1074;
                                v1074 = v1073 <= 98304ull;
                                bool v1075;
                                v1075 = v1074 == false;
                                if (v1075){
                                    assert("The dynamic shared memory is insufficient to allocate the tensor." && v1074);
                                } else {
                                }
                                extern __shared__ unsigned char v1077[];
                                bool v1078;
                                v1078 = v1073 <= v1073;
                                bool v1079;
                                v1079 = v1078 == false;
                                if (v1079){
                                    assert("The length of the partition has to be less than or equal to the length of the base array." && v1078);
                                } else {
                                }
                                Union1 * v1081;
                                v1081 = reinterpret_cast<Union1 *>(&v1077[0ull]);
                                int v1083;
                                v1083 = threadIdx.x;
                                bool v1084;
                                v1084 = v1083 == 0;
                                if (v1084){
                                    v1081[0] = v1071;
                                } else {
                                }
                                asm("barrier.cta.sync %0;" :: "r"(0));
                                Union1 v1085;
                                v1085 = v1081[0];
                                asm("barrier.cta.sync %0;" :: "r"(0));
                                v1088 = v1085;
                                break;
                            }
                            default: {
                                assert("Invalid tag." && false); __trap();
                            }
                        }
                        Union6 v1089;
                        v1089 = Union6{Union6_2{v120, v1088}};
                        v17.push(v1089);
                        v1215 = Union18{Union18_1{v114, v115, v116, v117, v118, v119, v1088}};
                        break;
                    }
                    case 5: { // G_Round'
                        int v1091 = v22.case5.v0; static_array<static_array<unsigned char,2>,2> v1092 = v22.case5.v1; static_array<int,2> v1093 = v22.case5.v2; int v1094 = v22.case5.v3; static_array<int,2> v1095 = v22.case5.v4; Union5 v1096 = v22.case5.v5; Union1 v1097 = v22.case5.v6;
                        int v1098;
                        v1098 = v1094 % 2;
                        Union6 v1099;
                        v1099 = Union6{Union6_2{v1098, v1097}};
                        v17.push(v1099);
                        v1215 = Union18{Union18_1{v1091, v1092, v1093, v1094, v1095, v1096, v1097}};
                        break;
                    }
                    case 6: { // G_Showdown
                        int v36 = v22.case6.v0; static_array<static_array<unsigned char,2>,2> v37 = v22.case6.v1; static_array<int,2> v38 = v22.case6.v2; int v39 = v22.case6.v3; static_array<int,2> v40 = v22.case6.v4; Union5 v41 = v22.case6.v5;
                        static_array<unsigned char,5> v44;
                        switch (v41.tag) {
                            case 2: { // River
                                static_array<unsigned char,5> v42 = v41.case2.v0;
                                v44 = v42;
                                break;
                            }
                            default: {
                                printf("%s\n", "Invalid street in showdown.");
                                __trap();
                            }
                        }
                        static_array<unsigned char,2> v45;
                        v45 = v37[0];
                        static_array<unsigned char,7> v47;
                        int v49;
                        v49 = 0;
                        while (while_method_0(v49)){
                            unsigned char v51;
                            v51 = v45[v49];
                            v47[v49] = v51;
                            v49 += 1 ;
                        }
                        int v53;
                        v53 = 0;
                        while (while_method_2(v53)){
                            unsigned char v55;
                            v55 = v44[v53];
                            int v57;
                            v57 = 2 + v53;
                            v47[v57] = v55;
                            v53 += 1 ;
                        }
                        static_array<unsigned char,5> v58; char v59;
                        Tuple0 tmp97 = score_51(v47);
                        v58 = tmp97.v0; v59 = tmp97.v1;
                        static_array<unsigned char,2> v60;
                        v60 = v37[1];
                        static_array<unsigned char,7> v62;
                        int v64;
                        v64 = 0;
                        while (while_method_0(v64)){
                            unsigned char v66;
                            v66 = v60[v64];
                            v62[v64] = v66;
                            v64 += 1 ;
                        }
                        int v68;
                        v68 = 0;
                        while (while_method_2(v68)){
                            unsigned char v70;
                            v70 = v44[v68];
                            int v72;
                            v72 = 2 + v68;
                            v62[v72] = v70;
                            v68 += 1 ;
                        }
                        static_array<unsigned char,5> v73; char v74;
                        Tuple0 tmp98 = score_51(v62);
                        v73 = tmp98.v0; v74 = tmp98.v1;
                        int v75;
                        v75 = v39 % 2;
                        int v76;
                        v76 = v38[v75];
                        bool v78;
                        v78 = v59 < v74;
                        Union11 v84;
                        if (v78){
                            v84 = Union11{Union11_2{}};
                        } else {
                            bool v80;
                            v80 = v59 > v74;
                            if (v80){
                                v84 = Union11{Union11_1{}};
                            } else {
                                v84 = Union11{Union11_0{}};
                            }
                        }
                        Union11 v103;
                        switch (v84.tag) {
                            case 0: { // Eq
                                Union11 v85;
                                v85 = Union11{Union11_0{}};
                                int v86;
                                v86 = 0;
                                while (while_method_2(v86)){
                                    unsigned char v88;
                                    v88 = v58[v86];
                                    unsigned char v90;
                                    v90 = v73[v86];
                                    unsigned char v92;
                                    v92 = v88 / 4u;
                                    unsigned char v93;
                                    v93 = v90 / 4u;
                                    bool v94;
                                    v94 = v92 < v93;
                                    Union11 v100;
                                    if (v94){
                                        v100 = Union11{Union11_2{}};
                                    } else {
                                        bool v96;
                                        v96 = v92 > v93;
                                        if (v96){
                                            v100 = Union11{Union11_1{}};
                                        } else {
                                            v100 = Union11{Union11_0{}};
                                        }
                                    }
                                    bool v101;
                                    switch (v100.tag) {
                                        case 0: { // Eq
                                            v101 = true;
                                            break;
                                        }
                                        default: {
                                            v101 = false;
                                        }
                                    }
                                    bool v102;
                                    v102 = v101 == false;
                                    if (v102){
                                        v85 = v100;
                                        break;
                                    } else {
                                    }
                                    v86 += 1 ;
                                }
                                v103 = v85;
                                break;
                            }
                            default: {
                                v103 = v84;
                            }
                        }
                        int v108; int v109;
                        switch (v103.tag) {
                            case 0: { // Eq
                                v108 = 0; v109 = -1;
                                break;
                            }
                            case 1: { // Gt
                                v108 = v76; v109 = 0;
                                break;
                            }
                            case 2: { // Lt
                                v108 = v76; v109 = 1;
                                break;
                            }
                            default: {
                                assert("Invalid tag." && false); __trap();
                            }
                        }
                        static_array<Tuple0,2> v110;
                        v110[0] = Tuple0{v58, v59};
                        v110[1] = Tuple0{v73, v74};
                        Union6 v112;
                        v112 = Union6{Union6_4{v108, v110, v109}};
                        v17.push(v112);
                        v1215 = Union18{Union18_0{}};
                        break;
                    }
                    case 7: { // G_Turn
                        int v1120 = v22.case7.v0; static_array<static_array<unsigned char,2>,2> v1121 = v22.case7.v1; static_array<int,2> v1122 = v22.case7.v2; int v1123 = v22.case7.v3; static_array<int,2> v1124 = v22.case7.v4; Union5 v1125 = v22.case7.v5;
                        curandStatePhilox4_32_10_t & v1126 = v2.v5;
                        curandStatePhilox4_32_10_t & v1127 = v1126;
                        static_array<unsigned char,1> v1128; unsigned long long v1129;
                        Tuple12 tmp99 = draw_cards_40(v1127, v18);
                        v1128 = tmp99.v0; v1129 = tmp99.v1;
                        v2.v0 = v1129;
                        static_array_list<unsigned char,5> v1130;
                        v1130 = get_community_cards_82(v1125, v1128);
                        Union6 v1131;
                        v1131 = Union6{Union6_0{v1130}};
                        v17.push(v1131);
                        Union5 v1146;
                        switch (v1125.tag) {
                            case 0: { // Flop
                                static_array<unsigned char,3> v1132 = v1125.case0.v0;
                                static_array<unsigned char,4> v1133;
                                int v1135;
                                v1135 = 0;
                                while (while_method_1(v1135)){
                                    unsigned char v1137;
                                    v1137 = v1132[v1135];
                                    v1133[v1135] = v1137;
                                    v1135 += 1 ;
                                }
                                int v1139;
                                v1139 = 0;
                                while (while_method_6(v1139)){
                                    unsigned char v1141;
                                    v1141 = v1128[v1139];
                                    int v1143;
                                    v1143 = 3 + v1139;
                                    v1133[v1143] = v1141;
                                    v1139 += 1 ;
                                }
                                v1146 = Union5{Union5_3{v1133}};
                                break;
                            }
                            default: {
                                printf("%s\n", "Invalid street in turn.");
                                __trap();
                            }
                        }
                        int v1147;
                        v1147 = 2;
                        int v1148;
                        v1148 = 0;
                        Union4 v1149;
                        v1149 = try_round_36(v1147, v1121, v1122, v1148, v1124, v1146);
                        v1215 = Union18{Union18_2{v1149}};
                        break;
                    }
                    default: {
                        assert("Invalid tag." && false); __trap();
                    }
                }
                switch (v1215.tag) {
                    case 0: { // T_none
                        v1421 = Union3{Union3_0{}};
                        break;
                    }
                    case 1: { // T_round
                        int v1219 = v1215.case1.v0; static_array<static_array<unsigned char,2>,2> v1220 = v1215.case1.v1; static_array<int,2> v1221 = v1215.case1.v2; int v1222 = v1215.case1.v3; static_array<int,2> v1223 = v1215.case1.v4; Union5 v1224 = v1215.case1.v5; Union1 v1225 = v1215.case1.v6;
                        int v1226;
                        v1226 = v1222 % 2;
                        Union4 v1414;
                        switch (v1225.tag) {
                            case 0: { // A_All_In
                                static_array<int,2> v1344;
                                int v1346;
                                v1346 = 0;
                                while (while_method_0(v1346)){
                                    int v1348;
                                    v1348 = v1223[v1346];
                                    int v1350;
                                    v1350 = v1221[v1346];
                                    int v1352;
                                    v1352 = v1348 + v1350;
                                    v1344[v1346] = v1352;
                                    v1346 += 1 ;
                                }
                                int v1353;
                                v1353 = v1221[0];
                                int v1355; int v1356;
                                Tuple4 tmp100 = Tuple4{1, v1353};
                                v1355 = tmp100.v0; v1356 = tmp100.v1;
                                while (while_method_0(v1355)){
                                    int v1358;
                                    v1358 = v1221[v1355];
                                    bool v1360;
                                    v1360 = v1356 >= v1358;
                                    int v1361;
                                    if (v1360){
                                        v1361 = v1356;
                                    } else {
                                        v1361 = v1358;
                                    }
                                    v1356 = v1361;
                                    v1355 += 1 ;
                                }
                                int v1362;
                                v1362 = v1344[v1226];
                                bool v1364;
                                v1364 = v1356 < v1362;
                                int v1365;
                                if (v1364){
                                    v1365 = v1356;
                                } else {
                                    v1365 = v1362;
                                }
                                static_array<int,2> v1366;
                                int v1368;
                                v1368 = 0;
                                while (while_method_0(v1368)){
                                    int v1370;
                                    v1370 = v1221[v1368];
                                    bool v1372;
                                    v1372 = v1226 == v1368;
                                    int v1373;
                                    if (v1372){
                                        v1373 = v1365;
                                    } else {
                                        v1373 = v1370;
                                    }
                                    v1366[v1368] = v1373;
                                    v1368 += 1 ;
                                }
                                static_array<int,2> v1374;
                                int v1376;
                                v1376 = 0;
                                while (while_method_0(v1376)){
                                    int v1378;
                                    v1378 = v1344[v1376];
                                    int v1380;
                                    v1380 = v1366[v1376];
                                    int v1382;
                                    v1382 = v1378 - v1380;
                                    v1374[v1376] = v1382;
                                    v1376 += 1 ;
                                }
                                int v1383;
                                v1383 = v1374[v1226];
                                int v1385;
                                v1385 = v1356 + v1383;
                                int v1386;
                                v1386 = v1344[v1226];
                                bool v1388;
                                v1388 = v1385 < v1386;
                                int v1389;
                                if (v1388){
                                    v1389 = v1385;
                                } else {
                                    v1389 = v1386;
                                }
                                static_array<int,2> v1390;
                                int v1392;
                                v1392 = 0;
                                while (while_method_0(v1392)){
                                    int v1394;
                                    v1394 = v1221[v1392];
                                    bool v1396;
                                    v1396 = v1226 == v1392;
                                    int v1397;
                                    if (v1396){
                                        v1397 = v1389;
                                    } else {
                                        v1397 = v1394;
                                    }
                                    v1390[v1392] = v1397;
                                    v1392 += 1 ;
                                }
                                static_array<int,2> v1398;
                                int v1400;
                                v1400 = 0;
                                while (while_method_0(v1400)){
                                    int v1402;
                                    v1402 = v1344[v1400];
                                    int v1404;
                                    v1404 = v1390[v1400];
                                    int v1406;
                                    v1406 = v1402 - v1404;
                                    v1398[v1400] = v1406;
                                    v1400 += 1 ;
                                }
                                bool v1407;
                                v1407 = v1383 >= v1219;
                                int v1408;
                                if (v1407){
                                    v1408 = v1383;
                                } else {
                                    v1408 = v1219;
                                }
                                int v1409;
                                v1409 = v1222 + 1;
                                v1414 = try_round_36(v1408, v1220, v1390, v1409, v1398, v1224);
                                break;
                            }
                            case 1: { // A_Call
                                static_array<int,2> v1228;
                                int v1230;
                                v1230 = 0;
                                while (while_method_0(v1230)){
                                    int v1232;
                                    v1232 = v1223[v1230];
                                    int v1234;
                                    v1234 = v1221[v1230];
                                    int v1236;
                                    v1236 = v1232 + v1234;
                                    v1228[v1230] = v1236;
                                    v1230 += 1 ;
                                }
                                int v1237;
                                v1237 = v1221[0];
                                int v1239; int v1240;
                                Tuple4 tmp101 = Tuple4{1, v1237};
                                v1239 = tmp101.v0; v1240 = tmp101.v1;
                                while (while_method_0(v1239)){
                                    int v1242;
                                    v1242 = v1221[v1239];
                                    bool v1244;
                                    v1244 = v1240 >= v1242;
                                    int v1245;
                                    if (v1244){
                                        v1245 = v1240;
                                    } else {
                                        v1245 = v1242;
                                    }
                                    v1240 = v1245;
                                    v1239 += 1 ;
                                }
                                int v1246;
                                v1246 = v1228[v1226];
                                bool v1248;
                                v1248 = v1240 < v1246;
                                int v1249;
                                if (v1248){
                                    v1249 = v1240;
                                } else {
                                    v1249 = v1246;
                                }
                                static_array<int,2> v1250;
                                int v1252;
                                v1252 = 0;
                                while (while_method_0(v1252)){
                                    int v1254;
                                    v1254 = v1221[v1252];
                                    bool v1256;
                                    v1256 = v1226 == v1252;
                                    int v1257;
                                    if (v1256){
                                        v1257 = v1249;
                                    } else {
                                        v1257 = v1254;
                                    }
                                    v1250[v1252] = v1257;
                                    v1252 += 1 ;
                                }
                                static_array<int,2> v1258;
                                int v1260;
                                v1260 = 0;
                                while (while_method_0(v1260)){
                                    int v1262;
                                    v1262 = v1228[v1260];
                                    int v1264;
                                    v1264 = v1250[v1260];
                                    int v1266;
                                    v1266 = v1262 - v1264;
                                    v1258[v1260] = v1266;
                                    v1260 += 1 ;
                                }
                                bool v1267;
                                v1267 = v1226 < 2;
                                if (v1267){
                                    int v1268;
                                    v1268 = v1222 + 1;
                                    v1414 = try_round_36(v1219, v1220, v1250, v1268, v1258, v1224);
                                } else {
                                    v1414 = go_next_street_38(v1219, v1220, v1250, v1222, v1258, v1224);
                                }
                                break;
                            }
                            case 2: { // A_Fold
                                v1414 = Union4{Union4_1{v1219, v1220, v1221, v1222, v1223, v1224}};
                                break;
                            }
                            case 3: { // A_Raise
                                int v1272 = v1225.case3.v0;
                                bool v1273;
                                v1273 = v1219 <= v1272;
                                bool v1274;
                                v1274 = v1273 == false;
                                if (v1274){
                                    assert("The raise amount must match the minimum." && v1273);
                                } else {
                                }
                                static_array<int,2> v1276;
                                int v1278;
                                v1278 = 0;
                                while (while_method_0(v1278)){
                                    int v1280;
                                    v1280 = v1223[v1278];
                                    int v1282;
                                    v1282 = v1221[v1278];
                                    int v1284;
                                    v1284 = v1280 + v1282;
                                    v1276[v1278] = v1284;
                                    v1278 += 1 ;
                                }
                                int v1285;
                                v1285 = v1221[0];
                                int v1287; int v1288;
                                Tuple4 tmp102 = Tuple4{1, v1285};
                                v1287 = tmp102.v0; v1288 = tmp102.v1;
                                while (while_method_0(v1287)){
                                    int v1290;
                                    v1290 = v1221[v1287];
                                    bool v1292;
                                    v1292 = v1288 >= v1290;
                                    int v1293;
                                    if (v1292){
                                        v1293 = v1288;
                                    } else {
                                        v1293 = v1290;
                                    }
                                    v1288 = v1293;
                                    v1287 += 1 ;
                                }
                                int v1294;
                                v1294 = v1276[v1226];
                                bool v1296;
                                v1296 = v1288 < v1294;
                                int v1297;
                                if (v1296){
                                    v1297 = v1288;
                                } else {
                                    v1297 = v1294;
                                }
                                static_array<int,2> v1298;
                                int v1300;
                                v1300 = 0;
                                while (while_method_0(v1300)){
                                    int v1302;
                                    v1302 = v1221[v1300];
                                    bool v1304;
                                    v1304 = v1226 == v1300;
                                    int v1305;
                                    if (v1304){
                                        v1305 = v1297;
                                    } else {
                                        v1305 = v1302;
                                    }
                                    v1298[v1300] = v1305;
                                    v1300 += 1 ;
                                }
                                static_array<int,2> v1306;
                                int v1308;
                                v1308 = 0;
                                while (while_method_0(v1308)){
                                    int v1310;
                                    v1310 = v1276[v1308];
                                    int v1312;
                                    v1312 = v1298[v1308];
                                    int v1314;
                                    v1314 = v1310 - v1312;
                                    v1306[v1308] = v1314;
                                    v1308 += 1 ;
                                }
                                int v1315;
                                v1315 = v1306[v1226];
                                bool v1317;
                                v1317 = v1272 < v1315;
                                bool v1318;
                                v1318 = v1317 == false;
                                if (v1318){
                                    assert("The raise amount must be less than the stack size after calling." && v1317);
                                } else {
                                }
                                int v1320;
                                v1320 = v1288 + v1272;
                                int v1321;
                                v1321 = v1276[v1226];
                                bool v1323;
                                v1323 = v1320 < v1321;
                                int v1324;
                                if (v1323){
                                    v1324 = v1320;
                                } else {
                                    v1324 = v1321;
                                }
                                static_array<int,2> v1325;
                                int v1327;
                                v1327 = 0;
                                while (while_method_0(v1327)){
                                    int v1329;
                                    v1329 = v1221[v1327];
                                    bool v1331;
                                    v1331 = v1226 == v1327;
                                    int v1332;
                                    if (v1331){
                                        v1332 = v1324;
                                    } else {
                                        v1332 = v1329;
                                    }
                                    v1325[v1327] = v1332;
                                    v1327 += 1 ;
                                }
                                static_array<int,2> v1333;
                                int v1335;
                                v1335 = 0;
                                while (while_method_0(v1335)){
                                    int v1337;
                                    v1337 = v1276[v1335];
                                    int v1339;
                                    v1339 = v1325[v1335];
                                    int v1341;
                                    v1341 = v1337 - v1339;
                                    v1333[v1335] = v1341;
                                    v1335 += 1 ;
                                }
                                int v1342;
                                v1342 = v1222 + 1;
                                v1414 = try_round_36(v1272, v1220, v1325, v1342, v1333, v1224);
                                break;
                            }
                            default: {
                                assert("Invalid tag." && false); __trap();
                            }
                        }
                        v1421 = Union3{Union3_1{v1414}};
                        break;
                    }
                    case 2: { // T_some
                        Union4 v1217 = v1215.case2.v0;
                        v1421 = Union3{Union3_1{v1217}};
                        break;
                    }
                    default: {
                        assert("Invalid tag." && false); __trap();
                    }
                }
                break;
            }
            default: {
                assert("Invalid tag." && false); __trap();
            }
        }
        v20 = v1421;
    }
    return ;
}
__device__ inline bool while_method_22(int v0){
    bool v1;
    v1 = v0 > 0;
    return v1;
}
__device__ inline bool while_method_23(int v0){
    bool v1;
    v1 = v0 < 256;
    return v1;
}
__device__ void method_84(unsigned char * v0, unsigned char * v1, StackMut1 & v2, Union4 v3){
    v2.v0 = 4503599627370495ull;
    static_array<float,2> v4;
    v4[0] = 0.0f;
    v4[1] = 0.0f;
    v2.v4 = v4;
    static_array_list<Union6,128> & v6 = v2.v2;
    v6.unsafe_set_length(0);
    static_array<Union2,2> v7;
    Union2 v9;
    v9 = Union2{Union2_0{}};
    v7[0] = v9;
    Union2 v11;
    v11 = Union2{Union2_0{}};
    v7[1] = v11;
    v2.v3 = v7;
    static_array_list<Union6,128> & v13 = v2.v2;
    unsigned long long & v14 = v2.v0;
    Union3 v15;
    v15 = Union3{Union3_1{v3}};
    Union3 v16;
    v16 = v15;
    while (while_method_21(v16)){
        Union3 v1417;
        switch (v16.tag) {
            case 0: { // None
                v1417 = Union3{Union3_0{}};
                break;
            }
            case 1: { // Some
                Union4 v18 = v16.case1.v0;
                Union18 v1211;
                switch (v18.tag) {
                    case 0: { // G_Flop
                        int v1097 = v18.case0.v0; static_array<static_array<unsigned char,2>,2> v1098 = v18.case0.v1; static_array<int,2> v1099 = v18.case0.v2; int v1100 = v18.case0.v3; static_array<int,2> v1101 = v18.case0.v4; Union5 v1102 = v18.case0.v5;
                        curandStatePhilox4_32_10_t & v1103 = v2.v5;
                        curandStatePhilox4_32_10_t & v1104 = v1103;
                        static_array<unsigned char,3> v1105; unsigned long long v1106;
                        Tuple8 tmp107 = draw_cards_32(v1104, v14);
                        v1105 = tmp107.v0; v1106 = tmp107.v1;
                        v2.v0 = v1106;
                        static_array_list<unsigned char,5> v1107;
                        v1107 = get_community_cards_81(v1102, v1105);
                        Union6 v1108;
                        v1108 = Union6{Union6_0{v1107}};
                        v13.push(v1108);
                        Union5 v1111;
                        switch (v1102.tag) {
                            case 1: { // Preflop
                                v1111 = Union5{Union5_0{v1105}};
                                break;
                            }
                            default: {
                                printf("%s\n", "Invalid street in flop.");
                                __trap();
                            }
                        }
                        int v1112;
                        v1112 = 2;
                        int v1113;
                        v1113 = 0;
                        Union4 v1114;
                        v1114 = try_round_36(v1112, v1098, v1099, v1113, v1101, v1111);
                        v1211 = Union18{Union18_2{v1114}};
                        break;
                    }
                    case 1: { // G_Fold
                        int v19 = v18.case1.v0; static_array<static_array<unsigned char,2>,2> v20 = v18.case1.v1; static_array<int,2> v21 = v18.case1.v2; int v22 = v18.case1.v3; static_array<int,2> v23 = v18.case1.v4; Union5 v24 = v18.case1.v5;
                        int v25;
                        v25 = v22 % 2;
                        int v26;
                        v26 = v21[v25];
                        int v28;
                        v28 = v22 + 1;
                        int v29;
                        v29 = v28 % 2;
                        Union6 v30;
                        v30 = Union6{Union6_1{v26, v29}};
                        v13.push(v30);
                        v1211 = Union18{Union18_0{}};
                        break;
                    }
                    case 2: { // G_Preflop
                        curandStatePhilox4_32_10_t & v1178 = v2.v5;
                        curandStatePhilox4_32_10_t & v1179 = v1178;
                        static_array<unsigned char,2> v1180; unsigned long long v1181;
                        Tuple11 tmp108 = draw_cards_39(v1179, v14);
                        v1180 = tmp108.v0; v1181 = tmp108.v1;
                        v2.v0 = v1181;
                        curandStatePhilox4_32_10_t & v1182 = v2.v5;
                        curandStatePhilox4_32_10_t & v1183 = v1182;
                        static_array<unsigned char,2> v1184; unsigned long long v1185;
                        Tuple11 tmp109 = draw_cards_39(v1183, v14);
                        v1184 = tmp109.v0; v1185 = tmp109.v1;
                        v2.v0 = v1185;
                        Union6 v1186;
                        v1186 = Union6{Union6_3{0, v1180}};
                        v13.push(v1186);
                        Union6 v1187;
                        v1187 = Union6{Union6_3{1, v1184}};
                        v13.push(v1187);
                        static_array<static_array<unsigned char,2>,2> v1188;
                        v1188[0] = v1180;
                        v1188[1] = v1184;
                        static_array<int,2> v1190;
                        v1190[0] = 2;
                        v1190[1] = 1;
                        static_array<int,2> v1192;
                        int v1194;
                        v1194 = 0;
                        while (while_method_0(v1194)){
                            int v1196;
                            v1196 = v1190[v1194];
                            int v1198;
                            v1198 = 100 - v1196;
                            v1192[v1194] = v1198;
                            v1194 += 1 ;
                        }
                        int v1199;
                        v1199 = 2;
                        int v1200;
                        v1200 = 0;
                        Union5 v1201;
                        v1201 = Union5{Union5_1{}};
                        Union4 v1202;
                        v1202 = try_round_36(v1199, v1188, v1190, v1200, v1192, v1201);
                        v1211 = Union18{Union18_2{v1202}};
                        break;
                    }
                    case 3: { // G_River
                        int v1147 = v18.case3.v0; static_array<static_array<unsigned char,2>,2> v1148 = v18.case3.v1; static_array<int,2> v1149 = v18.case3.v2; int v1150 = v18.case3.v3; static_array<int,2> v1151 = v18.case3.v4; Union5 v1152 = v18.case3.v5;
                        curandStatePhilox4_32_10_t & v1153 = v2.v5;
                        curandStatePhilox4_32_10_t & v1154 = v1153;
                        static_array<unsigned char,1> v1155; unsigned long long v1156;
                        Tuple12 tmp110 = draw_cards_40(v1154, v14);
                        v1155 = tmp110.v0; v1156 = tmp110.v1;
                        v2.v0 = v1156;
                        static_array_list<unsigned char,5> v1157;
                        v1157 = get_community_cards_82(v1152, v1155);
                        Union6 v1158;
                        v1158 = Union6{Union6_0{v1157}};
                        v13.push(v1158);
                        Union5 v1173;
                        switch (v1152.tag) {
                            case 3: { // Turn
                                static_array<unsigned char,4> v1159 = v1152.case3.v0;
                                static_array<unsigned char,5> v1160;
                                int v1162;
                                v1162 = 0;
                                while (while_method_3(v1162)){
                                    unsigned char v1164;
                                    v1164 = v1159[v1162];
                                    v1160[v1162] = v1164;
                                    v1162 += 1 ;
                                }
                                int v1166;
                                v1166 = 0;
                                while (while_method_6(v1166)){
                                    unsigned char v1168;
                                    v1168 = v1155[v1166];
                                    int v1170;
                                    v1170 = 4 + v1166;
                                    v1160[v1170] = v1168;
                                    v1166 += 1 ;
                                }
                                v1173 = Union5{Union5_2{v1160}};
                                break;
                            }
                            default: {
                                printf("%s\n", "Invalid street in river.");
                                __trap();
                            }
                        }
                        int v1174;
                        v1174 = 2;
                        int v1175;
                        v1175 = 0;
                        Union4 v1176;
                        v1176 = try_round_36(v1174, v1148, v1149, v1175, v1151, v1173);
                        v1211 = Union18{Union18_2{v1176}};
                        break;
                    }
                    case 4: { // G_Round
                        int v110 = v18.case4.v0; static_array<static_array<unsigned char,2>,2> v111 = v18.case4.v1; static_array<int,2> v112 = v18.case4.v2; int v113 = v18.case4.v3; static_array<int,2> v114 = v18.case4.v4; Union5 v115 = v18.case4.v5;
                        int v116;
                        v116 = v113 % 2;
                        static_array<Union2,2> & v117 = v2.v3;
                        Union2 v118;
                        v118 = v117[v116];
                        Union1 v1084;
                        switch (v118.tag) {
                            case 0: { // Computer
                                static_array_list<Union6,128> & v121 = v2.v2;
                                curandStatePhilox4_32_10_t & v122 = v2.v5;
                                curandStatePhilox4_32_10_t & v123 = v122;
                                unsigned int * v124;
                                v124 = reinterpret_cast<unsigned int *>(&v0[53477376ull]);
                                float * v126;
                                v126 = reinterpret_cast<float *>(&v0[0ull]);
                                int v128;
                                v128 = threadIdx.x;
                                int v129;
                                v129 = blockIdx.x;
                                int v130;
                                v130 = v129 * 256;
                                int v131;
                                v131 = v128 + v130;
                                unsigned long long v132;
                                v132 = (unsigned long long)v131;
                                curandStatePhilox4_32_10_t v133;
                                curand_init(12344321ull,v132,0ull,&v133);
                                float * v134;
                                v134 = reinterpret_cast<float *>(&v0[0ull]);
                                int v136;
                                v136 = blockIdx.x;
                                assert("Tensor range check" && 0 <= v136 && v136 < 24);
                                int v137;
                                v137 = 524288 * v136;
                                int v138;
                                v138 = threadIdx.x;
                                int v139;
                                v139 = blockIdx.x;
                                int v140;
                                v140 = v139 * 256;
                                int v141;
                                v141 = v138 + v140;
                                unsigned long long v142;
                                v142 = (unsigned long long)v141;
                                curandStatePhilox4_32_10_t v143;
                                curand_init(12344321ull,v142,0ull,&v143);
                                int v144;
                                v144 = threadIdx.x;
                                int v145;
                                v145 = v144;
                                while (while_method_7(v145)){
                                    bool v147;
                                    v147 = 0 <= v145;
                                    bool v148;
                                    v148 = v147 == false;
                                    if (v148){
                                        assert("The index needs to be zero or positive." && v147);
                                    } else {
                                    }
                                    int v150;
                                    v150 = v145 % 2048;
                                    int v151;
                                    v151 = v145 / 2048;
                                    bool v152;
                                    v152 = v151 < 256;
                                    bool v153;
                                    v153 = v152 == false;
                                    if (v153){
                                        assert("The last element of the projection dimensions needs to be greater than the index remainder." && v152);
                                    } else {
                                    }
                                    assert("Tensor range check" && 0 <= v151 && v151 < 256);
                                    assert("Tensor range check" && 0 <= v150 && v150 < 2048);
                                    int v155;
                                    v155 = v150 + v137;
                                    int v156;
                                    v156 = 2048 * v151;
                                    int v157;
                                    v157 = v156 + v155;
                                    v134[v157] = 0.0f;
                                    v145 += 256 ;
                                }
                                asm("barrier.cta.sync %0;" :: "r"(0));
                                int v158;
                                v158 = threadIdx.x;
                                assert("Tensor range check" && 0 <= v158 && v158 < 256);
                                int v159;
                                v159 = 2048 * v158;
                                int v160;
                                v160 = v159 + v137;
                                int v161;
                                v161 = v121.length;
                                bool v162;
                                v162 = 128 >= v161;
                                bool v163;
                                v163 = v162 == false;
                                if (v163){
                                    assert("The type level dimension has to equal the value passed at runtime into create." && v162);
                                } else {
                                }
                                static_array_list<Union8,128> v165;
                                v165 = static_array_list<Union8,128>{};
                                v165.unsafe_set_length(v161);
                                int v167;
                                v167 = 0;
                                while (while_method_4(v161, v167)){
                                    Union6 v169;
                                    v169 = v121[v167];
                                    Union8 v175;
                                    switch (v169.tag) {
                                        case 2: { // PlayerAction
                                            int v171 = v169.case2.v0; Union1 v172 = v169.case2.v1;
                                            v175 = Union8{Union8_1{v172}};
                                            break;
                                        }
                                        default: {
                                            v175 = Union8{Union8_0{}};
                                        }
                                    }
                                    v165[v167] = v175;
                                    v167 += 1 ;
                                }
                                static_array<int,2> v176;
                                int v178;
                                v178 = 0;
                                while (while_method_0(v178)){
                                    int v180;
                                    v180 = v178 + v116;
                                    int v181;
                                    v181 = v112[v180];
                                    v176[v178] = v181;
                                    v178 += 1 ;
                                }
                                static_array<int,2> v183;
                                int v185;
                                v185 = 0;
                                while (while_method_0(v185)){
                                    int v187;
                                    v187 = v185 + v116;
                                    int v188;
                                    v188 = v114[v187];
                                    v183[v185] = v188;
                                    v185 += 1 ;
                                }
                                static_array<unsigned char,2> v190;
                                v190 = v111[v116];
                                static_array_list<unsigned char,5> v192;
                                v192 = static_array_list<unsigned char,5>{};
                                switch (v115.tag) {
                                    case 0: { // Flop
                                        static_array<unsigned char,3> v194 = v115.case0.v0;
                                        int v195;
                                        v195 = 0;
                                        while (while_method_1(v195)){
                                            unsigned char v197;
                                            v197 = v194[v195];
                                            v192.push(v197);
                                            v195 += 1 ;
                                        }
                                        break;
                                    }
                                    case 1: { // Preflop
                                        break;
                                    }
                                    case 2: { // River
                                        static_array<unsigned char,5> v204 = v115.case2.v0;
                                        int v205;
                                        v205 = 0;
                                        while (while_method_2(v205)){
                                            unsigned char v207;
                                            v207 = v204[v205];
                                            v192.push(v207);
                                            v205 += 1 ;
                                        }
                                        break;
                                    }
                                    case 3: { // Turn
                                        static_array<unsigned char,4> v199 = v115.case3.v0;
                                        int v200;
                                        v200 = 0;
                                        while (while_method_3(v200)){
                                            unsigned char v202;
                                            v202 = v199[v200];
                                            v192.push(v202);
                                            v200 += 1 ;
                                        }
                                        break;
                                    }
                                    default: {
                                        assert("Invalid tag." && false); __trap();
                                    }
                                }
                                float * v209;
                                v209 = v134+v160;
                                int v211;
                                v211 = v165.length;
                                bool v212;
                                v212 = v211 == 0;
                                if (v212){
                                    v209[0] = 1.0f;
                                } else {
                                }
                                int v213;
                                v213 = v165.length;
                                int v214;
                                v214 = 0;
                                while (while_method_4(v213, v214)){
                                    Union8 v216;
                                    v216 = v165[v214];
                                    int v218;
                                    v218 = v214 * 14;
                                    int v219;
                                    v219 = 1 + v218;
                                    switch (v216.tag) {
                                        case 0: { // None
                                            v209[v219] = 1.0f;
                                            break;
                                        }
                                        case 1: { // Some
                                            Union1 v220 = v216.case1.v0;
                                            int v221;
                                            v221 = v219 + 1;
                                            switch (v220.tag) {
                                                case 0: { // A_All_In
                                                    v209[v221] = 1.0f;
                                                    break;
                                                }
                                                case 1: { // A_Call
                                                    int v222;
                                                    v222 = v221 + 1;
                                                    v209[v222] = 1.0f;
                                                    break;
                                                }
                                                case 2: { // A_Fold
                                                    int v223;
                                                    v223 = v221 + 2;
                                                    v209[v223] = 1.0f;
                                                    break;
                                                }
                                                case 3: { // A_Raise
                                                    int v224 = v220.case3.v0;
                                                    int v225;
                                                    v225 = v221 + 3;
                                                    bool v226;
                                                    v226 = 1 <= v224;
                                                    bool v228;
                                                    if (v226){
                                                        bool v227;
                                                        v227 = v224 < 1023;
                                                        v228 = v227;
                                                    } else {
                                                        v228 = false;
                                                    }
                                                    bool v229;
                                                    v229 = v228 == false;
                                                    if (v229){
                                                        assert("Pickle failure. The input is out of the bounds of the given range." && v228);
                                                    } else {
                                                    }
                                                    int v231;
                                                    v231 = v224 - 1;
                                                    unsigned int v232;
                                                    v232 = (unsigned int)v231;
                                                    method_42(v232, v209, v225);
                                                    break;
                                                }
                                                default: {
                                                    assert("Invalid tag." && false); __trap();
                                                }
                                            }
                                            break;
                                        }
                                        default: {
                                            assert("Invalid tag." && false); __trap();
                                        }
                                    }
                                    v214 += 1 ;
                                }
                                int v233;
                                v233 = 0;
                                while (while_method_0(v233)){
                                    int v235;
                                    v235 = v176[v233];
                                    int v237;
                                    v237 = v233 * 11;
                                    int v238;
                                    v238 = 1794 + v237;
                                    bool v239;
                                    v239 = 0 <= v235;
                                    bool v241;
                                    if (v239){
                                        bool v240;
                                        v240 = v235 < 1023;
                                        v241 = v240;
                                    } else {
                                        v241 = false;
                                    }
                                    bool v242;
                                    v242 = v241 == false;
                                    if (v242){
                                        assert("Pickle failure. The input is out of the bounds of the given range." && v241);
                                    } else {
                                    }
                                    unsigned int v244;
                                    v244 = (unsigned int)v235;
                                    method_43(v244, v209, v238);
                                    v233 += 1 ;
                                }
                                int v245;
                                v245 = 0;
                                while (while_method_0(v245)){
                                    int v247;
                                    v247 = v183[v245];
                                    int v249;
                                    v249 = v245 * 11;
                                    int v250;
                                    v250 = 1817 + v249;
                                    bool v251;
                                    v251 = 0 <= v247;
                                    bool v253;
                                    if (v251){
                                        bool v252;
                                        v252 = v247 < 1023;
                                        v253 = v252;
                                    } else {
                                        v253 = false;
                                    }
                                    bool v254;
                                    v254 = v253 == false;
                                    if (v254){
                                        assert("Pickle failure. The input is out of the bounds of the given range." && v253);
                                    } else {
                                    }
                                    unsigned int v256;
                                    v256 = (unsigned int)v247;
                                    method_43(v256, v209, v250);
                                    v245 += 1 ;
                                }
                                int v257;
                                v257 = 0;
                                while (while_method_0(v257)){
                                    unsigned char v259;
                                    v259 = v190[v257];
                                    int v261;
                                    v261 = v257 * 17;
                                    int v262;
                                    v262 = 1840 + v261;
                                    unsigned char v263;
                                    v263 = v259 % 4u;
                                    int v264;
                                    v264 = (int)v263;
                                    unsigned char v265;
                                    v265 = v259 / 4u;
                                    int v266;
                                    v266 = (int)v265;
                                    unsigned int v267;
                                    v267 = (unsigned int)v264;
                                    int v268;
                                    v268 = (int)v267;
                                    bool v269;
                                    v269 = v268 < 4;
                                    bool v270;
                                    v270 = v269 == false;
                                    if (v270){
                                        assert("Pickle failure. Int value out of bounds." && v269);
                                    } else {
                                    }
                                    int v272;
                                    v272 = v262 + v268;
                                    v209[v272] = 1.0f;
                                    int v273;
                                    v273 = v262 + 4;
                                    unsigned int v274;
                                    v274 = (unsigned int)v266;
                                    int v275;
                                    v275 = (int)v274;
                                    bool v276;
                                    v276 = v275 < 13;
                                    bool v277;
                                    v277 = v276 == false;
                                    if (v277){
                                        assert("Pickle failure. Int value out of bounds." && v276);
                                    } else {
                                    }
                                    int v279;
                                    v279 = v273 + v275;
                                    v209[v279] = 1.0f;
                                    v257 += 1 ;
                                }
                                int v280;
                                v280 = v192.length;
                                bool v281;
                                v281 = v280 == 0;
                                if (v281){
                                    v209[1874] = 1.0f;
                                } else {
                                }
                                int v282;
                                v282 = v192.length;
                                int v283;
                                v283 = 0;
                                while (while_method_4(v282, v283)){
                                    unsigned char v285;
                                    v285 = v192[v283];
                                    int v287;
                                    v287 = v283 * 17;
                                    int v288;
                                    v288 = 1875 + v287;
                                    unsigned char v289;
                                    v289 = v285 % 4u;
                                    int v290;
                                    v290 = (int)v289;
                                    unsigned char v291;
                                    v291 = v285 / 4u;
                                    int v292;
                                    v292 = (int)v291;
                                    unsigned int v293;
                                    v293 = (unsigned int)v290;
                                    int v294;
                                    v294 = (int)v293;
                                    bool v295;
                                    v295 = v294 < 4;
                                    bool v296;
                                    v296 = v295 == false;
                                    if (v296){
                                        assert("Pickle failure. Int value out of bounds." && v295);
                                    } else {
                                    }
                                    int v298;
                                    v298 = v288 + v294;
                                    v209[v298] = 1.0f;
                                    int v299;
                                    v299 = v288 + 4;
                                    unsigned int v300;
                                    v300 = (unsigned int)v292;
                                    int v301;
                                    v301 = (int)v300;
                                    bool v302;
                                    v302 = v301 < 13;
                                    bool v303;
                                    v303 = v302 == false;
                                    if (v303){
                                        assert("Pickle failure. Int value out of bounds." && v302);
                                    } else {
                                    }
                                    int v305;
                                    v305 = v299 + v301;
                                    v209[v305] = 1.0f;
                                    v283 += 1 ;
                                }
                                asm("barrier.cta.sync %0;" :: "r"(0));
                                int v306;
                                v306 = 0;
                                while (while_method_3(v306)){
                                    float * v308;
                                    v308 = reinterpret_cast<float *>(&v0[0ull]);
                                    float * v310;
                                    v310 = reinterpret_cast<float *>(&v1[0ull]);
                                    assert("Tensor range check" && 0 <= v306 && v306 < 4);
                                    int v312;
                                    v312 = 262144 * v306;
                                    float * v313;
                                    v313 = reinterpret_cast<float *>(&v0[50331648ull]);
                                    int v315;
                                    v315 = blockIdx.x;
                                    assert("Tensor range check" && 0 <= v315 && v315 < 24);
                                    int v316;
                                    v316 = 524288 * v315;
                                    int v317;
                                    v317 = blockIdx.x;
                                    assert("Tensor range check" && 0 <= v317 && v317 < 24);
                                    int v318;
                                    v318 = 32768 * v317;
                                    cuda::pipeline<cuda::thread_scope_thread> v319 = cuda::make_pipeline();
                                    extern __shared__ unsigned char v320[];
                                    float * v321;
                                    v321 = reinterpret_cast<float *>(&v320[0ull]);
                                    float * v323;
                                    v323 = reinterpret_cast<float *>(&v320[34816ull]);
                                    float * v325;
                                    v325 = reinterpret_cast<float *>(&v320[0ull]);
                                    int v327;
                                    v327 = threadIdx.x;
                                    int v328;
                                    v328 = v327 / 32;
                                    bool v329;
                                    v329 = 0 <= v328;
                                    bool v330;
                                    v330 = v329 == false;
                                    if (v330){
                                        assert("The index needs to be zero or positive." && v329);
                                    } else {
                                    }
                                    int v332;
                                    v332 = v328 % 8;
                                    int v333;
                                    v333 = v328 / 8;
                                    bool v334;
                                    v334 = v333 < 1;
                                    bool v335;
                                    v335 = v334 == false;
                                    if (v335){
                                        assert("The last element of the projection dimensions needs to be greater than the index remainder." && v334);
                                    } else {
                                    }
                                    assert("Tensor range check" && 0 <= v333 && v333 < 1);
                                    assert("Tensor range check" && 0 <= v332 && v332 < 8);
                                    int v337;
                                    v337 = 16 * v332;
                                    int v338;
                                    v338 = 17408 * v333;
                                    int v339;
                                    v339 = v338 + v337;
                                    float * v340;
                                    v340 = v325+v339;
                                    assert("Tensor range check" && 0 <= v333 && v333 < 1);
                                    int v342;
                                    v342 = 8704 * v333;
                                    int v343;
                                    v343 = threadIdx.x;
                                    int v344;
                                    v344 = v343 % 32;
                                    bool v345;
                                    v345 = 0 <= v344;
                                    bool v346;
                                    v346 = v345 == false;
                                    if (v346){
                                        assert("The index needs to be zero or positive." && v345);
                                    } else {
                                    }
                                    int v348;
                                    v348 = v344 % 4;
                                    int v349;
                                    v349 = v344 / 4;
                                    bool v350;
                                    v350 = v349 < 8;
                                    bool v351;
                                    v351 = v350 == false;
                                    if (v351){
                                        assert("The last element of the projection dimensions needs to be greater than the index remainder." && v350);
                                    } else {
                                    }
                                    assert("Tensor range check" && 0 <= v349 && v349 < 8);
                                    assert("Tensor range check" && 0 <= v348 && v348 < 4);
                                    int v353;
                                    v353 = v348 + v342;
                                    int v354;
                                    v354 = 68 * v349;
                                    int v355;
                                    v355 = v354 + v353;
                                    float * v356;
                                    v356 = v321+v355;
                                    assert("Tensor range check" && 0 <= v332 && v332 < 8);
                                    int v358;
                                    v358 = 1088 * v332;
                                    int v359;
                                    v359 = threadIdx.x;
                                    int v360;
                                    v360 = v359 % 32;
                                    bool v361;
                                    v361 = 0 <= v360;
                                    bool v362;
                                    v362 = v361 == false;
                                    if (v362){
                                        assert("The index needs to be zero or positive." && v361);
                                    } else {
                                    }
                                    int v364;
                                    v364 = v360 % 4;
                                    int v365;
                                    v365 = v360 / 4;
                                    bool v366;
                                    v366 = v365 < 8;
                                    bool v367;
                                    v367 = v366 == false;
                                    if (v367){
                                        assert("The last element of the projection dimensions needs to be greater than the index remainder." && v366);
                                    } else {
                                    }
                                    assert("Tensor range check" && 0 <= v365 && v365 < 8);
                                    assert("Tensor range check" && 0 <= v364 && v364 < 4);
                                    int v369;
                                    v369 = v364 + v358;
                                    int v370;
                                    v370 = 68 * v365;
                                    int v371;
                                    v371 = v370 + v369;
                                    float * v372;
                                    v372 = v323+v371;
                                    wmma::fragment<wmma::accumulator, 16, 16, 8, float> v374[8];
                                    int v375;
                                    v375 = 0;
                                    while (while_method_0(v375)){
                                        int v377;
                                        v377 = 0;
                                        while (while_method_6(v377)){
                                            assert("Tensor range check" && 0 <= v375 && v375 < 2);
                                            assert("Tensor range check" && 0 <= v377 && v377 < 1);
                                            int v379;
                                            v379 = 128 * v377;
                                            int v380;
                                            v380 = v379 + v318;
                                            int v381;
                                            v381 = 16384 * v375;
                                            int v382;
                                            v382 = v381 + v380;
                                            float * v383;
                                            v383 = v313+v382;
                                            // Pushing the loop unrolling to: 0
                                            int v385;
                                            v385 = 0;
                                            #pragma unroll
                                            while (while_method_10(v385)){
                                                int v387;
                                                v387 = 0;
                                                #pragma unroll
                                                while (while_method_6(v387)){
                                                    assert("Tensor range check" && 0 <= v385 && v385 < 8);
                                                    assert("Tensor range check" && 0 <= v387 && v387 < 1);
                                                    int v389;
                                                    v389 = v385 + v387;
                                                    wmma::fragment<wmma::accumulator, 16, 16, 8, float> & v390 = v374[v389];
                                                    wmma::fill_fragment(v390, 0.0f);
                                                    v387 += 1 ;
                                                }
                                                v385 += 1 ;
                                            }
                                            // Poping the loop unrolling to: 0
                                            int v391;
                                            v391 = 0;
                                            while (while_method_11(v391)){
                                                int v393;
                                                v393 = v391 + 1;
                                                bool v394;
                                                v394 = v391 == 0;
                                                int v395;
                                                v395 = v391 % 2;
                                                bool v396;
                                                v396 = 0 <= v391;
                                                bool v397;
                                                v397 = v396 == false;
                                                if (v397){
                                                    assert("The index needs to be zero or positive." && v396);
                                                } else {
                                                }
                                                bool v399;
                                                v399 = v391 < 32;
                                                bool v400;
                                                v400 = v399 == false;
                                                if (v400){
                                                    assert("The last element of the projection dimensions needs to be greater than the index remainder." && v399);
                                                } else {
                                                }
                                                bool v402;
                                                v402 = v393 < 32;
                                                Union9 v408;
                                                if (v402){
                                                    bool v403;
                                                    v403 = 0 <= v393;
                                                    bool v404;
                                                    v404 = v403 == false;
                                                    if (v404){
                                                        assert("The index needs to be zero or positive." && v403);
                                                    } else {
                                                    }
                                                    v408 = Union9{Union9_1{v393}};
                                                } else {
                                                    v408 = Union9{Union9_0{}};
                                                }
                                                assert("Tensor range check" && 0 <= v375 && v375 < 2);
                                                int v409;
                                                v409 = 262144 * v375;
                                                int v410;
                                                v410 = v409 + v316;
                                                assert("Tensor range check" && 0 <= v391 && v391 < 32);
                                                int v411;
                                                v411 = 64 * v391;
                                                int v412;
                                                v412 = v411 + v410;
                                                float * v413;
                                                v413 = v308+v412;
                                                assert("Tensor range check" && 0 <= v377 && v377 < 1);
                                                int v415;
                                                v415 = 262144 * v377;
                                                int v416;
                                                v416 = v415 + v312;
                                                if (v394){
                                                    assert("Tensor range check" && 0 <= v391 && v391 < 32);
                                                    int v417;
                                                    v417 = v411 + v416;
                                                    float * v418;
                                                    v418 = v310+v417;
                                                    // Pushing the loop unrolling to: 0
                                                    v319.producer_acquire();
                                                    int v420;
                                                    v420 = threadIdx.x;
                                                    bool v421;
                                                    v421 = 0 <= v420;
                                                    bool v422;
                                                    v422 = v421 == false;
                                                    if (v422){
                                                        assert("The index needs to be zero or positive." && v421);
                                                    } else {
                                                    }
                                                    int v424;
                                                    v424 = v420 % 16;
                                                    int v425;
                                                    v425 = v420 / 16;
                                                    bool v426;
                                                    v426 = v425 < 16;
                                                    bool v427;
                                                    v427 = v426 == false;
                                                    if (v427){
                                                        assert("The last element of the projection dimensions needs to be greater than the index remainder." && v426);
                                                    } else {
                                                    }
                                                    assert("Tensor range check" && 0 <= v425 && v425 < 16);
                                                    assert("Tensor range check" && 0 <= v424 && v424 < 16);
                                                    int v429;
                                                    v429 = 4 * v424;
                                                    int v430;
                                                    v430 = 68 * v425;
                                                    int v431;
                                                    v431 = v430 + v429;
                                                    int v432;
                                                    v432 = 2048 * v425;
                                                    int v433;
                                                    v433 = v432 + v429;
                                                    float * v434;
                                                    v434 = v323+v431;
                                                    float * v436;
                                                    v436 = v418+v433;
                                                    int v438;
                                                    v438 = 0;
                                                    #pragma unroll
                                                    while (while_method_10(v438)){
                                                        int v440;
                                                        v440 = 0;
                                                        #pragma unroll
                                                        while (while_method_6(v440)){
                                                            assert("Tensor range check" && 0 <= v438 && v438 < 8);
                                                            assert("Tensor range check" && 0 <= v440 && v440 < 1);
                                                            int v442;
                                                            v442 = 64 * v440;
                                                            int v443;
                                                            v443 = 1088 * v438;
                                                            int v444;
                                                            v444 = v443 + v442;
                                                            int v445;
                                                            v445 = 32768 * v438;
                                                            int v446;
                                                            v446 = v445 + v442;
                                                            constexpr int v447 = sizeof(float) * 4;
                                                            assert("Pointer alignment check" && (unsigned long long)(v436 + v446) % v447 == 0 && (unsigned long long)(v434 + v444) % v447 == 0);
                                                            cuda::memcpy_async(v434 + v444, v436 + v446, cuda::aligned_size_t<v447>(v447), v319);
                                                            v440 += 1 ;
                                                        }
                                                        v438 += 1 ;
                                                    }
                                                    v319.producer_commit();
                                                    // Poping the loop unrolling to: 0
                                                } else {
                                                }
                                                // Pushing the loop unrolling to: 0
                                                int v448;
                                                v448 = threadIdx.x;
                                                bool v449;
                                                v449 = 0 <= v448;
                                                bool v450;
                                                v450 = v449 == false;
                                                if (v450){
                                                    assert("The index needs to be zero or positive." && v449);
                                                } else {
                                                }
                                                int v452;
                                                v452 = v448 % 16;
                                                int v453;
                                                v453 = v448 / 16;
                                                bool v454;
                                                v454 = v453 < 16;
                                                bool v455;
                                                v455 = v454 == false;
                                                if (v455){
                                                    assert("The last element of the projection dimensions needs to be greater than the index remainder." && v454);
                                                } else {
                                                }
                                                assert("Tensor range check" && 0 <= v453 && v453 < 16);
                                                assert("Tensor range check" && 0 <= v452 && v452 < 16);
                                                int v457;
                                                v457 = 4 * v452;
                                                int v458;
                                                v458 = 68 * v453;
                                                int v459;
                                                v459 = v458 + v457;
                                                int v460;
                                                v460 = 2048 * v453;
                                                int v461;
                                                v461 = v460 + v457;
                                                float * v462;
                                                v462 = v321+v459;
                                                float * v464;
                                                v464 = v413+v461;
                                                int v466;
                                                v466 = 0;
                                                #pragma unroll
                                                while (while_method_10(v466)){
                                                    int v468;
                                                    v468 = 0;
                                                    #pragma unroll
                                                    while (while_method_6(v468)){
                                                        assert("Tensor range check" && 0 <= v466 && v466 < 8);
                                                        assert("Tensor range check" && 0 <= v468 && v468 < 1);
                                                        int v470;
                                                        v470 = 64 * v468;
                                                        int v471;
                                                        v471 = 1088 * v466;
                                                        int v472;
                                                        v472 = v471 + v470;
                                                        int v473;
                                                        v473 = 32768 * v466;
                                                        int v474;
                                                        v474 = v473 + v470;
                                                        int4* v475;
                                                        v475 = reinterpret_cast<int4*>(v464 + v474);
                                                        int4* v476;
                                                        v476 = reinterpret_cast<int4*>(v462 + v472);
                                                        assert("Pointer alignment check" && (unsigned long long)(v475) % 4 == 0 && (unsigned long long)(v476) % 4 == 0);
                                                        *v476 = *v475;
                                                        v468 += 1 ;
                                                    }
                                                    v466 += 1 ;
                                                }
                                                // Poping the loop unrolling to: 0
                                                wmma::fragment<wmma::matrix_a, 16, 16, 8, wmma::precision::tf32, wmma::row_major> v477[1];
                                                wmma::fragment<wmma::matrix_b, 16, 16, 8, wmma::precision::tf32, wmma::col_major> v478[8];
                                                cuda::pipeline_consumer_wait_prior<0>(v319);;
                                                asm("barrier.cta.sync %0;" :: "r"(0));
                                                // Pushing the loop unrolling to: 0
                                                int v479;
                                                v479 = 0;
                                                #pragma unroll
                                                while (while_method_6(v479)){
                                                    int v481;
                                                    v481 = 0;
                                                    #pragma unroll
                                                    while (while_method_10(v481)){
                                                        assert("Tensor range check" && 0 <= v479 && v479 < 1);
                                                        assert("Tensor range check" && 0 <= v481 && v481 < 8);
                                                        int v483;
                                                        v483 = 8 * v479;
                                                        int v484;
                                                        v484 = v483 + v481;
                                                        wmma::fragment<wmma::matrix_b, 16, 16, 8, wmma::precision::tf32, wmma::col_major> & v485 = v478[v484];
                                                        assert("Tensor range check" && 0 <= v479 && v479 < 1);
                                                        int v486;
                                                        v486 = 1088 * v479;
                                                        assert("Tensor range check" && 0 <= v481 && v481 < 8);
                                                        int v487;
                                                        v487 = 8 * v481;
                                                        int v488;
                                                        v488 = v487 + v486;
                                                        int v489;
                                                        v489 = 0;
                                                        #pragma unroll
                                                        while (while_method_0(v489)){
                                                            int v491;
                                                            v491 = 0;
                                                            #pragma unroll
                                                            while (while_method_0(v491)){
                                                                assert("Tensor range check" && 0 <= v489 && v489 < 2);
                                                                assert("Tensor range check" && 0 <= v491 && v491 < 2);
                                                                int v493;
                                                                v493 = 4 * v491;
                                                                int v494;
                                                                v494 = v493 + v488;
                                                                int v495;
                                                                v495 = 544 * v489;
                                                                int v496;
                                                                v496 = v495 + v494;
                                                                float v497;
                                                                v497 = v372[v496];
                                                                bool v498;
                                                                v498 = 0 <= v491;
                                                                bool v500;
                                                                if (v498){
                                                                    bool v499;
                                                                    v499 = v491 < 2;
                                                                    v500 = v499;
                                                                } else {
                                                                    v500 = false;
                                                                }
                                                                bool v501;
                                                                v501 = v500 == false;
                                                                if (v501){
                                                                    assert("The indices should be inside the range of the dimension." && v500);
                                                                } else {
                                                                }
                                                                bool v503;
                                                                v503 = 0 <= v489;
                                                                bool v505;
                                                                if (v503){
                                                                    bool v504;
                                                                    v504 = v489 < 2;
                                                                    v505 = v504;
                                                                } else {
                                                                    v505 = false;
                                                                }
                                                                bool v506;
                                                                v506 = v505 == false;
                                                                if (v506){
                                                                    assert("The indices should be inside the range of the dimension." && v505);
                                                                } else {
                                                                }
                                                                int v508;
                                                                v508 = v489 * 2;
                                                                int v509;
                                                                v509 = v491 + v508;
                                                                v485.x[v509] = wmma::__float_to_tf32(v497);
                                                                v491 += 1 ;
                                                            }
                                                            v489 += 1 ;
                                                        }
                                                        v481 += 1 ;
                                                    }
                                                    v479 += 1 ;
                                                }
                                                // Poping the loop unrolling to: 0
                                                v319.consumer_release();
                                                switch (v408.tag) {
                                                    case 0: { // None
                                                        break;
                                                    }
                                                    case 1: { // Some
                                                        int v510 = v408.case1.v0;
                                                        assert("Tensor range check" && 0 <= v510 && v510 < 32);
                                                        int v511;
                                                        v511 = 64 * v510;
                                                        int v512;
                                                        v512 = v511 + v416;
                                                        float * v513;
                                                        v513 = v310+v512;
                                                        asm("barrier.cta.sync %0;" :: "r"(0));
                                                        // Pushing the loop unrolling to: 0
                                                        v319.producer_acquire();
                                                        int v515;
                                                        v515 = threadIdx.x;
                                                        bool v516;
                                                        v516 = 0 <= v515;
                                                        bool v517;
                                                        v517 = v516 == false;
                                                        if (v517){
                                                            assert("The index needs to be zero or positive." && v516);
                                                        } else {
                                                        }
                                                        int v519;
                                                        v519 = v515 % 16;
                                                        int v520;
                                                        v520 = v515 / 16;
                                                        bool v521;
                                                        v521 = v520 < 16;
                                                        bool v522;
                                                        v522 = v521 == false;
                                                        if (v522){
                                                            assert("The last element of the projection dimensions needs to be greater than the index remainder." && v521);
                                                        } else {
                                                        }
                                                        assert("Tensor range check" && 0 <= v520 && v520 < 16);
                                                        assert("Tensor range check" && 0 <= v519 && v519 < 16);
                                                        int v524;
                                                        v524 = 4 * v519;
                                                        int v525;
                                                        v525 = 68 * v520;
                                                        int v526;
                                                        v526 = v525 + v524;
                                                        int v527;
                                                        v527 = 2048 * v520;
                                                        int v528;
                                                        v528 = v527 + v524;
                                                        float * v529;
                                                        v529 = v323+v526;
                                                        float * v531;
                                                        v531 = v513+v528;
                                                        int v533;
                                                        v533 = 0;
                                                        #pragma unroll
                                                        while (while_method_10(v533)){
                                                            int v535;
                                                            v535 = 0;
                                                            #pragma unroll
                                                            while (while_method_6(v535)){
                                                                assert("Tensor range check" && 0 <= v533 && v533 < 8);
                                                                assert("Tensor range check" && 0 <= v535 && v535 < 1);
                                                                int v537;
                                                                v537 = 64 * v535;
                                                                int v538;
                                                                v538 = 1088 * v533;
                                                                int v539;
                                                                v539 = v538 + v537;
                                                                int v540;
                                                                v540 = 32768 * v533;
                                                                int v541;
                                                                v541 = v540 + v537;
                                                                constexpr int v542 = sizeof(float) * 4;
                                                                assert("Pointer alignment check" && (unsigned long long)(v531 + v541) % v542 == 0 && (unsigned long long)(v529 + v539) % v542 == 0);
                                                                cuda::memcpy_async(v529 + v539, v531 + v541, cuda::aligned_size_t<v542>(v542), v319);
                                                                v535 += 1 ;
                                                            }
                                                            v533 += 1 ;
                                                        }
                                                        v319.producer_commit();
                                                        // Poping the loop unrolling to: 0
                                                        break;
                                                    }
                                                    default: {
                                                        assert("Invalid tag." && false); __trap();
                                                    }
                                                }
                                                // Pushing the loop unrolling to: 0
                                                int v543;
                                                v543 = 0;
                                                #pragma unroll
                                                while (while_method_10(v543)){
                                                    int v545;
                                                    v545 = 0;
                                                    #pragma unroll
                                                    while (while_method_10(v545)){
                                                        wmma::fragment<wmma::matrix_a, 16, 16, 8, wmma::precision::tf32, wmma::row_major> & v547 = v477[0];
                                                        assert("Tensor range check" && 0 <= v543 && v543 < 8);
                                                        int v548;
                                                        v548 = 1088 * v543;
                                                        assert("Tensor range check" && 0 <= v545 && v545 < 8);
                                                        int v549;
                                                        v549 = 8 * v545;
                                                        int v550;
                                                        v550 = v549 + v548;
                                                        int v551;
                                                        v551 = 0;
                                                        #pragma unroll
                                                        while (while_method_0(v551)){
                                                            int v553;
                                                            v553 = 0;
                                                            #pragma unroll
                                                            while (while_method_0(v553)){
                                                                assert("Tensor range check" && 0 <= v551 && v551 < 2);
                                                                assert("Tensor range check" && 0 <= v553 && v553 < 2);
                                                                int v555;
                                                                v555 = 544 * v553;
                                                                int v556;
                                                                v556 = v555 + v550;
                                                                int v557;
                                                                v557 = 4 * v551;
                                                                int v558;
                                                                v558 = v557 + v556;
                                                                float v559;
                                                                v559 = v356[v558];
                                                                bool v560;
                                                                v560 = 0 <= v553;
                                                                bool v562;
                                                                if (v560){
                                                                    bool v561;
                                                                    v561 = v553 < 2;
                                                                    v562 = v561;
                                                                } else {
                                                                    v562 = false;
                                                                }
                                                                bool v563;
                                                                v563 = v562 == false;
                                                                if (v563){
                                                                    assert("The indices should be inside the range of the dimension." && v562);
                                                                } else {
                                                                }
                                                                bool v565;
                                                                v565 = 0 <= v551;
                                                                bool v567;
                                                                if (v565){
                                                                    bool v566;
                                                                    v566 = v551 < 2;
                                                                    v567 = v566;
                                                                } else {
                                                                    v567 = false;
                                                                }
                                                                bool v568;
                                                                v568 = v567 == false;
                                                                if (v568){
                                                                    assert("The indices should be inside the range of the dimension." && v567);
                                                                } else {
                                                                }
                                                                int v570;
                                                                v570 = v551 * 2;
                                                                int v571;
                                                                v571 = v553 + v570;
                                                                v547.x[v571] = wmma::__float_to_tf32(v559);
                                                                v553 += 1 ;
                                                            }
                                                            v551 += 1 ;
                                                        }
                                                        int v572;
                                                        v572 = 0;
                                                        #pragma unroll
                                                        while (while_method_6(v572)){
                                                            assert("Tensor range check" && 0 <= v543 && v543 < 8);
                                                            assert("Tensor range check" && 0 <= v572 && v572 < 1);
                                                            int v574;
                                                            v574 = v543 + v572;
                                                            wmma::fragment<wmma::accumulator, 16, 16, 8, float> & v575 = v374[v574];
                                                            assert("Tensor range check" && 0 <= v572 && v572 < 1);
                                                            assert("Tensor range check" && 0 <= v545 && v545 < 8);
                                                            int v576;
                                                            v576 = 8 * v572;
                                                            int v577;
                                                            v577 = v576 + v545;
                                                            wmma::fragment<wmma::matrix_b, 16, 16, 8, wmma::precision::tf32, wmma::col_major> & v578 = v478[v577];
                                                            wmma::mma_sync(v575, v547, v578, v575);
                                                            v572 += 1 ;
                                                        }
                                                        v545 += 1 ;
                                                    }
                                                    v543 += 1 ;
                                                }
                                                // Poping the loop unrolling to: 0
                                                asm("barrier.cta.sync %0;" :: "r"(0));
                                                v391 = v393;
                                            }
                                            // Pushing the loop unrolling to: 0
                                            int v579;
                                            v579 = 0;
                                            #pragma unroll
                                            while (while_method_10(v579)){
                                                int v581;
                                                v581 = 0;
                                                #pragma unroll
                                                while (while_method_6(v581)){
                                                    assert("Tensor range check" && 0 <= v579 && v579 < 8);
                                                    assert("Tensor range check" && 0 <= v581 && v581 < 1);
                                                    int v583;
                                                    v583 = v579 + v581;
                                                    wmma::fragment<wmma::accumulator, 16, 16, 8, float> & v584 = v374[v583];
                                                    assert("Tensor range check" && 0 <= v579 && v579 < 8);
                                                    assert("Tensor range check" && 0 <= v581 && v581 < 1);
                                                    int v585;
                                                    v585 = 16 * v581;
                                                    int v586;
                                                    v586 = 2176 * v579;
                                                    int v587;
                                                    v587 = v586 + v585;
                                                    float * v588;
                                                    v588 = v340+v587;
                                                    wmma::store_matrix_sync(v588, v584, 136, wmma::mem_row_major);
                                                    v581 += 1 ;
                                                }
                                                v579 += 1 ;
                                            }
                                            // Poping the loop unrolling to: 0
                                            asm("barrier.cta.sync %0;" :: "r"(0));
                                            // Pushing the loop unrolling to: 0
                                            int v590;
                                            v590 = threadIdx.x;
                                            bool v591;
                                            v591 = 0 <= v590;
                                            bool v592;
                                            v592 = v591 == false;
                                            if (v592){
                                                assert("The index needs to be zero or positive." && v591);
                                            } else {
                                            }
                                            int v594;
                                            v594 = v590 % 32;
                                            int v595;
                                            v595 = v590 / 32;
                                            bool v596;
                                            v596 = v595 < 8;
                                            bool v597;
                                            v597 = v596 == false;
                                            if (v597){
                                                assert("The last element of the projection dimensions needs to be greater than the index remainder." && v596);
                                            } else {
                                            }
                                            assert("Tensor range check" && 0 <= v595 && v595 < 8);
                                            assert("Tensor range check" && 0 <= v594 && v594 < 32);
                                            int v599;
                                            v599 = 4 * v594;
                                            int v600;
                                            v600 = 128 * v595;
                                            int v601;
                                            v601 = v600 + v599;
                                            int v602;
                                            v602 = 136 * v595;
                                            int v603;
                                            v603 = v602 + v599;
                                            float * v604;
                                            v604 = v383+v601;
                                            float * v606;
                                            v606 = v325+v603;
                                            int v608;
                                            v608 = 0;
                                            #pragma unroll
                                            while (while_method_12(v608)){
                                                int v610;
                                                v610 = 0;
                                                #pragma unroll
                                                while (while_method_6(v610)){
                                                    assert("Tensor range check" && 0 <= v608 && v608 < 16);
                                                    assert("Tensor range check" && 0 <= v610 && v610 < 1);
                                                    int v612;
                                                    v612 = 128 * v610;
                                                    int v613;
                                                    v613 = 1024 * v608;
                                                    int v614;
                                                    v614 = v613 + v612;
                                                    int v615;
                                                    v615 = 1088 * v608;
                                                    int v616;
                                                    v616 = v615 + v612;
                                                    int4* v617;
                                                    v617 = reinterpret_cast<int4*>(v606 + v616);
                                                    int4* v618;
                                                    v618 = reinterpret_cast<int4*>(v604 + v614);
                                                    assert("Pointer alignment check" && (unsigned long long)(v617) % 4 == 0 && (unsigned long long)(v618) % 4 == 0);
                                                    *v618 = *v617;
                                                    v610 += 1 ;
                                                }
                                                v608 += 1 ;
                                            }
                                            // Poping the loop unrolling to: 0
                                            asm("barrier.cta.sync %0;" :: "r"(0));
                                            v377 += 1 ;
                                        }
                                        v375 += 1 ;
                                    }
                                    unsigned int * v619;
                                    v619 = reinterpret_cast<unsigned int *>(&v0[53477376ull]);
                                    assert("Tensor range check" && 0 <= v306 && v306 < 4);
                                    int v621;
                                    v621 = 6144 * v306;
                                    method_45(v619, v621, v313);
                                    int * v622;
                                    v622 = reinterpret_cast<int *>(&v1[4194304ull]);
                                    float * v624;
                                    v624 = reinterpret_cast<float *>(&v1[4194320ull]);
                                    float * v626;
                                    v626 = reinterpret_cast<float *>(&v1[5242896ull]);
                                    float * v628;
                                    v628 = reinterpret_cast<float *>(&v1[6291472ull]);
                                    float * v630;
                                    v630 = reinterpret_cast<float *>(&v1[7340048ull]);
                                    float * v632;
                                    v632 = reinterpret_cast<float *>(&v1[8388624ull]);
                                    float * v634;
                                    v634 = reinterpret_cast<float *>(&v1[9437200ull]);
                                    float * v636;
                                    v636 = reinterpret_cast<float *>(&v1[10485776ull]);
                                    int * v638;
                                    v638 = reinterpret_cast<int *>(&v0[53575680ull]);
                                    float * v640;
                                    v640 = reinterpret_cast<float *>(&v0[66158592ull]);
                                    int * v642;
                                    v642 = reinterpret_cast<int *>(&v0[78741504ull]);
                                    int * v644;
                                    v644 = reinterpret_cast<int *>(&v0[91324416ull]);
                                    double * v646;
                                    v646 = reinterpret_cast<double *>(&v0[103907328ull]);
                                    double * v648;
                                    v648 = reinterpret_cast<double *>(&v0[154238976ull]);
                                    double * v650;
                                    v650 = reinterpret_cast<double *>(&v1[11534352ull]);
                                    double * v652;
                                    v652 = reinterpret_cast<double *>(&v1[11927568ull]);
                                    int * v654;
                                    v654 = reinterpret_cast<int *>(&v1[12320784ull]);
                                    v306 += 1 ;
                                }
                                asm("barrier.cta.sync %0;" :: "r"(0));
                                int * v656;
                                v656 = reinterpret_cast<int *>(&v1[4194304ull]);
                                float * v658;
                                v658 = reinterpret_cast<float *>(&v1[4194320ull]);
                                float * v660;
                                v660 = reinterpret_cast<float *>(&v1[5242896ull]);
                                float * v662;
                                v662 = reinterpret_cast<float *>(&v1[6291472ull]);
                                float * v664;
                                v664 = reinterpret_cast<float *>(&v1[7340048ull]);
                                float * v666;
                                v666 = reinterpret_cast<float *>(&v1[8388624ull]);
                                float * v668;
                                v668 = reinterpret_cast<float *>(&v1[9437200ull]);
                                float * v670;
                                v670 = reinterpret_cast<float *>(&v1[10485776ull]);
                                int v672;
                                v672 = v656[0];
                                unsigned int * v673;
                                v673 = reinterpret_cast<unsigned int *>(&v0[53477376ull]);
                                int v675;
                                v675 = blockIdx.x;
                                int v676;
                                v676 = threadIdx.x;
                                assert("Tensor range check" && 0 <= v672 && v672 < 4);
                                assert("Tensor range check" && 0 <= v675 && v675 < 24);
                                assert("Tensor range check" && 0 <= v676 && v676 < 256);
                                int v677;
                                v677 = 256 * v675;
                                int v678;
                                v678 = v677 + v676;
                                int v679;
                                v679 = 6144 * v672;
                                int v680;
                                v680 = v679 + v678;
                                unsigned int v681;
                                v681 = v673[v680];
                                int v682;
                                v682 = (int)v681;
                                float v683; int v684;
                                Tuple14 tmp111 = method_46(v123, v656, v658, v660, v662, v664, v666, v668, v670, v682, v672);
                                v683 = tmp111.v0; v684 = tmp111.v1;
                                extern __shared__ unsigned char v685[];
                                float * v686;
                                v686 = reinterpret_cast<float *>(&v685[0ull]);
                                int * v688;
                                v688 = reinterpret_cast<int *>(&v685[16ull]);
                                int v690;
                                v690 = threadIdx.x;
                                bool v691;
                                v691 = v690 == 0;
                                if (v691){
                                    v686[0] = v683;
                                    v688[0] = v684;
                                } else {
                                }
                                asm("barrier.cta.sync %0;" :: "r"(0));
                                float v692;
                                v692 = v686[0];
                                int v693;
                                v693 = v688[0];
                                asm("barrier.cta.sync %0;" :: "r"(0));
                                double * v694;
                                v694 = reinterpret_cast<double *>(&v1[11534352ull]);
                                double * v696;
                                v696 = reinterpret_cast<double *>(&v1[11927568ull]);
                                int * v698;
                                v698 = reinterpret_cast<int *>(&v1[12320784ull]);
                                int * v700;
                                v700 = reinterpret_cast<int *>(&v0[53575680ull]);
                                float * v702;
                                v702 = reinterpret_cast<float *>(&v0[66158592ull]);
                                int * v704;
                                v704 = reinterpret_cast<int *>(&v0[78741504ull]);
                                int * v706;
                                v706 = reinterpret_cast<int *>(&v0[91324416ull]);
                                double * v708;
                                v708 = reinterpret_cast<double *>(&v0[103907328ull]);
                                double * v710;
                                v710 = reinterpret_cast<double *>(&v0[154238976ull]);
                                int v712;
                                v712 = threadIdx.x;
                                int v713;
                                v713 = blockIdx.x;
                                int v714;
                                v714 = v713 * 256;
                                int v715;
                                v715 = v712 + v714;
                                int v716;
                                v716 = 0;
                                while (while_method_3(v716)){
                                    unsigned int * v718;
                                    v718 = reinterpret_cast<unsigned int *>(&v0[53477376ull]);
                                    int v720;
                                    v720 = blockIdx.x;
                                    int v721;
                                    v721 = threadIdx.x;
                                    assert("Tensor range check" && 0 <= v716 && v716 < 4);
                                    assert("Tensor range check" && 0 <= v720 && v720 < 24);
                                    assert("Tensor range check" && 0 <= v721 && v721 < 256);
                                    int v722;
                                    v722 = 256 * v720;
                                    int v723;
                                    v723 = v722 + v721;
                                    int v724;
                                    v724 = 6144 * v716;
                                    int v725;
                                    v725 = v724 + v723;
                                    unsigned int v726;
                                    v726 = v718[v725];
                                    int v727;
                                    v727 = (int)v726;
                                    float v728;
                                    v728 = method_83(v656, v658, v660, v662, v664, v666, v668, v670, v727, v716, v693);
                                    assert("Tensor range check" && 0 <= v716 && v716 < 4);
                                    assert("Tensor range check" && 0 <= v715 && v715 < 6144);
                                    int v729;
                                    v729 = v724 + v715;
                                    int v730;
                                    v730 = v698[v729];
                                    int v731;
                                    v731 = v730 + 1;
                                    assert("Tensor range check" && 0 <= v716 && v716 < 4);
                                    assert("Tensor range check" && 0 <= v715 && v715 < 6144);
                                    v698[v729] = v731;
                                    assert("Tensor range check" && 0 <= v716 && v716 < 4);
                                    assert("Tensor range check" && 0 <= v730 && v730 < 128);
                                    assert("Tensor range check" && 0 <= v715 && v715 < 6144);
                                    int v732;
                                    v732 = 6144 * v730;
                                    int v733;
                                    v733 = v732 + v715;
                                    int v734;
                                    v734 = 786432 * v716;
                                    int v735;
                                    v735 = v734 + v733;
                                    v700[v735] = v693;
                                    v702[v735] = v692;
                                    v704[v735] = v116;
                                    v706[v735] = v727;
                                    assert("Tensor range check" && 0 <= v716 && v716 < 4);
                                    int v736;
                                    v736 = 12288 * v716;
                                    assert("Tensor range check" && 0 <= v715 && v715 < 6144);
                                    int v737;
                                    v737 = 2 * v715;
                                    int v738;
                                    v738 = v737 + v736;
                                    assert("Tensor range check" && 0 <= v716 && v716 < 4);
                                    int v739;
                                    v739 = 1572864 * v716;
                                    assert("Tensor range check" && 0 <= v730 && v730 < 128);
                                    int v740;
                                    v740 = 12288 * v730;
                                    int v741;
                                    v741 = v740 + v739;
                                    assert("Tensor range check" && 0 <= v715 && v715 < 6144);
                                    int v742;
                                    v742 = v737 + v741;
                                    double * v743;
                                    v743 = v694+v738;
                                    double * v745;
                                    v745 = v696+v738;
                                    double * v747;
                                    v747 = v708+v742;
                                    double * v749;
                                    v749 = v710+v742;
                                    int v751;
                                    v751 = sizeof(double *);
                                    unsigned long long v752;
                                    v752 = (unsigned long long)v751;
                                    unsigned long long v753;
                                    v753 = 256ull * v752;
                                    unsigned long long v754;
                                    v754 = v753 + 16ull;
                                    unsigned long long v755;
                                    v755 = v754 - 1ull;
                                    unsigned long long v756;
                                    v756 = v755 % 16ull;
                                    unsigned long long v757;
                                    v757 = v755 - v756;
                                    unsigned long long v758;
                                    v758 = v757 + v753;
                                    unsigned long long v759;
                                    v759 = v758 + 16ull;
                                    unsigned long long v760;
                                    v760 = v759 - 1ull;
                                    unsigned long long v761;
                                    v761 = v760 % 16ull;
                                    unsigned long long v762;
                                    v762 = v760 - v761;
                                    unsigned long long v763;
                                    v763 = v762 + v753;
                                    unsigned long long v764;
                                    v764 = v763 + 16ull;
                                    unsigned long long v765;
                                    v765 = v764 - 1ull;
                                    unsigned long long v766;
                                    v766 = v765 % 16ull;
                                    unsigned long long v767;
                                    v767 = v765 - v766;
                                    unsigned long long v768;
                                    v768 = v767 + v753;
                                    bool v769;
                                    v769 = v768 <= 98304ull;
                                    bool v770;
                                    v770 = v769 == false;
                                    if (v770){
                                        assert("The dynamic shared memory is insufficient to allocate the tensor." && v769);
                                    } else {
                                    }
                                    extern __shared__ unsigned char v772[];
                                    bool v773;
                                    v773 = v768 <= v768;
                                    bool v774;
                                    v774 = v773 == false;
                                    if (v774){
                                        assert("The length of the partition has to be less than or equal to the length of the base array." && v773);
                                    } else {
                                    }
                                    double * * v776;
                                    v776 = reinterpret_cast<double * *>(&v772[0ull]);
                                    double * * v778;
                                    v778 = reinterpret_cast<double * *>(&v772[v757]);
                                    double * * v780;
                                    v780 = reinterpret_cast<double * *>(&v772[v762]);
                                    double * * v782;
                                    v782 = reinterpret_cast<double * *>(&v772[v767]);
                                    int v784;
                                    v784 = threadIdx.x;
                                    assert("Tensor range check" && 0 <= v784 && v784 < 256);
                                    v776[v784] = v743;
                                    v778[v784] = v745;
                                    v780[v784] = v747;
                                    v782[v784] = v749;
                                    asm("barrier.cta.sync %0;" :: "r"(0));
                                    bool v785;
                                    v785 = 0 <= v784;
                                    bool v786;
                                    v786 = v785 == false;
                                    if (v786){
                                        assert("The index needs to be zero or positive." && v785);
                                    } else {
                                    }
                                    int v788;
                                    v788 = v784 % 1;
                                    bool v789;
                                    v789 = v784 < 256;
                                    bool v790;
                                    v790 = v789 == false;
                                    if (v790){
                                        assert("The last element of the projection dimensions needs to be greater than the index remainder." && v789);
                                    } else {
                                    }
                                    assert("Tensor range check" && 0 <= v784 && v784 < 256);
                                    int v792;
                                    v792 = 0;
                                    while (while_method_6(v792)){
                                        bool v794;
                                        v794 = v785 && v789;
                                        bool v795;
                                        v795 = v794 == false;
                                        if (v795){
                                            assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v794);
                                        } else {
                                        }
                                        bool v797;
                                        v797 = 0 <= v792;
                                        bool v799;
                                        if (v797){
                                            bool v798;
                                            v798 = v792 < 1;
                                            v799 = v798;
                                        } else {
                                            v799 = false;
                                        }
                                        bool v800;
                                        v800 = v799 == false;
                                        if (v800){
                                            assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v799);
                                        } else {
                                        }
                                        int v802;
                                        v802 = v792 * 256;
                                        int v803;
                                        v803 = v802 + v784;
                                        assert("Tensor range check" && 0 <= v792 && v792 < 1);
                                        int v804;
                                        v804 = 256 * v792;
                                        int v805;
                                        v805 = v804 + v784;
                                        double * v806;
                                        v806 = v776[v805];
                                        double * v807;
                                        v807 = v778[v805];
                                        double * v808;
                                        v808 = v780[v805];
                                        double * v809;
                                        v809 = v782[v805];
                                        int v810;
                                        v810 = blockIdx.x;
                                        int v811;
                                        v811 = v810 * 256;
                                        int v812;
                                        v812 = v811 + v803;
                                        assert("Tensor range check" && 0 <= v788 && v788 < 1);
                                        int v813;
                                        v813 = 2 * v788;
                                        double v814[2];
                                        double v815[2];
                                        int v816[2];
                                        int v817;
                                        v817 = 0;
                                        while (while_method_6(v817)){
                                            assert("Tensor range check" && 0 <= v817 && v817 < 1);
                                            int v819;
                                            v819 = 2 * v817;
                                            assert("Tensor range check" && 0 <= v817 && v817 < 1);
                                            int v820;
                                            v820 = v819 + v813;
                                            int4* v821;
                                            v821 = reinterpret_cast<int4*>(v806 + v820);
                                            int4* v822;
                                            v822 = reinterpret_cast<int4*>(v814 + v819);
                                            assert("Pointer alignment check" && (unsigned long long)(v821) % 2 == 0 && (unsigned long long)(v822) % 2 == 0);
                                            *v822 = *v821;
                                            int4* v823;
                                            v823 = reinterpret_cast<int4*>(v807 + v820);
                                            int4* v824;
                                            v824 = reinterpret_cast<int4*>(v815 + v819);
                                            assert("Pointer alignment check" && (unsigned long long)(v823) % 2 == 0 && (unsigned long long)(v824) % 2 == 0);
                                            *v824 = *v823;
                                            v817 += 1 ;
                                        }
                                        int v825;
                                        v825 = 0;
                                        while (while_method_6(v825)){
                                            int v827;
                                            v827 = 0;
                                            while (while_method_0(v827)){
                                                bool v829;
                                                v829 = 0 <= v827;
                                                bool v831;
                                                if (v829){
                                                    bool v830;
                                                    v830 = v827 < 2;
                                                    v831 = v830;
                                                } else {
                                                    v831 = false;
                                                }
                                                bool v832;
                                                v832 = v831 == false;
                                                if (v832){
                                                    assert("The indices should be inside the range of the dimension." && v831);
                                                } else {
                                                }
                                                bool v834;
                                                v834 = 0 <= v788;
                                                bool v836;
                                                if (v834){
                                                    bool v835;
                                                    v835 = v788 < 1;
                                                    v836 = v835;
                                                } else {
                                                    v836 = false;
                                                }
                                                bool v837;
                                                v837 = v836 == false;
                                                if (v837){
                                                    assert("The indices should be inside the range of the dimension." && v836);
                                                } else {
                                                }
                                                int v839;
                                                v839 = v788 * 2;
                                                int v840;
                                                v840 = v827 + v839;
                                                bool v841;
                                                v841 = 0 <= v825;
                                                bool v843;
                                                if (v841){
                                                    bool v842;
                                                    v842 = v825 < 1;
                                                    v843 = v842;
                                                } else {
                                                    v843 = false;
                                                }
                                                bool v844;
                                                v844 = v843 == false;
                                                if (v844){
                                                    assert("The indices should be inside the range of the dimension." && v843);
                                                } else {
                                                }
                                                int v846;
                                                v846 = v825 * 2;
                                                int v847;
                                                v847 = v840 + v846;
                                                assert("Tensor range check" && 0 <= v825 && v825 < 1);
                                                assert("Tensor range check" && 0 <= v827 && v827 < 2);
                                                int v848;
                                                v848 = 2 * v825;
                                                int v849;
                                                v849 = v848 + v827;
                                                v816[v849] = v847;
                                                v827 += 1 ;
                                            }
                                            v825 += 1 ;
                                        }
                                        int v850;
                                        v850 = 0;
                                        while (while_method_6(v850)){
                                            assert("Tensor range check" && 0 <= v850 && v850 < 1);
                                            int v852;
                                            v852 = 2 * v850;
                                            int v853;
                                            v853 = v852 + v813;
                                            assert("Tensor range check" && 0 <= v850 && v850 < 1);
                                            int4* v854;
                                            v854 = reinterpret_cast<int4*>(v814 + v852);
                                            int4* v855;
                                            v855 = reinterpret_cast<int4*>(v808 + v853);
                                            assert("Pointer alignment check" && (unsigned long long)(v854) % 2 == 0 && (unsigned long long)(v855) % 2 == 0);
                                            *v855 = *v854;
                                            int4* v856;
                                            v856 = reinterpret_cast<int4*>(v815 + v852);
                                            int4* v857;
                                            v857 = reinterpret_cast<int4*>(v809 + v853);
                                            assert("Pointer alignment check" && (unsigned long long)(v856) % 2 == 0 && (unsigned long long)(v857) % 2 == 0);
                                            *v857 = *v856;
                                            v850 += 1 ;
                                        }
                                        assert("Tensor range check" && 0 <= v803 && v803 < 256);
                                        v792 += 1 ;
                                    }
                                    asm("barrier.cta.sync %0;" :: "r"(0));
                                    assert("Tensor range check" && 0 <= v784 && v784 < 256);
                                    asm("barrier.cta.sync %0;" :: "r"(0));
                                    double v858;
                                    v858 = (double)v692;
                                    double v859;
                                    v859 = log(v858);
                                    double v860;
                                    v860 = (double)v728;
                                    double v861;
                                    v861 = log(v860);
                                    assert("Tensor range check" && 0 <= v716 && v716 < 4);
                                    assert("Tensor range check" && 0 <= v715 && v715 < 6144);
                                    assert("Tensor range check" && 0 <= v116 && v116 < 2);
                                    int v862;
                                    v862 = v737 + v116;
                                    int v863;
                                    v863 = v736 + v862;
                                    double v864;
                                    v864 = v694[v863];
                                    double v865;
                                    v865 = v696[v863];
                                    double v866;
                                    v866 = v861 + v864;
                                    double v867;
                                    v867 = v859 + v865;
                                    assert("Tensor range check" && 0 <= v716 && v716 < 4);
                                    assert("Tensor range check" && 0 <= v715 && v715 < 6144);
                                    assert("Tensor range check" && 0 <= v116 && v116 < 2);
                                    v694[v863] = v866;
                                    v696[v863] = v867;
                                    v716 += 1 ;
                                }
                                bool v868;
                                v868 = 0 == v693;
                                Union10 v901;
                                if (v868){
                                    v901 = Union10{Union10_1{}};
                                } else {
                                    bool v870;
                                    v870 = 1 == v693;
                                    if (v870){
                                        v901 = Union10{Union10_0{}};
                                    } else {
                                        bool v872;
                                        v872 = 2 == v693;
                                        if (v872){
                                            v901 = Union10{Union10_2{1, 3}};
                                        } else {
                                            bool v874;
                                            v874 = 3 == v693;
                                            if (v874){
                                                v901 = Union10{Union10_2{1, 2}};
                                            } else {
                                                bool v876;
                                                v876 = 4 == v693;
                                                if (v876){
                                                    v901 = Union10{Union10_2{2, 3}};
                                                } else {
                                                    bool v878;
                                                    v878 = 5 == v693;
                                                    if (v878){
                                                        v901 = Union10{Union10_2{3, 4}};
                                                    } else {
                                                        bool v880;
                                                        v880 = 6 == v693;
                                                        if (v880){
                                                            v901 = Union10{Union10_2{1, 1}};
                                                        } else {
                                                            bool v882;
                                                            v882 = 7 == v693;
                                                            if (v882){
                                                                v901 = Union10{Union10_2{3, 2}};
                                                            } else {
                                                                bool v884;
                                                                v884 = 8 == v693;
                                                                if (v884){
                                                                    v901 = Union10{Union10_2{2, 1}};
                                                                } else {
                                                                    bool v886;
                                                                    v886 = 9 == v693;
                                                                    if (v886){
                                                                        v901 = Union10{Union10_2{3, 1}};
                                                                    } else {
                                                                        bool v888;
                                                                        v888 = 10 == v693;
                                                                        if (v888){
                                                                            v901 = Union10{Union10_2{2147483647, 1}};
                                                                        } else {
                                                                            printf("%s\n", "Invalid output id in the NL Holdem model.");
                                                                            __trap();
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                switch (v901.tag) {
                                    case 0: { // AA_Call
                                        v1084 = Union1{Union1_1{}};
                                        break;
                                    }
                                    case 1: { // AA_Fold
                                        int v902;
                                        v902 = v112[0];
                                        int v904; int v905;
                                        Tuple4 tmp112 = Tuple4{1, v902};
                                        v904 = tmp112.v0; v905 = tmp112.v1;
                                        while (while_method_0(v904)){
                                            int v907;
                                            v907 = v112[v904];
                                            bool v909;
                                            v909 = v905 >= v907;
                                            int v910;
                                            if (v909){
                                                v910 = v905;
                                            } else {
                                                v910 = v907;
                                            }
                                            v905 = v910;
                                            v904 += 1 ;
                                        }
                                        int v911;
                                        v911 = v112[v116];
                                        bool v913;
                                        v913 = v911 == v905;
                                        if (v913){
                                            v1084 = Union1{Union1_1{}};
                                        } else {
                                            v1084 = Union1{Union1_2{}};
                                        }
                                        break;
                                    }
                                    case 2: { // AA_Raise
                                        int v918 = v901.case2.v0; int v919 = v901.case2.v1;
                                        static_array<int,2> v920;
                                        int v922;
                                        v922 = 0;
                                        while (while_method_0(v922)){
                                            int v924;
                                            v924 = v114[v922];
                                            int v926;
                                            v926 = v112[v922];
                                            int v928;
                                            v928 = v924 + v926;
                                            v920[v922] = v928;
                                            v922 += 1 ;
                                        }
                                        int v929;
                                        v929 = v112[0];
                                        int v931; int v932;
                                        Tuple4 tmp113 = Tuple4{1, v929};
                                        v931 = tmp113.v0; v932 = tmp113.v1;
                                        while (while_method_0(v931)){
                                            int v934;
                                            v934 = v112[v931];
                                            bool v936;
                                            v936 = v932 >= v934;
                                            int v937;
                                            if (v936){
                                                v937 = v932;
                                            } else {
                                                v937 = v934;
                                            }
                                            v932 = v937;
                                            v931 += 1 ;
                                        }
                                        int v938;
                                        v938 = v920[v116];
                                        bool v940;
                                        v940 = v932 < v938;
                                        int v941;
                                        if (v940){
                                            v941 = v932;
                                        } else {
                                            v941 = v938;
                                        }
                                        static_array<int,2> v942;
                                        int v944;
                                        v944 = 0;
                                        while (while_method_0(v944)){
                                            int v946;
                                            v946 = v112[v944];
                                            bool v948;
                                            v948 = v116 == v944;
                                            int v949;
                                            if (v948){
                                                v949 = v941;
                                            } else {
                                                v949 = v946;
                                            }
                                            v942[v944] = v949;
                                            v944 += 1 ;
                                        }
                                        int v950;
                                        v950 = v942[0];
                                        int v952; int v953;
                                        Tuple4 tmp114 = Tuple4{1, v950};
                                        v952 = tmp114.v0; v953 = tmp114.v1;
                                        while (while_method_0(v952)){
                                            int v955;
                                            v955 = v942[v952];
                                            int v957;
                                            v957 = v953 + v955;
                                            v953 = v957;
                                            v952 += 1 ;
                                        }
                                        static_array<int,2> v958;
                                        int v960;
                                        v960 = 0;
                                        while (while_method_0(v960)){
                                            int v962;
                                            v962 = v920[v960];
                                            int v964;
                                            v964 = v942[v960];
                                            int v966;
                                            v966 = v962 - v964;
                                            v958[v960] = v966;
                                            v960 += 1 ;
                                        }
                                        int v967;
                                        v967 = v918 * v953;
                                        int v968;
                                        v968 = v967 / v919;
                                        bool v969;
                                        v969 = v110 >= v968;
                                        int v970;
                                        if (v969){
                                            v970 = v110;
                                        } else {
                                            v970 = v968;
                                        }
                                        int v971;
                                        v971 = v958[v116];
                                        bool v973;
                                        v973 = v970 >= v971;
                                        if (v973){
                                            v1084 = Union1{Union1_0{}};
                                        } else {
                                            v1084 = Union1{Union1_3{v970}};
                                        }
                                        break;
                                    }
                                    default: {
                                        assert("Invalid tag." && false); __trap();
                                    }
                                }
                                break;
                            }
                            case 1: { // Human
                                printf("%s\n", "Humans aren't allowed during training.");
                                __trap();
                                break;
                            }
                            case 2: { // Random
                                curandStatePhilox4_32_10_t & v980 = v2.v5;
                                curandStatePhilox4_32_10_t & v981 = v980;
                                static_array<int,2> v982;
                                int v984;
                                v984 = 0;
                                while (while_method_0(v984)){
                                    int v986;
                                    v986 = v114[v984];
                                    int v988;
                                    v988 = v112[v984];
                                    int v990;
                                    v990 = v986 + v988;
                                    v982[v984] = v990;
                                    v984 += 1 ;
                                }
                                int v991;
                                v991 = v112[0];
                                int v993; int v994;
                                Tuple4 tmp115 = Tuple4{1, v991};
                                v993 = tmp115.v0; v994 = tmp115.v1;
                                while (while_method_0(v993)){
                                    int v996;
                                    v996 = v112[v993];
                                    bool v998;
                                    v998 = v994 >= v996;
                                    int v999;
                                    if (v998){
                                        v999 = v994;
                                    } else {
                                        v999 = v996;
                                    }
                                    v994 = v999;
                                    v993 += 1 ;
                                }
                                int v1000;
                                v1000 = v982[v116];
                                bool v1002;
                                v1002 = v994 < v1000;
                                int v1003;
                                if (v1002){
                                    v1003 = v994;
                                } else {
                                    v1003 = v1000;
                                }
                                static_array<int,2> v1004;
                                int v1006;
                                v1006 = 0;
                                while (while_method_0(v1006)){
                                    int v1008;
                                    v1008 = v112[v1006];
                                    bool v1010;
                                    v1010 = v116 == v1006;
                                    int v1011;
                                    if (v1010){
                                        v1011 = v1003;
                                    } else {
                                        v1011 = v1008;
                                    }
                                    v1004[v1006] = v1011;
                                    v1006 += 1 ;
                                }
                                int v1012;
                                v1012 = v1004[0];
                                int v1014; int v1015;
                                Tuple4 tmp116 = Tuple4{1, v1012};
                                v1014 = tmp116.v0; v1015 = tmp116.v1;
                                while (while_method_0(v1014)){
                                    int v1017;
                                    v1017 = v1004[v1014];
                                    int v1019;
                                    v1019 = v1015 + v1017;
                                    v1015 = v1019;
                                    v1014 += 1 ;
                                }
                                static_array<int,2> v1020;
                                int v1022;
                                v1022 = 0;
                                while (while_method_0(v1022)){
                                    int v1024;
                                    v1024 = v982[v1022];
                                    int v1026;
                                    v1026 = v1004[v1022];
                                    int v1028;
                                    v1028 = v1024 - v1026;
                                    v1020[v1022] = v1028;
                                    v1022 += 1 ;
                                }
                                int v1029;
                                v1029 = v112[v116];
                                bool v1031;
                                v1031 = v1029 < v994;
                                float v1032;
                                if (v1031){
                                    v1032 = 1.0f;
                                } else {
                                    v1032 = 0.0f;
                                }
                                int v1033;
                                v1033 = v1015 / 3;
                                bool v1034;
                                v1034 = v110 <= v1033;
                                bool v1038;
                                if (v1034){
                                    int v1035;
                                    v1035 = v1020[v116];
                                    bool v1037;
                                    v1037 = v1033 < v1035;
                                    v1038 = v1037;
                                } else {
                                    v1038 = false;
                                }
                                float v1039;
                                if (v1038){
                                    v1039 = 1.0f;
                                } else {
                                    v1039 = 0.0f;
                                }
                                int v1040;
                                v1040 = v1015 / 2;
                                bool v1041;
                                v1041 = v110 <= v1040;
                                bool v1045;
                                if (v1041){
                                    int v1042;
                                    v1042 = v1020[v116];
                                    bool v1044;
                                    v1044 = v1040 < v1042;
                                    v1045 = v1044;
                                } else {
                                    v1045 = false;
                                }
                                float v1046;
                                if (v1045){
                                    v1046 = 1.0f;
                                } else {
                                    v1046 = 0.0f;
                                }
                                bool v1047;
                                v1047 = v110 <= v1015;
                                bool v1051;
                                if (v1047){
                                    int v1048;
                                    v1048 = v1020[v116];
                                    bool v1050;
                                    v1050 = v1015 < v1048;
                                    v1051 = v1050;
                                } else {
                                    v1051 = false;
                                }
                                float v1052;
                                if (v1051){
                                    v1052 = 1.0f;
                                } else {
                                    v1052 = 0.0f;
                                }
                                static_array<Tuple18,6> v1053;
                                Union1 v1055;
                                v1055 = Union1{Union1_2{}};
                                v1053[0] = Tuple18{v1055, v1032};
                                Union1 v1057;
                                v1057 = Union1{Union1_1{}};
                                v1053[1] = Tuple18{v1057, 4.0f};
                                Union1 v1059;
                                v1059 = Union1{Union1_3{v1033}};
                                v1053[2] = Tuple18{v1059, v1039};
                                Union1 v1061;
                                v1061 = Union1{Union1_3{v1040}};
                                v1053[3] = Tuple18{v1061, v1046};
                                Union1 v1063;
                                v1063 = Union1{Union1_3{v1015}};
                                v1053[4] = Tuple18{v1063, v1052};
                                Union1 v1065;
                                v1065 = Union1{Union1_0{}};
                                v1053[5] = Tuple18{v1065, 1.0f};
                                Union1 v1067;
                                v1067 = sample_discrete_47(v1053, v981);
                                int v1068;
                                v1068 = sizeof(Union1);
                                unsigned long long v1069;
                                v1069 = (unsigned long long)v1068;
                                bool v1070;
                                v1070 = v1069 <= 98304ull;
                                bool v1071;
                                v1071 = v1070 == false;
                                if (v1071){
                                    assert("The dynamic shared memory is insufficient to allocate the tensor." && v1070);
                                } else {
                                }
                                extern __shared__ unsigned char v1073[];
                                bool v1074;
                                v1074 = v1069 <= v1069;
                                bool v1075;
                                v1075 = v1074 == false;
                                if (v1075){
                                    assert("The length of the partition has to be less than or equal to the length of the base array." && v1074);
                                } else {
                                }
                                Union1 * v1077;
                                v1077 = reinterpret_cast<Union1 *>(&v1073[0ull]);
                                int v1079;
                                v1079 = threadIdx.x;
                                bool v1080;
                                v1080 = v1079 == 0;
                                if (v1080){
                                    v1077[0] = v1067;
                                } else {
                                }
                                asm("barrier.cta.sync %0;" :: "r"(0));
                                Union1 v1081;
                                v1081 = v1077[0];
                                asm("barrier.cta.sync %0;" :: "r"(0));
                                v1084 = v1081;
                                break;
                            }
                            default: {
                                assert("Invalid tag." && false); __trap();
                            }
                        }
                        Union6 v1085;
                        v1085 = Union6{Union6_2{v116, v1084}};
                        v13.push(v1085);
                        v1211 = Union18{Union18_1{v110, v111, v112, v113, v114, v115, v1084}};
                        break;
                    }
                    case 5: { // G_Round'
                        int v1087 = v18.case5.v0; static_array<static_array<unsigned char,2>,2> v1088 = v18.case5.v1; static_array<int,2> v1089 = v18.case5.v2; int v1090 = v18.case5.v3; static_array<int,2> v1091 = v18.case5.v4; Union5 v1092 = v18.case5.v5; Union1 v1093 = v18.case5.v6;
                        int v1094;
                        v1094 = v1090 % 2;
                        Union6 v1095;
                        v1095 = Union6{Union6_2{v1094, v1093}};
                        v13.push(v1095);
                        v1211 = Union18{Union18_1{v1087, v1088, v1089, v1090, v1091, v1092, v1093}};
                        break;
                    }
                    case 6: { // G_Showdown
                        int v32 = v18.case6.v0; static_array<static_array<unsigned char,2>,2> v33 = v18.case6.v1; static_array<int,2> v34 = v18.case6.v2; int v35 = v18.case6.v3; static_array<int,2> v36 = v18.case6.v4; Union5 v37 = v18.case6.v5;
                        static_array<unsigned char,5> v40;
                        switch (v37.tag) {
                            case 2: { // River
                                static_array<unsigned char,5> v38 = v37.case2.v0;
                                v40 = v38;
                                break;
                            }
                            default: {
                                printf("%s\n", "Invalid street in showdown.");
                                __trap();
                            }
                        }
                        static_array<unsigned char,2> v41;
                        v41 = v33[0];
                        static_array<unsigned char,7> v43;
                        int v45;
                        v45 = 0;
                        while (while_method_0(v45)){
                            unsigned char v47;
                            v47 = v41[v45];
                            v43[v45] = v47;
                            v45 += 1 ;
                        }
                        int v49;
                        v49 = 0;
                        while (while_method_2(v49)){
                            unsigned char v51;
                            v51 = v40[v49];
                            int v53;
                            v53 = 2 + v49;
                            v43[v53] = v51;
                            v49 += 1 ;
                        }
                        static_array<unsigned char,5> v54; char v55;
                        Tuple0 tmp117 = score_51(v43);
                        v54 = tmp117.v0; v55 = tmp117.v1;
                        static_array<unsigned char,2> v56;
                        v56 = v33[1];
                        static_array<unsigned char,7> v58;
                        int v60;
                        v60 = 0;
                        while (while_method_0(v60)){
                            unsigned char v62;
                            v62 = v56[v60];
                            v58[v60] = v62;
                            v60 += 1 ;
                        }
                        int v64;
                        v64 = 0;
                        while (while_method_2(v64)){
                            unsigned char v66;
                            v66 = v40[v64];
                            int v68;
                            v68 = 2 + v64;
                            v58[v68] = v66;
                            v64 += 1 ;
                        }
                        static_array<unsigned char,5> v69; char v70;
                        Tuple0 tmp118 = score_51(v58);
                        v69 = tmp118.v0; v70 = tmp118.v1;
                        int v71;
                        v71 = v35 % 2;
                        int v72;
                        v72 = v34[v71];
                        bool v74;
                        v74 = v55 < v70;
                        Union11 v80;
                        if (v74){
                            v80 = Union11{Union11_2{}};
                        } else {
                            bool v76;
                            v76 = v55 > v70;
                            if (v76){
                                v80 = Union11{Union11_1{}};
                            } else {
                                v80 = Union11{Union11_0{}};
                            }
                        }
                        Union11 v99;
                        switch (v80.tag) {
                            case 0: { // Eq
                                Union11 v81;
                                v81 = Union11{Union11_0{}};
                                int v82;
                                v82 = 0;
                                while (while_method_2(v82)){
                                    unsigned char v84;
                                    v84 = v54[v82];
                                    unsigned char v86;
                                    v86 = v69[v82];
                                    unsigned char v88;
                                    v88 = v84 / 4u;
                                    unsigned char v89;
                                    v89 = v86 / 4u;
                                    bool v90;
                                    v90 = v88 < v89;
                                    Union11 v96;
                                    if (v90){
                                        v96 = Union11{Union11_2{}};
                                    } else {
                                        bool v92;
                                        v92 = v88 > v89;
                                        if (v92){
                                            v96 = Union11{Union11_1{}};
                                        } else {
                                            v96 = Union11{Union11_0{}};
                                        }
                                    }
                                    bool v97;
                                    switch (v96.tag) {
                                        case 0: { // Eq
                                            v97 = true;
                                            break;
                                        }
                                        default: {
                                            v97 = false;
                                        }
                                    }
                                    bool v98;
                                    v98 = v97 == false;
                                    if (v98){
                                        v81 = v96;
                                        break;
                                    } else {
                                    }
                                    v82 += 1 ;
                                }
                                v99 = v81;
                                break;
                            }
                            default: {
                                v99 = v80;
                            }
                        }
                        int v104; int v105;
                        switch (v99.tag) {
                            case 0: { // Eq
                                v104 = 0; v105 = -1;
                                break;
                            }
                            case 1: { // Gt
                                v104 = v72; v105 = 0;
                                break;
                            }
                            case 2: { // Lt
                                v104 = v72; v105 = 1;
                                break;
                            }
                            default: {
                                assert("Invalid tag." && false); __trap();
                            }
                        }
                        static_array<Tuple0,2> v106;
                        v106[0] = Tuple0{v54, v55};
                        v106[1] = Tuple0{v69, v70};
                        Union6 v108;
                        v108 = Union6{Union6_4{v104, v106, v105}};
                        v13.push(v108);
                        v1211 = Union18{Union18_0{}};
                        break;
                    }
                    case 7: { // G_Turn
                        int v1116 = v18.case7.v0; static_array<static_array<unsigned char,2>,2> v1117 = v18.case7.v1; static_array<int,2> v1118 = v18.case7.v2; int v1119 = v18.case7.v3; static_array<int,2> v1120 = v18.case7.v4; Union5 v1121 = v18.case7.v5;
                        curandStatePhilox4_32_10_t & v1122 = v2.v5;
                        curandStatePhilox4_32_10_t & v1123 = v1122;
                        static_array<unsigned char,1> v1124; unsigned long long v1125;
                        Tuple12 tmp119 = draw_cards_40(v1123, v14);
                        v1124 = tmp119.v0; v1125 = tmp119.v1;
                        v2.v0 = v1125;
                        static_array_list<unsigned char,5> v1126;
                        v1126 = get_community_cards_82(v1121, v1124);
                        Union6 v1127;
                        v1127 = Union6{Union6_0{v1126}};
                        v13.push(v1127);
                        Union5 v1142;
                        switch (v1121.tag) {
                            case 0: { // Flop
                                static_array<unsigned char,3> v1128 = v1121.case0.v0;
                                static_array<unsigned char,4> v1129;
                                int v1131;
                                v1131 = 0;
                                while (while_method_1(v1131)){
                                    unsigned char v1133;
                                    v1133 = v1128[v1131];
                                    v1129[v1131] = v1133;
                                    v1131 += 1 ;
                                }
                                int v1135;
                                v1135 = 0;
                                while (while_method_6(v1135)){
                                    unsigned char v1137;
                                    v1137 = v1124[v1135];
                                    int v1139;
                                    v1139 = 3 + v1135;
                                    v1129[v1139] = v1137;
                                    v1135 += 1 ;
                                }
                                v1142 = Union5{Union5_3{v1129}};
                                break;
                            }
                            default: {
                                printf("%s\n", "Invalid street in turn.");
                                __trap();
                            }
                        }
                        int v1143;
                        v1143 = 2;
                        int v1144;
                        v1144 = 0;
                        Union4 v1145;
                        v1145 = try_round_36(v1143, v1117, v1118, v1144, v1120, v1142);
                        v1211 = Union18{Union18_2{v1145}};
                        break;
                    }
                    default: {
                        assert("Invalid tag." && false); __trap();
                    }
                }
                switch (v1211.tag) {
                    case 0: { // T_none
                        v1417 = Union3{Union3_0{}};
                        break;
                    }
                    case 1: { // T_round
                        int v1215 = v1211.case1.v0; static_array<static_array<unsigned char,2>,2> v1216 = v1211.case1.v1; static_array<int,2> v1217 = v1211.case1.v2; int v1218 = v1211.case1.v3; static_array<int,2> v1219 = v1211.case1.v4; Union5 v1220 = v1211.case1.v5; Union1 v1221 = v1211.case1.v6;
                        int v1222;
                        v1222 = v1218 % 2;
                        Union4 v1410;
                        switch (v1221.tag) {
                            case 0: { // A_All_In
                                static_array<int,2> v1340;
                                int v1342;
                                v1342 = 0;
                                while (while_method_0(v1342)){
                                    int v1344;
                                    v1344 = v1219[v1342];
                                    int v1346;
                                    v1346 = v1217[v1342];
                                    int v1348;
                                    v1348 = v1344 + v1346;
                                    v1340[v1342] = v1348;
                                    v1342 += 1 ;
                                }
                                int v1349;
                                v1349 = v1217[0];
                                int v1351; int v1352;
                                Tuple4 tmp120 = Tuple4{1, v1349};
                                v1351 = tmp120.v0; v1352 = tmp120.v1;
                                while (while_method_0(v1351)){
                                    int v1354;
                                    v1354 = v1217[v1351];
                                    bool v1356;
                                    v1356 = v1352 >= v1354;
                                    int v1357;
                                    if (v1356){
                                        v1357 = v1352;
                                    } else {
                                        v1357 = v1354;
                                    }
                                    v1352 = v1357;
                                    v1351 += 1 ;
                                }
                                int v1358;
                                v1358 = v1340[v1222];
                                bool v1360;
                                v1360 = v1352 < v1358;
                                int v1361;
                                if (v1360){
                                    v1361 = v1352;
                                } else {
                                    v1361 = v1358;
                                }
                                static_array<int,2> v1362;
                                int v1364;
                                v1364 = 0;
                                while (while_method_0(v1364)){
                                    int v1366;
                                    v1366 = v1217[v1364];
                                    bool v1368;
                                    v1368 = v1222 == v1364;
                                    int v1369;
                                    if (v1368){
                                        v1369 = v1361;
                                    } else {
                                        v1369 = v1366;
                                    }
                                    v1362[v1364] = v1369;
                                    v1364 += 1 ;
                                }
                                static_array<int,2> v1370;
                                int v1372;
                                v1372 = 0;
                                while (while_method_0(v1372)){
                                    int v1374;
                                    v1374 = v1340[v1372];
                                    int v1376;
                                    v1376 = v1362[v1372];
                                    int v1378;
                                    v1378 = v1374 - v1376;
                                    v1370[v1372] = v1378;
                                    v1372 += 1 ;
                                }
                                int v1379;
                                v1379 = v1370[v1222];
                                int v1381;
                                v1381 = v1352 + v1379;
                                int v1382;
                                v1382 = v1340[v1222];
                                bool v1384;
                                v1384 = v1381 < v1382;
                                int v1385;
                                if (v1384){
                                    v1385 = v1381;
                                } else {
                                    v1385 = v1382;
                                }
                                static_array<int,2> v1386;
                                int v1388;
                                v1388 = 0;
                                while (while_method_0(v1388)){
                                    int v1390;
                                    v1390 = v1217[v1388];
                                    bool v1392;
                                    v1392 = v1222 == v1388;
                                    int v1393;
                                    if (v1392){
                                        v1393 = v1385;
                                    } else {
                                        v1393 = v1390;
                                    }
                                    v1386[v1388] = v1393;
                                    v1388 += 1 ;
                                }
                                static_array<int,2> v1394;
                                int v1396;
                                v1396 = 0;
                                while (while_method_0(v1396)){
                                    int v1398;
                                    v1398 = v1340[v1396];
                                    int v1400;
                                    v1400 = v1386[v1396];
                                    int v1402;
                                    v1402 = v1398 - v1400;
                                    v1394[v1396] = v1402;
                                    v1396 += 1 ;
                                }
                                bool v1403;
                                v1403 = v1379 >= v1215;
                                int v1404;
                                if (v1403){
                                    v1404 = v1379;
                                } else {
                                    v1404 = v1215;
                                }
                                int v1405;
                                v1405 = v1218 + 1;
                                v1410 = try_round_36(v1404, v1216, v1386, v1405, v1394, v1220);
                                break;
                            }
                            case 1: { // A_Call
                                static_array<int,2> v1224;
                                int v1226;
                                v1226 = 0;
                                while (while_method_0(v1226)){
                                    int v1228;
                                    v1228 = v1219[v1226];
                                    int v1230;
                                    v1230 = v1217[v1226];
                                    int v1232;
                                    v1232 = v1228 + v1230;
                                    v1224[v1226] = v1232;
                                    v1226 += 1 ;
                                }
                                int v1233;
                                v1233 = v1217[0];
                                int v1235; int v1236;
                                Tuple4 tmp121 = Tuple4{1, v1233};
                                v1235 = tmp121.v0; v1236 = tmp121.v1;
                                while (while_method_0(v1235)){
                                    int v1238;
                                    v1238 = v1217[v1235];
                                    bool v1240;
                                    v1240 = v1236 >= v1238;
                                    int v1241;
                                    if (v1240){
                                        v1241 = v1236;
                                    } else {
                                        v1241 = v1238;
                                    }
                                    v1236 = v1241;
                                    v1235 += 1 ;
                                }
                                int v1242;
                                v1242 = v1224[v1222];
                                bool v1244;
                                v1244 = v1236 < v1242;
                                int v1245;
                                if (v1244){
                                    v1245 = v1236;
                                } else {
                                    v1245 = v1242;
                                }
                                static_array<int,2> v1246;
                                int v1248;
                                v1248 = 0;
                                while (while_method_0(v1248)){
                                    int v1250;
                                    v1250 = v1217[v1248];
                                    bool v1252;
                                    v1252 = v1222 == v1248;
                                    int v1253;
                                    if (v1252){
                                        v1253 = v1245;
                                    } else {
                                        v1253 = v1250;
                                    }
                                    v1246[v1248] = v1253;
                                    v1248 += 1 ;
                                }
                                static_array<int,2> v1254;
                                int v1256;
                                v1256 = 0;
                                while (while_method_0(v1256)){
                                    int v1258;
                                    v1258 = v1224[v1256];
                                    int v1260;
                                    v1260 = v1246[v1256];
                                    int v1262;
                                    v1262 = v1258 - v1260;
                                    v1254[v1256] = v1262;
                                    v1256 += 1 ;
                                }
                                bool v1263;
                                v1263 = v1222 < 2;
                                if (v1263){
                                    int v1264;
                                    v1264 = v1218 + 1;
                                    v1410 = try_round_36(v1215, v1216, v1246, v1264, v1254, v1220);
                                } else {
                                    v1410 = go_next_street_38(v1215, v1216, v1246, v1218, v1254, v1220);
                                }
                                break;
                            }
                            case 2: { // A_Fold
                                v1410 = Union4{Union4_1{v1215, v1216, v1217, v1218, v1219, v1220}};
                                break;
                            }
                            case 3: { // A_Raise
                                int v1268 = v1221.case3.v0;
                                bool v1269;
                                v1269 = v1215 <= v1268;
                                bool v1270;
                                v1270 = v1269 == false;
                                if (v1270){
                                    assert("The raise amount must match the minimum." && v1269);
                                } else {
                                }
                                static_array<int,2> v1272;
                                int v1274;
                                v1274 = 0;
                                while (while_method_0(v1274)){
                                    int v1276;
                                    v1276 = v1219[v1274];
                                    int v1278;
                                    v1278 = v1217[v1274];
                                    int v1280;
                                    v1280 = v1276 + v1278;
                                    v1272[v1274] = v1280;
                                    v1274 += 1 ;
                                }
                                int v1281;
                                v1281 = v1217[0];
                                int v1283; int v1284;
                                Tuple4 tmp122 = Tuple4{1, v1281};
                                v1283 = tmp122.v0; v1284 = tmp122.v1;
                                while (while_method_0(v1283)){
                                    int v1286;
                                    v1286 = v1217[v1283];
                                    bool v1288;
                                    v1288 = v1284 >= v1286;
                                    int v1289;
                                    if (v1288){
                                        v1289 = v1284;
                                    } else {
                                        v1289 = v1286;
                                    }
                                    v1284 = v1289;
                                    v1283 += 1 ;
                                }
                                int v1290;
                                v1290 = v1272[v1222];
                                bool v1292;
                                v1292 = v1284 < v1290;
                                int v1293;
                                if (v1292){
                                    v1293 = v1284;
                                } else {
                                    v1293 = v1290;
                                }
                                static_array<int,2> v1294;
                                int v1296;
                                v1296 = 0;
                                while (while_method_0(v1296)){
                                    int v1298;
                                    v1298 = v1217[v1296];
                                    bool v1300;
                                    v1300 = v1222 == v1296;
                                    int v1301;
                                    if (v1300){
                                        v1301 = v1293;
                                    } else {
                                        v1301 = v1298;
                                    }
                                    v1294[v1296] = v1301;
                                    v1296 += 1 ;
                                }
                                static_array<int,2> v1302;
                                int v1304;
                                v1304 = 0;
                                while (while_method_0(v1304)){
                                    int v1306;
                                    v1306 = v1272[v1304];
                                    int v1308;
                                    v1308 = v1294[v1304];
                                    int v1310;
                                    v1310 = v1306 - v1308;
                                    v1302[v1304] = v1310;
                                    v1304 += 1 ;
                                }
                                int v1311;
                                v1311 = v1302[v1222];
                                bool v1313;
                                v1313 = v1268 < v1311;
                                bool v1314;
                                v1314 = v1313 == false;
                                if (v1314){
                                    assert("The raise amount must be less than the stack size after calling." && v1313);
                                } else {
                                }
                                int v1316;
                                v1316 = v1284 + v1268;
                                int v1317;
                                v1317 = v1272[v1222];
                                bool v1319;
                                v1319 = v1316 < v1317;
                                int v1320;
                                if (v1319){
                                    v1320 = v1316;
                                } else {
                                    v1320 = v1317;
                                }
                                static_array<int,2> v1321;
                                int v1323;
                                v1323 = 0;
                                while (while_method_0(v1323)){
                                    int v1325;
                                    v1325 = v1217[v1323];
                                    bool v1327;
                                    v1327 = v1222 == v1323;
                                    int v1328;
                                    if (v1327){
                                        v1328 = v1320;
                                    } else {
                                        v1328 = v1325;
                                    }
                                    v1321[v1323] = v1328;
                                    v1323 += 1 ;
                                }
                                static_array<int,2> v1329;
                                int v1331;
                                v1331 = 0;
                                while (while_method_0(v1331)){
                                    int v1333;
                                    v1333 = v1272[v1331];
                                    int v1335;
                                    v1335 = v1321[v1331];
                                    int v1337;
                                    v1337 = v1333 - v1335;
                                    v1329[v1331] = v1337;
                                    v1331 += 1 ;
                                }
                                int v1338;
                                v1338 = v1218 + 1;
                                v1410 = try_round_36(v1268, v1216, v1321, v1338, v1329, v1220);
                                break;
                            }
                            default: {
                                assert("Invalid tag." && false); __trap();
                            }
                        }
                        v1417 = Union3{Union3_1{v1410}};
                        break;
                    }
                    case 2: { // T_some
                        Union4 v1213 = v1211.case2.v0;
                        v1417 = Union3{Union3_1{v1213}};
                        break;
                    }
                    default: {
                        assert("Invalid tag." && false); __trap();
                    }
                }
                break;
            }
            default: {
                assert("Invalid tag." && false); __trap();
            }
        }
        v16 = v1417;
    }
    return ;
}
__device__ float method_86(int * v0, float * v1, float * v2, float * v3, float * v4, float * v5, float * v6, float * v7, int v8, int v9, int v10){
    assert("Tensor range check" && 0 <= v9 && v9 < 4);
    int v11;
    v11 = 65536 * v9;
    assert("Tensor range check" && 0 <= v8 && v8 < 4096);
    int v12;
    v12 = 16 * v8;
    int v13;
    v13 = v12 + v11;
    float * v14;
    v14 = v1+v13;
    int v16;
    v16 = sizeof(float *);
    unsigned long long v17;
    v17 = (unsigned long long)v16;
    unsigned long long v18;
    v18 = 256ull * v17;
    unsigned long long v19;
    v19 = 1024ull + v18;
    unsigned long long v20;
    v20 = v19 + 16ull;
    unsigned long long v21;
    v21 = v20 - 1ull;
    unsigned long long v22;
    v22 = v21 % 16ull;
    unsigned long long v23;
    v23 = v21 - v22;
    unsigned long long v24;
    v24 = v23 + 1024ull;
    bool v25;
    v25 = v24 <= 98304ull;
    bool v26;
    v26 = v25 == false;
    if (v26){
        assert("The dynamic shared memory is insufficient to allocate the tensor." && v25);
    } else {
    }
    extern __shared__ unsigned char v28[];
    bool v29;
    v29 = v24 <= v24;
    bool v30;
    v30 = v29 == false;
    if (v30){
        assert("The length of the partition has to be less than or equal to the length of the base array." && v29);
    } else {
    }
    int * v32;
    v32 = reinterpret_cast<int *>(&v28[0ull]);
    float * * v34;
    v34 = reinterpret_cast<float * *>(&v28[1024ull]);
    float * v36;
    v36 = reinterpret_cast<float *>(&v28[v23]);
    int v38;
    v38 = threadIdx.x;
    assert("Tensor range check" && 0 <= v38 && v38 < 256);
    v32[v38] = v10;
    v34[v38] = v14;
    asm("barrier.cta.sync %0;" :: "r"(0));
    bool v39;
    v39 = 0 <= v38;
    bool v40;
    v40 = v39 == false;
    if (v40){
        assert("The index needs to be zero or positive." && v39);
    } else {
    }
    int v42;
    v42 = v38 % 4;
    int v43;
    v43 = v38 / 4;
    bool v44;
    v44 = v43 < 64;
    bool v45;
    v45 = v44 == false;
    if (v45){
        assert("The last element of the projection dimensions needs to be greater than the index remainder." && v44);
    } else {
    }
    assert("Tensor range check" && 0 <= v43 && v43 < 64);
    int v47;
    v47 = 0;
    while (while_method_3(v47)){
        bool v49;
        v49 = 0 <= v43;
        bool v50;
        v50 = v49 && v44;
        bool v51;
        v51 = v50 == false;
        if (v51){
            assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v50);
        } else {
        }
        bool v53;
        v53 = 0 <= v47;
        bool v55;
        if (v53){
            bool v54;
            v54 = v47 < 4;
            v55 = v54;
        } else {
            v55 = false;
        }
        bool v56;
        v56 = v55 == false;
        if (v56){
            assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v55);
        } else {
        }
        int v58;
        v58 = v47 * 64;
        int v59;
        v59 = v58 + v43;
        assert("Tensor range check" && 0 <= v47 && v47 < 4);
        int v60;
        v60 = 64 * v47;
        int v61;
        v61 = v60 + v43;
        int v62;
        v62 = v32[v61];
        float * v63;
        v63 = v34[v61];
        int v64;
        v64 = blockIdx.x;
        int v65;
        v65 = v64 * 256;
        int v66;
        v66 = v65 + v59;
        assert("Tensor range check" && 0 <= v42 && v42 < 4);
        int v67;
        v67 = 4 * v42;
        float v68[4];
        int v69[4];
        int v70;
        v70 = 0;
        while (while_method_6(v70)){
            assert("Tensor range check" && 0 <= v70 && v70 < 1);
            int v72;
            v72 = 4 * v70;
            assert("Tensor range check" && 0 <= v70 && v70 < 1);
            int v73;
            v73 = 16 * v70;
            int v74;
            v74 = v73 + v67;
            int4* v75;
            v75 = reinterpret_cast<int4*>(v63 + v74);
            int4* v76;
            v76 = reinterpret_cast<int4*>(v68 + v72);
            assert("Pointer alignment check" && (unsigned long long)(v75) % 4 == 0 && (unsigned long long)(v76) % 4 == 0);
            *v76 = *v75;
            v70 += 1 ;
        }
        int v77;
        v77 = 0;
        while (while_method_6(v77)){
            int v79;
            v79 = 0;
            while (while_method_3(v79)){
                bool v81;
                v81 = 0 <= v79;
                bool v83;
                if (v81){
                    bool v82;
                    v82 = v79 < 4;
                    v83 = v82;
                } else {
                    v83 = false;
                }
                bool v84;
                v84 = v83 == false;
                if (v84){
                    assert("The indices should be inside the range of the dimension." && v83);
                } else {
                }
                bool v86;
                v86 = 0 <= v42;
                bool v88;
                if (v86){
                    bool v87;
                    v87 = v42 < 4;
                    v88 = v87;
                } else {
                    v88 = false;
                }
                bool v89;
                v89 = v88 == false;
                if (v89){
                    assert("The indices should be inside the range of the dimension." && v88);
                } else {
                }
                int v91;
                v91 = v42 * 4;
                int v92;
                v92 = v79 + v91;
                bool v93;
                v93 = 0 <= v77;
                bool v95;
                if (v93){
                    bool v94;
                    v94 = v77 < 1;
                    v95 = v94;
                } else {
                    v95 = false;
                }
                bool v96;
                v96 = v95 == false;
                if (v96){
                    assert("The indices should be inside the range of the dimension." && v95);
                } else {
                }
                int v98;
                v98 = v77 * 16;
                int v99;
                v99 = v92 + v98;
                assert("Tensor range check" && 0 <= v77 && v77 < 1);
                assert("Tensor range check" && 0 <= v79 && v79 < 4);
                int v100;
                v100 = 4 * v77;
                int v101;
                v101 = v100 + v79;
                v69[v101] = v99;
                v79 += 1 ;
            }
            v77 += 1 ;
        }
        bool v102[4];
        int v103;
        v103 = 0;
        while (while_method_6(v103)){
            int v105;
            v105 = 0;
            while (while_method_3(v105)){
                assert("Tensor range check" && 0 <= v103 && v103 < 1);
                assert("Tensor range check" && 0 <= v105 && v105 < 4);
                int v107;
                v107 = 4 * v103;
                int v108;
                v108 = v107 + v105;
                float v109;
                v109 = v68[v108];
                int v110;
                v110 = v69[v108];
                bool v111;
                v111 = v110 < 11;
                assert("Tensor range check" && 0 <= v103 && v103 < 1);
                assert("Tensor range check" && 0 <= v105 && v105 < 4);
                v102[v108] = v111;
                v105 += 1 ;
            }
            v103 += 1 ;
        }
        float v112[4];
        int v113;
        v113 = 0;
        while (while_method_6(v113)){
            int v115;
            v115 = 0;
            while (while_method_3(v115)){
                assert("Tensor range check" && 0 <= v113 && v113 < 1);
                assert("Tensor range check" && 0 <= v115 && v115 < 4);
                int v117;
                v117 = 4 * v113;
                int v118;
                v118 = v117 + v115;
                float v119;
                v119 = v68[v118];
                bool v120;
                v120 = v102[v118];
                float v123;
                if (v120){
                    bool v121;
                    v121 = 0.0f >= v119;
                    if (v121){
                        v123 = 0.0f;
                    } else {
                        v123 = v119;
                    }
                } else {
                    v123 = 0.0f;
                }
                assert("Tensor range check" && 0 <= v113 && v113 < 1);
                assert("Tensor range check" && 0 <= v115 && v115 < 4);
                v112[v118] = v123;
                v115 += 1 ;
            }
            v113 += 1 ;
        }
        float v124;
        v124 = 0.0f;
        int v125;
        v125 = 0;
        while (while_method_6(v125)){
            int v127;
            v127 = 0;
            while (while_method_3(v127)){
                assert("Tensor range check" && 0 <= v125 && v125 < 1);
                assert("Tensor range check" && 0 <= v127 && v127 < 4);
                int v129;
                v129 = 4 * v125;
                int v130;
                v130 = v129 + v127;
                float v131;
                v131 = v112[v130];
                float v132;
                v132 = v124 + v131;
                v124 = v132;
                v127 += 1 ;
            }
            v125 += 1 ;
        }
        auto v133 = cooperative_groups::coalesced_threads();
        int v134;
        v134 = threadIdx.x;
        int v135;
        v135 = v134 / 4;
        auto v136 = cooperative_groups::labeled_partition(v133,v135);
        Closure1 v137{};
        float v138;
        v138 = cooperative_groups::reduce(v136, v124, v137);
        int v139[4];
        int v140;
        v140 = 0;
        while (while_method_6(v140)){
            int v142;
            v142 = 0;
            while (while_method_3(v142)){
                assert("Tensor range check" && 0 <= v140 && v140 < 1);
                assert("Tensor range check" && 0 <= v142 && v142 < 4);
                int v144;
                v144 = 4 * v140;
                int v145;
                v145 = v144 + v142;
                bool v146;
                v146 = v102[v145];
                int v147;
                if (v146){
                    v147 = 1;
                } else {
                    v147 = 0;
                }
                assert("Tensor range check" && 0 <= v140 && v140 < 1);
                assert("Tensor range check" && 0 <= v142 && v142 < 4);
                v139[v145] = v147;
                v142 += 1 ;
            }
            v140 += 1 ;
        }
        int v148;
        v148 = 0;
        int v149;
        v149 = 0;
        while (while_method_6(v149)){
            int v151;
            v151 = 0;
            while (while_method_3(v151)){
                assert("Tensor range check" && 0 <= v149 && v149 < 1);
                assert("Tensor range check" && 0 <= v151 && v151 < 4);
                int v153;
                v153 = 4 * v149;
                int v154;
                v154 = v153 + v151;
                int v155;
                v155 = v139[v154];
                int v156;
                v156 = v148 + v155;
                v148 = v156;
                v151 += 1 ;
            }
            v149 += 1 ;
        }
        auto v157 = cooperative_groups::coalesced_threads();
        int v158;
        v158 = threadIdx.x;
        int v159;
        v159 = v158 / 4;
        auto v160 = cooperative_groups::labeled_partition(v157,v159);
        Closure2 v161{};
        int v162;
        v162 = cooperative_groups::reduce(v160, v148, v161);
        float v163;
        v163 = (float)v162;
        float v164;
        v164 = 1.0f / v163;
        float v165[4];
        int v166;
        v166 = 0;
        while (while_method_6(v166)){
            int v168;
            v168 = 0;
            while (while_method_3(v168)){
                assert("Tensor range check" && 0 <= v166 && v166 < 1);
                assert("Tensor range check" && 0 <= v168 && v168 < 4);
                int v170;
                v170 = 4 * v166;
                int v171;
                v171 = v170 + v168;
                float v172;
                v172 = v112[v171];
                bool v173;
                v173 = v102[v171];
                bool v174;
                v174 = v173 == false;
                float v179;
                if (v174){
                    v179 = 0.0f;
                } else {
                    bool v175;
                    v175 = v138 == 0.0f;
                    bool v176;
                    v176 = v175 != true;
                    if (v176){
                        float v177;
                        v177 = v172 / v138;
                        v179 = v177;
                    } else {
                        v179 = v164;
                    }
                }
                assert("Tensor range check" && 0 <= v166 && v166 < 1);
                assert("Tensor range check" && 0 <= v168 && v168 < 4);
                v165[v171] = v179;
                v168 += 1 ;
            }
            v166 += 1 ;
        }
        float v180; int v181;
        Tuple14 tmp128 = Tuple14{0.0f, 2147483647};
        v180 = tmp128.v0; v181 = tmp128.v1;
        int v182;
        v182 = 0;
        while (while_method_6(v182)){
            int v184;
            v184 = 0;
            while (while_method_3(v184)){
                assert("Tensor range check" && 0 <= v182 && v182 < 1);
                assert("Tensor range check" && 0 <= v184 && v184 < 4);
                int v186;
                v186 = 4 * v182;
                int v187;
                v187 = v186 + v184;
                float v188;
                v188 = v165[v187];
                int v189;
                v189 = v69[v187];
                bool v190;
                v190 = v181 == v62;
                float v194; int v195;
                if (v190){
                    v194 = v180; v195 = v181;
                } else {
                    bool v191;
                    v191 = v189 == v62;
                    if (v191){
                        v194 = v188; v195 = v189;
                    } else {
                        v194 = v180; v195 = v181;
                    }
                }
                v180 = v194;
                v181 = v195;
                v184 += 1 ;
            }
            v182 += 1 ;
        }
        auto v196 = cooperative_groups::coalesced_threads();
        int v197;
        v197 = threadIdx.x;
        int v198;
        v198 = v197 / 4;
        auto v199 = cooperative_groups::labeled_partition(v196,v198);
        Closure7 v200{v62};
        float v201; int v202;
        Tuple14 tmp129 = cooperative_groups::reduce(v199, Tuple14{v180, v181}, v200);
        v201 = tmp129.v0; v202 = tmp129.v1;
        bool v203;
        v203 = v202 == 2147483647;
        bool v204;
        v204 = v203 != true;
        bool v205;
        v205 = v204 == false;
        if (v205){
            assert("Expected a valid action id in get_action." && v204);
        } else {
        }
        int v207;
        v207 = 0;
        while (while_method_6(v207)){
            assert("Tensor range check" && 0 <= v207 && v207 < 1);
            assert("Tensor range check" && 0 <= v207 && v207 < 1);
            v207 += 1 ;
        }
        assert("Tensor range check" && 0 <= v59 && v59 < 256);
        v36[v59] = v201;
        v47 += 1 ;
    }
    asm("barrier.cta.sync %0;" :: "r"(0));
    assert("Tensor range check" && 0 <= v38 && v38 < 256);
    float v209;
    v209 = v36[v38];
    asm("barrier.cta.sync %0;" :: "r"(0));
    return v209;
}
__device__ void method_85(unsigned char * v0, unsigned char * v1, StackMut1 & v2, Union4 v3){
    v2.v0 = 4503599627370495ull;
    static_array<float,2> v4;
    v4[0] = 0.0f;
    v4[1] = 0.0f;
    v2.v4 = v4;
    static_array_list<Union6,128> & v6 = v2.v2;
    v6.unsafe_set_length(0);
    static_array<Union2,2> v7;
    Union2 v9;
    v9 = Union2{Union2_0{}};
    v7[0] = v9;
    Union2 v11;
    v11 = Union2{Union2_0{}};
    v7[1] = v11;
    v2.v3 = v7;
    static_array_list<Union6,128> & v13 = v2.v2;
    unsigned long long & v14 = v2.v0;
    Union3 v15;
    v15 = Union3{Union3_1{v3}};
    Union3 v16;
    v16 = v15;
    while (while_method_21(v16)){
        Union3 v1298;
        switch (v16.tag) {
            case 0: { // None
                v1298 = Union3{Union3_0{}};
                break;
            }
            case 1: { // Some
                Union4 v18 = v16.case1.v0;
                Union18 v1092;
                switch (v18.tag) {
                    case 0: { // G_Flop
                        int v978 = v18.case0.v0; static_array<static_array<unsigned char,2>,2> v979 = v18.case0.v1; static_array<int,2> v980 = v18.case0.v2; int v981 = v18.case0.v3; static_array<int,2> v982 = v18.case0.v4; Union5 v983 = v18.case0.v5;
                        curandStatePhilox4_32_10_t & v984 = v2.v5;
                        curandStatePhilox4_32_10_t & v985 = v984;
                        static_array<unsigned char,3> v986; unsigned long long v987;
                        Tuple8 tmp123 = draw_cards_32(v985, v14);
                        v986 = tmp123.v0; v987 = tmp123.v1;
                        v2.v0 = v987;
                        static_array_list<unsigned char,5> v988;
                        v988 = get_community_cards_81(v983, v986);
                        Union6 v989;
                        v989 = Union6{Union6_0{v988}};
                        v13.push(v989);
                        Union5 v992;
                        switch (v983.tag) {
                            case 1: { // Preflop
                                v992 = Union5{Union5_0{v986}};
                                break;
                            }
                            default: {
                                printf("%s\n", "Invalid street in flop.");
                                __trap();
                            }
                        }
                        int v993;
                        v993 = 2;
                        int v994;
                        v994 = 0;
                        Union4 v995;
                        v995 = try_round_36(v993, v979, v980, v994, v982, v992);
                        v1092 = Union18{Union18_2{v995}};
                        break;
                    }
                    case 1: { // G_Fold
                        int v19 = v18.case1.v0; static_array<static_array<unsigned char,2>,2> v20 = v18.case1.v1; static_array<int,2> v21 = v18.case1.v2; int v22 = v18.case1.v3; static_array<int,2> v23 = v18.case1.v4; Union5 v24 = v18.case1.v5;
                        int v25;
                        v25 = v22 % 2;
                        int v26;
                        v26 = v21[v25];
                        int v28;
                        v28 = v22 + 1;
                        int v29;
                        v29 = v28 % 2;
                        Union6 v30;
                        v30 = Union6{Union6_1{v26, v29}};
                        v13.push(v30);
                        v1092 = Union18{Union18_0{}};
                        break;
                    }
                    case 2: { // G_Preflop
                        curandStatePhilox4_32_10_t & v1059 = v2.v5;
                        curandStatePhilox4_32_10_t & v1060 = v1059;
                        static_array<unsigned char,2> v1061; unsigned long long v1062;
                        Tuple11 tmp124 = draw_cards_39(v1060, v14);
                        v1061 = tmp124.v0; v1062 = tmp124.v1;
                        v2.v0 = v1062;
                        curandStatePhilox4_32_10_t & v1063 = v2.v5;
                        curandStatePhilox4_32_10_t & v1064 = v1063;
                        static_array<unsigned char,2> v1065; unsigned long long v1066;
                        Tuple11 tmp125 = draw_cards_39(v1064, v14);
                        v1065 = tmp125.v0; v1066 = tmp125.v1;
                        v2.v0 = v1066;
                        Union6 v1067;
                        v1067 = Union6{Union6_3{0, v1061}};
                        v13.push(v1067);
                        Union6 v1068;
                        v1068 = Union6{Union6_3{1, v1065}};
                        v13.push(v1068);
                        static_array<static_array<unsigned char,2>,2> v1069;
                        v1069[0] = v1061;
                        v1069[1] = v1065;
                        static_array<int,2> v1071;
                        v1071[0] = 2;
                        v1071[1] = 1;
                        static_array<int,2> v1073;
                        int v1075;
                        v1075 = 0;
                        while (while_method_0(v1075)){
                            int v1077;
                            v1077 = v1071[v1075];
                            int v1079;
                            v1079 = 100 - v1077;
                            v1073[v1075] = v1079;
                            v1075 += 1 ;
                        }
                        int v1080;
                        v1080 = 2;
                        int v1081;
                        v1081 = 0;
                        Union5 v1082;
                        v1082 = Union5{Union5_1{}};
                        Union4 v1083;
                        v1083 = try_round_36(v1080, v1069, v1071, v1081, v1073, v1082);
                        v1092 = Union18{Union18_2{v1083}};
                        break;
                    }
                    case 3: { // G_River
                        int v1028 = v18.case3.v0; static_array<static_array<unsigned char,2>,2> v1029 = v18.case3.v1; static_array<int,2> v1030 = v18.case3.v2; int v1031 = v18.case3.v3; static_array<int,2> v1032 = v18.case3.v4; Union5 v1033 = v18.case3.v5;
                        curandStatePhilox4_32_10_t & v1034 = v2.v5;
                        curandStatePhilox4_32_10_t & v1035 = v1034;
                        static_array<unsigned char,1> v1036; unsigned long long v1037;
                        Tuple12 tmp126 = draw_cards_40(v1035, v14);
                        v1036 = tmp126.v0; v1037 = tmp126.v1;
                        v2.v0 = v1037;
                        static_array_list<unsigned char,5> v1038;
                        v1038 = get_community_cards_82(v1033, v1036);
                        Union6 v1039;
                        v1039 = Union6{Union6_0{v1038}};
                        v13.push(v1039);
                        Union5 v1054;
                        switch (v1033.tag) {
                            case 3: { // Turn
                                static_array<unsigned char,4> v1040 = v1033.case3.v0;
                                static_array<unsigned char,5> v1041;
                                int v1043;
                                v1043 = 0;
                                while (while_method_3(v1043)){
                                    unsigned char v1045;
                                    v1045 = v1040[v1043];
                                    v1041[v1043] = v1045;
                                    v1043 += 1 ;
                                }
                                int v1047;
                                v1047 = 0;
                                while (while_method_6(v1047)){
                                    unsigned char v1049;
                                    v1049 = v1036[v1047];
                                    int v1051;
                                    v1051 = 4 + v1047;
                                    v1041[v1051] = v1049;
                                    v1047 += 1 ;
                                }
                                v1054 = Union5{Union5_2{v1041}};
                                break;
                            }
                            default: {
                                printf("%s\n", "Invalid street in river.");
                                __trap();
                            }
                        }
                        int v1055;
                        v1055 = 2;
                        int v1056;
                        v1056 = 0;
                        Union4 v1057;
                        v1057 = try_round_36(v1055, v1029, v1030, v1056, v1032, v1054);
                        v1092 = Union18{Union18_2{v1057}};
                        break;
                    }
                    case 4: { // G_Round
                        int v110 = v18.case4.v0; static_array<static_array<unsigned char,2>,2> v111 = v18.case4.v1; static_array<int,2> v112 = v18.case4.v2; int v113 = v18.case4.v3; static_array<int,2> v114 = v18.case4.v4; Union5 v115 = v18.case4.v5;
                        int v116;
                        v116 = v113 % 2;
                        static_array<Union2,2> & v117 = v2.v3;
                        Union2 v118;
                        v118 = v117[v116];
                        Union1 v965;
                        switch (v118.tag) {
                            case 0: { // Computer
                                static_array_list<Union6,128> & v121 = v2.v2;
                                curandStatePhilox4_32_10_t & v122 = v2.v5;
                                curandStatePhilox4_32_10_t & v123 = v122;
                                unsigned int * v124;
                                v124 = reinterpret_cast<unsigned int *>(&v0[53477376ull]);
                                float * v126;
                                v126 = reinterpret_cast<float *>(&v0[0ull]);
                                int v128;
                                v128 = threadIdx.x;
                                int v129;
                                v129 = blockIdx.x;
                                int v130;
                                v130 = v129 * 256;
                                int v131;
                                v131 = v128 + v130;
                                unsigned long long v132;
                                v132 = (unsigned long long)v131;
                                curandStatePhilox4_32_10_t v133;
                                curand_init(12344321ull,v132,0ull,&v133);
                                float * v134;
                                v134 = reinterpret_cast<float *>(&v0[0ull]);
                                int v136;
                                v136 = blockIdx.x;
                                assert("Tensor range check" && 0 <= v136 && v136 < 24);
                                int v137;
                                v137 = 524288 * v136;
                                int v138;
                                v138 = threadIdx.x;
                                int v139;
                                v139 = blockIdx.x;
                                int v140;
                                v140 = v139 * 256;
                                int v141;
                                v141 = v138 + v140;
                                unsigned long long v142;
                                v142 = (unsigned long long)v141;
                                curandStatePhilox4_32_10_t v143;
                                curand_init(12344321ull,v142,0ull,&v143);
                                int v144;
                                v144 = threadIdx.x;
                                int v145;
                                v145 = v144;
                                while (while_method_7(v145)){
                                    bool v147;
                                    v147 = 0 <= v145;
                                    bool v148;
                                    v148 = v147 == false;
                                    if (v148){
                                        assert("The index needs to be zero or positive." && v147);
                                    } else {
                                    }
                                    int v150;
                                    v150 = v145 % 2048;
                                    int v151;
                                    v151 = v145 / 2048;
                                    bool v152;
                                    v152 = v151 < 256;
                                    bool v153;
                                    v153 = v152 == false;
                                    if (v153){
                                        assert("The last element of the projection dimensions needs to be greater than the index remainder." && v152);
                                    } else {
                                    }
                                    assert("Tensor range check" && 0 <= v151 && v151 < 256);
                                    assert("Tensor range check" && 0 <= v150 && v150 < 2048);
                                    int v155;
                                    v155 = v150 + v137;
                                    int v156;
                                    v156 = 2048 * v151;
                                    int v157;
                                    v157 = v156 + v155;
                                    v134[v157] = 0.0f;
                                    v145 += 256 ;
                                }
                                asm("barrier.cta.sync %0;" :: "r"(0));
                                int v158;
                                v158 = threadIdx.x;
                                assert("Tensor range check" && 0 <= v158 && v158 < 256);
                                int v159;
                                v159 = 2048 * v158;
                                int v160;
                                v160 = v159 + v137;
                                int v161;
                                v161 = v121.length;
                                bool v162;
                                v162 = 128 >= v161;
                                bool v163;
                                v163 = v162 == false;
                                if (v163){
                                    assert("The type level dimension has to equal the value passed at runtime into create." && v162);
                                } else {
                                }
                                static_array_list<Union8,128> v165;
                                v165 = static_array_list<Union8,128>{};
                                v165.unsafe_set_length(v161);
                                int v167;
                                v167 = 0;
                                while (while_method_4(v161, v167)){
                                    Union6 v169;
                                    v169 = v121[v167];
                                    Union8 v175;
                                    switch (v169.tag) {
                                        case 2: { // PlayerAction
                                            int v171 = v169.case2.v0; Union1 v172 = v169.case2.v1;
                                            v175 = Union8{Union8_1{v172}};
                                            break;
                                        }
                                        default: {
                                            v175 = Union8{Union8_0{}};
                                        }
                                    }
                                    v165[v167] = v175;
                                    v167 += 1 ;
                                }
                                static_array<int,2> v176;
                                int v178;
                                v178 = 0;
                                while (while_method_0(v178)){
                                    int v180;
                                    v180 = v178 + v116;
                                    int v181;
                                    v181 = v112[v180];
                                    v176[v178] = v181;
                                    v178 += 1 ;
                                }
                                static_array<int,2> v183;
                                int v185;
                                v185 = 0;
                                while (while_method_0(v185)){
                                    int v187;
                                    v187 = v185 + v116;
                                    int v188;
                                    v188 = v114[v187];
                                    v183[v185] = v188;
                                    v185 += 1 ;
                                }
                                static_array<unsigned char,2> v190;
                                v190 = v111[v116];
                                static_array_list<unsigned char,5> v192;
                                v192 = static_array_list<unsigned char,5>{};
                                switch (v115.tag) {
                                    case 0: { // Flop
                                        static_array<unsigned char,3> v194 = v115.case0.v0;
                                        int v195;
                                        v195 = 0;
                                        while (while_method_1(v195)){
                                            unsigned char v197;
                                            v197 = v194[v195];
                                            v192.push(v197);
                                            v195 += 1 ;
                                        }
                                        break;
                                    }
                                    case 1: { // Preflop
                                        break;
                                    }
                                    case 2: { // River
                                        static_array<unsigned char,5> v204 = v115.case2.v0;
                                        int v205;
                                        v205 = 0;
                                        while (while_method_2(v205)){
                                            unsigned char v207;
                                            v207 = v204[v205];
                                            v192.push(v207);
                                            v205 += 1 ;
                                        }
                                        break;
                                    }
                                    case 3: { // Turn
                                        static_array<unsigned char,4> v199 = v115.case3.v0;
                                        int v200;
                                        v200 = 0;
                                        while (while_method_3(v200)){
                                            unsigned char v202;
                                            v202 = v199[v200];
                                            v192.push(v202);
                                            v200 += 1 ;
                                        }
                                        break;
                                    }
                                    default: {
                                        assert("Invalid tag." && false); __trap();
                                    }
                                }
                                float * v209;
                                v209 = v134+v160;
                                int v211;
                                v211 = v165.length;
                                bool v212;
                                v212 = v211 == 0;
                                if (v212){
                                    v209[0] = 1.0f;
                                } else {
                                }
                                int v213;
                                v213 = v165.length;
                                int v214;
                                v214 = 0;
                                while (while_method_4(v213, v214)){
                                    Union8 v216;
                                    v216 = v165[v214];
                                    int v218;
                                    v218 = v214 * 14;
                                    int v219;
                                    v219 = 1 + v218;
                                    switch (v216.tag) {
                                        case 0: { // None
                                            v209[v219] = 1.0f;
                                            break;
                                        }
                                        case 1: { // Some
                                            Union1 v220 = v216.case1.v0;
                                            int v221;
                                            v221 = v219 + 1;
                                            switch (v220.tag) {
                                                case 0: { // A_All_In
                                                    v209[v221] = 1.0f;
                                                    break;
                                                }
                                                case 1: { // A_Call
                                                    int v222;
                                                    v222 = v221 + 1;
                                                    v209[v222] = 1.0f;
                                                    break;
                                                }
                                                case 2: { // A_Fold
                                                    int v223;
                                                    v223 = v221 + 2;
                                                    v209[v223] = 1.0f;
                                                    break;
                                                }
                                                case 3: { // A_Raise
                                                    int v224 = v220.case3.v0;
                                                    int v225;
                                                    v225 = v221 + 3;
                                                    bool v226;
                                                    v226 = 1 <= v224;
                                                    bool v228;
                                                    if (v226){
                                                        bool v227;
                                                        v227 = v224 < 1023;
                                                        v228 = v227;
                                                    } else {
                                                        v228 = false;
                                                    }
                                                    bool v229;
                                                    v229 = v228 == false;
                                                    if (v229){
                                                        assert("Pickle failure. The input is out of the bounds of the given range." && v228);
                                                    } else {
                                                    }
                                                    int v231;
                                                    v231 = v224 - 1;
                                                    unsigned int v232;
                                                    v232 = (unsigned int)v231;
                                                    method_42(v232, v209, v225);
                                                    break;
                                                }
                                                default: {
                                                    assert("Invalid tag." && false); __trap();
                                                }
                                            }
                                            break;
                                        }
                                        default: {
                                            assert("Invalid tag." && false); __trap();
                                        }
                                    }
                                    v214 += 1 ;
                                }
                                int v233;
                                v233 = 0;
                                while (while_method_0(v233)){
                                    int v235;
                                    v235 = v176[v233];
                                    int v237;
                                    v237 = v233 * 11;
                                    int v238;
                                    v238 = 1794 + v237;
                                    bool v239;
                                    v239 = 0 <= v235;
                                    bool v241;
                                    if (v239){
                                        bool v240;
                                        v240 = v235 < 1023;
                                        v241 = v240;
                                    } else {
                                        v241 = false;
                                    }
                                    bool v242;
                                    v242 = v241 == false;
                                    if (v242){
                                        assert("Pickle failure. The input is out of the bounds of the given range." && v241);
                                    } else {
                                    }
                                    unsigned int v244;
                                    v244 = (unsigned int)v235;
                                    method_43(v244, v209, v238);
                                    v233 += 1 ;
                                }
                                int v245;
                                v245 = 0;
                                while (while_method_0(v245)){
                                    int v247;
                                    v247 = v183[v245];
                                    int v249;
                                    v249 = v245 * 11;
                                    int v250;
                                    v250 = 1817 + v249;
                                    bool v251;
                                    v251 = 0 <= v247;
                                    bool v253;
                                    if (v251){
                                        bool v252;
                                        v252 = v247 < 1023;
                                        v253 = v252;
                                    } else {
                                        v253 = false;
                                    }
                                    bool v254;
                                    v254 = v253 == false;
                                    if (v254){
                                        assert("Pickle failure. The input is out of the bounds of the given range." && v253);
                                    } else {
                                    }
                                    unsigned int v256;
                                    v256 = (unsigned int)v247;
                                    method_43(v256, v209, v250);
                                    v245 += 1 ;
                                }
                                int v257;
                                v257 = 0;
                                while (while_method_0(v257)){
                                    unsigned char v259;
                                    v259 = v190[v257];
                                    int v261;
                                    v261 = v257 * 17;
                                    int v262;
                                    v262 = 1840 + v261;
                                    unsigned char v263;
                                    v263 = v259 % 4u;
                                    int v264;
                                    v264 = (int)v263;
                                    unsigned char v265;
                                    v265 = v259 / 4u;
                                    int v266;
                                    v266 = (int)v265;
                                    unsigned int v267;
                                    v267 = (unsigned int)v264;
                                    int v268;
                                    v268 = (int)v267;
                                    bool v269;
                                    v269 = v268 < 4;
                                    bool v270;
                                    v270 = v269 == false;
                                    if (v270){
                                        assert("Pickle failure. Int value out of bounds." && v269);
                                    } else {
                                    }
                                    int v272;
                                    v272 = v262 + v268;
                                    v209[v272] = 1.0f;
                                    int v273;
                                    v273 = v262 + 4;
                                    unsigned int v274;
                                    v274 = (unsigned int)v266;
                                    int v275;
                                    v275 = (int)v274;
                                    bool v276;
                                    v276 = v275 < 13;
                                    bool v277;
                                    v277 = v276 == false;
                                    if (v277){
                                        assert("Pickle failure. Int value out of bounds." && v276);
                                    } else {
                                    }
                                    int v279;
                                    v279 = v273 + v275;
                                    v209[v279] = 1.0f;
                                    v257 += 1 ;
                                }
                                int v280;
                                v280 = v192.length;
                                bool v281;
                                v281 = v280 == 0;
                                if (v281){
                                    v209[1874] = 1.0f;
                                } else {
                                }
                                int v282;
                                v282 = v192.length;
                                int v283;
                                v283 = 0;
                                while (while_method_4(v282, v283)){
                                    unsigned char v285;
                                    v285 = v192[v283];
                                    int v287;
                                    v287 = v283 * 17;
                                    int v288;
                                    v288 = 1875 + v287;
                                    unsigned char v289;
                                    v289 = v285 % 4u;
                                    int v290;
                                    v290 = (int)v289;
                                    unsigned char v291;
                                    v291 = v285 / 4u;
                                    int v292;
                                    v292 = (int)v291;
                                    unsigned int v293;
                                    v293 = (unsigned int)v290;
                                    int v294;
                                    v294 = (int)v293;
                                    bool v295;
                                    v295 = v294 < 4;
                                    bool v296;
                                    v296 = v295 == false;
                                    if (v296){
                                        assert("Pickle failure. Int value out of bounds." && v295);
                                    } else {
                                    }
                                    int v298;
                                    v298 = v288 + v294;
                                    v209[v298] = 1.0f;
                                    int v299;
                                    v299 = v288 + 4;
                                    unsigned int v300;
                                    v300 = (unsigned int)v292;
                                    int v301;
                                    v301 = (int)v300;
                                    bool v302;
                                    v302 = v301 < 13;
                                    bool v303;
                                    v303 = v302 == false;
                                    if (v303){
                                        assert("Pickle failure. Int value out of bounds." && v302);
                                    } else {
                                    }
                                    int v305;
                                    v305 = v299 + v301;
                                    v209[v305] = 1.0f;
                                    v283 += 1 ;
                                }
                                asm("barrier.cta.sync %0;" :: "r"(0));
                                int v306;
                                v306 = 0;
                                while (while_method_3(v306)){
                                    float * v308;
                                    v308 = reinterpret_cast<float *>(&v0[0ull]);
                                    float * v310;
                                    v310 = reinterpret_cast<float *>(&v1[0ull]);
                                    assert("Tensor range check" && 0 <= v306 && v306 < 4);
                                    int v312;
                                    v312 = 262144 * v306;
                                    float * v313;
                                    v313 = reinterpret_cast<float *>(&v0[50331648ull]);
                                    int v315;
                                    v315 = blockIdx.x;
                                    assert("Tensor range check" && 0 <= v315 && v315 < 24);
                                    int v316;
                                    v316 = 524288 * v315;
                                    int v317;
                                    v317 = blockIdx.x;
                                    assert("Tensor range check" && 0 <= v317 && v317 < 24);
                                    int v318;
                                    v318 = 32768 * v317;
                                    cuda::pipeline<cuda::thread_scope_thread> v319 = cuda::make_pipeline();
                                    extern __shared__ unsigned char v320[];
                                    float * v321;
                                    v321 = reinterpret_cast<float *>(&v320[0ull]);
                                    float * v323;
                                    v323 = reinterpret_cast<float *>(&v320[34816ull]);
                                    float * v325;
                                    v325 = reinterpret_cast<float *>(&v320[0ull]);
                                    int v327;
                                    v327 = threadIdx.x;
                                    int v328;
                                    v328 = v327 / 32;
                                    bool v329;
                                    v329 = 0 <= v328;
                                    bool v330;
                                    v330 = v329 == false;
                                    if (v330){
                                        assert("The index needs to be zero or positive." && v329);
                                    } else {
                                    }
                                    int v332;
                                    v332 = v328 % 8;
                                    int v333;
                                    v333 = v328 / 8;
                                    bool v334;
                                    v334 = v333 < 1;
                                    bool v335;
                                    v335 = v334 == false;
                                    if (v335){
                                        assert("The last element of the projection dimensions needs to be greater than the index remainder." && v334);
                                    } else {
                                    }
                                    assert("Tensor range check" && 0 <= v333 && v333 < 1);
                                    assert("Tensor range check" && 0 <= v332 && v332 < 8);
                                    int v337;
                                    v337 = 16 * v332;
                                    int v338;
                                    v338 = 17408 * v333;
                                    int v339;
                                    v339 = v338 + v337;
                                    float * v340;
                                    v340 = v325+v339;
                                    assert("Tensor range check" && 0 <= v333 && v333 < 1);
                                    int v342;
                                    v342 = 8704 * v333;
                                    int v343;
                                    v343 = threadIdx.x;
                                    int v344;
                                    v344 = v343 % 32;
                                    bool v345;
                                    v345 = 0 <= v344;
                                    bool v346;
                                    v346 = v345 == false;
                                    if (v346){
                                        assert("The index needs to be zero or positive." && v345);
                                    } else {
                                    }
                                    int v348;
                                    v348 = v344 % 4;
                                    int v349;
                                    v349 = v344 / 4;
                                    bool v350;
                                    v350 = v349 < 8;
                                    bool v351;
                                    v351 = v350 == false;
                                    if (v351){
                                        assert("The last element of the projection dimensions needs to be greater than the index remainder." && v350);
                                    } else {
                                    }
                                    assert("Tensor range check" && 0 <= v349 && v349 < 8);
                                    assert("Tensor range check" && 0 <= v348 && v348 < 4);
                                    int v353;
                                    v353 = v348 + v342;
                                    int v354;
                                    v354 = 68 * v349;
                                    int v355;
                                    v355 = v354 + v353;
                                    float * v356;
                                    v356 = v321+v355;
                                    assert("Tensor range check" && 0 <= v332 && v332 < 8);
                                    int v358;
                                    v358 = 1088 * v332;
                                    int v359;
                                    v359 = threadIdx.x;
                                    int v360;
                                    v360 = v359 % 32;
                                    bool v361;
                                    v361 = 0 <= v360;
                                    bool v362;
                                    v362 = v361 == false;
                                    if (v362){
                                        assert("The index needs to be zero or positive." && v361);
                                    } else {
                                    }
                                    int v364;
                                    v364 = v360 % 4;
                                    int v365;
                                    v365 = v360 / 4;
                                    bool v366;
                                    v366 = v365 < 8;
                                    bool v367;
                                    v367 = v366 == false;
                                    if (v367){
                                        assert("The last element of the projection dimensions needs to be greater than the index remainder." && v366);
                                    } else {
                                    }
                                    assert("Tensor range check" && 0 <= v365 && v365 < 8);
                                    assert("Tensor range check" && 0 <= v364 && v364 < 4);
                                    int v369;
                                    v369 = v364 + v358;
                                    int v370;
                                    v370 = 68 * v365;
                                    int v371;
                                    v371 = v370 + v369;
                                    float * v372;
                                    v372 = v323+v371;
                                    wmma::fragment<wmma::accumulator, 16, 16, 8, float> v374[8];
                                    int v375;
                                    v375 = 0;
                                    while (while_method_0(v375)){
                                        int v377;
                                        v377 = 0;
                                        while (while_method_6(v377)){
                                            assert("Tensor range check" && 0 <= v375 && v375 < 2);
                                            assert("Tensor range check" && 0 <= v377 && v377 < 1);
                                            int v379;
                                            v379 = 128 * v377;
                                            int v380;
                                            v380 = v379 + v318;
                                            int v381;
                                            v381 = 16384 * v375;
                                            int v382;
                                            v382 = v381 + v380;
                                            float * v383;
                                            v383 = v313+v382;
                                            // Pushing the loop unrolling to: 0
                                            int v385;
                                            v385 = 0;
                                            #pragma unroll
                                            while (while_method_10(v385)){
                                                int v387;
                                                v387 = 0;
                                                #pragma unroll
                                                while (while_method_6(v387)){
                                                    assert("Tensor range check" && 0 <= v385 && v385 < 8);
                                                    assert("Tensor range check" && 0 <= v387 && v387 < 1);
                                                    int v389;
                                                    v389 = v385 + v387;
                                                    wmma::fragment<wmma::accumulator, 16, 16, 8, float> & v390 = v374[v389];
                                                    wmma::fill_fragment(v390, 0.0f);
                                                    v387 += 1 ;
                                                }
                                                v385 += 1 ;
                                            }
                                            // Poping the loop unrolling to: 0
                                            int v391;
                                            v391 = 0;
                                            while (while_method_11(v391)){
                                                int v393;
                                                v393 = v391 + 1;
                                                bool v394;
                                                v394 = v391 == 0;
                                                int v395;
                                                v395 = v391 % 2;
                                                bool v396;
                                                v396 = 0 <= v391;
                                                bool v397;
                                                v397 = v396 == false;
                                                if (v397){
                                                    assert("The index needs to be zero or positive." && v396);
                                                } else {
                                                }
                                                bool v399;
                                                v399 = v391 < 32;
                                                bool v400;
                                                v400 = v399 == false;
                                                if (v400){
                                                    assert("The last element of the projection dimensions needs to be greater than the index remainder." && v399);
                                                } else {
                                                }
                                                bool v402;
                                                v402 = v393 < 32;
                                                Union9 v408;
                                                if (v402){
                                                    bool v403;
                                                    v403 = 0 <= v393;
                                                    bool v404;
                                                    v404 = v403 == false;
                                                    if (v404){
                                                        assert("The index needs to be zero or positive." && v403);
                                                    } else {
                                                    }
                                                    v408 = Union9{Union9_1{v393}};
                                                } else {
                                                    v408 = Union9{Union9_0{}};
                                                }
                                                assert("Tensor range check" && 0 <= v375 && v375 < 2);
                                                int v409;
                                                v409 = 262144 * v375;
                                                int v410;
                                                v410 = v409 + v316;
                                                assert("Tensor range check" && 0 <= v391 && v391 < 32);
                                                int v411;
                                                v411 = 64 * v391;
                                                int v412;
                                                v412 = v411 + v410;
                                                float * v413;
                                                v413 = v308+v412;
                                                assert("Tensor range check" && 0 <= v377 && v377 < 1);
                                                int v415;
                                                v415 = 262144 * v377;
                                                int v416;
                                                v416 = v415 + v312;
                                                if (v394){
                                                    assert("Tensor range check" && 0 <= v391 && v391 < 32);
                                                    int v417;
                                                    v417 = v411 + v416;
                                                    float * v418;
                                                    v418 = v310+v417;
                                                    // Pushing the loop unrolling to: 0
                                                    v319.producer_acquire();
                                                    int v420;
                                                    v420 = threadIdx.x;
                                                    bool v421;
                                                    v421 = 0 <= v420;
                                                    bool v422;
                                                    v422 = v421 == false;
                                                    if (v422){
                                                        assert("The index needs to be zero or positive." && v421);
                                                    } else {
                                                    }
                                                    int v424;
                                                    v424 = v420 % 16;
                                                    int v425;
                                                    v425 = v420 / 16;
                                                    bool v426;
                                                    v426 = v425 < 16;
                                                    bool v427;
                                                    v427 = v426 == false;
                                                    if (v427){
                                                        assert("The last element of the projection dimensions needs to be greater than the index remainder." && v426);
                                                    } else {
                                                    }
                                                    assert("Tensor range check" && 0 <= v425 && v425 < 16);
                                                    assert("Tensor range check" && 0 <= v424 && v424 < 16);
                                                    int v429;
                                                    v429 = 4 * v424;
                                                    int v430;
                                                    v430 = 68 * v425;
                                                    int v431;
                                                    v431 = v430 + v429;
                                                    int v432;
                                                    v432 = 2048 * v425;
                                                    int v433;
                                                    v433 = v432 + v429;
                                                    float * v434;
                                                    v434 = v323+v431;
                                                    float * v436;
                                                    v436 = v418+v433;
                                                    int v438;
                                                    v438 = 0;
                                                    #pragma unroll
                                                    while (while_method_10(v438)){
                                                        int v440;
                                                        v440 = 0;
                                                        #pragma unroll
                                                        while (while_method_6(v440)){
                                                            assert("Tensor range check" && 0 <= v438 && v438 < 8);
                                                            assert("Tensor range check" && 0 <= v440 && v440 < 1);
                                                            int v442;
                                                            v442 = 64 * v440;
                                                            int v443;
                                                            v443 = 1088 * v438;
                                                            int v444;
                                                            v444 = v443 + v442;
                                                            int v445;
                                                            v445 = 32768 * v438;
                                                            int v446;
                                                            v446 = v445 + v442;
                                                            constexpr int v447 = sizeof(float) * 4;
                                                            assert("Pointer alignment check" && (unsigned long long)(v436 + v446) % v447 == 0 && (unsigned long long)(v434 + v444) % v447 == 0);
                                                            cuda::memcpy_async(v434 + v444, v436 + v446, cuda::aligned_size_t<v447>(v447), v319);
                                                            v440 += 1 ;
                                                        }
                                                        v438 += 1 ;
                                                    }
                                                    v319.producer_commit();
                                                    // Poping the loop unrolling to: 0
                                                } else {
                                                }
                                                // Pushing the loop unrolling to: 0
                                                int v448;
                                                v448 = threadIdx.x;
                                                bool v449;
                                                v449 = 0 <= v448;
                                                bool v450;
                                                v450 = v449 == false;
                                                if (v450){
                                                    assert("The index needs to be zero or positive." && v449);
                                                } else {
                                                }
                                                int v452;
                                                v452 = v448 % 16;
                                                int v453;
                                                v453 = v448 / 16;
                                                bool v454;
                                                v454 = v453 < 16;
                                                bool v455;
                                                v455 = v454 == false;
                                                if (v455){
                                                    assert("The last element of the projection dimensions needs to be greater than the index remainder." && v454);
                                                } else {
                                                }
                                                assert("Tensor range check" && 0 <= v453 && v453 < 16);
                                                assert("Tensor range check" && 0 <= v452 && v452 < 16);
                                                int v457;
                                                v457 = 4 * v452;
                                                int v458;
                                                v458 = 68 * v453;
                                                int v459;
                                                v459 = v458 + v457;
                                                int v460;
                                                v460 = 2048 * v453;
                                                int v461;
                                                v461 = v460 + v457;
                                                float * v462;
                                                v462 = v321+v459;
                                                float * v464;
                                                v464 = v413+v461;
                                                int v466;
                                                v466 = 0;
                                                #pragma unroll
                                                while (while_method_10(v466)){
                                                    int v468;
                                                    v468 = 0;
                                                    #pragma unroll
                                                    while (while_method_6(v468)){
                                                        assert("Tensor range check" && 0 <= v466 && v466 < 8);
                                                        assert("Tensor range check" && 0 <= v468 && v468 < 1);
                                                        int v470;
                                                        v470 = 64 * v468;
                                                        int v471;
                                                        v471 = 1088 * v466;
                                                        int v472;
                                                        v472 = v471 + v470;
                                                        int v473;
                                                        v473 = 32768 * v466;
                                                        int v474;
                                                        v474 = v473 + v470;
                                                        int4* v475;
                                                        v475 = reinterpret_cast<int4*>(v464 + v474);
                                                        int4* v476;
                                                        v476 = reinterpret_cast<int4*>(v462 + v472);
                                                        assert("Pointer alignment check" && (unsigned long long)(v475) % 4 == 0 && (unsigned long long)(v476) % 4 == 0);
                                                        *v476 = *v475;
                                                        v468 += 1 ;
                                                    }
                                                    v466 += 1 ;
                                                }
                                                // Poping the loop unrolling to: 0
                                                wmma::fragment<wmma::matrix_a, 16, 16, 8, wmma::precision::tf32, wmma::row_major> v477[1];
                                                wmma::fragment<wmma::matrix_b, 16, 16, 8, wmma::precision::tf32, wmma::col_major> v478[8];
                                                cuda::pipeline_consumer_wait_prior<0>(v319);;
                                                asm("barrier.cta.sync %0;" :: "r"(0));
                                                // Pushing the loop unrolling to: 0
                                                int v479;
                                                v479 = 0;
                                                #pragma unroll
                                                while (while_method_6(v479)){
                                                    int v481;
                                                    v481 = 0;
                                                    #pragma unroll
                                                    while (while_method_10(v481)){
                                                        assert("Tensor range check" && 0 <= v479 && v479 < 1);
                                                        assert("Tensor range check" && 0 <= v481 && v481 < 8);
                                                        int v483;
                                                        v483 = 8 * v479;
                                                        int v484;
                                                        v484 = v483 + v481;
                                                        wmma::fragment<wmma::matrix_b, 16, 16, 8, wmma::precision::tf32, wmma::col_major> & v485 = v478[v484];
                                                        assert("Tensor range check" && 0 <= v479 && v479 < 1);
                                                        int v486;
                                                        v486 = 1088 * v479;
                                                        assert("Tensor range check" && 0 <= v481 && v481 < 8);
                                                        int v487;
                                                        v487 = 8 * v481;
                                                        int v488;
                                                        v488 = v487 + v486;
                                                        int v489;
                                                        v489 = 0;
                                                        #pragma unroll
                                                        while (while_method_0(v489)){
                                                            int v491;
                                                            v491 = 0;
                                                            #pragma unroll
                                                            while (while_method_0(v491)){
                                                                assert("Tensor range check" && 0 <= v489 && v489 < 2);
                                                                assert("Tensor range check" && 0 <= v491 && v491 < 2);
                                                                int v493;
                                                                v493 = 4 * v491;
                                                                int v494;
                                                                v494 = v493 + v488;
                                                                int v495;
                                                                v495 = 544 * v489;
                                                                int v496;
                                                                v496 = v495 + v494;
                                                                float v497;
                                                                v497 = v372[v496];
                                                                bool v498;
                                                                v498 = 0 <= v491;
                                                                bool v500;
                                                                if (v498){
                                                                    bool v499;
                                                                    v499 = v491 < 2;
                                                                    v500 = v499;
                                                                } else {
                                                                    v500 = false;
                                                                }
                                                                bool v501;
                                                                v501 = v500 == false;
                                                                if (v501){
                                                                    assert("The indices should be inside the range of the dimension." && v500);
                                                                } else {
                                                                }
                                                                bool v503;
                                                                v503 = 0 <= v489;
                                                                bool v505;
                                                                if (v503){
                                                                    bool v504;
                                                                    v504 = v489 < 2;
                                                                    v505 = v504;
                                                                } else {
                                                                    v505 = false;
                                                                }
                                                                bool v506;
                                                                v506 = v505 == false;
                                                                if (v506){
                                                                    assert("The indices should be inside the range of the dimension." && v505);
                                                                } else {
                                                                }
                                                                int v508;
                                                                v508 = v489 * 2;
                                                                int v509;
                                                                v509 = v491 + v508;
                                                                v485.x[v509] = wmma::__float_to_tf32(v497);
                                                                v491 += 1 ;
                                                            }
                                                            v489 += 1 ;
                                                        }
                                                        v481 += 1 ;
                                                    }
                                                    v479 += 1 ;
                                                }
                                                // Poping the loop unrolling to: 0
                                                v319.consumer_release();
                                                switch (v408.tag) {
                                                    case 0: { // None
                                                        break;
                                                    }
                                                    case 1: { // Some
                                                        int v510 = v408.case1.v0;
                                                        assert("Tensor range check" && 0 <= v510 && v510 < 32);
                                                        int v511;
                                                        v511 = 64 * v510;
                                                        int v512;
                                                        v512 = v511 + v416;
                                                        float * v513;
                                                        v513 = v310+v512;
                                                        asm("barrier.cta.sync %0;" :: "r"(0));
                                                        // Pushing the loop unrolling to: 0
                                                        v319.producer_acquire();
                                                        int v515;
                                                        v515 = threadIdx.x;
                                                        bool v516;
                                                        v516 = 0 <= v515;
                                                        bool v517;
                                                        v517 = v516 == false;
                                                        if (v517){
                                                            assert("The index needs to be zero or positive." && v516);
                                                        } else {
                                                        }
                                                        int v519;
                                                        v519 = v515 % 16;
                                                        int v520;
                                                        v520 = v515 / 16;
                                                        bool v521;
                                                        v521 = v520 < 16;
                                                        bool v522;
                                                        v522 = v521 == false;
                                                        if (v522){
                                                            assert("The last element of the projection dimensions needs to be greater than the index remainder." && v521);
                                                        } else {
                                                        }
                                                        assert("Tensor range check" && 0 <= v520 && v520 < 16);
                                                        assert("Tensor range check" && 0 <= v519 && v519 < 16);
                                                        int v524;
                                                        v524 = 4 * v519;
                                                        int v525;
                                                        v525 = 68 * v520;
                                                        int v526;
                                                        v526 = v525 + v524;
                                                        int v527;
                                                        v527 = 2048 * v520;
                                                        int v528;
                                                        v528 = v527 + v524;
                                                        float * v529;
                                                        v529 = v323+v526;
                                                        float * v531;
                                                        v531 = v513+v528;
                                                        int v533;
                                                        v533 = 0;
                                                        #pragma unroll
                                                        while (while_method_10(v533)){
                                                            int v535;
                                                            v535 = 0;
                                                            #pragma unroll
                                                            while (while_method_6(v535)){
                                                                assert("Tensor range check" && 0 <= v533 && v533 < 8);
                                                                assert("Tensor range check" && 0 <= v535 && v535 < 1);
                                                                int v537;
                                                                v537 = 64 * v535;
                                                                int v538;
                                                                v538 = 1088 * v533;
                                                                int v539;
                                                                v539 = v538 + v537;
                                                                int v540;
                                                                v540 = 32768 * v533;
                                                                int v541;
                                                                v541 = v540 + v537;
                                                                constexpr int v542 = sizeof(float) * 4;
                                                                assert("Pointer alignment check" && (unsigned long long)(v531 + v541) % v542 == 0 && (unsigned long long)(v529 + v539) % v542 == 0);
                                                                cuda::memcpy_async(v529 + v539, v531 + v541, cuda::aligned_size_t<v542>(v542), v319);
                                                                v535 += 1 ;
                                                            }
                                                            v533 += 1 ;
                                                        }
                                                        v319.producer_commit();
                                                        // Poping the loop unrolling to: 0
                                                        break;
                                                    }
                                                    default: {
                                                        assert("Invalid tag." && false); __trap();
                                                    }
                                                }
                                                // Pushing the loop unrolling to: 0
                                                int v543;
                                                v543 = 0;
                                                #pragma unroll
                                                while (while_method_10(v543)){
                                                    int v545;
                                                    v545 = 0;
                                                    #pragma unroll
                                                    while (while_method_10(v545)){
                                                        wmma::fragment<wmma::matrix_a, 16, 16, 8, wmma::precision::tf32, wmma::row_major> & v547 = v477[0];
                                                        assert("Tensor range check" && 0 <= v543 && v543 < 8);
                                                        int v548;
                                                        v548 = 1088 * v543;
                                                        assert("Tensor range check" && 0 <= v545 && v545 < 8);
                                                        int v549;
                                                        v549 = 8 * v545;
                                                        int v550;
                                                        v550 = v549 + v548;
                                                        int v551;
                                                        v551 = 0;
                                                        #pragma unroll
                                                        while (while_method_0(v551)){
                                                            int v553;
                                                            v553 = 0;
                                                            #pragma unroll
                                                            while (while_method_0(v553)){
                                                                assert("Tensor range check" && 0 <= v551 && v551 < 2);
                                                                assert("Tensor range check" && 0 <= v553 && v553 < 2);
                                                                int v555;
                                                                v555 = 544 * v553;
                                                                int v556;
                                                                v556 = v555 + v550;
                                                                int v557;
                                                                v557 = 4 * v551;
                                                                int v558;
                                                                v558 = v557 + v556;
                                                                float v559;
                                                                v559 = v356[v558];
                                                                bool v560;
                                                                v560 = 0 <= v553;
                                                                bool v562;
                                                                if (v560){
                                                                    bool v561;
                                                                    v561 = v553 < 2;
                                                                    v562 = v561;
                                                                } else {
                                                                    v562 = false;
                                                                }
                                                                bool v563;
                                                                v563 = v562 == false;
                                                                if (v563){
                                                                    assert("The indices should be inside the range of the dimension." && v562);
                                                                } else {
                                                                }
                                                                bool v565;
                                                                v565 = 0 <= v551;
                                                                bool v567;
                                                                if (v565){
                                                                    bool v566;
                                                                    v566 = v551 < 2;
                                                                    v567 = v566;
                                                                } else {
                                                                    v567 = false;
                                                                }
                                                                bool v568;
                                                                v568 = v567 == false;
                                                                if (v568){
                                                                    assert("The indices should be inside the range of the dimension." && v567);
                                                                } else {
                                                                }
                                                                int v570;
                                                                v570 = v551 * 2;
                                                                int v571;
                                                                v571 = v553 + v570;
                                                                v547.x[v571] = wmma::__float_to_tf32(v559);
                                                                v553 += 1 ;
                                                            }
                                                            v551 += 1 ;
                                                        }
                                                        int v572;
                                                        v572 = 0;
                                                        #pragma unroll
                                                        while (while_method_6(v572)){
                                                            assert("Tensor range check" && 0 <= v543 && v543 < 8);
                                                            assert("Tensor range check" && 0 <= v572 && v572 < 1);
                                                            int v574;
                                                            v574 = v543 + v572;
                                                            wmma::fragment<wmma::accumulator, 16, 16, 8, float> & v575 = v374[v574];
                                                            assert("Tensor range check" && 0 <= v572 && v572 < 1);
                                                            assert("Tensor range check" && 0 <= v545 && v545 < 8);
                                                            int v576;
                                                            v576 = 8 * v572;
                                                            int v577;
                                                            v577 = v576 + v545;
                                                            wmma::fragment<wmma::matrix_b, 16, 16, 8, wmma::precision::tf32, wmma::col_major> & v578 = v478[v577];
                                                            wmma::mma_sync(v575, v547, v578, v575);
                                                            v572 += 1 ;
                                                        }
                                                        v545 += 1 ;
                                                    }
                                                    v543 += 1 ;
                                                }
                                                // Poping the loop unrolling to: 0
                                                asm("barrier.cta.sync %0;" :: "r"(0));
                                                v391 = v393;
                                            }
                                            // Pushing the loop unrolling to: 0
                                            int v579;
                                            v579 = 0;
                                            #pragma unroll
                                            while (while_method_10(v579)){
                                                int v581;
                                                v581 = 0;
                                                #pragma unroll
                                                while (while_method_6(v581)){
                                                    assert("Tensor range check" && 0 <= v579 && v579 < 8);
                                                    assert("Tensor range check" && 0 <= v581 && v581 < 1);
                                                    int v583;
                                                    v583 = v579 + v581;
                                                    wmma::fragment<wmma::accumulator, 16, 16, 8, float> & v584 = v374[v583];
                                                    assert("Tensor range check" && 0 <= v579 && v579 < 8);
                                                    assert("Tensor range check" && 0 <= v581 && v581 < 1);
                                                    int v585;
                                                    v585 = 16 * v581;
                                                    int v586;
                                                    v586 = 2176 * v579;
                                                    int v587;
                                                    v587 = v586 + v585;
                                                    float * v588;
                                                    v588 = v340+v587;
                                                    wmma::store_matrix_sync(v588, v584, 136, wmma::mem_row_major);
                                                    v581 += 1 ;
                                                }
                                                v579 += 1 ;
                                            }
                                            // Poping the loop unrolling to: 0
                                            asm("barrier.cta.sync %0;" :: "r"(0));
                                            // Pushing the loop unrolling to: 0
                                            int v590;
                                            v590 = threadIdx.x;
                                            bool v591;
                                            v591 = 0 <= v590;
                                            bool v592;
                                            v592 = v591 == false;
                                            if (v592){
                                                assert("The index needs to be zero or positive." && v591);
                                            } else {
                                            }
                                            int v594;
                                            v594 = v590 % 32;
                                            int v595;
                                            v595 = v590 / 32;
                                            bool v596;
                                            v596 = v595 < 8;
                                            bool v597;
                                            v597 = v596 == false;
                                            if (v597){
                                                assert("The last element of the projection dimensions needs to be greater than the index remainder." && v596);
                                            } else {
                                            }
                                            assert("Tensor range check" && 0 <= v595 && v595 < 8);
                                            assert("Tensor range check" && 0 <= v594 && v594 < 32);
                                            int v599;
                                            v599 = 4 * v594;
                                            int v600;
                                            v600 = 128 * v595;
                                            int v601;
                                            v601 = v600 + v599;
                                            int v602;
                                            v602 = 136 * v595;
                                            int v603;
                                            v603 = v602 + v599;
                                            float * v604;
                                            v604 = v383+v601;
                                            float * v606;
                                            v606 = v325+v603;
                                            int v608;
                                            v608 = 0;
                                            #pragma unroll
                                            while (while_method_12(v608)){
                                                int v610;
                                                v610 = 0;
                                                #pragma unroll
                                                while (while_method_6(v610)){
                                                    assert("Tensor range check" && 0 <= v608 && v608 < 16);
                                                    assert("Tensor range check" && 0 <= v610 && v610 < 1);
                                                    int v612;
                                                    v612 = 128 * v610;
                                                    int v613;
                                                    v613 = 1024 * v608;
                                                    int v614;
                                                    v614 = v613 + v612;
                                                    int v615;
                                                    v615 = 1088 * v608;
                                                    int v616;
                                                    v616 = v615 + v612;
                                                    int4* v617;
                                                    v617 = reinterpret_cast<int4*>(v606 + v616);
                                                    int4* v618;
                                                    v618 = reinterpret_cast<int4*>(v604 + v614);
                                                    assert("Pointer alignment check" && (unsigned long long)(v617) % 4 == 0 && (unsigned long long)(v618) % 4 == 0);
                                                    *v618 = *v617;
                                                    v610 += 1 ;
                                                }
                                                v608 += 1 ;
                                            }
                                            // Poping the loop unrolling to: 0
                                            asm("barrier.cta.sync %0;" :: "r"(0));
                                            v377 += 1 ;
                                        }
                                        v375 += 1 ;
                                    }
                                    unsigned int * v619;
                                    v619 = reinterpret_cast<unsigned int *>(&v0[53477376ull]);
                                    assert("Tensor range check" && 0 <= v306 && v306 < 4);
                                    int v621;
                                    v621 = 6144 * v306;
                                    method_45(v619, v621, v313);
                                    int * v622;
                                    v622 = reinterpret_cast<int *>(&v1[4194304ull]);
                                    float * v624;
                                    v624 = reinterpret_cast<float *>(&v1[4194320ull]);
                                    float * v626;
                                    v626 = reinterpret_cast<float *>(&v1[5242896ull]);
                                    float * v628;
                                    v628 = reinterpret_cast<float *>(&v1[6291472ull]);
                                    float * v630;
                                    v630 = reinterpret_cast<float *>(&v1[7340048ull]);
                                    float * v632;
                                    v632 = reinterpret_cast<float *>(&v1[8388624ull]);
                                    float * v634;
                                    v634 = reinterpret_cast<float *>(&v1[9437200ull]);
                                    float * v636;
                                    v636 = reinterpret_cast<float *>(&v1[10485776ull]);
                                    int * v638;
                                    v638 = reinterpret_cast<int *>(&v0[53575680ull]);
                                    float * v640;
                                    v640 = reinterpret_cast<float *>(&v0[66158592ull]);
                                    int * v642;
                                    v642 = reinterpret_cast<int *>(&v0[78741504ull]);
                                    int * v644;
                                    v644 = reinterpret_cast<int *>(&v0[91324416ull]);
                                    double * v646;
                                    v646 = reinterpret_cast<double *>(&v0[103907328ull]);
                                    double * v648;
                                    v648 = reinterpret_cast<double *>(&v0[154238976ull]);
                                    double * v650;
                                    v650 = reinterpret_cast<double *>(&v1[11534352ull]);
                                    double * v652;
                                    v652 = reinterpret_cast<double *>(&v1[11927568ull]);
                                    int * v654;
                                    v654 = reinterpret_cast<int *>(&v1[12320784ull]);
                                    v306 += 1 ;
                                }
                                asm("barrier.cta.sync %0;" :: "r"(0));
                                int * v656;
                                v656 = reinterpret_cast<int *>(&v1[4194304ull]);
                                float * v658;
                                v658 = reinterpret_cast<float *>(&v1[4194320ull]);
                                float * v660;
                                v660 = reinterpret_cast<float *>(&v1[5242896ull]);
                                float * v662;
                                v662 = reinterpret_cast<float *>(&v1[6291472ull]);
                                float * v664;
                                v664 = reinterpret_cast<float *>(&v1[7340048ull]);
                                float * v666;
                                v666 = reinterpret_cast<float *>(&v1[8388624ull]);
                                float * v668;
                                v668 = reinterpret_cast<float *>(&v1[9437200ull]);
                                float * v670;
                                v670 = reinterpret_cast<float *>(&v1[10485776ull]);
                                int v672;
                                v672 = 0;
                                int v673;
                                v673 = 4;
                                int v674;
                                v674 = int_range_44(v673, v672, v123);
                                extern __shared__ unsigned char v675[];
                                int * v676;
                                v676 = reinterpret_cast<int *>(&v675[0ull]);
                                int v678;
                                v678 = threadIdx.x;
                                bool v679;
                                v679 = v678 == 0;
                                if (v679){
                                    v676[0] = v674;
                                } else {
                                }
                                asm("barrier.cta.sync %0;" :: "r"(0));
                                int v680;
                                v680 = v676[0];
                                asm("barrier.cta.sync %0;" :: "r"(0));
                                unsigned int * v681;
                                v681 = reinterpret_cast<unsigned int *>(&v0[53477376ull]);
                                int v683;
                                v683 = blockIdx.x;
                                int v684;
                                v684 = threadIdx.x;
                                assert("Tensor range check" && 0 <= v680 && v680 < 4);
                                assert("Tensor range check" && 0 <= v683 && v683 < 24);
                                assert("Tensor range check" && 0 <= v684 && v684 < 256);
                                int v685;
                                v685 = 256 * v683;
                                int v686;
                                v686 = v685 + v684;
                                int v687;
                                v687 = 6144 * v680;
                                int v688;
                                v688 = v687 + v686;
                                unsigned int v689;
                                v689 = v681[v688];
                                int v690;
                                v690 = (int)v689;
                                float v691; int v692;
                                Tuple14 tmp127 = method_46(v123, v656, v658, v660, v662, v664, v666, v668, v670, v690, v680);
                                v691 = tmp127.v0; v692 = tmp127.v1;
                                extern __shared__ unsigned char v693[];
                                float * v694;
                                v694 = reinterpret_cast<float *>(&v693[0ull]);
                                int * v696;
                                v696 = reinterpret_cast<int *>(&v693[16ull]);
                                int v698;
                                v698 = threadIdx.x;
                                bool v699;
                                v699 = v698 == 0;
                                if (v699){
                                    v694[0] = v691;
                                    v696[0] = v692;
                                } else {
                                }
                                asm("barrier.cta.sync %0;" :: "r"(0));
                                float v700;
                                v700 = v694[0];
                                int v701;
                                v701 = v696[0];
                                asm("barrier.cta.sync %0;" :: "r"(0));
                                double * v702;
                                v702 = reinterpret_cast<double *>(&v1[11534352ull]);
                                double * v704;
                                v704 = reinterpret_cast<double *>(&v1[11927568ull]);
                                int * v706;
                                v706 = reinterpret_cast<int *>(&v1[12320784ull]);
                                int * v708;
                                v708 = reinterpret_cast<int *>(&v0[53575680ull]);
                                float * v710;
                                v710 = reinterpret_cast<float *>(&v0[66158592ull]);
                                int * v712;
                                v712 = reinterpret_cast<int *>(&v0[78741504ull]);
                                int * v714;
                                v714 = reinterpret_cast<int *>(&v0[91324416ull]);
                                double * v716;
                                v716 = reinterpret_cast<double *>(&v0[103907328ull]);
                                double * v718;
                                v718 = reinterpret_cast<double *>(&v0[154238976ull]);
                                int v720;
                                v720 = threadIdx.x;
                                int v721;
                                v721 = blockIdx.x;
                                int v722;
                                v722 = v721 * 256;
                                int v723;
                                v723 = v720 + v722;
                                int v724;
                                v724 = 0;
                                while (while_method_3(v724)){
                                    unsigned int * v726;
                                    v726 = reinterpret_cast<unsigned int *>(&v0[53477376ull]);
                                    int v728;
                                    v728 = blockIdx.x;
                                    int v729;
                                    v729 = threadIdx.x;
                                    assert("Tensor range check" && 0 <= v724 && v724 < 4);
                                    assert("Tensor range check" && 0 <= v728 && v728 < 24);
                                    assert("Tensor range check" && 0 <= v729 && v729 < 256);
                                    int v730;
                                    v730 = 256 * v728;
                                    int v731;
                                    v731 = v730 + v729;
                                    int v732;
                                    v732 = 6144 * v724;
                                    int v733;
                                    v733 = v732 + v731;
                                    unsigned int v734;
                                    v734 = v726[v733];
                                    int v735;
                                    v735 = (int)v734;
                                    float v736;
                                    v736 = method_86(v656, v658, v660, v662, v664, v666, v668, v670, v735, v724, v701);
                                    double v737;
                                    v737 = (double)v700;
                                    double v738;
                                    v738 = log(v737);
                                    double v739;
                                    v739 = (double)v736;
                                    double v740;
                                    v740 = log(v739);
                                    assert("Tensor range check" && 0 <= v724 && v724 < 4);
                                    assert("Tensor range check" && 0 <= v723 && v723 < 6144);
                                    assert("Tensor range check" && 0 <= v116 && v116 < 2);
                                    int v741;
                                    v741 = 2 * v723;
                                    int v742;
                                    v742 = v741 + v116;
                                    int v743;
                                    v743 = 12288 * v724;
                                    int v744;
                                    v744 = v743 + v742;
                                    double v745;
                                    v745 = v702[v744];
                                    double v746;
                                    v746 = v704[v744];
                                    double v747;
                                    v747 = v740 + v745;
                                    double v748;
                                    v748 = v738 + v746;
                                    assert("Tensor range check" && 0 <= v724 && v724 < 4);
                                    assert("Tensor range check" && 0 <= v723 && v723 < 6144);
                                    assert("Tensor range check" && 0 <= v116 && v116 < 2);
                                    v702[v744] = v747;
                                    v704[v744] = v748;
                                    v724 += 1 ;
                                }
                                bool v749;
                                v749 = 0 == v701;
                                Union10 v782;
                                if (v749){
                                    v782 = Union10{Union10_1{}};
                                } else {
                                    bool v751;
                                    v751 = 1 == v701;
                                    if (v751){
                                        v782 = Union10{Union10_0{}};
                                    } else {
                                        bool v753;
                                        v753 = 2 == v701;
                                        if (v753){
                                            v782 = Union10{Union10_2{1, 3}};
                                        } else {
                                            bool v755;
                                            v755 = 3 == v701;
                                            if (v755){
                                                v782 = Union10{Union10_2{1, 2}};
                                            } else {
                                                bool v757;
                                                v757 = 4 == v701;
                                                if (v757){
                                                    v782 = Union10{Union10_2{2, 3}};
                                                } else {
                                                    bool v759;
                                                    v759 = 5 == v701;
                                                    if (v759){
                                                        v782 = Union10{Union10_2{3, 4}};
                                                    } else {
                                                        bool v761;
                                                        v761 = 6 == v701;
                                                        if (v761){
                                                            v782 = Union10{Union10_2{1, 1}};
                                                        } else {
                                                            bool v763;
                                                            v763 = 7 == v701;
                                                            if (v763){
                                                                v782 = Union10{Union10_2{3, 2}};
                                                            } else {
                                                                bool v765;
                                                                v765 = 8 == v701;
                                                                if (v765){
                                                                    v782 = Union10{Union10_2{2, 1}};
                                                                } else {
                                                                    bool v767;
                                                                    v767 = 9 == v701;
                                                                    if (v767){
                                                                        v782 = Union10{Union10_2{3, 1}};
                                                                    } else {
                                                                        bool v769;
                                                                        v769 = 10 == v701;
                                                                        if (v769){
                                                                            v782 = Union10{Union10_2{2147483647, 1}};
                                                                        } else {
                                                                            printf("%s\n", "Invalid output id in the NL Holdem model.");
                                                                            __trap();
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                switch (v782.tag) {
                                    case 0: { // AA_Call
                                        v965 = Union1{Union1_1{}};
                                        break;
                                    }
                                    case 1: { // AA_Fold
                                        int v783;
                                        v783 = v112[0];
                                        int v785; int v786;
                                        Tuple4 tmp130 = Tuple4{1, v783};
                                        v785 = tmp130.v0; v786 = tmp130.v1;
                                        while (while_method_0(v785)){
                                            int v788;
                                            v788 = v112[v785];
                                            bool v790;
                                            v790 = v786 >= v788;
                                            int v791;
                                            if (v790){
                                                v791 = v786;
                                            } else {
                                                v791 = v788;
                                            }
                                            v786 = v791;
                                            v785 += 1 ;
                                        }
                                        int v792;
                                        v792 = v112[v116];
                                        bool v794;
                                        v794 = v792 == v786;
                                        if (v794){
                                            v965 = Union1{Union1_1{}};
                                        } else {
                                            v965 = Union1{Union1_2{}};
                                        }
                                        break;
                                    }
                                    case 2: { // AA_Raise
                                        int v799 = v782.case2.v0; int v800 = v782.case2.v1;
                                        static_array<int,2> v801;
                                        int v803;
                                        v803 = 0;
                                        while (while_method_0(v803)){
                                            int v805;
                                            v805 = v114[v803];
                                            int v807;
                                            v807 = v112[v803];
                                            int v809;
                                            v809 = v805 + v807;
                                            v801[v803] = v809;
                                            v803 += 1 ;
                                        }
                                        int v810;
                                        v810 = v112[0];
                                        int v812; int v813;
                                        Tuple4 tmp131 = Tuple4{1, v810};
                                        v812 = tmp131.v0; v813 = tmp131.v1;
                                        while (while_method_0(v812)){
                                            int v815;
                                            v815 = v112[v812];
                                            bool v817;
                                            v817 = v813 >= v815;
                                            int v818;
                                            if (v817){
                                                v818 = v813;
                                            } else {
                                                v818 = v815;
                                            }
                                            v813 = v818;
                                            v812 += 1 ;
                                        }
                                        int v819;
                                        v819 = v801[v116];
                                        bool v821;
                                        v821 = v813 < v819;
                                        int v822;
                                        if (v821){
                                            v822 = v813;
                                        } else {
                                            v822 = v819;
                                        }
                                        static_array<int,2> v823;
                                        int v825;
                                        v825 = 0;
                                        while (while_method_0(v825)){
                                            int v827;
                                            v827 = v112[v825];
                                            bool v829;
                                            v829 = v116 == v825;
                                            int v830;
                                            if (v829){
                                                v830 = v822;
                                            } else {
                                                v830 = v827;
                                            }
                                            v823[v825] = v830;
                                            v825 += 1 ;
                                        }
                                        int v831;
                                        v831 = v823[0];
                                        int v833; int v834;
                                        Tuple4 tmp132 = Tuple4{1, v831};
                                        v833 = tmp132.v0; v834 = tmp132.v1;
                                        while (while_method_0(v833)){
                                            int v836;
                                            v836 = v823[v833];
                                            int v838;
                                            v838 = v834 + v836;
                                            v834 = v838;
                                            v833 += 1 ;
                                        }
                                        static_array<int,2> v839;
                                        int v841;
                                        v841 = 0;
                                        while (while_method_0(v841)){
                                            int v843;
                                            v843 = v801[v841];
                                            int v845;
                                            v845 = v823[v841];
                                            int v847;
                                            v847 = v843 - v845;
                                            v839[v841] = v847;
                                            v841 += 1 ;
                                        }
                                        int v848;
                                        v848 = v799 * v834;
                                        int v849;
                                        v849 = v848 / v800;
                                        bool v850;
                                        v850 = v110 >= v849;
                                        int v851;
                                        if (v850){
                                            v851 = v110;
                                        } else {
                                            v851 = v849;
                                        }
                                        int v852;
                                        v852 = v839[v116];
                                        bool v854;
                                        v854 = v851 >= v852;
                                        if (v854){
                                            v965 = Union1{Union1_0{}};
                                        } else {
                                            v965 = Union1{Union1_3{v851}};
                                        }
                                        break;
                                    }
                                    default: {
                                        assert("Invalid tag." && false); __trap();
                                    }
                                }
                                break;
                            }
                            case 1: { // Human
                                printf("%s\n", "Humans aren't allowed during training.");
                                __trap();
                                break;
                            }
                            case 2: { // Random
                                curandStatePhilox4_32_10_t & v861 = v2.v5;
                                curandStatePhilox4_32_10_t & v862 = v861;
                                static_array<int,2> v863;
                                int v865;
                                v865 = 0;
                                while (while_method_0(v865)){
                                    int v867;
                                    v867 = v114[v865];
                                    int v869;
                                    v869 = v112[v865];
                                    int v871;
                                    v871 = v867 + v869;
                                    v863[v865] = v871;
                                    v865 += 1 ;
                                }
                                int v872;
                                v872 = v112[0];
                                int v874; int v875;
                                Tuple4 tmp133 = Tuple4{1, v872};
                                v874 = tmp133.v0; v875 = tmp133.v1;
                                while (while_method_0(v874)){
                                    int v877;
                                    v877 = v112[v874];
                                    bool v879;
                                    v879 = v875 >= v877;
                                    int v880;
                                    if (v879){
                                        v880 = v875;
                                    } else {
                                        v880 = v877;
                                    }
                                    v875 = v880;
                                    v874 += 1 ;
                                }
                                int v881;
                                v881 = v863[v116];
                                bool v883;
                                v883 = v875 < v881;
                                int v884;
                                if (v883){
                                    v884 = v875;
                                } else {
                                    v884 = v881;
                                }
                                static_array<int,2> v885;
                                int v887;
                                v887 = 0;
                                while (while_method_0(v887)){
                                    int v889;
                                    v889 = v112[v887];
                                    bool v891;
                                    v891 = v116 == v887;
                                    int v892;
                                    if (v891){
                                        v892 = v884;
                                    } else {
                                        v892 = v889;
                                    }
                                    v885[v887] = v892;
                                    v887 += 1 ;
                                }
                                int v893;
                                v893 = v885[0];
                                int v895; int v896;
                                Tuple4 tmp134 = Tuple4{1, v893};
                                v895 = tmp134.v0; v896 = tmp134.v1;
                                while (while_method_0(v895)){
                                    int v898;
                                    v898 = v885[v895];
                                    int v900;
                                    v900 = v896 + v898;
                                    v896 = v900;
                                    v895 += 1 ;
                                }
                                static_array<int,2> v901;
                                int v903;
                                v903 = 0;
                                while (while_method_0(v903)){
                                    int v905;
                                    v905 = v863[v903];
                                    int v907;
                                    v907 = v885[v903];
                                    int v909;
                                    v909 = v905 - v907;
                                    v901[v903] = v909;
                                    v903 += 1 ;
                                }
                                int v910;
                                v910 = v112[v116];
                                bool v912;
                                v912 = v910 < v875;
                                float v913;
                                if (v912){
                                    v913 = 1.0f;
                                } else {
                                    v913 = 0.0f;
                                }
                                int v914;
                                v914 = v896 / 3;
                                bool v915;
                                v915 = v110 <= v914;
                                bool v919;
                                if (v915){
                                    int v916;
                                    v916 = v901[v116];
                                    bool v918;
                                    v918 = v914 < v916;
                                    v919 = v918;
                                } else {
                                    v919 = false;
                                }
                                float v920;
                                if (v919){
                                    v920 = 1.0f;
                                } else {
                                    v920 = 0.0f;
                                }
                                int v921;
                                v921 = v896 / 2;
                                bool v922;
                                v922 = v110 <= v921;
                                bool v926;
                                if (v922){
                                    int v923;
                                    v923 = v901[v116];
                                    bool v925;
                                    v925 = v921 < v923;
                                    v926 = v925;
                                } else {
                                    v926 = false;
                                }
                                float v927;
                                if (v926){
                                    v927 = 1.0f;
                                } else {
                                    v927 = 0.0f;
                                }
                                bool v928;
                                v928 = v110 <= v896;
                                bool v932;
                                if (v928){
                                    int v929;
                                    v929 = v901[v116];
                                    bool v931;
                                    v931 = v896 < v929;
                                    v932 = v931;
                                } else {
                                    v932 = false;
                                }
                                float v933;
                                if (v932){
                                    v933 = 1.0f;
                                } else {
                                    v933 = 0.0f;
                                }
                                static_array<Tuple18,6> v934;
                                Union1 v936;
                                v936 = Union1{Union1_2{}};
                                v934[0] = Tuple18{v936, v913};
                                Union1 v938;
                                v938 = Union1{Union1_1{}};
                                v934[1] = Tuple18{v938, 4.0f};
                                Union1 v940;
                                v940 = Union1{Union1_3{v914}};
                                v934[2] = Tuple18{v940, v920};
                                Union1 v942;
                                v942 = Union1{Union1_3{v921}};
                                v934[3] = Tuple18{v942, v927};
                                Union1 v944;
                                v944 = Union1{Union1_3{v896}};
                                v934[4] = Tuple18{v944, v933};
                                Union1 v946;
                                v946 = Union1{Union1_0{}};
                                v934[5] = Tuple18{v946, 1.0f};
                                Union1 v948;
                                v948 = sample_discrete_47(v934, v862);
                                int v949;
                                v949 = sizeof(Union1);
                                unsigned long long v950;
                                v950 = (unsigned long long)v949;
                                bool v951;
                                v951 = v950 <= 98304ull;
                                bool v952;
                                v952 = v951 == false;
                                if (v952){
                                    assert("The dynamic shared memory is insufficient to allocate the tensor." && v951);
                                } else {
                                }
                                extern __shared__ unsigned char v954[];
                                bool v955;
                                v955 = v950 <= v950;
                                bool v956;
                                v956 = v955 == false;
                                if (v956){
                                    assert("The length of the partition has to be less than or equal to the length of the base array." && v955);
                                } else {
                                }
                                Union1 * v958;
                                v958 = reinterpret_cast<Union1 *>(&v954[0ull]);
                                int v960;
                                v960 = threadIdx.x;
                                bool v961;
                                v961 = v960 == 0;
                                if (v961){
                                    v958[0] = v948;
                                } else {
                                }
                                asm("barrier.cta.sync %0;" :: "r"(0));
                                Union1 v962;
                                v962 = v958[0];
                                asm("barrier.cta.sync %0;" :: "r"(0));
                                v965 = v962;
                                break;
                            }
                            default: {
                                assert("Invalid tag." && false); __trap();
                            }
                        }
                        Union6 v966;
                        v966 = Union6{Union6_2{v116, v965}};
                        v13.push(v966);
                        v1092 = Union18{Union18_1{v110, v111, v112, v113, v114, v115, v965}};
                        break;
                    }
                    case 5: { // G_Round'
                        int v968 = v18.case5.v0; static_array<static_array<unsigned char,2>,2> v969 = v18.case5.v1; static_array<int,2> v970 = v18.case5.v2; int v971 = v18.case5.v3; static_array<int,2> v972 = v18.case5.v4; Union5 v973 = v18.case5.v5; Union1 v974 = v18.case5.v6;
                        int v975;
                        v975 = v971 % 2;
                        Union6 v976;
                        v976 = Union6{Union6_2{v975, v974}};
                        v13.push(v976);
                        v1092 = Union18{Union18_1{v968, v969, v970, v971, v972, v973, v974}};
                        break;
                    }
                    case 6: { // G_Showdown
                        int v32 = v18.case6.v0; static_array<static_array<unsigned char,2>,2> v33 = v18.case6.v1; static_array<int,2> v34 = v18.case6.v2; int v35 = v18.case6.v3; static_array<int,2> v36 = v18.case6.v4; Union5 v37 = v18.case6.v5;
                        static_array<unsigned char,5> v40;
                        switch (v37.tag) {
                            case 2: { // River
                                static_array<unsigned char,5> v38 = v37.case2.v0;
                                v40 = v38;
                                break;
                            }
                            default: {
                                printf("%s\n", "Invalid street in showdown.");
                                __trap();
                            }
                        }
                        static_array<unsigned char,2> v41;
                        v41 = v33[0];
                        static_array<unsigned char,7> v43;
                        int v45;
                        v45 = 0;
                        while (while_method_0(v45)){
                            unsigned char v47;
                            v47 = v41[v45];
                            v43[v45] = v47;
                            v45 += 1 ;
                        }
                        int v49;
                        v49 = 0;
                        while (while_method_2(v49)){
                            unsigned char v51;
                            v51 = v40[v49];
                            int v53;
                            v53 = 2 + v49;
                            v43[v53] = v51;
                            v49 += 1 ;
                        }
                        static_array<unsigned char,5> v54; char v55;
                        Tuple0 tmp135 = score_51(v43);
                        v54 = tmp135.v0; v55 = tmp135.v1;
                        static_array<unsigned char,2> v56;
                        v56 = v33[1];
                        static_array<unsigned char,7> v58;
                        int v60;
                        v60 = 0;
                        while (while_method_0(v60)){
                            unsigned char v62;
                            v62 = v56[v60];
                            v58[v60] = v62;
                            v60 += 1 ;
                        }
                        int v64;
                        v64 = 0;
                        while (while_method_2(v64)){
                            unsigned char v66;
                            v66 = v40[v64];
                            int v68;
                            v68 = 2 + v64;
                            v58[v68] = v66;
                            v64 += 1 ;
                        }
                        static_array<unsigned char,5> v69; char v70;
                        Tuple0 tmp136 = score_51(v58);
                        v69 = tmp136.v0; v70 = tmp136.v1;
                        int v71;
                        v71 = v35 % 2;
                        int v72;
                        v72 = v34[v71];
                        bool v74;
                        v74 = v55 < v70;
                        Union11 v80;
                        if (v74){
                            v80 = Union11{Union11_2{}};
                        } else {
                            bool v76;
                            v76 = v55 > v70;
                            if (v76){
                                v80 = Union11{Union11_1{}};
                            } else {
                                v80 = Union11{Union11_0{}};
                            }
                        }
                        Union11 v99;
                        switch (v80.tag) {
                            case 0: { // Eq
                                Union11 v81;
                                v81 = Union11{Union11_0{}};
                                int v82;
                                v82 = 0;
                                while (while_method_2(v82)){
                                    unsigned char v84;
                                    v84 = v54[v82];
                                    unsigned char v86;
                                    v86 = v69[v82];
                                    unsigned char v88;
                                    v88 = v84 / 4u;
                                    unsigned char v89;
                                    v89 = v86 / 4u;
                                    bool v90;
                                    v90 = v88 < v89;
                                    Union11 v96;
                                    if (v90){
                                        v96 = Union11{Union11_2{}};
                                    } else {
                                        bool v92;
                                        v92 = v88 > v89;
                                        if (v92){
                                            v96 = Union11{Union11_1{}};
                                        } else {
                                            v96 = Union11{Union11_0{}};
                                        }
                                    }
                                    bool v97;
                                    switch (v96.tag) {
                                        case 0: { // Eq
                                            v97 = true;
                                            break;
                                        }
                                        default: {
                                            v97 = false;
                                        }
                                    }
                                    bool v98;
                                    v98 = v97 == false;
                                    if (v98){
                                        v81 = v96;
                                        break;
                                    } else {
                                    }
                                    v82 += 1 ;
                                }
                                v99 = v81;
                                break;
                            }
                            default: {
                                v99 = v80;
                            }
                        }
                        int v104; int v105;
                        switch (v99.tag) {
                            case 0: { // Eq
                                v104 = 0; v105 = -1;
                                break;
                            }
                            case 1: { // Gt
                                v104 = v72; v105 = 0;
                                break;
                            }
                            case 2: { // Lt
                                v104 = v72; v105 = 1;
                                break;
                            }
                            default: {
                                assert("Invalid tag." && false); __trap();
                            }
                        }
                        static_array<Tuple0,2> v106;
                        v106[0] = Tuple0{v54, v55};
                        v106[1] = Tuple0{v69, v70};
                        Union6 v108;
                        v108 = Union6{Union6_4{v104, v106, v105}};
                        v13.push(v108);
                        v1092 = Union18{Union18_0{}};
                        break;
                    }
                    case 7: { // G_Turn
                        int v997 = v18.case7.v0; static_array<static_array<unsigned char,2>,2> v998 = v18.case7.v1; static_array<int,2> v999 = v18.case7.v2; int v1000 = v18.case7.v3; static_array<int,2> v1001 = v18.case7.v4; Union5 v1002 = v18.case7.v5;
                        curandStatePhilox4_32_10_t & v1003 = v2.v5;
                        curandStatePhilox4_32_10_t & v1004 = v1003;
                        static_array<unsigned char,1> v1005; unsigned long long v1006;
                        Tuple12 tmp137 = draw_cards_40(v1004, v14);
                        v1005 = tmp137.v0; v1006 = tmp137.v1;
                        v2.v0 = v1006;
                        static_array_list<unsigned char,5> v1007;
                        v1007 = get_community_cards_82(v1002, v1005);
                        Union6 v1008;
                        v1008 = Union6{Union6_0{v1007}};
                        v13.push(v1008);
                        Union5 v1023;
                        switch (v1002.tag) {
                            case 0: { // Flop
                                static_array<unsigned char,3> v1009 = v1002.case0.v0;
                                static_array<unsigned char,4> v1010;
                                int v1012;
                                v1012 = 0;
                                while (while_method_1(v1012)){
                                    unsigned char v1014;
                                    v1014 = v1009[v1012];
                                    v1010[v1012] = v1014;
                                    v1012 += 1 ;
                                }
                                int v1016;
                                v1016 = 0;
                                while (while_method_6(v1016)){
                                    unsigned char v1018;
                                    v1018 = v1005[v1016];
                                    int v1020;
                                    v1020 = 3 + v1016;
                                    v1010[v1020] = v1018;
                                    v1016 += 1 ;
                                }
                                v1023 = Union5{Union5_3{v1010}};
                                break;
                            }
                            default: {
                                printf("%s\n", "Invalid street in turn.");
                                __trap();
                            }
                        }
                        int v1024;
                        v1024 = 2;
                        int v1025;
                        v1025 = 0;
                        Union4 v1026;
                        v1026 = try_round_36(v1024, v998, v999, v1025, v1001, v1023);
                        v1092 = Union18{Union18_2{v1026}};
                        break;
                    }
                    default: {
                        assert("Invalid tag." && false); __trap();
                    }
                }
                switch (v1092.tag) {
                    case 0: { // T_none
                        v1298 = Union3{Union3_0{}};
                        break;
                    }
                    case 1: { // T_round
                        int v1096 = v1092.case1.v0; static_array<static_array<unsigned char,2>,2> v1097 = v1092.case1.v1; static_array<int,2> v1098 = v1092.case1.v2; int v1099 = v1092.case1.v3; static_array<int,2> v1100 = v1092.case1.v4; Union5 v1101 = v1092.case1.v5; Union1 v1102 = v1092.case1.v6;
                        int v1103;
                        v1103 = v1099 % 2;
                        Union4 v1291;
                        switch (v1102.tag) {
                            case 0: { // A_All_In
                                static_array<int,2> v1221;
                                int v1223;
                                v1223 = 0;
                                while (while_method_0(v1223)){
                                    int v1225;
                                    v1225 = v1100[v1223];
                                    int v1227;
                                    v1227 = v1098[v1223];
                                    int v1229;
                                    v1229 = v1225 + v1227;
                                    v1221[v1223] = v1229;
                                    v1223 += 1 ;
                                }
                                int v1230;
                                v1230 = v1098[0];
                                int v1232; int v1233;
                                Tuple4 tmp138 = Tuple4{1, v1230};
                                v1232 = tmp138.v0; v1233 = tmp138.v1;
                                while (while_method_0(v1232)){
                                    int v1235;
                                    v1235 = v1098[v1232];
                                    bool v1237;
                                    v1237 = v1233 >= v1235;
                                    int v1238;
                                    if (v1237){
                                        v1238 = v1233;
                                    } else {
                                        v1238 = v1235;
                                    }
                                    v1233 = v1238;
                                    v1232 += 1 ;
                                }
                                int v1239;
                                v1239 = v1221[v1103];
                                bool v1241;
                                v1241 = v1233 < v1239;
                                int v1242;
                                if (v1241){
                                    v1242 = v1233;
                                } else {
                                    v1242 = v1239;
                                }
                                static_array<int,2> v1243;
                                int v1245;
                                v1245 = 0;
                                while (while_method_0(v1245)){
                                    int v1247;
                                    v1247 = v1098[v1245];
                                    bool v1249;
                                    v1249 = v1103 == v1245;
                                    int v1250;
                                    if (v1249){
                                        v1250 = v1242;
                                    } else {
                                        v1250 = v1247;
                                    }
                                    v1243[v1245] = v1250;
                                    v1245 += 1 ;
                                }
                                static_array<int,2> v1251;
                                int v1253;
                                v1253 = 0;
                                while (while_method_0(v1253)){
                                    int v1255;
                                    v1255 = v1221[v1253];
                                    int v1257;
                                    v1257 = v1243[v1253];
                                    int v1259;
                                    v1259 = v1255 - v1257;
                                    v1251[v1253] = v1259;
                                    v1253 += 1 ;
                                }
                                int v1260;
                                v1260 = v1251[v1103];
                                int v1262;
                                v1262 = v1233 + v1260;
                                int v1263;
                                v1263 = v1221[v1103];
                                bool v1265;
                                v1265 = v1262 < v1263;
                                int v1266;
                                if (v1265){
                                    v1266 = v1262;
                                } else {
                                    v1266 = v1263;
                                }
                                static_array<int,2> v1267;
                                int v1269;
                                v1269 = 0;
                                while (while_method_0(v1269)){
                                    int v1271;
                                    v1271 = v1098[v1269];
                                    bool v1273;
                                    v1273 = v1103 == v1269;
                                    int v1274;
                                    if (v1273){
                                        v1274 = v1266;
                                    } else {
                                        v1274 = v1271;
                                    }
                                    v1267[v1269] = v1274;
                                    v1269 += 1 ;
                                }
                                static_array<int,2> v1275;
                                int v1277;
                                v1277 = 0;
                                while (while_method_0(v1277)){
                                    int v1279;
                                    v1279 = v1221[v1277];
                                    int v1281;
                                    v1281 = v1267[v1277];
                                    int v1283;
                                    v1283 = v1279 - v1281;
                                    v1275[v1277] = v1283;
                                    v1277 += 1 ;
                                }
                                bool v1284;
                                v1284 = v1260 >= v1096;
                                int v1285;
                                if (v1284){
                                    v1285 = v1260;
                                } else {
                                    v1285 = v1096;
                                }
                                int v1286;
                                v1286 = v1099 + 1;
                                v1291 = try_round_36(v1285, v1097, v1267, v1286, v1275, v1101);
                                break;
                            }
                            case 1: { // A_Call
                                static_array<int,2> v1105;
                                int v1107;
                                v1107 = 0;
                                while (while_method_0(v1107)){
                                    int v1109;
                                    v1109 = v1100[v1107];
                                    int v1111;
                                    v1111 = v1098[v1107];
                                    int v1113;
                                    v1113 = v1109 + v1111;
                                    v1105[v1107] = v1113;
                                    v1107 += 1 ;
                                }
                                int v1114;
                                v1114 = v1098[0];
                                int v1116; int v1117;
                                Tuple4 tmp139 = Tuple4{1, v1114};
                                v1116 = tmp139.v0; v1117 = tmp139.v1;
                                while (while_method_0(v1116)){
                                    int v1119;
                                    v1119 = v1098[v1116];
                                    bool v1121;
                                    v1121 = v1117 >= v1119;
                                    int v1122;
                                    if (v1121){
                                        v1122 = v1117;
                                    } else {
                                        v1122 = v1119;
                                    }
                                    v1117 = v1122;
                                    v1116 += 1 ;
                                }
                                int v1123;
                                v1123 = v1105[v1103];
                                bool v1125;
                                v1125 = v1117 < v1123;
                                int v1126;
                                if (v1125){
                                    v1126 = v1117;
                                } else {
                                    v1126 = v1123;
                                }
                                static_array<int,2> v1127;
                                int v1129;
                                v1129 = 0;
                                while (while_method_0(v1129)){
                                    int v1131;
                                    v1131 = v1098[v1129];
                                    bool v1133;
                                    v1133 = v1103 == v1129;
                                    int v1134;
                                    if (v1133){
                                        v1134 = v1126;
                                    } else {
                                        v1134 = v1131;
                                    }
                                    v1127[v1129] = v1134;
                                    v1129 += 1 ;
                                }
                                static_array<int,2> v1135;
                                int v1137;
                                v1137 = 0;
                                while (while_method_0(v1137)){
                                    int v1139;
                                    v1139 = v1105[v1137];
                                    int v1141;
                                    v1141 = v1127[v1137];
                                    int v1143;
                                    v1143 = v1139 - v1141;
                                    v1135[v1137] = v1143;
                                    v1137 += 1 ;
                                }
                                bool v1144;
                                v1144 = v1103 < 2;
                                if (v1144){
                                    int v1145;
                                    v1145 = v1099 + 1;
                                    v1291 = try_round_36(v1096, v1097, v1127, v1145, v1135, v1101);
                                } else {
                                    v1291 = go_next_street_38(v1096, v1097, v1127, v1099, v1135, v1101);
                                }
                                break;
                            }
                            case 2: { // A_Fold
                                v1291 = Union4{Union4_1{v1096, v1097, v1098, v1099, v1100, v1101}};
                                break;
                            }
                            case 3: { // A_Raise
                                int v1149 = v1102.case3.v0;
                                bool v1150;
                                v1150 = v1096 <= v1149;
                                bool v1151;
                                v1151 = v1150 == false;
                                if (v1151){
                                    assert("The raise amount must match the minimum." && v1150);
                                } else {
                                }
                                static_array<int,2> v1153;
                                int v1155;
                                v1155 = 0;
                                while (while_method_0(v1155)){
                                    int v1157;
                                    v1157 = v1100[v1155];
                                    int v1159;
                                    v1159 = v1098[v1155];
                                    int v1161;
                                    v1161 = v1157 + v1159;
                                    v1153[v1155] = v1161;
                                    v1155 += 1 ;
                                }
                                int v1162;
                                v1162 = v1098[0];
                                int v1164; int v1165;
                                Tuple4 tmp140 = Tuple4{1, v1162};
                                v1164 = tmp140.v0; v1165 = tmp140.v1;
                                while (while_method_0(v1164)){
                                    int v1167;
                                    v1167 = v1098[v1164];
                                    bool v1169;
                                    v1169 = v1165 >= v1167;
                                    int v1170;
                                    if (v1169){
                                        v1170 = v1165;
                                    } else {
                                        v1170 = v1167;
                                    }
                                    v1165 = v1170;
                                    v1164 += 1 ;
                                }
                                int v1171;
                                v1171 = v1153[v1103];
                                bool v1173;
                                v1173 = v1165 < v1171;
                                int v1174;
                                if (v1173){
                                    v1174 = v1165;
                                } else {
                                    v1174 = v1171;
                                }
                                static_array<int,2> v1175;
                                int v1177;
                                v1177 = 0;
                                while (while_method_0(v1177)){
                                    int v1179;
                                    v1179 = v1098[v1177];
                                    bool v1181;
                                    v1181 = v1103 == v1177;
                                    int v1182;
                                    if (v1181){
                                        v1182 = v1174;
                                    } else {
                                        v1182 = v1179;
                                    }
                                    v1175[v1177] = v1182;
                                    v1177 += 1 ;
                                }
                                static_array<int,2> v1183;
                                int v1185;
                                v1185 = 0;
                                while (while_method_0(v1185)){
                                    int v1187;
                                    v1187 = v1153[v1185];
                                    int v1189;
                                    v1189 = v1175[v1185];
                                    int v1191;
                                    v1191 = v1187 - v1189;
                                    v1183[v1185] = v1191;
                                    v1185 += 1 ;
                                }
                                int v1192;
                                v1192 = v1183[v1103];
                                bool v1194;
                                v1194 = v1149 < v1192;
                                bool v1195;
                                v1195 = v1194 == false;
                                if (v1195){
                                    assert("The raise amount must be less than the stack size after calling." && v1194);
                                } else {
                                }
                                int v1197;
                                v1197 = v1165 + v1149;
                                int v1198;
                                v1198 = v1153[v1103];
                                bool v1200;
                                v1200 = v1197 < v1198;
                                int v1201;
                                if (v1200){
                                    v1201 = v1197;
                                } else {
                                    v1201 = v1198;
                                }
                                static_array<int,2> v1202;
                                int v1204;
                                v1204 = 0;
                                while (while_method_0(v1204)){
                                    int v1206;
                                    v1206 = v1098[v1204];
                                    bool v1208;
                                    v1208 = v1103 == v1204;
                                    int v1209;
                                    if (v1208){
                                        v1209 = v1201;
                                    } else {
                                        v1209 = v1206;
                                    }
                                    v1202[v1204] = v1209;
                                    v1204 += 1 ;
                                }
                                static_array<int,2> v1210;
                                int v1212;
                                v1212 = 0;
                                while (while_method_0(v1212)){
                                    int v1214;
                                    v1214 = v1153[v1212];
                                    int v1216;
                                    v1216 = v1202[v1212];
                                    int v1218;
                                    v1218 = v1214 - v1216;
                                    v1210[v1212] = v1218;
                                    v1212 += 1 ;
                                }
                                int v1219;
                                v1219 = v1099 + 1;
                                v1291 = try_round_36(v1149, v1097, v1202, v1219, v1210, v1101);
                                break;
                            }
                            default: {
                                assert("Invalid tag." && false); __trap();
                            }
                        }
                        v1298 = Union3{Union3_1{v1291}};
                        break;
                    }
                    case 2: { // T_some
                        Union4 v1094 = v1092.case2.v0;
                        v1298 = Union3{Union3_1{v1094}};
                        break;
                    }
                    default: {
                        assert("Invalid tag." && false); __trap();
                    }
                }
                break;
            }
            default: {
                assert("Invalid tag." && false); __trap();
            }
        }
        v16 = v1298;
    }
    return ;
}
extern "C" __global__ void entry0(unsigned char * v0, unsigned char * v1, unsigned char * v2, unsigned long long v3, unsigned char * v4, unsigned long long v5) {
    Union0 v6;
    v6 = f_0(v1);
    unsigned long long v7; Union3 v8; static_array_list<Union6,128> v9; static_array<Union2,2> v10; Union7 v11;
    Tuple1 tmp15 = f_6(v0);
    v7 = tmp15.v0; v8 = tmp15.v1; v9 = tmp15.v2; v10 = tmp15.v3; v11 = tmp15.v4;
    unsigned long long v12;
    v12 = clock64();
    int v13;
    v13 = threadIdx.x;
    int v14;
    v14 = blockIdx.x;
    int v15;
    v15 = v14 * 256;
    int v16;
    v16 = v13 + v15;
    unsigned long long v17;
    v17 = (unsigned long long)v16;
    curandStatePhilox4_32_10_t v18;
    curand_init(v12,v17,0ull,&v18);
    curandStatePhilox4_32_10_t & v19 = v18;
    StackMut0 v20{v7, v8, v9, v10, v19, v11};
    Union3 v57;
    switch (v6.tag) {
        case 0: { // ActionSelected
            Union1 v35 = v6.case0.v0;
            Union3 & v36 = v20.v1;
            switch (v36.tag) {
                case 0: { // None
                    printf("%s\n", "The game hasn't been started in ActionSelected.");
                    __trap();
                    break;
                }
                case 1: { // Some
                    Union4 v37 = v36.case1.v0;
                    switch (v37.tag) {
                        case 4: { // G_Round
                            int v38 = v37.case4.v0; static_array<static_array<unsigned char,2>,2> v39 = v37.case4.v1; static_array<int,2> v40 = v37.case4.v2; int v41 = v37.case4.v3; static_array<int,2> v42 = v37.case4.v4; Union5 v43 = v37.case4.v5;
                            Union4 v44;
                            v44 = Union4{Union4_5{v38, v39, v40, v41, v42, v43, v35}};
                            v57 = Union3{Union3_1{v44}};
                            break;
                        }
                        default: {
                            printf("%s\n", "Unexpected game node in ActionSelected.");
                            __trap();
                        }
                    }
                    break;
                }
                default: {
                    assert("Invalid tag." && false); __trap();
                }
            }
            break;
        }
        case 1: { // PlayerChanged
            static_array<Union2,2> v33 = v6.case1.v0;
            v20.v3 = v33;
            v57 = Union3{Union3_0{}};
            break;
        }
        case 2: { // StartGame
            static_array<Union2,2> v21;
            Union2 v23;
            v23 = Union2{Union2_0{}};
            v21[0] = v23;
            Union2 v25;
            v25 = Union2{Union2_1{}};
            v21[1] = v25;
            static_array_list<Union6,128> v27;
            v27 = static_array_list<Union6,128>{};
            Union7 v29;
            v29 = Union7{Union7_0{}};
            v20.v5 = v29;
            v20.v3 = v21;
            Union3 v30;
            v30 = Union3{Union3_0{}};
            v20.v1 = v30;
            v20.v0 = 4503599627370495ull;
            v20.v2 = v27;
            Union4 v31;
            v31 = Union4{Union4_2{}};
            v57 = Union3{Union3_1{v31}};
            break;
        }
        case 3: { // StartTrainingVsRando
            printf("%s\n", "Training is not supported in the `event_loop_play` function.");
            __trap();
            break;
        }
        case 4: { // StartTrainingVsSelf
            printf("%s\n", "Training is not supported in the `event_loop_play` function.");
            __trap();
            break;
        }
        default: {
            assert("Invalid tag." && false); __trap();
        }
    }
    switch (v57.tag) {
        case 0: { // None
            break;
        }
        case 1: { // Some
            Union4 v58 = v57.case1.v0;
            play_loop_31(v2, v3, v4, v5, v20, v58);
            break;
        }
        default: {
            assert("Invalid tag." && false); __trap();
        }
    }
    int v59;
    v59 = threadIdx.x;
    int v60;
    v60 = blockIdx.x;
    int v61;
    v61 = v60 * 256;
    int v62;
    v62 = v59 + v61;
    bool v63;
    v63 = v62 == 0;
    if (v63){
        Union7 & v64 = v20.v5;
        static_array<Union2,2> & v65 = v20.v3;
        static_array_list<Union6,128> & v66 = v20.v2;
        Union3 & v67 = v20.v1;
        unsigned long long & v68 = v20.v0;
        return f_52(v0, v68, v67, v66, v65, v64);
    } else {
        return ;
    }
}
extern "C" __global__ void entry1(unsigned char * v0, unsigned long long v1, unsigned char * v2, unsigned long long v3, float * v4, float * v5, float * v6) {
    auto v7 = cooperative_groups::this_grid();
    unsigned long long v8;
    v8 = clock64();
    int v9;
    v9 = threadIdx.x;
    int v10;
    v10 = blockIdx.x;
    int v11;
    v11 = v10 * 256;
    int v12;
    v12 = v9 + v11;
    unsigned long long v13;
    v13 = (unsigned long long)v12;
    curandStatePhilox4_32_10_t v14;
    curand_init(v8,v13,0ull,&v14);
    static_array<Union2,2> v15;
    Union2 v17;
    v17 = Union2{Union2_2{}};
    v15[0] = v17;
    Union2 v19;
    v19 = Union2{Union2_2{}};
    v15[1] = v19;
    static_array_list<Union6,128> v21;
    v21 = static_array_list<Union6,128>{};
    static_array<float,2> v23;
    v23[0] = 0.0f;
    v23[1] = 0.0f;
    cooperative_groups::grid_group & v25 = v7;
    curandStatePhilox4_32_10_t & v26 = v14;
    StackMut1 v27{4503599627370495ull, v25, v21, v15, v23, v26};
    bool v28;
    v28 = 12419088ull == v3;
    bool v29;
    v29 = v28 == false;
    if (v29){
        assert("The params needs to have matching offsets." && v28);
    } else {
    }
    bool v31;
    v31 = 204570624ull == v1;
    bool v32;
    v32 = v31 == false;
    if (v32){
        assert("The outputs needs to have matching offsets." && v31);
    } else {
    }
    int v34;
    v34 = 0;
    while (while_method_3(v34)){
        int v36;
        v36 = 0;
        while (while_method_10(v36)){
            int v38;
            v38 = 0;
            while (while_method_0(v38)){
                Union4 v40;
                v40 = Union4{Union4_2{}};
                method_80(v0, v2, v27, v38, v40);
                static_array<float,2> & v41 = v27.v4;
                float v42;
                v42 = v41[v38];
                double * v44;
                v44 = reinterpret_cast<double *>(&v2[11534352ull]);
                double * v46;
                v46 = reinterpret_cast<double *>(&v2[11927568ull]);
                int * v48;
                v48 = reinterpret_cast<int *>(&v2[12320784ull]);
                int v50;
                v50 = threadIdx.x;
                int v51;
                v51 = blockIdx.x;
                int v52;
                v52 = v51 * 256;
                int v53;
                v53 = v50 + v52;
                assert("Tensor range check" && 0 <= v53 && v53 < 6144);
                int v54;
                v54 = 2 * v53;
                int v55; double v56;
                Tuple24 tmp103 = Tuple24{0, 1.0};
                v55 = tmp103.v0; v56 = tmp103.v1;
                while (while_method_0(v55)){
                    assert("Tensor range check" && 0 <= v55 && v55 < 2);
                    int v58;
                    v58 = v55 + v54;
                    int v59; double v60;
                    Tuple24 tmp104 = Tuple24{0, 0.0};
                    v59 = tmp104.v0; v60 = tmp104.v1;
                    while (while_method_3(v59)){
                        assert("Tensor range check" && 0 <= v59 && v59 < 4);
                        int v62;
                        v62 = 12288 * v59;
                        int v63;
                        v63 = v62 + v58;
                        double v64;
                        v64 = v44[v63];
                        double v65;
                        v65 = v46[v63];
                        double v66;
                        v66 = v64 - v65;
                        double v67;
                        v67 = exp(v66);
                        double v68;
                        v68 = v60 + v67;
                        v60 = v68;
                        v59 += 1 ;
                    }
                    double v69;
                    v69 = v56 * v60;
                    v56 = v69;
                    v55 += 1 ;
                }
                float v70;
                v70 = (float)v56;
                int v71;
                v71 = 0;
                while (while_method_3(v71)){
                    double * v73;
                    v73 = reinterpret_cast<double *>(&v2[11534352ull]);
                    double * v75;
                    v75 = reinterpret_cast<double *>(&v2[11927568ull]);
                    int * v77;
                    v77 = reinterpret_cast<int *>(&v2[12320784ull]);
                    int v79;
                    v79 = threadIdx.x;
                    int v80;
                    v80 = blockIdx.x;
                    int v81;
                    v81 = v80 * 256;
                    int v82;
                    v82 = v79 + v81;
                    assert("Tensor range check" && 0 <= v82 && v82 < 6144);
                    int v83;
                    v83 = 2 * v82;
                    int v84; double v85;
                    Tuple24 tmp105 = Tuple24{0, 1.0};
                    v84 = tmp105.v0; v85 = tmp105.v1;
                    while (while_method_0(v84)){
                        assert("Tensor range check" && 0 <= v84 && v84 < 2);
                        int v87;
                        v87 = v84 + v83;
                        int v88; double v89;
                        Tuple24 tmp106 = Tuple24{0, 0.0};
                        v88 = tmp106.v0; v89 = tmp106.v1;
                        while (while_method_3(v88)){
                            assert("Tensor range check" && 0 <= v88 && v88 < 4);
                            int v91;
                            v91 = 12288 * v88;
                            int v92;
                            v92 = v91 + v87;
                            double v93;
                            v93 = v73[v92];
                            double v94;
                            v94 = v75[v92];
                            double v95;
                            v95 = v93 - v94;
                            double v96;
                            v96 = exp(v95);
                            bool v97;
                            v97 = v71 == v88;
                            bool v98;
                            v98 = v97 != true;
                            double v99;
                            if (v98){
                                v99 = v96;
                            } else {
                                v99 = 0.0;
                            }
                            double v100;
                            v100 = v89 + v99;
                            v89 = v100;
                            v88 += 1 ;
                        }
                        double v101;
                        v101 = v85 * v89;
                        v85 = v101;
                        v84 += 1 ;
                    }
                    float v102;
                    v102 = (float)v85;
                    float v103;
                    v103 = v70 - v102;
                    float v104;
                    v104 = v42 * v103;
                    assert("Tensor range check" && 0 <= v71 && v71 < 4);
                    assert("Tensor range check" && 0 <= v34 && v34 < 4);
                    int v105;
                    v105 = 4 * v71;
                    int v106;
                    v106 = v105 + v34;
                    float * v107;
                    v107 = v4+v106;
                    float * v109;
                    v109 = v5+v106;
                    float v111;
                    v111 = atomicAdd(v107,v104);
                    float v112;
                    v112 = atomicAdd(v109,v103);
                    v71 += 1 ;
                }
                static_array<float,2> & v113 = v27.v4;
                unsigned int * v114;
                v114 = reinterpret_cast<unsigned int *>(&v0[53477376ull]);
                int * v116;
                v116 = reinterpret_cast<int *>(&v2[4194304ull]);
                float * v118;
                v118 = reinterpret_cast<float *>(&v2[4194320ull]);
                float * v120;
                v120 = reinterpret_cast<float *>(&v2[5242896ull]);
                float * v122;
                v122 = reinterpret_cast<float *>(&v2[6291472ull]);
                float * v124;
                v124 = reinterpret_cast<float *>(&v2[7340048ull]);
                float * v126;
                v126 = reinterpret_cast<float *>(&v2[8388624ull]);
                float * v128;
                v128 = reinterpret_cast<float *>(&v2[9437200ull]);
                float * v130;
                v130 = reinterpret_cast<float *>(&v2[10485776ull]);
                int * v132;
                v132 = reinterpret_cast<int *>(&v0[53575680ull]);
                float * v134;
                v134 = reinterpret_cast<float *>(&v0[66158592ull]);
                int * v136;
                v136 = reinterpret_cast<int *>(&v0[78741504ull]);
                int * v138;
                v138 = reinterpret_cast<int *>(&v0[91324416ull]);
                double * v140;
                v140 = reinterpret_cast<double *>(&v0[103907328ull]);
                double * v142;
                v142 = reinterpret_cast<double *>(&v0[154238976ull]);
                double * v144;
                v144 = reinterpret_cast<double *>(&v2[11534352ull]);
                double * v146;
                v146 = reinterpret_cast<double *>(&v2[11927568ull]);
                int * v148;
                v148 = reinterpret_cast<int *>(&v2[12320784ull]);
                int v150;
                v150 = 0;
                while (while_method_3(v150)){
                    int v152;
                    v152 = threadIdx.x;
                    int v153;
                    v153 = blockIdx.x;
                    int v154;
                    v154 = v153 * 256;
                    int v155;
                    v155 = v152 + v154;
                    float v156[2];
                    int v157;
                    v157 = 0;
                    while (while_method_0(v157)){
                        float v159;
                        v159 = v113[v157];
                        v156[v157] = v159;
                        v157 += 1 ;
                    }
                    assert("Tensor range check" && 0 <= v150 && v150 < 4);
                    assert("Tensor range check" && 0 <= v155 && v155 < 6144);
                    int v161;
                    v161 = 6144 * v150;
                    int v162;
                    v162 = v161 + v155;
                    int v163;
                    v163 = v148[v162];
                    int v164;
                    v164 = v163;
                    while (while_method_22(v164)){
                        v164 -= 1 ;
                        assert("Tensor range check" && 0 <= v150 && v150 < 4);
                        assert("Tensor range check" && 0 <= v164 && v164 < 128);
                        assert("Tensor range check" && 0 <= v155 && v155 < 6144);
                        int v166;
                        v166 = 6144 * v164;
                        int v167;
                        v167 = v166 + v155;
                        int v168;
                        v168 = 786432 * v150;
                        int v169;
                        v169 = v168 + v167;
                        int v170;
                        v170 = v132[v169];
                        float v171;
                        v171 = v134[v169];
                        int v172;
                        v172 = v136[v169];
                        int v173;
                        v173 = v138[v169];
                        assert("Tensor range check" && 0 <= v172 && v172 < 2);
                        float v174;
                        v174 = v156[v172];
                        assert("Tensor range check" && 0 <= v150 && v150 < 4);
                        int v175;
                        v175 = 65536 * v150;
                        assert("Tensor range check" && 0 <= v173 && v173 < 4096);
                        int v176;
                        v176 = 16 * v173;
                        int v177;
                        v177 = v176 + v175;
                        float * v178;
                        v178 = v118+v177;
                        float * v180;
                        v180 = v120+v177;
                        float * v182;
                        v182 = v122+v177;
                        float * v184;
                        v184 = v124+v177;
                        float * v186;
                        v186 = v126+v177;
                        float * v188;
                        v188 = v128+v177;
                        float * v190;
                        v190 = v130+v177;
                        assert("Tensor range check" && 0 <= v150 && v150 < 4);
                        int v192;
                        v192 = 1572864 * v150;
                        assert("Tensor range check" && 0 <= v164 && v164 < 128);
                        int v193;
                        v193 = 12288 * v164;
                        int v194;
                        v194 = v193 + v192;
                        assert("Tensor range check" && 0 <= v155 && v155 < 6144);
                        int v195;
                        v195 = 2 * v155;
                        int v196;
                        v196 = v195 + v194;
                        double v197[2];
                        int v198;
                        v198 = 0;
                        while (while_method_0(v198)){
                            assert("Tensor range check" && 0 <= v198 && v198 < 2);
                            int v200;
                            v200 = v198 + v196;
                            double v201;
                            v201 = v140[v200];
                            bool v202;
                            v202 = v172 == v198;
                            double v203;
                            if (v202){
                                v203 = 0.0;
                            } else {
                                v203 = v201;
                            }
                            assert("Tensor range check" && 0 <= v198 && v198 < 2);
                            v197[v198] = v203;
                            v198 += 1 ;
                        }
                        double v204;
                        v204 = 0.0;
                        int v205;
                        v205 = 0;
                        while (while_method_0(v205)){
                            assert("Tensor range check" && 0 <= v205 && v205 < 2);
                            double v207;
                            v207 = v197[v205];
                            double v208;
                            v208 = v204 + v207;
                            v204 = v208;
                            v205 += 1 ;
                        }
                        double v209;
                        v209 = 0.0;
                        int v210;
                        v210 = 0;
                        while (while_method_0(v210)){
                            assert("Tensor range check" && 0 <= v210 && v210 < 2);
                            int v212;
                            v212 = v210 + v196;
                            double v213;
                            v213 = v142[v212];
                            double v214;
                            v214 = v209 + v213;
                            v209 = v214;
                            v210 += 1 ;
                        }
                        double v215;
                        v215 = v204 - v209;
                        double v216;
                        v216 = exp(v215);
                        float v217;
                        v217 = (float)v216;
                        float v218;
                        v218 = v174 * v217;
                        assert("Tensor range check" && 0 <= v170 && v170 < 16);
                        float * v219;
                        v219 = v188+v170;
                        float * v221;
                        v221 = v190+v170;
                        float v223;
                        v223 = atomicAdd(v219,v218);
                        float v224;
                        v224 = atomicAdd(v221,v217);
                        float * v225;
                        v225 = v180+0;
                        float * v227;
                        v227 = v184+0;
                        float * v229;
                        v229 = v186+0;
                        int v231;
                        v231 = sizeof(float *);
                        unsigned long long v232;
                        v232 = (unsigned long long)v231;
                        unsigned long long v233;
                        v233 = 256ull * v232;
                        unsigned long long v234;
                        v234 = 4096ull + v233;
                        unsigned long long v235;
                        v235 = v234 + 16ull;
                        unsigned long long v236;
                        v236 = v235 - 1ull;
                        unsigned long long v237;
                        v237 = v236 % 16ull;
                        unsigned long long v238;
                        v238 = v236 - v237;
                        unsigned long long v239;
                        v239 = v238 + v233;
                        unsigned long long v240;
                        v240 = v239 + 16ull;
                        unsigned long long v241;
                        v241 = v240 - 1ull;
                        unsigned long long v242;
                        v242 = v241 % 16ull;
                        unsigned long long v243;
                        v243 = v241 - v242;
                        unsigned long long v244;
                        v244 = v243 + v233;
                        unsigned long long v245;
                        v245 = v244 + 16ull;
                        unsigned long long v246;
                        v246 = v245 - 1ull;
                        unsigned long long v247;
                        v247 = v246 % 16ull;
                        unsigned long long v248;
                        v248 = v246 - v247;
                        unsigned long long v249;
                        v249 = v248 + v233;
                        unsigned long long v250;
                        v250 = v249 + 16ull;
                        unsigned long long v251;
                        v251 = v250 - 1ull;
                        unsigned long long v252;
                        v252 = v251 % 16ull;
                        unsigned long long v253;
                        v253 = v251 - v252;
                        unsigned long long v254;
                        v254 = v253 + 1024ull;
                        bool v255;
                        v255 = v254 <= 98304ull;
                        bool v256;
                        v256 = v255 == false;
                        if (v256){
                            assert("The dynamic shared memory is insufficient to allocate the tensor." && v255);
                        } else {
                        }
                        extern __shared__ unsigned char v258[];
                        bool v259;
                        v259 = v254 <= v254;
                        bool v260;
                        v260 = v259 == false;
                        if (v260){
                            assert("The length of the partition has to be less than or equal to the length of the base array." && v259);
                        } else {
                        }
                        float * v262;
                        v262 = reinterpret_cast<float *>(&v258[0ull]);
                        int * v264;
                        v264 = reinterpret_cast<int *>(&v258[1024ull]);
                        float * v266;
                        v266 = reinterpret_cast<float *>(&v258[2048ull]);
                        float * v268;
                        v268 = reinterpret_cast<float *>(&v258[3072ull]);
                        float * * v270;
                        v270 = reinterpret_cast<float * *>(&v258[4096ull]);
                        float * * v272;
                        v272 = reinterpret_cast<float * *>(&v258[v238]);
                        float * * v274;
                        v274 = reinterpret_cast<float * *>(&v258[v243]);
                        float * * v276;
                        v276 = reinterpret_cast<float * *>(&v258[v248]);
                        float * v278;
                        v278 = reinterpret_cast<float *>(&v258[v253]);
                        int v280;
                        v280 = threadIdx.x;
                        assert("Tensor range check" && 0 <= v280 && v280 < 256);
                        v262[v280] = v171;
                        v264[v280] = v170;
                        v266[v280] = v174;
                        v268[v280] = v217;
                        v270[v280] = v182;
                        v272[v280] = v225;
                        v274[v280] = v227;
                        v276[v280] = v229;
                        asm("barrier.cta.sync %0;" :: "r"(0));
                        bool v281;
                        v281 = 0 <= v280;
                        bool v282;
                        v282 = v281 == false;
                        if (v282){
                            assert("The index needs to be zero or positive." && v281);
                        } else {
                        }
                        int v284;
                        v284 = v280 % 4;
                        int v285;
                        v285 = v280 / 4;
                        bool v286;
                        v286 = v285 < 64;
                        bool v287;
                        v287 = v286 == false;
                        if (v287){
                            assert("The last element of the projection dimensions needs to be greater than the index remainder." && v286);
                        } else {
                        }
                        assert("Tensor range check" && 0 <= v285 && v285 < 64);
                        int v289;
                        v289 = 0;
                        while (while_method_3(v289)){
                            bool v291;
                            v291 = 0 <= v285;
                            bool v292;
                            v292 = v291 && v286;
                            bool v293;
                            v293 = v292 == false;
                            if (v293){
                                assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v292);
                            } else {
                            }
                            bool v295;
                            v295 = 0 <= v289;
                            bool v297;
                            if (v295){
                                bool v296;
                                v296 = v289 < 4;
                                v297 = v296;
                            } else {
                                v297 = false;
                            }
                            bool v298;
                            v298 = v297 == false;
                            if (v298){
                                assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v297);
                            } else {
                            }
                            int v300;
                            v300 = v289 * 64;
                            int v301;
                            v301 = v300 + v285;
                            assert("Tensor range check" && 0 <= v289 && v289 < 4);
                            int v302;
                            v302 = 64 * v289;
                            int v303;
                            v303 = v302 + v285;
                            float v304;
                            v304 = v262[v303];
                            int v305;
                            v305 = v264[v303];
                            float v306;
                            v306 = v266[v303];
                            float v307;
                            v307 = v268[v303];
                            float * v308;
                            v308 = v270[v303];
                            float * v309;
                            v309 = v272[v303];
                            float * v310;
                            v310 = v274[v303];
                            float * v311;
                            v311 = v276[v303];
                            int v312;
                            v312 = blockIdx.x;
                            int v313;
                            v313 = v312 * 256;
                            int v314;
                            v314 = v313 + v301;
                            assert("Tensor range check" && 0 <= v284 && v284 < 4);
                            int v315;
                            v315 = 4 * v284;
                            float v316[4];
                            float v317[4];
                            float v318[4];
                            int v319[4];
                            int v320;
                            v320 = 0;
                            while (while_method_6(v320)){
                                assert("Tensor range check" && 0 <= v320 && v320 < 1);
                                int v322;
                                v322 = 4 * v320;
                                assert("Tensor range check" && 0 <= v320 && v320 < 1);
                                int v323;
                                v323 = 16 * v320;
                                int v324;
                                v324 = v323 + v315;
                                int4* v325;
                                v325 = reinterpret_cast<int4*>(v309 + v324);
                                int4* v326;
                                v326 = reinterpret_cast<int4*>(v316 + v322);
                                assert("Pointer alignment check" && (unsigned long long)(v325) % 4 == 0 && (unsigned long long)(v326) % 4 == 0);
                                *v326 = *v325;
                                int4* v327;
                                v327 = reinterpret_cast<int4*>(v310 + v324);
                                int4* v328;
                                v328 = reinterpret_cast<int4*>(v317 + v322);
                                assert("Pointer alignment check" && (unsigned long long)(v327) % 4 == 0 && (unsigned long long)(v328) % 4 == 0);
                                *v328 = *v327;
                                int4* v329;
                                v329 = reinterpret_cast<int4*>(v311 + v324);
                                int4* v330;
                                v330 = reinterpret_cast<int4*>(v318 + v322);
                                assert("Pointer alignment check" && (unsigned long long)(v329) % 4 == 0 && (unsigned long long)(v330) % 4 == 0);
                                *v330 = *v329;
                                v320 += 1 ;
                            }
                            int v331;
                            v331 = 0;
                            while (while_method_6(v331)){
                                int v333;
                                v333 = 0;
                                while (while_method_3(v333)){
                                    bool v335;
                                    v335 = 0 <= v333;
                                    bool v337;
                                    if (v335){
                                        bool v336;
                                        v336 = v333 < 4;
                                        v337 = v336;
                                    } else {
                                        v337 = false;
                                    }
                                    bool v338;
                                    v338 = v337 == false;
                                    if (v338){
                                        assert("The indices should be inside the range of the dimension." && v337);
                                    } else {
                                    }
                                    bool v340;
                                    v340 = 0 <= v284;
                                    bool v342;
                                    if (v340){
                                        bool v341;
                                        v341 = v284 < 4;
                                        v342 = v341;
                                    } else {
                                        v342 = false;
                                    }
                                    bool v343;
                                    v343 = v342 == false;
                                    if (v343){
                                        assert("The indices should be inside the range of the dimension." && v342);
                                    } else {
                                    }
                                    int v345;
                                    v345 = v284 * 4;
                                    int v346;
                                    v346 = v333 + v345;
                                    bool v347;
                                    v347 = 0 <= v331;
                                    bool v349;
                                    if (v347){
                                        bool v348;
                                        v348 = v331 < 1;
                                        v349 = v348;
                                    } else {
                                        v349 = false;
                                    }
                                    bool v350;
                                    v350 = v349 == false;
                                    if (v350){
                                        assert("The indices should be inside the range of the dimension." && v349);
                                    } else {
                                    }
                                    int v352;
                                    v352 = v331 * 16;
                                    int v353;
                                    v353 = v346 + v352;
                                    assert("Tensor range check" && 0 <= v331 && v331 < 1);
                                    assert("Tensor range check" && 0 <= v333 && v333 < 4);
                                    int v354;
                                    v354 = 4 * v331;
                                    int v355;
                                    v355 = v354 + v333;
                                    v319[v355] = v353;
                                    v333 += 1 ;
                                }
                                v331 += 1 ;
                            }
                            float v356[4];
                            int v357;
                            v357 = 0;
                            while (while_method_6(v357)){
                                int v359;
                                v359 = 0;
                                while (while_method_3(v359)){
                                    assert("Tensor range check" && 0 <= v357 && v357 < 1);
                                    assert("Tensor range check" && 0 <= v359 && v359 < 4);
                                    int v361;
                                    v361 = 4 * v357;
                                    int v362;
                                    v362 = v361 + v359;
                                    float v363;
                                    v363 = v317[v362];
                                    float v364;
                                    v364 = v318[v362];
                                    bool v365;
                                    v365 = v364 == 0.0f;
                                    bool v366;
                                    v366 = v365 != true;
                                    float v368;
                                    if (v366){
                                        float v367;
                                        v367 = v363 / v364;
                                        v368 = v367;
                                    } else {
                                        v368 = 0.0f;
                                    }
                                    assert("Tensor range check" && 0 <= v357 && v357 < 1);
                                    assert("Tensor range check" && 0 <= v359 && v359 < 4);
                                    v356[v362] = v368;
                                    v359 += 1 ;
                                }
                                v357 += 1 ;
                            }
                            bool v369[4];
                            int v370;
                            v370 = 0;
                            while (while_method_6(v370)){
                                int v372;
                                v372 = 0;
                                while (while_method_3(v372)){
                                    assert("Tensor range check" && 0 <= v370 && v370 < 1);
                                    assert("Tensor range check" && 0 <= v372 && v372 < 4);
                                    int v374;
                                    v374 = 4 * v370;
                                    int v375;
                                    v375 = v374 + v372;
                                    float v376;
                                    v376 = v316[v375];
                                    int v377;
                                    v377 = v319[v375];
                                    bool v378;
                                    v378 = v377 < 11;
                                    assert("Tensor range check" && 0 <= v370 && v370 < 1);
                                    assert("Tensor range check" && 0 <= v372 && v372 < 4);
                                    v369[v375] = v378;
                                    v372 += 1 ;
                                }
                                v370 += 1 ;
                            }
                            float v379[4];
                            int v380;
                            v380 = 0;
                            while (while_method_6(v380)){
                                int v382;
                                v382 = 0;
                                while (while_method_3(v382)){
                                    assert("Tensor range check" && 0 <= v380 && v380 < 1);
                                    assert("Tensor range check" && 0 <= v382 && v382 < 4);
                                    int v384;
                                    v384 = 4 * v380;
                                    int v385;
                                    v385 = v384 + v382;
                                    float v386;
                                    v386 = v316[v385];
                                    bool v387;
                                    v387 = v369[v385];
                                    float v390;
                                    if (v387){
                                        bool v388;
                                        v388 = 0.0f >= v386;
                                        if (v388){
                                            v390 = 0.0f;
                                        } else {
                                            v390 = v386;
                                        }
                                    } else {
                                        v390 = 0.0f;
                                    }
                                    assert("Tensor range check" && 0 <= v380 && v380 < 1);
                                    assert("Tensor range check" && 0 <= v382 && v382 < 4);
                                    v379[v385] = v390;
                                    v382 += 1 ;
                                }
                                v380 += 1 ;
                            }
                            float v391;
                            v391 = 0.0f;
                            int v392;
                            v392 = 0;
                            while (while_method_6(v392)){
                                int v394;
                                v394 = 0;
                                while (while_method_3(v394)){
                                    assert("Tensor range check" && 0 <= v392 && v392 < 1);
                                    assert("Tensor range check" && 0 <= v394 && v394 < 4);
                                    int v396;
                                    v396 = 4 * v392;
                                    int v397;
                                    v397 = v396 + v394;
                                    float v398;
                                    v398 = v379[v397];
                                    float v399;
                                    v399 = v391 + v398;
                                    v391 = v399;
                                    v394 += 1 ;
                                }
                                v392 += 1 ;
                            }
                            auto v400 = cooperative_groups::coalesced_threads();
                            int v401;
                            v401 = threadIdx.x;
                            int v402;
                            v402 = v401 / 4;
                            auto v403 = cooperative_groups::labeled_partition(v400,v402);
                            Closure1 v404{};
                            float v405;
                            v405 = cooperative_groups::reduce(v403, v391, v404);
                            int v406[4];
                            int v407;
                            v407 = 0;
                            while (while_method_6(v407)){
                                int v409;
                                v409 = 0;
                                while (while_method_3(v409)){
                                    assert("Tensor range check" && 0 <= v407 && v407 < 1);
                                    assert("Tensor range check" && 0 <= v409 && v409 < 4);
                                    int v411;
                                    v411 = 4 * v407;
                                    int v412;
                                    v412 = v411 + v409;
                                    bool v413;
                                    v413 = v369[v412];
                                    int v414;
                                    if (v413){
                                        v414 = 1;
                                    } else {
                                        v414 = 0;
                                    }
                                    assert("Tensor range check" && 0 <= v407 && v407 < 1);
                                    assert("Tensor range check" && 0 <= v409 && v409 < 4);
                                    v406[v412] = v414;
                                    v409 += 1 ;
                                }
                                v407 += 1 ;
                            }
                            int v415;
                            v415 = 0;
                            int v416;
                            v416 = 0;
                            while (while_method_6(v416)){
                                int v418;
                                v418 = 0;
                                while (while_method_3(v418)){
                                    assert("Tensor range check" && 0 <= v416 && v416 < 1);
                                    assert("Tensor range check" && 0 <= v418 && v418 < 4);
                                    int v420;
                                    v420 = 4 * v416;
                                    int v421;
                                    v421 = v420 + v418;
                                    int v422;
                                    v422 = v406[v421];
                                    int v423;
                                    v423 = v415 + v422;
                                    v415 = v423;
                                    v418 += 1 ;
                                }
                                v416 += 1 ;
                            }
                            auto v424 = cooperative_groups::coalesced_threads();
                            int v425;
                            v425 = threadIdx.x;
                            int v426;
                            v426 = v425 / 4;
                            auto v427 = cooperative_groups::labeled_partition(v424,v426);
                            Closure2 v428{};
                            int v429;
                            v429 = cooperative_groups::reduce(v427, v415, v428);
                            float v430;
                            v430 = (float)v429;
                            float v431;
                            v431 = 1.0f / v430;
                            float v432[4];
                            int v433;
                            v433 = 0;
                            while (while_method_6(v433)){
                                int v435;
                                v435 = 0;
                                while (while_method_3(v435)){
                                    assert("Tensor range check" && 0 <= v433 && v433 < 1);
                                    assert("Tensor range check" && 0 <= v435 && v435 < 4);
                                    int v437;
                                    v437 = 4 * v433;
                                    int v438;
                                    v438 = v437 + v435;
                                    float v439;
                                    v439 = v379[v438];
                                    bool v440;
                                    v440 = v369[v438];
                                    bool v441;
                                    v441 = v440 == false;
                                    float v446;
                                    if (v441){
                                        v446 = 0.0f;
                                    } else {
                                        bool v442;
                                        v442 = v405 == 0.0f;
                                        bool v443;
                                        v443 = v442 != true;
                                        if (v443){
                                            float v444;
                                            v444 = v439 / v405;
                                            v446 = v444;
                                        } else {
                                            v446 = v431;
                                        }
                                    }
                                    assert("Tensor range check" && 0 <= v433 && v433 < 1);
                                    assert("Tensor range check" && 0 <= v435 && v435 < 4);
                                    v432[v438] = v446;
                                    v435 += 1 ;
                                }
                                v433 += 1 ;
                            }
                            float v447[4];
                            int v448;
                            v448 = 0;
                            while (while_method_6(v448)){
                                int v450;
                                v450 = 0;
                                while (while_method_3(v450)){
                                    assert("Tensor range check" && 0 <= v448 && v448 < 1);
                                    assert("Tensor range check" && 0 <= v450 && v450 < 4);
                                    int v452;
                                    v452 = 4 * v448;
                                    int v453;
                                    v453 = v452 + v450;
                                    float v454;
                                    v454 = v356[v453];
                                    int v455;
                                    v455 = v319[v453];
                                    bool v456;
                                    v456 = v305 == v455;
                                    float v459;
                                    if (v456){
                                        float v457;
                                        v457 = v306 - v454;
                                        float v458;
                                        v458 = v457 / v304;
                                        v459 = v458;
                                    } else {
                                        v459 = 0.0f;
                                    }
                                    float v460;
                                    v460 = v459 + v454;
                                    assert("Tensor range check" && 0 <= v448 && v448 < 1);
                                    assert("Tensor range check" && 0 <= v450 && v450 < 4);
                                    v447[v453] = v460;
                                    v450 += 1 ;
                                }
                                v448 += 1 ;
                            }
                            float v461[4];
                            int v462;
                            v462 = 0;
                            while (while_method_6(v462)){
                                int v464;
                                v464 = 0;
                                while (while_method_3(v464)){
                                    assert("Tensor range check" && 0 <= v462 && v462 < 1);
                                    assert("Tensor range check" && 0 <= v464 && v464 < 4);
                                    int v466;
                                    v466 = 4 * v462;
                                    int v467;
                                    v467 = v466 + v464;
                                    float v468;
                                    v468 = v432[v467];
                                    float v469;
                                    v469 = v447[v467];
                                    float v470;
                                    v470 = v468 * v469;
                                    assert("Tensor range check" && 0 <= v462 && v462 < 1);
                                    assert("Tensor range check" && 0 <= v464 && v464 < 4);
                                    v461[v467] = v470;
                                    v464 += 1 ;
                                }
                                v462 += 1 ;
                            }
                            float v471;
                            v471 = 0.0f;
                            int v472;
                            v472 = 0;
                            while (while_method_6(v472)){
                                int v474;
                                v474 = 0;
                                while (while_method_3(v474)){
                                    assert("Tensor range check" && 0 <= v472 && v472 < 1);
                                    assert("Tensor range check" && 0 <= v474 && v474 < 4);
                                    int v476;
                                    v476 = 4 * v472;
                                    int v477;
                                    v477 = v476 + v474;
                                    float v478;
                                    v478 = v461[v477];
                                    float v479;
                                    v479 = v471 + v478;
                                    v471 = v479;
                                    v474 += 1 ;
                                }
                                v472 += 1 ;
                            }
                            auto v480 = cooperative_groups::coalesced_threads();
                            int v481;
                            v481 = threadIdx.x;
                            int v482;
                            v482 = v481 / 4;
                            auto v483 = cooperative_groups::labeled_partition(v480,v482);
                            float v484;
                            v484 = cooperative_groups::reduce(v483, v471, v404);
                            int v485;
                            v485 = 0;
                            while (while_method_6(v485)){
                                int v487;
                                v487 = 0;
                                while (while_method_3(v487)){
                                    assert("Tensor range check" && 0 <= v485 && v485 < 1);
                                    assert("Tensor range check" && 0 <= v487 && v487 < 4);
                                    int v489;
                                    v489 = 4 * v485;
                                    int v490;
                                    v490 = v489 + v487;
                                    float v491;
                                    v491 = v447[v490];
                                    int v492;
                                    v492 = v319[v490];
                                    float v493;
                                    v493 = v491 - v484;
                                    float v494;
                                    v494 = v307 * v493;
                                    assert("Tensor range check" && 0 <= v492 && v492 < 16);
                                    float * v495;
                                    v495 = v308+v492;
                                    float v497;
                                    v497 = atomicAdd(v495,v494);
                                    v487 += 1 ;
                                }
                                v485 += 1 ;
                            }
                            int v498;
                            v498 = 0;
                            while (while_method_6(v498)){
                                assert("Tensor range check" && 0 <= v498 && v498 < 1);
                                assert("Tensor range check" && 0 <= v498 && v498 < 1);
                                v498 += 1 ;
                            }
                            assert("Tensor range check" && 0 <= v301 && v301 < 256);
                            v278[v301] = v484;
                            v289 += 1 ;
                        }
                        asm("barrier.cta.sync %0;" :: "r"(0));
                        assert("Tensor range check" && 0 <= v280 && v280 < 256);
                        float v500;
                        v500 = v278[v280];
                        asm("barrier.cta.sync %0;" :: "r"(0));
                        assert("Tensor range check" && 0 <= v172 && v172 < 2);
                        v156[v172] = v500;
                    }
                    int v501;
                    v501 = threadIdx.x;
                    int v502;
                    v502 = blockIdx.x;
                    int v503;
                    v503 = v502 * 256;
                    int v504;
                    v504 = v501 + v503;
                    assert("Tensor range check" && 0 <= v150 && v150 < 4);
                    int v505;
                    v505 = 12288 * v150;
                    assert("Tensor range check" && 0 <= v504 && v504 < 6144);
                    int v506;
                    v506 = 2 * v504;
                    int v507;
                    v507 = v506 + v505;
                    double * v508;
                    v508 = v144+v507;
                    double * v510;
                    v510 = v146+v507;
                    double * v512;
                    v512 = v508+0;
                    double * v514;
                    v514 = v510+0;
                    double * v516;
                    v516 = v508+0;
                    double * v518;
                    v518 = v510+0;
                    int v520;
                    v520 = sizeof(double *);
                    unsigned long long v521;
                    v521 = (unsigned long long)v520;
                    unsigned long long v522;
                    v522 = 256ull * v521;
                    unsigned long long v523;
                    v523 = v522 + 16ull;
                    unsigned long long v524;
                    v524 = v523 - 1ull;
                    unsigned long long v525;
                    v525 = v524 % 16ull;
                    unsigned long long v526;
                    v526 = v524 - v525;
                    unsigned long long v527;
                    v527 = v526 + v522;
                    unsigned long long v528;
                    v528 = v527 + 16ull;
                    unsigned long long v529;
                    v529 = v528 - 1ull;
                    unsigned long long v530;
                    v530 = v529 % 16ull;
                    unsigned long long v531;
                    v531 = v529 - v530;
                    unsigned long long v532;
                    v532 = v531 + v522;
                    unsigned long long v533;
                    v533 = v532 + 16ull;
                    unsigned long long v534;
                    v534 = v533 - 1ull;
                    unsigned long long v535;
                    v535 = v534 % 16ull;
                    unsigned long long v536;
                    v536 = v534 - v535;
                    unsigned long long v537;
                    v537 = v536 + v522;
                    bool v538;
                    v538 = v537 <= 98304ull;
                    bool v539;
                    v539 = v538 == false;
                    if (v539){
                        assert("The dynamic shared memory is insufficient to allocate the tensor." && v538);
                    } else {
                    }
                    extern __shared__ unsigned char v541[];
                    bool v542;
                    v542 = v537 <= v537;
                    bool v543;
                    v543 = v542 == false;
                    if (v543){
                        assert("The length of the partition has to be less than or equal to the length of the base array." && v542);
                    } else {
                    }
                    double * * v545;
                    v545 = reinterpret_cast<double * *>(&v541[0ull]);
                    double * * v547;
                    v547 = reinterpret_cast<double * *>(&v541[v526]);
                    double * * v549;
                    v549 = reinterpret_cast<double * *>(&v541[v531]);
                    double * * v551;
                    v551 = reinterpret_cast<double * *>(&v541[v536]);
                    int v553;
                    v553 = threadIdx.x;
                    assert("Tensor range check" && 0 <= v553 && v553 < 256);
                    v545[v553] = v512;
                    v547[v553] = v514;
                    v549[v553] = v516;
                    v551[v553] = v518;
                    asm("barrier.cta.sync %0;" :: "r"(0));
                    bool v554;
                    v554 = 0 <= v553;
                    bool v555;
                    v555 = v554 == false;
                    if (v555){
                        assert("The index needs to be zero or positive." && v554);
                    } else {
                    }
                    int v557;
                    v557 = v553 % 1;
                    bool v558;
                    v558 = v553 < 256;
                    bool v559;
                    v559 = v558 == false;
                    if (v559){
                        assert("The last element of the projection dimensions needs to be greater than the index remainder." && v558);
                    } else {
                    }
                    assert("Tensor range check" && 0 <= v553 && v553 < 256);
                    int v561;
                    v561 = 0;
                    while (while_method_6(v561)){
                        bool v563;
                        v563 = v554 && v558;
                        bool v564;
                        v564 = v563 == false;
                        if (v564){
                            assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v563);
                        } else {
                        }
                        bool v566;
                        v566 = 0 <= v561;
                        bool v568;
                        if (v566){
                            bool v567;
                            v567 = v561 < 1;
                            v568 = v567;
                        } else {
                            v568 = false;
                        }
                        bool v569;
                        v569 = v568 == false;
                        if (v569){
                            assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v568);
                        } else {
                        }
                        int v571;
                        v571 = v561 * 256;
                        int v572;
                        v572 = v571 + v553;
                        assert("Tensor range check" && 0 <= v561 && v561 < 1);
                        int v573;
                        v573 = 256 * v561;
                        int v574;
                        v574 = v573 + v553;
                        double * v575;
                        v575 = v545[v574];
                        double * v576;
                        v576 = v547[v574];
                        double * v577;
                        v577 = v549[v574];
                        double * v578;
                        v578 = v551[v574];
                        int v579;
                        v579 = blockIdx.x;
                        int v580;
                        v580 = v579 * 256;
                        int v581;
                        v581 = v580 + v572;
                        assert("Tensor range check" && 0 <= v557 && v557 < 1);
                        int v582;
                        v582 = 2 * v557;
                        double v583[2];
                        double v584[2];
                        int v585[2];
                        int v586;
                        v586 = 0;
                        while (while_method_6(v586)){
                            assert("Tensor range check" && 0 <= v586 && v586 < 1);
                            int v588;
                            v588 = 2 * v586;
                            assert("Tensor range check" && 0 <= v586 && v586 < 1);
                            int v589;
                            v589 = v588 + v582;
                            int4* v590;
                            v590 = reinterpret_cast<int4*>(v575 + v589);
                            int4* v591;
                            v591 = reinterpret_cast<int4*>(v583 + v588);
                            assert("Pointer alignment check" && (unsigned long long)(v590) % 2 == 0 && (unsigned long long)(v591) % 2 == 0);
                            *v591 = *v590;
                            int4* v592;
                            v592 = reinterpret_cast<int4*>(v576 + v589);
                            int4* v593;
                            v593 = reinterpret_cast<int4*>(v584 + v588);
                            assert("Pointer alignment check" && (unsigned long long)(v592) % 2 == 0 && (unsigned long long)(v593) % 2 == 0);
                            *v593 = *v592;
                            v586 += 1 ;
                        }
                        int v594;
                        v594 = 0;
                        while (while_method_6(v594)){
                            int v596;
                            v596 = 0;
                            while (while_method_0(v596)){
                                bool v598;
                                v598 = 0 <= v596;
                                bool v600;
                                if (v598){
                                    bool v599;
                                    v599 = v596 < 2;
                                    v600 = v599;
                                } else {
                                    v600 = false;
                                }
                                bool v601;
                                v601 = v600 == false;
                                if (v601){
                                    assert("The indices should be inside the range of the dimension." && v600);
                                } else {
                                }
                                bool v603;
                                v603 = 0 <= v557;
                                bool v605;
                                if (v603){
                                    bool v604;
                                    v604 = v557 < 1;
                                    v605 = v604;
                                } else {
                                    v605 = false;
                                }
                                bool v606;
                                v606 = v605 == false;
                                if (v606){
                                    assert("The indices should be inside the range of the dimension." && v605);
                                } else {
                                }
                                int v608;
                                v608 = v557 * 2;
                                int v609;
                                v609 = v596 + v608;
                                bool v610;
                                v610 = 0 <= v594;
                                bool v612;
                                if (v610){
                                    bool v611;
                                    v611 = v594 < 1;
                                    v612 = v611;
                                } else {
                                    v612 = false;
                                }
                                bool v613;
                                v613 = v612 == false;
                                if (v613){
                                    assert("The indices should be inside the range of the dimension." && v612);
                                } else {
                                }
                                int v615;
                                v615 = v594 * 2;
                                int v616;
                                v616 = v609 + v615;
                                assert("Tensor range check" && 0 <= v594 && v594 < 1);
                                assert("Tensor range check" && 0 <= v596 && v596 < 2);
                                int v617;
                                v617 = 2 * v594;
                                int v618;
                                v618 = v617 + v596;
                                v585[v618] = v616;
                                v596 += 1 ;
                            }
                            v594 += 1 ;
                        }
                        double v619[2];
                        double v620[2];
                        int v621;
                        v621 = 0;
                        while (while_method_6(v621)){
                            int v623;
                            v623 = 0;
                            while (while_method_0(v623)){
                                assert("Tensor range check" && 0 <= v621 && v621 < 1);
                                assert("Tensor range check" && 0 <= v623 && v623 < 2);
                                int v625;
                                v625 = 2 * v621;
                                int v626;
                                v626 = v625 + v623;
                                double v627;
                                v627 = v583[v626];
                                double v628;
                                v628 = v584[v626];
                                assert("Tensor range check" && 0 <= v621 && v621 < 1);
                                assert("Tensor range check" && 0 <= v623 && v623 < 2);
                                v619[v626] = 0.0;
                                v620[v626] = 0.0;
                                v623 += 1 ;
                            }
                            v621 += 1 ;
                        }
                        int v629;
                        v629 = 0;
                        while (while_method_6(v629)){
                            assert("Tensor range check" && 0 <= v629 && v629 < 1);
                            int v631;
                            v631 = 2 * v629;
                            int v632;
                            v632 = v631 + v582;
                            assert("Tensor range check" && 0 <= v629 && v629 < 1);
                            int4* v633;
                            v633 = reinterpret_cast<int4*>(v619 + v631);
                            int4* v634;
                            v634 = reinterpret_cast<int4*>(v577 + v632);
                            assert("Pointer alignment check" && (unsigned long long)(v633) % 2 == 0 && (unsigned long long)(v634) % 2 == 0);
                            *v634 = *v633;
                            int4* v635;
                            v635 = reinterpret_cast<int4*>(v620 + v631);
                            int4* v636;
                            v636 = reinterpret_cast<int4*>(v578 + v632);
                            assert("Pointer alignment check" && (unsigned long long)(v635) % 2 == 0 && (unsigned long long)(v636) % 2 == 0);
                            *v636 = *v635;
                            v629 += 1 ;
                        }
                        assert("Tensor range check" && 0 <= v572 && v572 < 256);
                        v561 += 1 ;
                    }
                    asm("barrier.cta.sync %0;" :: "r"(0));
                    assert("Tensor range check" && 0 <= v553 && v553 < 256);
                    asm("barrier.cta.sync %0;" :: "r"(0));
                    assert("Tensor range check" && 0 <= v150 && v150 < 4);
                    assert("Tensor range check" && 0 <= v504 && v504 < 6144);
                    int v637;
                    v637 = v161 + v504;
                    v148[v637] = 0;
                    v150 += 1 ;
                }
                v38 += 1 ;
            }
            v36 += 1 ;
        }
        cooperative_groups::grid_group & v638 = v27.v1;
        cooperative_groups::grid_group & v639 = v638;
        curandStatePhilox4_32_10_t & v640 = v27.v5;
        curandStatePhilox4_32_10_t & v641 = v640;
        unsigned int * v642;
        v642 = reinterpret_cast<unsigned int *>(&v0[53477376ull]);
        int * v644;
        v644 = reinterpret_cast<int *>(&v2[4194304ull]);
        float * v646;
        v646 = reinterpret_cast<float *>(&v2[4194320ull]);
        float * v648;
        v648 = reinterpret_cast<float *>(&v2[5242896ull]);
        float * v650;
        v650 = reinterpret_cast<float *>(&v2[6291472ull]);
        float * v652;
        v652 = reinterpret_cast<float *>(&v2[7340048ull]);
        float * v654;
        v654 = reinterpret_cast<float *>(&v2[8388624ull]);
        float * v656;
        v656 = reinterpret_cast<float *>(&v2[9437200ull]);
        float * v658;
        v658 = reinterpret_cast<float *>(&v2[10485776ull]);
        int * v660;
        v660 = reinterpret_cast<int *>(&v0[53575680ull]);
        float * v662;
        v662 = reinterpret_cast<float *>(&v0[66158592ull]);
        int * v664;
        v664 = reinterpret_cast<int *>(&v0[78741504ull]);
        int * v666;
        v666 = reinterpret_cast<int *>(&v0[91324416ull]);
        double * v668;
        v668 = reinterpret_cast<double *>(&v0[103907328ull]);
        double * v670;
        v670 = reinterpret_cast<double *>(&v0[154238976ull]);
        double * v672;
        v672 = reinterpret_cast<double *>(&v2[11534352ull]);
        double * v674;
        v674 = reinterpret_cast<double *>(&v2[11927568ull]);
        int * v676;
        v676 = reinterpret_cast<int *>(&v2[12320784ull]);
        v639.sync() ;
        int v678;
        v678 = threadIdx.x;
        int v679;
        v679 = blockIdx.x;
        int v680;
        v680 = v679 * 256;
        int v681;
        v681 = v678 + v680;
        bool v682;
        v682 = v681 == 0;
        if (v682){
            int v683;
            v683 = 0;
            int v684;
            v684 = 4;
            int v685;
            v685 = int_range_44(v684, v683, v641);
            v644[0] = v685;
        } else {
        }
        __syncwarp();
        int v686;
        v686 = threadIdx.x;
        bool v687;
        v687 = 0 <= v686;
        bool v688;
        v688 = v687 == false;
        if (v688){
            assert("The index needs to be zero or positive." && v687);
        } else {
        }
        int v690;
        v690 = v686 % 4;
        int v691;
        v691 = v686 / 4;
        int v692;
        v692 = v691 % 64;
        int v693;
        v693 = v691 / 64;
        bool v694;
        v694 = v693 < 1;
        bool v695;
        v695 = v694 == false;
        if (v695){
            assert("The last element of the projection dimensions needs to be greater than the index remainder." && v694);
        } else {
        }
        assert("Tensor range check" && 0 <= v693 && v693 < 1);
        assert("Tensor range check" && 0 <= v692 && v692 < 64);
        assert("Tensor range check" && 0 <= v690 && v690 < 4);
        int v697;
        v697 = 4 * v690;
        int v698;
        v698 = 16 * v692;
        int v699;
        v699 = v698 + v697;
        int v700;
        v700 = 65536 * v693;
        int v701;
        v701 = v700 + v699;
        assert("Tensor range check" && 0 <= v693 && v693 < 1);
        assert("Tensor range check" && 0 <= v692 && v692 < 64);
        assert("Tensor range check" && 0 <= v690 && v690 < 4);
        int v702;
        v702 = blockIdx.x;
        int v703;
        v703 = v702;
        while (while_method_23(v703)){
            bool v705;
            v705 = 0 <= v703;
            bool v706;
            v706 = v705 == false;
            if (v706){
                assert("The index needs to be zero or positive." && v705);
            } else {
            }
            int v708;
            v708 = v703 % 64;
            int v709;
            v709 = v703 / 64;
            bool v710;
            v710 = v709 < 4;
            bool v711;
            v711 = v710 == false;
            if (v711){
                assert("The last element of the projection dimensions needs to be greater than the index remainder." && v710);
            } else {
            }
            assert("Tensor range check" && 0 <= v709 && v709 < 4);
            assert("Tensor range check" && 0 <= v708 && v708 < 64);
            int v713;
            v713 = 1024 * v708;
            int v714;
            v714 = v713 + v701;
            int v715;
            v715 = 65536 * v709;
            int v716;
            v716 = v715 + v714;
            float v717[4];
            float v718[4];
            float v719[4];
            float v720[4];
            float v721[4];
            float v722[4];
            float v723[4];
            int v724[4];
            int v725;
            v725 = 0;
            while (while_method_6(v725)){
                assert("Tensor range check" && 0 <= v725 && v725 < 1);
                int v727;
                v727 = 4 * v725;
                assert("Tensor range check" && 0 <= v725 && v725 < 1);
                int v728;
                v728 = 16 * v725;
                int v729;
                v729 = v728 + v716;
                int4* v730;
                v730 = reinterpret_cast<int4*>(v646 + v729);
                int4* v731;
                v731 = reinterpret_cast<int4*>(v717 + v727);
                assert("Pointer alignment check" && (unsigned long long)(v730) % 4 == 0 && (unsigned long long)(v731) % 4 == 0);
                *v731 = *v730;
                int4* v732;
                v732 = reinterpret_cast<int4*>(v648 + v729);
                int4* v733;
                v733 = reinterpret_cast<int4*>(v718 + v727);
                assert("Pointer alignment check" && (unsigned long long)(v732) % 4 == 0 && (unsigned long long)(v733) % 4 == 0);
                *v733 = *v732;
                int4* v734;
                v734 = reinterpret_cast<int4*>(v650 + v729);
                int4* v735;
                v735 = reinterpret_cast<int4*>(v719 + v727);
                assert("Pointer alignment check" && (unsigned long long)(v734) % 4 == 0 && (unsigned long long)(v735) % 4 == 0);
                *v735 = *v734;
                int4* v736;
                v736 = reinterpret_cast<int4*>(v652 + v729);
                int4* v737;
                v737 = reinterpret_cast<int4*>(v720 + v727);
                assert("Pointer alignment check" && (unsigned long long)(v736) % 4 == 0 && (unsigned long long)(v737) % 4 == 0);
                *v737 = *v736;
                int4* v738;
                v738 = reinterpret_cast<int4*>(v654 + v729);
                int4* v739;
                v739 = reinterpret_cast<int4*>(v721 + v727);
                assert("Pointer alignment check" && (unsigned long long)(v738) % 4 == 0 && (unsigned long long)(v739) % 4 == 0);
                *v739 = *v738;
                int4* v740;
                v740 = reinterpret_cast<int4*>(v656 + v729);
                int4* v741;
                v741 = reinterpret_cast<int4*>(v722 + v727);
                assert("Pointer alignment check" && (unsigned long long)(v740) % 4 == 0 && (unsigned long long)(v741) % 4 == 0);
                *v741 = *v740;
                int4* v742;
                v742 = reinterpret_cast<int4*>(v658 + v729);
                int4* v743;
                v743 = reinterpret_cast<int4*>(v723 + v727);
                assert("Pointer alignment check" && (unsigned long long)(v742) % 4 == 0 && (unsigned long long)(v743) % 4 == 0);
                *v743 = *v742;
                v725 += 1 ;
            }
            int v744;
            v744 = 0;
            while (while_method_6(v744)){
                int v746;
                v746 = 0;
                while (while_method_3(v746)){
                    bool v748;
                    v748 = 0 <= v746;
                    bool v750;
                    if (v748){
                        bool v749;
                        v749 = v746 < 4;
                        v750 = v749;
                    } else {
                        v750 = false;
                    }
                    bool v751;
                    v751 = v750 == false;
                    if (v751){
                        assert("The indices should be inside the range of the dimension." && v750);
                    } else {
                    }
                    bool v753;
                    v753 = 0 <= v690;
                    bool v755;
                    if (v753){
                        bool v754;
                        v754 = v690 < 4;
                        v755 = v754;
                    } else {
                        v755 = false;
                    }
                    bool v756;
                    v756 = v755 == false;
                    if (v756){
                        assert("The indices should be inside the range of the dimension." && v755);
                    } else {
                    }
                    int v758;
                    v758 = v690 * 4;
                    int v759;
                    v759 = v746 + v758;
                    bool v760;
                    v760 = 0 <= v744;
                    bool v762;
                    if (v760){
                        bool v761;
                        v761 = v744 < 1;
                        v762 = v761;
                    } else {
                        v762 = false;
                    }
                    bool v763;
                    v763 = v762 == false;
                    if (v763){
                        assert("The indices should be inside the range of the dimension." && v762);
                    } else {
                    }
                    int v765;
                    v765 = v744 * 16;
                    int v766;
                    v766 = v759 + v765;
                    assert("Tensor range check" && 0 <= v744 && v744 < 1);
                    assert("Tensor range check" && 0 <= v746 && v746 < 4);
                    int v767;
                    v767 = 4 * v744;
                    int v768;
                    v768 = v767 + v746;
                    v724[v768] = v766;
                    v746 += 1 ;
                }
                v744 += 1 ;
            }
            bool v769;
            v769 = 0 <= v693;
            bool v770;
            v770 = v769 && v694;
            bool v771;
            v771 = v770 == false;
            if (v771){
                assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v770);
            } else {
            }
            bool v773;
            v773 = 0 <= v692;
            bool v775;
            if (v773){
                bool v774;
                v774 = v692 < 64;
                v775 = v774;
            } else {
                v775 = false;
            }
            bool v776;
            v776 = v775 == false;
            if (v776){
                assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v775);
            } else {
            }
            bool v778;
            v778 = 0 <= v709;
            bool v779;
            v779 = v778 && v710;
            bool v780;
            v780 = v779 == false;
            if (v780){
                assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v779);
            } else {
            }
            bool v782;
            v782 = 0 <= v708;
            bool v784;
            if (v782){
                bool v783;
                v783 = v708 < 64;
                v784 = v783;
            } else {
                v784 = false;
            }
            bool v785;
            v785 = v784 == false;
            if (v785){
                assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v784);
            } else {
            }
            int v787;
            v787 = v708 * 64;
            int v788;
            v788 = v709 + v693;
            int v789;
            v789 = v787 + v692;
            bool v790[4];
            int v791;
            v791 = 0;
            while (while_method_6(v791)){
                int v793;
                v793 = 0;
                while (while_method_3(v793)){
                    assert("Tensor range check" && 0 <= v791 && v791 < 1);
                    assert("Tensor range check" && 0 <= v793 && v793 < 4);
                    int v795;
                    v795 = 4 * v791;
                    int v796;
                    v796 = v795 + v793;
                    float v797;
                    v797 = v719[v796];
                    bool v798;
                    v798 = v797 == 0.0f;
                    bool v799;
                    v799 = v798 != true;
                    assert("Tensor range check" && 0 <= v791 && v791 < 1);
                    assert("Tensor range check" && 0 <= v793 && v793 < 4);
                    v790[v796] = v799;
                    v793 += 1 ;
                }
                v791 += 1 ;
            }
            bool v800;
            v800 = false;
            int v801;
            v801 = 0;
            while (while_method_6(v801)){
                int v803;
                v803 = 0;
                while (while_method_3(v803)){
                    assert("Tensor range check" && 0 <= v801 && v801 < 1);
                    assert("Tensor range check" && 0 <= v803 && v803 < 4);
                    int v805;
                    v805 = 4 * v801;
                    int v806;
                    v806 = v805 + v803;
                    bool v807;
                    v807 = v790[v806];
                    bool v808;
                    v808 = v800 || v807;
                    v800 = v808;
                    v803 += 1 ;
                }
                v801 += 1 ;
            }
            auto v809 = cooperative_groups::coalesced_threads();
            int v810;
            v810 = threadIdx.x;
            int v811;
            v811 = v810 / 4;
            auto v812 = cooperative_groups::labeled_partition(v809,v811);
            Closure8 v813{};
            bool v814;
            v814 = cooperative_groups::reduce(v812, v800, v813);
            if (v814){
                float v815[4];
                int v816;
                v816 = 0;
                while (while_method_6(v816)){
                    int v818;
                    v818 = 0;
                    while (while_method_3(v818)){
                        assert("Tensor range check" && 0 <= v816 && v816 < 1);
                        assert("Tensor range check" && 0 <= v818 && v818 < 4);
                        int v820;
                        v820 = 4 * v816;
                        int v821;
                        v821 = v820 + v818;
                        float v822;
                        v822 = v718[v821];
                        float v823;
                        v823 = v719[v821];
                        float v824;
                        v824 = v822 + v823;
                        bool v825;
                        v825 = 0.0f >= v824;
                        float v826;
                        if (v825){
                            v826 = 0.0f;
                        } else {
                            v826 = v824;
                        }
                        assert("Tensor range check" && 0 <= v816 && v816 < 1);
                        assert("Tensor range check" && 0 <= v818 && v818 < 4);
                        v815[v821] = v826;
                        v818 += 1 ;
                    }
                    v816 += 1 ;
                }
                float v827[4];
                int v828;
                v828 = 0;
                while (while_method_6(v828)){
                    int v830;
                    v830 = 0;
                    while (while_method_3(v830)){
                        assert("Tensor range check" && 0 <= v828 && v828 < 1);
                        assert("Tensor range check" && 0 <= v830 && v830 < 4);
                        int v832;
                        v832 = 4 * v828;
                        int v833;
                        v833 = v832 + v830;
                        float v834;
                        v834 = v815[v833];
                        bool v835;
                        v835 = 0.0f >= v834;
                        float v836;
                        if (v835){
                            v836 = 0.0f;
                        } else {
                            v836 = v834;
                        }
                        assert("Tensor range check" && 0 <= v828 && v828 < 1);
                        assert("Tensor range check" && 0 <= v830 && v830 < 4);
                        v827[v833] = v836;
                        v830 += 1 ;
                    }
                    v828 += 1 ;
                }
                float v837;
                v837 = 0.0f;
                int v838;
                v838 = 0;
                while (while_method_6(v838)){
                    int v840;
                    v840 = 0;
                    while (while_method_3(v840)){
                        assert("Tensor range check" && 0 <= v838 && v838 < 1);
                        assert("Tensor range check" && 0 <= v840 && v840 < 4);
                        int v842;
                        v842 = 4 * v838;
                        int v843;
                        v843 = v842 + v840;
                        float v844;
                        v844 = v827[v843];
                        float v845;
                        v845 = v837 + v844;
                        v837 = v845;
                        v840 += 1 ;
                    }
                    v838 += 1 ;
                }
                auto v846 = cooperative_groups::coalesced_threads();
                int v847;
                v847 = threadIdx.x;
                int v848;
                v848 = v847 / 4;
                auto v849 = cooperative_groups::labeled_partition(v846,v848);
                Closure1 v850{};
                float v851;
                v851 = cooperative_groups::reduce(v849, v837, v850);
                float v852[4];
                int v853;
                v853 = 0;
                while (while_method_6(v853)){
                    int v855;
                    v855 = 0;
                    while (while_method_3(v855)){
                        assert("Tensor range check" && 0 <= v853 && v853 < 1);
                        assert("Tensor range check" && 0 <= v855 && v855 < 4);
                        int v857;
                        v857 = 4 * v853;
                        int v858;
                        v858 = v857 + v855;
                        float v859;
                        v859 = v827[v858];
                        bool v860;
                        v860 = v851 == 0.0f;
                        bool v861;
                        v861 = v860 != true;
                        float v863;
                        if (v861){
                            float v862;
                            v862 = v859 / v851;
                            v863 = v862;
                        } else {
                            v863 = 0.0625f;
                        }
                        assert("Tensor range check" && 0 <= v853 && v853 < 1);
                        assert("Tensor range check" && 0 <= v855 && v855 < 4);
                        v852[v858] = v863;
                        v855 += 1 ;
                    }
                    v853 += 1 ;
                }
                float v864[4];
                int v865;
                v865 = 0;
                while (while_method_6(v865)){
                    int v867;
                    v867 = 0;
                    while (while_method_3(v867)){
                        assert("Tensor range check" && 0 <= v865 && v865 < 1);
                        assert("Tensor range check" && 0 <= v867 && v867 < 4);
                        int v869;
                        v869 = 4 * v865;
                        int v870;
                        v870 = v869 + v867;
                        float v871;
                        v871 = v717[v870];
                        float v872;
                        v872 = v852[v870];
                        float v873;
                        v873 = v871 + v872;
                        assert("Tensor range check" && 0 <= v865 && v865 < 1);
                        assert("Tensor range check" && 0 <= v867 && v867 < 4);
                        v864[v870] = v873;
                        v867 += 1 ;
                    }
                    v865 += 1 ;
                }
                float v874[4];
                int v875;
                v875 = 0;
                while (while_method_6(v875)){
                    int v877;
                    v877 = 0;
                    while (while_method_3(v877)){
                        assert("Tensor range check" && 0 <= v875 && v875 < 1);
                        assert("Tensor range check" && 0 <= v877 && v877 < 4);
                        int v879;
                        v879 = 4 * v875;
                        int v880;
                        v880 = v879 + v877;
                        float v881;
                        v881 = v864[v880];
                        float v882;
                        v882 = -v881;
                        bool v883;
                        v883 = v881 >= v882;
                        float v884;
                        if (v883){
                            v884 = v881;
                        } else {
                            v884 = v882;
                        }
                        assert("Tensor range check" && 0 <= v875 && v875 < 1);
                        assert("Tensor range check" && 0 <= v877 && v877 < 4);
                        v874[v880] = v884;
                        v877 += 1 ;
                    }
                    v875 += 1 ;
                }
                float v885;
                v885 = 0.0f;
                int v886;
                v886 = 0;
                while (while_method_6(v886)){
                    int v888;
                    v888 = 0;
                    while (while_method_3(v888)){
                        assert("Tensor range check" && 0 <= v886 && v886 < 1);
                        assert("Tensor range check" && 0 <= v888 && v888 < 4);
                        int v890;
                        v890 = 4 * v886;
                        int v891;
                        v891 = v890 + v888;
                        float v892;
                        v892 = v874[v891];
                        float v893;
                        v893 = v885 + v892;
                        v885 = v893;
                        v888 += 1 ;
                    }
                    v886 += 1 ;
                }
                auto v894 = cooperative_groups::coalesced_threads();
                int v895;
                v895 = threadIdx.x;
                int v896;
                v896 = v895 / 4;
                auto v897 = cooperative_groups::labeled_partition(v894,v896);
                float v898;
                v898 = cooperative_groups::reduce(v897, v885, v850);
                bool v899;
                v899 = v898 > 100.0f;
                float v901;
                if (v899){
                    float v900;
                    v900 = 100.0f / v898;
                    v901 = v900;
                } else {
                    v901 = 1.0f;
                }
                float v902[4];
                int v903;
                v903 = 0;
                while (while_method_6(v903)){
                    int v905;
                    v905 = 0;
                    while (while_method_3(v905)){
                        assert("Tensor range check" && 0 <= v903 && v903 < 1);
                        assert("Tensor range check" && 0 <= v905 && v905 < 4);
                        int v907;
                        v907 = 4 * v903;
                        int v908;
                        v908 = v907 + v905;
                        float v909;
                        v909 = v874[v908];
                        float v910;
                        v910 = v901 * v909;
                        assert("Tensor range check" && 0 <= v903 && v903 < 1);
                        assert("Tensor range check" && 0 <= v905 && v905 < 4);
                        v902[v908] = v910;
                        v905 += 1 ;
                    }
                    v903 += 1 ;
                }
                float v911[4];
                float v912[4];
                int v913;
                v913 = 0;
                while (while_method_6(v913)){
                    int v915;
                    v915 = 0;
                    while (while_method_3(v915)){
                        assert("Tensor range check" && 0 <= v913 && v913 < 1);
                        assert("Tensor range check" && 0 <= v915 && v915 < 4);
                        int v917;
                        v917 = 4 * v913;
                        int v918;
                        v918 = v917 + v915;
                        float v919;
                        v919 = v717[v918];
                        float v920;
                        v920 = v718[v918];
                        float v921;
                        v921 = v719[v918];
                        float v922;
                        v922 = v720[v918];
                        float v923;
                        v923 = v721[v918];
                        float v924;
                        v924 = v722[v918];
                        float v925;
                        v925 = v723[v918];
                        float v926;
                        v926 = v922 + v924;
                        float v927;
                        v927 = v923 + v925;
                        assert("Tensor range check" && 0 <= v913 && v913 < 1);
                        assert("Tensor range check" && 0 <= v915 && v915 < 4);
                        v911[v918] = v926;
                        v912[v918] = v927;
                        v915 += 1 ;
                    }
                    v913 += 1 ;
                }
                int v928;
                v928 = 0;
                while (while_method_6(v928)){
                    int v930;
                    v930 = 0;
                    while (while_method_3(v930)){
                        assert("Tensor range check" && 0 <= v928 && v928 < 1);
                        assert("Tensor range check" && 0 <= v930 && v930 < 4);
                        int v932;
                        v932 = 4 * v928;
                        int v933;
                        v933 = v932 + v930;
                        float v934;
                        v934 = v902[v933];
                        float v935;
                        v935 = v815[v933];
                        float v936;
                        v936 = v911[v933];
                        float v937;
                        v937 = v912[v933];
                        assert("Tensor range check" && 0 <= v928 && v928 < 1);
                        assert("Tensor range check" && 0 <= v930 && v930 < 4);
                        v717[v933] = v934;
                        v718[v933] = v935;
                        v719[v933] = 0.0f;
                        v720[v933] = v936;
                        v721[v933] = v937;
                        v722[v933] = 0.0f;
                        v723[v933] = 0.0f;
                        v930 += 1 ;
                    }
                    v928 += 1 ;
                }
            } else {
            }
            assert("Tensor range check" && 0 <= v709 && v709 < 4);
            assert("Tensor range check" && 0 <= v708 && v708 < 64);
            int v938;
            v938 = 0;
            while (while_method_6(v938)){
                assert("Tensor range check" && 0 <= v938 && v938 < 1);
                int v940;
                v940 = 16 * v938;
                int v941;
                v941 = v940 + v716;
                assert("Tensor range check" && 0 <= v938 && v938 < 1);
                int v942;
                v942 = 4 * v938;
                int4* v943;
                v943 = reinterpret_cast<int4*>(v717 + v942);
                int4* v944;
                v944 = reinterpret_cast<int4*>(v646 + v941);
                assert("Pointer alignment check" && (unsigned long long)(v943) % 4 == 0 && (unsigned long long)(v944) % 4 == 0);
                *v944 = *v943;
                int4* v945;
                v945 = reinterpret_cast<int4*>(v718 + v942);
                int4* v946;
                v946 = reinterpret_cast<int4*>(v648 + v941);
                assert("Pointer alignment check" && (unsigned long long)(v945) % 4 == 0 && (unsigned long long)(v946) % 4 == 0);
                *v946 = *v945;
                int4* v947;
                v947 = reinterpret_cast<int4*>(v719 + v942);
                int4* v948;
                v948 = reinterpret_cast<int4*>(v650 + v941);
                assert("Pointer alignment check" && (unsigned long long)(v947) % 4 == 0 && (unsigned long long)(v948) % 4 == 0);
                *v948 = *v947;
                int4* v949;
                v949 = reinterpret_cast<int4*>(v720 + v942);
                int4* v950;
                v950 = reinterpret_cast<int4*>(v652 + v941);
                assert("Pointer alignment check" && (unsigned long long)(v949) % 4 == 0 && (unsigned long long)(v950) % 4 == 0);
                *v950 = *v949;
                int4* v951;
                v951 = reinterpret_cast<int4*>(v721 + v942);
                int4* v952;
                v952 = reinterpret_cast<int4*>(v654 + v941);
                assert("Pointer alignment check" && (unsigned long long)(v951) % 4 == 0 && (unsigned long long)(v952) % 4 == 0);
                *v952 = *v951;
                int4* v953;
                v953 = reinterpret_cast<int4*>(v722 + v942);
                int4* v954;
                v954 = reinterpret_cast<int4*>(v656 + v941);
                assert("Pointer alignment check" && (unsigned long long)(v953) % 4 == 0 && (unsigned long long)(v954) % 4 == 0);
                *v954 = *v953;
                int4* v955;
                v955 = reinterpret_cast<int4*>(v723 + v942);
                int4* v956;
                v956 = reinterpret_cast<int4*>(v658 + v941);
                assert("Pointer alignment check" && (unsigned long long)(v955) % 4 == 0 && (unsigned long long)(v956) % 4 == 0);
                *v956 = *v955;
                v938 += 1 ;
            }
            v703 += 24 ;
        }
        v639.sync() ;
        v34 += 1 ;
    }
    cooperative_groups::grid_group & v957 = v27.v1;
    cooperative_groups::grid_group & v958 = v957;
    int v959;
    v959 = threadIdx.x;
    int v960;
    v960 = blockIdx.x;
    int v961;
    v961 = v960 * 256;
    int v962;
    v962 = v959 + v961;
    int v963;
    v963 = v962;
    while (while_method_3(v963)){
        bool v965;
        v965 = 0 <= v963;
        bool v966;
        v966 = v965 == false;
        if (v966){
            assert("The index needs to be zero or positive." && v965);
        } else {
        }
        int v968;
        v968 = v963 % 1;
        bool v969;
        v969 = v963 < 4;
        bool v970;
        v970 = v969 == false;
        if (v970){
            assert("The last element of the projection dimensions needs to be greater than the index remainder." && v969);
        } else {
        }
        assert("Tensor range check" && 0 <= v963 && v963 < 4);
        assert("Tensor range check" && 0 <= v968 && v968 < 1);
        int v972;
        v972 = 4 * v968;
        int v973;
        v973 = 4 * v963;
        int v974;
        v974 = v973 + v972;
        assert("Tensor range check" && 0 <= v963 && v963 < 4);
        assert("Tensor range check" && 0 <= v968 && v968 < 1);
        float v975[4];
        float v976[4];
        float v977[4];
        int4* v978;
        v978 = reinterpret_cast<int4*>(v4 + v974);
        int4* v979;
        v979 = reinterpret_cast<int4*>(v975 + 0);
        assert("Pointer alignment check" && (unsigned long long)(v978) % 4 == 0 && (unsigned long long)(v979) % 4 == 0);
        *v979 = *v978;
        int4* v980;
        v980 = reinterpret_cast<int4*>(v5 + v974);
        int4* v981;
        v981 = reinterpret_cast<int4*>(v976 + 0);
        assert("Pointer alignment check" && (unsigned long long)(v980) % 4 == 0 && (unsigned long long)(v981) % 4 == 0);
        *v981 = *v980;
        // Pushing the loop unrolling to: 0
        int v982;
        v982 = 0;
        #pragma unroll
        while (while_method_3(v982)){
            assert("Tensor range check" && 0 <= v982 && v982 < 4);
            float v984;
            v984 = v975[v982];
            float v985;
            v985 = v976[v982];
            bool v986;
            v986 = v985 == 0.0f;
            bool v987;
            v987 = v986 != true;
            float v989;
            if (v987){
                float v988;
                v988 = v984 / v985;
                v989 = v988;
            } else {
                v989 = 0.0f;
            }
            assert("Tensor range check" && 0 <= v982 && v982 < 4);
            v977[v982] = v989;
            v982 += 1 ;
        }
        // Poping the loop unrolling to: 0
        int4* v990;
        v990 = reinterpret_cast<int4*>(v977 + 0);
        int4* v991;
        v991 = reinterpret_cast<int4*>(v6 + v974);
        assert("Pointer alignment check" && (unsigned long long)(v990) % 4 == 0 && (unsigned long long)(v991) % 4 == 0);
        *v991 = *v990;
        v963 += 6144 ;
    }
    v958.sync() ;
    return ;
}
extern "C" __global__ void entry2(unsigned char * v0, unsigned long long v1, unsigned char * v2, unsigned long long v3, float * v4, float * v5, float * v6) {
    auto v7 = cooperative_groups::this_grid();
    unsigned long long v8;
    v8 = clock64();
    int v9;
    v9 = threadIdx.x;
    int v10;
    v10 = blockIdx.x;
    int v11;
    v11 = v10 * 256;
    int v12;
    v12 = v9 + v11;
    unsigned long long v13;
    v13 = (unsigned long long)v12;
    curandStatePhilox4_32_10_t v14;
    curand_init(v8,v13,0ull,&v14);
    static_array<Union2,2> v15;
    Union2 v17;
    v17 = Union2{Union2_2{}};
    v15[0] = v17;
    Union2 v19;
    v19 = Union2{Union2_2{}};
    v15[1] = v19;
    static_array_list<Union6,128> v21;
    v21 = static_array_list<Union6,128>{};
    static_array<float,2> v23;
    v23[0] = 0.0f;
    v23[1] = 0.0f;
    cooperative_groups::grid_group & v25 = v7;
    curandStatePhilox4_32_10_t & v26 = v14;
    StackMut1 v27{4503599627370495ull, v25, v21, v15, v23, v26};
    bool v28;
    v28 = 12419088ull == v3;
    bool v29;
    v29 = v28 == false;
    if (v29){
        assert("The params needs to have matching offsets." && v28);
    } else {
    }
    bool v31;
    v31 = 204570624ull == v1;
    bool v32;
    v32 = v31 == false;
    if (v32){
        assert("The outputs needs to have matching offsets." && v31);
    } else {
    }
    int v34;
    v34 = 0;
    while (while_method_3(v34)){
        int v36;
        v36 = 0;
        while (while_method_10(v36)){
            Union4 v38;
            v38 = Union4{Union4_2{}};
            method_84(v0, v2, v27, v38);
            static_array<float,2> & v39 = v27.v4;
            unsigned int * v40;
            v40 = reinterpret_cast<unsigned int *>(&v0[53477376ull]);
            int * v42;
            v42 = reinterpret_cast<int *>(&v2[4194304ull]);
            float * v44;
            v44 = reinterpret_cast<float *>(&v2[4194320ull]);
            float * v46;
            v46 = reinterpret_cast<float *>(&v2[5242896ull]);
            float * v48;
            v48 = reinterpret_cast<float *>(&v2[6291472ull]);
            float * v50;
            v50 = reinterpret_cast<float *>(&v2[7340048ull]);
            float * v52;
            v52 = reinterpret_cast<float *>(&v2[8388624ull]);
            float * v54;
            v54 = reinterpret_cast<float *>(&v2[9437200ull]);
            float * v56;
            v56 = reinterpret_cast<float *>(&v2[10485776ull]);
            int * v58;
            v58 = reinterpret_cast<int *>(&v0[53575680ull]);
            float * v60;
            v60 = reinterpret_cast<float *>(&v0[66158592ull]);
            int * v62;
            v62 = reinterpret_cast<int *>(&v0[78741504ull]);
            int * v64;
            v64 = reinterpret_cast<int *>(&v0[91324416ull]);
            double * v66;
            v66 = reinterpret_cast<double *>(&v0[103907328ull]);
            double * v68;
            v68 = reinterpret_cast<double *>(&v0[154238976ull]);
            double * v70;
            v70 = reinterpret_cast<double *>(&v2[11534352ull]);
            double * v72;
            v72 = reinterpret_cast<double *>(&v2[11927568ull]);
            int * v74;
            v74 = reinterpret_cast<int *>(&v2[12320784ull]);
            int v76;
            v76 = 0;
            while (while_method_3(v76)){
                int v78;
                v78 = threadIdx.x;
                int v79;
                v79 = blockIdx.x;
                int v80;
                v80 = v79 * 256;
                int v81;
                v81 = v78 + v80;
                float v82[2];
                int v83;
                v83 = 0;
                while (while_method_0(v83)){
                    float v85;
                    v85 = v39[v83];
                    v82[v83] = v85;
                    v83 += 1 ;
                }
                assert("Tensor range check" && 0 <= v76 && v76 < 4);
                assert("Tensor range check" && 0 <= v81 && v81 < 6144);
                int v87;
                v87 = 6144 * v76;
                int v88;
                v88 = v87 + v81;
                int v89;
                v89 = v74[v88];
                int v90;
                v90 = v89;
                while (while_method_22(v90)){
                    v90 -= 1 ;
                    assert("Tensor range check" && 0 <= v76 && v76 < 4);
                    assert("Tensor range check" && 0 <= v90 && v90 < 128);
                    assert("Tensor range check" && 0 <= v81 && v81 < 6144);
                    int v92;
                    v92 = 6144 * v90;
                    int v93;
                    v93 = v92 + v81;
                    int v94;
                    v94 = 786432 * v76;
                    int v95;
                    v95 = v94 + v93;
                    int v96;
                    v96 = v58[v95];
                    float v97;
                    v97 = v60[v95];
                    int v98;
                    v98 = v62[v95];
                    int v99;
                    v99 = v64[v95];
                    assert("Tensor range check" && 0 <= v98 && v98 < 2);
                    float v100;
                    v100 = v82[v98];
                    assert("Tensor range check" && 0 <= v76 && v76 < 4);
                    int v101;
                    v101 = 65536 * v76;
                    assert("Tensor range check" && 0 <= v99 && v99 < 4096);
                    int v102;
                    v102 = 16 * v99;
                    int v103;
                    v103 = v102 + v101;
                    float * v104;
                    v104 = v44+v103;
                    float * v106;
                    v106 = v46+v103;
                    float * v108;
                    v108 = v48+v103;
                    float * v110;
                    v110 = v50+v103;
                    float * v112;
                    v112 = v52+v103;
                    float * v114;
                    v114 = v54+v103;
                    float * v116;
                    v116 = v56+v103;
                    assert("Tensor range check" && 0 <= v76 && v76 < 4);
                    int v118;
                    v118 = 1572864 * v76;
                    assert("Tensor range check" && 0 <= v90 && v90 < 128);
                    int v119;
                    v119 = 12288 * v90;
                    int v120;
                    v120 = v119 + v118;
                    assert("Tensor range check" && 0 <= v81 && v81 < 6144);
                    int v121;
                    v121 = 2 * v81;
                    int v122;
                    v122 = v121 + v120;
                    double v123[2];
                    int v124;
                    v124 = 0;
                    while (while_method_0(v124)){
                        assert("Tensor range check" && 0 <= v124 && v124 < 2);
                        int v126;
                        v126 = v124 + v122;
                        double v127;
                        v127 = v66[v126];
                        bool v128;
                        v128 = v98 == v124;
                        double v129;
                        if (v128){
                            v129 = 0.0;
                        } else {
                            v129 = v127;
                        }
                        assert("Tensor range check" && 0 <= v124 && v124 < 2);
                        v123[v124] = v129;
                        v124 += 1 ;
                    }
                    double v130;
                    v130 = 0.0;
                    int v131;
                    v131 = 0;
                    while (while_method_0(v131)){
                        assert("Tensor range check" && 0 <= v131 && v131 < 2);
                        double v133;
                        v133 = v123[v131];
                        double v134;
                        v134 = v130 + v133;
                        v130 = v134;
                        v131 += 1 ;
                    }
                    double v135;
                    v135 = 0.0;
                    int v136;
                    v136 = 0;
                    while (while_method_0(v136)){
                        assert("Tensor range check" && 0 <= v136 && v136 < 2);
                        int v138;
                        v138 = v136 + v122;
                        double v139;
                        v139 = v68[v138];
                        double v140;
                        v140 = v135 + v139;
                        v135 = v140;
                        v136 += 1 ;
                    }
                    double v141;
                    v141 = v130 - v135;
                    double v142;
                    v142 = exp(v141);
                    float v143;
                    v143 = (float)v142;
                    float v144;
                    v144 = v100 * v143;
                    assert("Tensor range check" && 0 <= v96 && v96 < 16);
                    float * v145;
                    v145 = v114+v96;
                    float * v147;
                    v147 = v116+v96;
                    float v149;
                    v149 = atomicAdd(v145,v144);
                    float v150;
                    v150 = atomicAdd(v147,v143);
                    float * v151;
                    v151 = v106+0;
                    float * v153;
                    v153 = v110+0;
                    float * v155;
                    v155 = v112+0;
                    int v157;
                    v157 = sizeof(float *);
                    unsigned long long v158;
                    v158 = (unsigned long long)v157;
                    unsigned long long v159;
                    v159 = 256ull * v158;
                    unsigned long long v160;
                    v160 = 4096ull + v159;
                    unsigned long long v161;
                    v161 = v160 + 16ull;
                    unsigned long long v162;
                    v162 = v161 - 1ull;
                    unsigned long long v163;
                    v163 = v162 % 16ull;
                    unsigned long long v164;
                    v164 = v162 - v163;
                    unsigned long long v165;
                    v165 = v164 + v159;
                    unsigned long long v166;
                    v166 = v165 + 16ull;
                    unsigned long long v167;
                    v167 = v166 - 1ull;
                    unsigned long long v168;
                    v168 = v167 % 16ull;
                    unsigned long long v169;
                    v169 = v167 - v168;
                    unsigned long long v170;
                    v170 = v169 + v159;
                    unsigned long long v171;
                    v171 = v170 + 16ull;
                    unsigned long long v172;
                    v172 = v171 - 1ull;
                    unsigned long long v173;
                    v173 = v172 % 16ull;
                    unsigned long long v174;
                    v174 = v172 - v173;
                    unsigned long long v175;
                    v175 = v174 + v159;
                    unsigned long long v176;
                    v176 = v175 + 16ull;
                    unsigned long long v177;
                    v177 = v176 - 1ull;
                    unsigned long long v178;
                    v178 = v177 % 16ull;
                    unsigned long long v179;
                    v179 = v177 - v178;
                    unsigned long long v180;
                    v180 = v179 + 1024ull;
                    bool v181;
                    v181 = v180 <= 98304ull;
                    bool v182;
                    v182 = v181 == false;
                    if (v182){
                        assert("The dynamic shared memory is insufficient to allocate the tensor." && v181);
                    } else {
                    }
                    extern __shared__ unsigned char v184[];
                    bool v185;
                    v185 = v180 <= v180;
                    bool v186;
                    v186 = v185 == false;
                    if (v186){
                        assert("The length of the partition has to be less than or equal to the length of the base array." && v185);
                    } else {
                    }
                    float * v188;
                    v188 = reinterpret_cast<float *>(&v184[0ull]);
                    int * v190;
                    v190 = reinterpret_cast<int *>(&v184[1024ull]);
                    float * v192;
                    v192 = reinterpret_cast<float *>(&v184[2048ull]);
                    float * v194;
                    v194 = reinterpret_cast<float *>(&v184[3072ull]);
                    float * * v196;
                    v196 = reinterpret_cast<float * *>(&v184[4096ull]);
                    float * * v198;
                    v198 = reinterpret_cast<float * *>(&v184[v164]);
                    float * * v200;
                    v200 = reinterpret_cast<float * *>(&v184[v169]);
                    float * * v202;
                    v202 = reinterpret_cast<float * *>(&v184[v174]);
                    float * v204;
                    v204 = reinterpret_cast<float *>(&v184[v179]);
                    int v206;
                    v206 = threadIdx.x;
                    assert("Tensor range check" && 0 <= v206 && v206 < 256);
                    v188[v206] = v97;
                    v190[v206] = v96;
                    v192[v206] = v100;
                    v194[v206] = v143;
                    v196[v206] = v108;
                    v198[v206] = v151;
                    v200[v206] = v153;
                    v202[v206] = v155;
                    asm("barrier.cta.sync %0;" :: "r"(0));
                    bool v207;
                    v207 = 0 <= v206;
                    bool v208;
                    v208 = v207 == false;
                    if (v208){
                        assert("The index needs to be zero or positive." && v207);
                    } else {
                    }
                    int v210;
                    v210 = v206 % 4;
                    int v211;
                    v211 = v206 / 4;
                    bool v212;
                    v212 = v211 < 64;
                    bool v213;
                    v213 = v212 == false;
                    if (v213){
                        assert("The last element of the projection dimensions needs to be greater than the index remainder." && v212);
                    } else {
                    }
                    assert("Tensor range check" && 0 <= v211 && v211 < 64);
                    int v215;
                    v215 = 0;
                    while (while_method_3(v215)){
                        bool v217;
                        v217 = 0 <= v211;
                        bool v218;
                        v218 = v217 && v212;
                        bool v219;
                        v219 = v218 == false;
                        if (v219){
                            assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v218);
                        } else {
                        }
                        bool v221;
                        v221 = 0 <= v215;
                        bool v223;
                        if (v221){
                            bool v222;
                            v222 = v215 < 4;
                            v223 = v222;
                        } else {
                            v223 = false;
                        }
                        bool v224;
                        v224 = v223 == false;
                        if (v224){
                            assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v223);
                        } else {
                        }
                        int v226;
                        v226 = v215 * 64;
                        int v227;
                        v227 = v226 + v211;
                        assert("Tensor range check" && 0 <= v215 && v215 < 4);
                        int v228;
                        v228 = 64 * v215;
                        int v229;
                        v229 = v228 + v211;
                        float v230;
                        v230 = v188[v229];
                        int v231;
                        v231 = v190[v229];
                        float v232;
                        v232 = v192[v229];
                        float v233;
                        v233 = v194[v229];
                        float * v234;
                        v234 = v196[v229];
                        float * v235;
                        v235 = v198[v229];
                        float * v236;
                        v236 = v200[v229];
                        float * v237;
                        v237 = v202[v229];
                        int v238;
                        v238 = blockIdx.x;
                        int v239;
                        v239 = v238 * 256;
                        int v240;
                        v240 = v239 + v227;
                        assert("Tensor range check" && 0 <= v210 && v210 < 4);
                        int v241;
                        v241 = 4 * v210;
                        float v242[4];
                        float v243[4];
                        float v244[4];
                        int v245[4];
                        int v246;
                        v246 = 0;
                        while (while_method_6(v246)){
                            assert("Tensor range check" && 0 <= v246 && v246 < 1);
                            int v248;
                            v248 = 4 * v246;
                            assert("Tensor range check" && 0 <= v246 && v246 < 1);
                            int v249;
                            v249 = 16 * v246;
                            int v250;
                            v250 = v249 + v241;
                            int4* v251;
                            v251 = reinterpret_cast<int4*>(v235 + v250);
                            int4* v252;
                            v252 = reinterpret_cast<int4*>(v242 + v248);
                            assert("Pointer alignment check" && (unsigned long long)(v251) % 4 == 0 && (unsigned long long)(v252) % 4 == 0);
                            *v252 = *v251;
                            int4* v253;
                            v253 = reinterpret_cast<int4*>(v236 + v250);
                            int4* v254;
                            v254 = reinterpret_cast<int4*>(v243 + v248);
                            assert("Pointer alignment check" && (unsigned long long)(v253) % 4 == 0 && (unsigned long long)(v254) % 4 == 0);
                            *v254 = *v253;
                            int4* v255;
                            v255 = reinterpret_cast<int4*>(v237 + v250);
                            int4* v256;
                            v256 = reinterpret_cast<int4*>(v244 + v248);
                            assert("Pointer alignment check" && (unsigned long long)(v255) % 4 == 0 && (unsigned long long)(v256) % 4 == 0);
                            *v256 = *v255;
                            v246 += 1 ;
                        }
                        int v257;
                        v257 = 0;
                        while (while_method_6(v257)){
                            int v259;
                            v259 = 0;
                            while (while_method_3(v259)){
                                bool v261;
                                v261 = 0 <= v259;
                                bool v263;
                                if (v261){
                                    bool v262;
                                    v262 = v259 < 4;
                                    v263 = v262;
                                } else {
                                    v263 = false;
                                }
                                bool v264;
                                v264 = v263 == false;
                                if (v264){
                                    assert("The indices should be inside the range of the dimension." && v263);
                                } else {
                                }
                                bool v266;
                                v266 = 0 <= v210;
                                bool v268;
                                if (v266){
                                    bool v267;
                                    v267 = v210 < 4;
                                    v268 = v267;
                                } else {
                                    v268 = false;
                                }
                                bool v269;
                                v269 = v268 == false;
                                if (v269){
                                    assert("The indices should be inside the range of the dimension." && v268);
                                } else {
                                }
                                int v271;
                                v271 = v210 * 4;
                                int v272;
                                v272 = v259 + v271;
                                bool v273;
                                v273 = 0 <= v257;
                                bool v275;
                                if (v273){
                                    bool v274;
                                    v274 = v257 < 1;
                                    v275 = v274;
                                } else {
                                    v275 = false;
                                }
                                bool v276;
                                v276 = v275 == false;
                                if (v276){
                                    assert("The indices should be inside the range of the dimension." && v275);
                                } else {
                                }
                                int v278;
                                v278 = v257 * 16;
                                int v279;
                                v279 = v272 + v278;
                                assert("Tensor range check" && 0 <= v257 && v257 < 1);
                                assert("Tensor range check" && 0 <= v259 && v259 < 4);
                                int v280;
                                v280 = 4 * v257;
                                int v281;
                                v281 = v280 + v259;
                                v245[v281] = v279;
                                v259 += 1 ;
                            }
                            v257 += 1 ;
                        }
                        float v282[4];
                        int v283;
                        v283 = 0;
                        while (while_method_6(v283)){
                            int v285;
                            v285 = 0;
                            while (while_method_3(v285)){
                                assert("Tensor range check" && 0 <= v283 && v283 < 1);
                                assert("Tensor range check" && 0 <= v285 && v285 < 4);
                                int v287;
                                v287 = 4 * v283;
                                int v288;
                                v288 = v287 + v285;
                                float v289;
                                v289 = v243[v288];
                                float v290;
                                v290 = v244[v288];
                                bool v291;
                                v291 = v290 == 0.0f;
                                bool v292;
                                v292 = v291 != true;
                                float v294;
                                if (v292){
                                    float v293;
                                    v293 = v289 / v290;
                                    v294 = v293;
                                } else {
                                    v294 = 0.0f;
                                }
                                assert("Tensor range check" && 0 <= v283 && v283 < 1);
                                assert("Tensor range check" && 0 <= v285 && v285 < 4);
                                v282[v288] = v294;
                                v285 += 1 ;
                            }
                            v283 += 1 ;
                        }
                        bool v295[4];
                        int v296;
                        v296 = 0;
                        while (while_method_6(v296)){
                            int v298;
                            v298 = 0;
                            while (while_method_3(v298)){
                                assert("Tensor range check" && 0 <= v296 && v296 < 1);
                                assert("Tensor range check" && 0 <= v298 && v298 < 4);
                                int v300;
                                v300 = 4 * v296;
                                int v301;
                                v301 = v300 + v298;
                                float v302;
                                v302 = v242[v301];
                                int v303;
                                v303 = v245[v301];
                                bool v304;
                                v304 = v303 < 11;
                                assert("Tensor range check" && 0 <= v296 && v296 < 1);
                                assert("Tensor range check" && 0 <= v298 && v298 < 4);
                                v295[v301] = v304;
                                v298 += 1 ;
                            }
                            v296 += 1 ;
                        }
                        float v305[4];
                        int v306;
                        v306 = 0;
                        while (while_method_6(v306)){
                            int v308;
                            v308 = 0;
                            while (while_method_3(v308)){
                                assert("Tensor range check" && 0 <= v306 && v306 < 1);
                                assert("Tensor range check" && 0 <= v308 && v308 < 4);
                                int v310;
                                v310 = 4 * v306;
                                int v311;
                                v311 = v310 + v308;
                                float v312;
                                v312 = v242[v311];
                                bool v313;
                                v313 = v295[v311];
                                float v316;
                                if (v313){
                                    bool v314;
                                    v314 = 0.0f >= v312;
                                    if (v314){
                                        v316 = 0.0f;
                                    } else {
                                        v316 = v312;
                                    }
                                } else {
                                    v316 = 0.0f;
                                }
                                assert("Tensor range check" && 0 <= v306 && v306 < 1);
                                assert("Tensor range check" && 0 <= v308 && v308 < 4);
                                v305[v311] = v316;
                                v308 += 1 ;
                            }
                            v306 += 1 ;
                        }
                        float v317;
                        v317 = 0.0f;
                        int v318;
                        v318 = 0;
                        while (while_method_6(v318)){
                            int v320;
                            v320 = 0;
                            while (while_method_3(v320)){
                                assert("Tensor range check" && 0 <= v318 && v318 < 1);
                                assert("Tensor range check" && 0 <= v320 && v320 < 4);
                                int v322;
                                v322 = 4 * v318;
                                int v323;
                                v323 = v322 + v320;
                                float v324;
                                v324 = v305[v323];
                                float v325;
                                v325 = v317 + v324;
                                v317 = v325;
                                v320 += 1 ;
                            }
                            v318 += 1 ;
                        }
                        auto v326 = cooperative_groups::coalesced_threads();
                        int v327;
                        v327 = threadIdx.x;
                        int v328;
                        v328 = v327 / 4;
                        auto v329 = cooperative_groups::labeled_partition(v326,v328);
                        Closure1 v330{};
                        float v331;
                        v331 = cooperative_groups::reduce(v329, v317, v330);
                        int v332[4];
                        int v333;
                        v333 = 0;
                        while (while_method_6(v333)){
                            int v335;
                            v335 = 0;
                            while (while_method_3(v335)){
                                assert("Tensor range check" && 0 <= v333 && v333 < 1);
                                assert("Tensor range check" && 0 <= v335 && v335 < 4);
                                int v337;
                                v337 = 4 * v333;
                                int v338;
                                v338 = v337 + v335;
                                bool v339;
                                v339 = v295[v338];
                                int v340;
                                if (v339){
                                    v340 = 1;
                                } else {
                                    v340 = 0;
                                }
                                assert("Tensor range check" && 0 <= v333 && v333 < 1);
                                assert("Tensor range check" && 0 <= v335 && v335 < 4);
                                v332[v338] = v340;
                                v335 += 1 ;
                            }
                            v333 += 1 ;
                        }
                        int v341;
                        v341 = 0;
                        int v342;
                        v342 = 0;
                        while (while_method_6(v342)){
                            int v344;
                            v344 = 0;
                            while (while_method_3(v344)){
                                assert("Tensor range check" && 0 <= v342 && v342 < 1);
                                assert("Tensor range check" && 0 <= v344 && v344 < 4);
                                int v346;
                                v346 = 4 * v342;
                                int v347;
                                v347 = v346 + v344;
                                int v348;
                                v348 = v332[v347];
                                int v349;
                                v349 = v341 + v348;
                                v341 = v349;
                                v344 += 1 ;
                            }
                            v342 += 1 ;
                        }
                        auto v350 = cooperative_groups::coalesced_threads();
                        int v351;
                        v351 = threadIdx.x;
                        int v352;
                        v352 = v351 / 4;
                        auto v353 = cooperative_groups::labeled_partition(v350,v352);
                        Closure2 v354{};
                        int v355;
                        v355 = cooperative_groups::reduce(v353, v341, v354);
                        float v356;
                        v356 = (float)v355;
                        float v357;
                        v357 = 1.0f / v356;
                        float v358[4];
                        int v359;
                        v359 = 0;
                        while (while_method_6(v359)){
                            int v361;
                            v361 = 0;
                            while (while_method_3(v361)){
                                assert("Tensor range check" && 0 <= v359 && v359 < 1);
                                assert("Tensor range check" && 0 <= v361 && v361 < 4);
                                int v363;
                                v363 = 4 * v359;
                                int v364;
                                v364 = v363 + v361;
                                float v365;
                                v365 = v305[v364];
                                bool v366;
                                v366 = v295[v364];
                                bool v367;
                                v367 = v366 == false;
                                float v372;
                                if (v367){
                                    v372 = 0.0f;
                                } else {
                                    bool v368;
                                    v368 = v331 == 0.0f;
                                    bool v369;
                                    v369 = v368 != true;
                                    if (v369){
                                        float v370;
                                        v370 = v365 / v331;
                                        v372 = v370;
                                    } else {
                                        v372 = v357;
                                    }
                                }
                                assert("Tensor range check" && 0 <= v359 && v359 < 1);
                                assert("Tensor range check" && 0 <= v361 && v361 < 4);
                                v358[v364] = v372;
                                v361 += 1 ;
                            }
                            v359 += 1 ;
                        }
                        float v373[4];
                        int v374;
                        v374 = 0;
                        while (while_method_6(v374)){
                            int v376;
                            v376 = 0;
                            while (while_method_3(v376)){
                                assert("Tensor range check" && 0 <= v374 && v374 < 1);
                                assert("Tensor range check" && 0 <= v376 && v376 < 4);
                                int v378;
                                v378 = 4 * v374;
                                int v379;
                                v379 = v378 + v376;
                                float v380;
                                v380 = v282[v379];
                                int v381;
                                v381 = v245[v379];
                                bool v382;
                                v382 = v231 == v381;
                                float v385;
                                if (v382){
                                    float v383;
                                    v383 = v232 - v380;
                                    float v384;
                                    v384 = v383 / v230;
                                    v385 = v384;
                                } else {
                                    v385 = 0.0f;
                                }
                                float v386;
                                v386 = v385 + v380;
                                assert("Tensor range check" && 0 <= v374 && v374 < 1);
                                assert("Tensor range check" && 0 <= v376 && v376 < 4);
                                v373[v379] = v386;
                                v376 += 1 ;
                            }
                            v374 += 1 ;
                        }
                        float v387[4];
                        int v388;
                        v388 = 0;
                        while (while_method_6(v388)){
                            int v390;
                            v390 = 0;
                            while (while_method_3(v390)){
                                assert("Tensor range check" && 0 <= v388 && v388 < 1);
                                assert("Tensor range check" && 0 <= v390 && v390 < 4);
                                int v392;
                                v392 = 4 * v388;
                                int v393;
                                v393 = v392 + v390;
                                float v394;
                                v394 = v358[v393];
                                float v395;
                                v395 = v373[v393];
                                float v396;
                                v396 = v394 * v395;
                                assert("Tensor range check" && 0 <= v388 && v388 < 1);
                                assert("Tensor range check" && 0 <= v390 && v390 < 4);
                                v387[v393] = v396;
                                v390 += 1 ;
                            }
                            v388 += 1 ;
                        }
                        float v397;
                        v397 = 0.0f;
                        int v398;
                        v398 = 0;
                        while (while_method_6(v398)){
                            int v400;
                            v400 = 0;
                            while (while_method_3(v400)){
                                assert("Tensor range check" && 0 <= v398 && v398 < 1);
                                assert("Tensor range check" && 0 <= v400 && v400 < 4);
                                int v402;
                                v402 = 4 * v398;
                                int v403;
                                v403 = v402 + v400;
                                float v404;
                                v404 = v387[v403];
                                float v405;
                                v405 = v397 + v404;
                                v397 = v405;
                                v400 += 1 ;
                            }
                            v398 += 1 ;
                        }
                        auto v406 = cooperative_groups::coalesced_threads();
                        int v407;
                        v407 = threadIdx.x;
                        int v408;
                        v408 = v407 / 4;
                        auto v409 = cooperative_groups::labeled_partition(v406,v408);
                        float v410;
                        v410 = cooperative_groups::reduce(v409, v397, v330);
                        int v411;
                        v411 = 0;
                        while (while_method_6(v411)){
                            int v413;
                            v413 = 0;
                            while (while_method_3(v413)){
                                assert("Tensor range check" && 0 <= v411 && v411 < 1);
                                assert("Tensor range check" && 0 <= v413 && v413 < 4);
                                int v415;
                                v415 = 4 * v411;
                                int v416;
                                v416 = v415 + v413;
                                float v417;
                                v417 = v373[v416];
                                int v418;
                                v418 = v245[v416];
                                float v419;
                                v419 = v417 - v410;
                                float v420;
                                v420 = v233 * v419;
                                assert("Tensor range check" && 0 <= v418 && v418 < 16);
                                float * v421;
                                v421 = v234+v418;
                                float v423;
                                v423 = atomicAdd(v421,v420);
                                v413 += 1 ;
                            }
                            v411 += 1 ;
                        }
                        int v424;
                        v424 = 0;
                        while (while_method_6(v424)){
                            assert("Tensor range check" && 0 <= v424 && v424 < 1);
                            assert("Tensor range check" && 0 <= v424 && v424 < 1);
                            v424 += 1 ;
                        }
                        assert("Tensor range check" && 0 <= v227 && v227 < 256);
                        v204[v227] = v410;
                        v215 += 1 ;
                    }
                    asm("barrier.cta.sync %0;" :: "r"(0));
                    assert("Tensor range check" && 0 <= v206 && v206 < 256);
                    float v426;
                    v426 = v204[v206];
                    asm("barrier.cta.sync %0;" :: "r"(0));
                    assert("Tensor range check" && 0 <= v98 && v98 < 2);
                    v82[v98] = v426;
                }
                int v427;
                v427 = threadIdx.x;
                int v428;
                v428 = blockIdx.x;
                int v429;
                v429 = v428 * 256;
                int v430;
                v430 = v427 + v429;
                assert("Tensor range check" && 0 <= v76 && v76 < 4);
                int v431;
                v431 = 12288 * v76;
                assert("Tensor range check" && 0 <= v430 && v430 < 6144);
                int v432;
                v432 = 2 * v430;
                int v433;
                v433 = v432 + v431;
                double * v434;
                v434 = v70+v433;
                double * v436;
                v436 = v72+v433;
                double * v438;
                v438 = v434+0;
                double * v440;
                v440 = v436+0;
                double * v442;
                v442 = v434+0;
                double * v444;
                v444 = v436+0;
                int v446;
                v446 = sizeof(double *);
                unsigned long long v447;
                v447 = (unsigned long long)v446;
                unsigned long long v448;
                v448 = 256ull * v447;
                unsigned long long v449;
                v449 = v448 + 16ull;
                unsigned long long v450;
                v450 = v449 - 1ull;
                unsigned long long v451;
                v451 = v450 % 16ull;
                unsigned long long v452;
                v452 = v450 - v451;
                unsigned long long v453;
                v453 = v452 + v448;
                unsigned long long v454;
                v454 = v453 + 16ull;
                unsigned long long v455;
                v455 = v454 - 1ull;
                unsigned long long v456;
                v456 = v455 % 16ull;
                unsigned long long v457;
                v457 = v455 - v456;
                unsigned long long v458;
                v458 = v457 + v448;
                unsigned long long v459;
                v459 = v458 + 16ull;
                unsigned long long v460;
                v460 = v459 - 1ull;
                unsigned long long v461;
                v461 = v460 % 16ull;
                unsigned long long v462;
                v462 = v460 - v461;
                unsigned long long v463;
                v463 = v462 + v448;
                bool v464;
                v464 = v463 <= 98304ull;
                bool v465;
                v465 = v464 == false;
                if (v465){
                    assert("The dynamic shared memory is insufficient to allocate the tensor." && v464);
                } else {
                }
                extern __shared__ unsigned char v467[];
                bool v468;
                v468 = v463 <= v463;
                bool v469;
                v469 = v468 == false;
                if (v469){
                    assert("The length of the partition has to be less than or equal to the length of the base array." && v468);
                } else {
                }
                double * * v471;
                v471 = reinterpret_cast<double * *>(&v467[0ull]);
                double * * v473;
                v473 = reinterpret_cast<double * *>(&v467[v452]);
                double * * v475;
                v475 = reinterpret_cast<double * *>(&v467[v457]);
                double * * v477;
                v477 = reinterpret_cast<double * *>(&v467[v462]);
                int v479;
                v479 = threadIdx.x;
                assert("Tensor range check" && 0 <= v479 && v479 < 256);
                v471[v479] = v438;
                v473[v479] = v440;
                v475[v479] = v442;
                v477[v479] = v444;
                asm("barrier.cta.sync %0;" :: "r"(0));
                bool v480;
                v480 = 0 <= v479;
                bool v481;
                v481 = v480 == false;
                if (v481){
                    assert("The index needs to be zero or positive." && v480);
                } else {
                }
                int v483;
                v483 = v479 % 1;
                bool v484;
                v484 = v479 < 256;
                bool v485;
                v485 = v484 == false;
                if (v485){
                    assert("The last element of the projection dimensions needs to be greater than the index remainder." && v484);
                } else {
                }
                assert("Tensor range check" && 0 <= v479 && v479 < 256);
                int v487;
                v487 = 0;
                while (while_method_6(v487)){
                    bool v489;
                    v489 = v480 && v484;
                    bool v490;
                    v490 = v489 == false;
                    if (v490){
                        assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v489);
                    } else {
                    }
                    bool v492;
                    v492 = 0 <= v487;
                    bool v494;
                    if (v492){
                        bool v493;
                        v493 = v487 < 1;
                        v494 = v493;
                    } else {
                        v494 = false;
                    }
                    bool v495;
                    v495 = v494 == false;
                    if (v495){
                        assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v494);
                    } else {
                    }
                    int v497;
                    v497 = v487 * 256;
                    int v498;
                    v498 = v497 + v479;
                    assert("Tensor range check" && 0 <= v487 && v487 < 1);
                    int v499;
                    v499 = 256 * v487;
                    int v500;
                    v500 = v499 + v479;
                    double * v501;
                    v501 = v471[v500];
                    double * v502;
                    v502 = v473[v500];
                    double * v503;
                    v503 = v475[v500];
                    double * v504;
                    v504 = v477[v500];
                    int v505;
                    v505 = blockIdx.x;
                    int v506;
                    v506 = v505 * 256;
                    int v507;
                    v507 = v506 + v498;
                    assert("Tensor range check" && 0 <= v483 && v483 < 1);
                    int v508;
                    v508 = 2 * v483;
                    double v509[2];
                    double v510[2];
                    int v511[2];
                    int v512;
                    v512 = 0;
                    while (while_method_6(v512)){
                        assert("Tensor range check" && 0 <= v512 && v512 < 1);
                        int v514;
                        v514 = 2 * v512;
                        assert("Tensor range check" && 0 <= v512 && v512 < 1);
                        int v515;
                        v515 = v514 + v508;
                        int4* v516;
                        v516 = reinterpret_cast<int4*>(v501 + v515);
                        int4* v517;
                        v517 = reinterpret_cast<int4*>(v509 + v514);
                        assert("Pointer alignment check" && (unsigned long long)(v516) % 2 == 0 && (unsigned long long)(v517) % 2 == 0);
                        *v517 = *v516;
                        int4* v518;
                        v518 = reinterpret_cast<int4*>(v502 + v515);
                        int4* v519;
                        v519 = reinterpret_cast<int4*>(v510 + v514);
                        assert("Pointer alignment check" && (unsigned long long)(v518) % 2 == 0 && (unsigned long long)(v519) % 2 == 0);
                        *v519 = *v518;
                        v512 += 1 ;
                    }
                    int v520;
                    v520 = 0;
                    while (while_method_6(v520)){
                        int v522;
                        v522 = 0;
                        while (while_method_0(v522)){
                            bool v524;
                            v524 = 0 <= v522;
                            bool v526;
                            if (v524){
                                bool v525;
                                v525 = v522 < 2;
                                v526 = v525;
                            } else {
                                v526 = false;
                            }
                            bool v527;
                            v527 = v526 == false;
                            if (v527){
                                assert("The indices should be inside the range of the dimension." && v526);
                            } else {
                            }
                            bool v529;
                            v529 = 0 <= v483;
                            bool v531;
                            if (v529){
                                bool v530;
                                v530 = v483 < 1;
                                v531 = v530;
                            } else {
                                v531 = false;
                            }
                            bool v532;
                            v532 = v531 == false;
                            if (v532){
                                assert("The indices should be inside the range of the dimension." && v531);
                            } else {
                            }
                            int v534;
                            v534 = v483 * 2;
                            int v535;
                            v535 = v522 + v534;
                            bool v536;
                            v536 = 0 <= v520;
                            bool v538;
                            if (v536){
                                bool v537;
                                v537 = v520 < 1;
                                v538 = v537;
                            } else {
                                v538 = false;
                            }
                            bool v539;
                            v539 = v538 == false;
                            if (v539){
                                assert("The indices should be inside the range of the dimension." && v538);
                            } else {
                            }
                            int v541;
                            v541 = v520 * 2;
                            int v542;
                            v542 = v535 + v541;
                            assert("Tensor range check" && 0 <= v520 && v520 < 1);
                            assert("Tensor range check" && 0 <= v522 && v522 < 2);
                            int v543;
                            v543 = 2 * v520;
                            int v544;
                            v544 = v543 + v522;
                            v511[v544] = v542;
                            v522 += 1 ;
                        }
                        v520 += 1 ;
                    }
                    double v545[2];
                    double v546[2];
                    int v547;
                    v547 = 0;
                    while (while_method_6(v547)){
                        int v549;
                        v549 = 0;
                        while (while_method_0(v549)){
                            assert("Tensor range check" && 0 <= v547 && v547 < 1);
                            assert("Tensor range check" && 0 <= v549 && v549 < 2);
                            int v551;
                            v551 = 2 * v547;
                            int v552;
                            v552 = v551 + v549;
                            double v553;
                            v553 = v509[v552];
                            double v554;
                            v554 = v510[v552];
                            assert("Tensor range check" && 0 <= v547 && v547 < 1);
                            assert("Tensor range check" && 0 <= v549 && v549 < 2);
                            v545[v552] = 0.0;
                            v546[v552] = 0.0;
                            v549 += 1 ;
                        }
                        v547 += 1 ;
                    }
                    int v555;
                    v555 = 0;
                    while (while_method_6(v555)){
                        assert("Tensor range check" && 0 <= v555 && v555 < 1);
                        int v557;
                        v557 = 2 * v555;
                        int v558;
                        v558 = v557 + v508;
                        assert("Tensor range check" && 0 <= v555 && v555 < 1);
                        int4* v559;
                        v559 = reinterpret_cast<int4*>(v545 + v557);
                        int4* v560;
                        v560 = reinterpret_cast<int4*>(v503 + v558);
                        assert("Pointer alignment check" && (unsigned long long)(v559) % 2 == 0 && (unsigned long long)(v560) % 2 == 0);
                        *v560 = *v559;
                        int4* v561;
                        v561 = reinterpret_cast<int4*>(v546 + v557);
                        int4* v562;
                        v562 = reinterpret_cast<int4*>(v504 + v558);
                        assert("Pointer alignment check" && (unsigned long long)(v561) % 2 == 0 && (unsigned long long)(v562) % 2 == 0);
                        *v562 = *v561;
                        v555 += 1 ;
                    }
                    assert("Tensor range check" && 0 <= v498 && v498 < 256);
                    v487 += 1 ;
                }
                asm("barrier.cta.sync %0;" :: "r"(0));
                assert("Tensor range check" && 0 <= v479 && v479 < 256);
                asm("barrier.cta.sync %0;" :: "r"(0));
                assert("Tensor range check" && 0 <= v76 && v76 < 4);
                assert("Tensor range check" && 0 <= v430 && v430 < 6144);
                int v563;
                v563 = v87 + v430;
                v74[v563] = 0;
                v76 += 1 ;
            }
            Union4 v564;
            v564 = Union4{Union4_2{}};
            method_85(v0, v2, v27, v564);
            double * v565;
            v565 = reinterpret_cast<double *>(&v2[11534352ull]);
            double * v567;
            v567 = reinterpret_cast<double *>(&v2[11927568ull]);
            int * v569;
            v569 = reinterpret_cast<int *>(&v2[12320784ull]);
            int v571;
            v571 = threadIdx.x;
            int v572;
            v572 = blockIdx.x;
            int v573;
            v573 = v572 * 256;
            int v574;
            v574 = v571 + v573;
            assert("Tensor range check" && 0 <= v574 && v574 < 6144);
            int v575;
            v575 = 2 * v574;
            int v576; double v577;
            Tuple24 tmp141 = Tuple24{0, 1.0};
            v576 = tmp141.v0; v577 = tmp141.v1;
            while (while_method_0(v576)){
                assert("Tensor range check" && 0 <= v576 && v576 < 2);
                int v579;
                v579 = v576 + v575;
                int v580; double v581;
                Tuple24 tmp142 = Tuple24{0, 0.0};
                v580 = tmp142.v0; v581 = tmp142.v1;
                while (while_method_3(v580)){
                    assert("Tensor range check" && 0 <= v580 && v580 < 4);
                    int v583;
                    v583 = 12288 * v580;
                    int v584;
                    v584 = v583 + v579;
                    double v585;
                    v585 = v565[v584];
                    double v586;
                    v586 = v567[v584];
                    double v587;
                    v587 = v585 - v586;
                    double v588;
                    v588 = exp(v587);
                    double v589;
                    v589 = v581 + v588;
                    v581 = v589;
                    v580 += 1 ;
                }
                double v590;
                v590 = v577 * v581;
                v577 = v590;
                v576 += 1 ;
            }
            float v591;
            v591 = (float)v577;
            int v592;
            v592 = 0;
            while (while_method_0(v592)){
                static_array<float,2> & v594 = v27.v4;
                float v595;
                v595 = v594[v592];
                float v597;
                v597 = v595 * v591;
                assert("Tensor range check" && 0 <= v592 && v592 < 2);
                assert("Tensor range check" && 0 <= v34 && v34 < 4);
                int v598;
                v598 = 4 * v592;
                int v599;
                v599 = v598 + v34;
                float * v600;
                v600 = v4+v599;
                float * v602;
                v602 = v5+v599;
                float v604;
                v604 = atomicAdd(v600,v597);
                float v605;
                v605 = atomicAdd(v602,v591);
                v592 += 1 ;
            }
            double * v606;
            v606 = reinterpret_cast<double *>(&v2[11534352ull]);
            double * v608;
            v608 = reinterpret_cast<double *>(&v2[11927568ull]);
            int * v610;
            v610 = reinterpret_cast<int *>(&v2[12320784ull]);
            int v612;
            v612 = 0;
            while (while_method_3(v612)){
                int v614;
                v614 = threadIdx.x;
                int v615;
                v615 = blockIdx.x;
                int v616;
                v616 = v615 * 256;
                int v617;
                v617 = v614 + v616;
                assert("Tensor range check" && 0 <= v612 && v612 < 4);
                int v618;
                v618 = 12288 * v612;
                assert("Tensor range check" && 0 <= v617 && v617 < 6144);
                int v619;
                v619 = 2 * v617;
                int v620;
                v620 = v619 + v618;
                double * v621;
                v621 = v606+v620;
                double * v623;
                v623 = v608+v620;
                double * v625;
                v625 = v621+0;
                double * v627;
                v627 = v623+0;
                double * v629;
                v629 = v621+0;
                double * v631;
                v631 = v623+0;
                int v633;
                v633 = sizeof(double *);
                unsigned long long v634;
                v634 = (unsigned long long)v633;
                unsigned long long v635;
                v635 = 256ull * v634;
                unsigned long long v636;
                v636 = v635 + 16ull;
                unsigned long long v637;
                v637 = v636 - 1ull;
                unsigned long long v638;
                v638 = v637 % 16ull;
                unsigned long long v639;
                v639 = v637 - v638;
                unsigned long long v640;
                v640 = v639 + v635;
                unsigned long long v641;
                v641 = v640 + 16ull;
                unsigned long long v642;
                v642 = v641 - 1ull;
                unsigned long long v643;
                v643 = v642 % 16ull;
                unsigned long long v644;
                v644 = v642 - v643;
                unsigned long long v645;
                v645 = v644 + v635;
                unsigned long long v646;
                v646 = v645 + 16ull;
                unsigned long long v647;
                v647 = v646 - 1ull;
                unsigned long long v648;
                v648 = v647 % 16ull;
                unsigned long long v649;
                v649 = v647 - v648;
                unsigned long long v650;
                v650 = v649 + v635;
                bool v651;
                v651 = v650 <= 98304ull;
                bool v652;
                v652 = v651 == false;
                if (v652){
                    assert("The dynamic shared memory is insufficient to allocate the tensor." && v651);
                } else {
                }
                extern __shared__ unsigned char v654[];
                bool v655;
                v655 = v650 <= v650;
                bool v656;
                v656 = v655 == false;
                if (v656){
                    assert("The length of the partition has to be less than or equal to the length of the base array." && v655);
                } else {
                }
                double * * v658;
                v658 = reinterpret_cast<double * *>(&v654[0ull]);
                double * * v660;
                v660 = reinterpret_cast<double * *>(&v654[v639]);
                double * * v662;
                v662 = reinterpret_cast<double * *>(&v654[v644]);
                double * * v664;
                v664 = reinterpret_cast<double * *>(&v654[v649]);
                int v666;
                v666 = threadIdx.x;
                assert("Tensor range check" && 0 <= v666 && v666 < 256);
                v658[v666] = v625;
                v660[v666] = v627;
                v662[v666] = v629;
                v664[v666] = v631;
                asm("barrier.cta.sync %0;" :: "r"(0));
                bool v667;
                v667 = 0 <= v666;
                bool v668;
                v668 = v667 == false;
                if (v668){
                    assert("The index needs to be zero or positive." && v667);
                } else {
                }
                int v670;
                v670 = v666 % 1;
                bool v671;
                v671 = v666 < 256;
                bool v672;
                v672 = v671 == false;
                if (v672){
                    assert("The last element of the projection dimensions needs to be greater than the index remainder." && v671);
                } else {
                }
                assert("Tensor range check" && 0 <= v666 && v666 < 256);
                int v674;
                v674 = 0;
                while (while_method_6(v674)){
                    bool v676;
                    v676 = v667 && v671;
                    bool v677;
                    v677 = v676 == false;
                    if (v677){
                        assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v676);
                    } else {
                    }
                    bool v679;
                    v679 = 0 <= v674;
                    bool v681;
                    if (v679){
                        bool v680;
                        v680 = v674 < 1;
                        v681 = v680;
                    } else {
                        v681 = false;
                    }
                    bool v682;
                    v682 = v681 == false;
                    if (v682){
                        assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v681);
                    } else {
                    }
                    int v684;
                    v684 = v674 * 256;
                    int v685;
                    v685 = v684 + v666;
                    assert("Tensor range check" && 0 <= v674 && v674 < 1);
                    int v686;
                    v686 = 256 * v674;
                    int v687;
                    v687 = v686 + v666;
                    double * v688;
                    v688 = v658[v687];
                    double * v689;
                    v689 = v660[v687];
                    double * v690;
                    v690 = v662[v687];
                    double * v691;
                    v691 = v664[v687];
                    int v692;
                    v692 = blockIdx.x;
                    int v693;
                    v693 = v692 * 256;
                    int v694;
                    v694 = v693 + v685;
                    assert("Tensor range check" && 0 <= v670 && v670 < 1);
                    int v695;
                    v695 = 2 * v670;
                    double v696[2];
                    double v697[2];
                    int v698[2];
                    int v699;
                    v699 = 0;
                    while (while_method_6(v699)){
                        assert("Tensor range check" && 0 <= v699 && v699 < 1);
                        int v701;
                        v701 = 2 * v699;
                        assert("Tensor range check" && 0 <= v699 && v699 < 1);
                        int v702;
                        v702 = v701 + v695;
                        int4* v703;
                        v703 = reinterpret_cast<int4*>(v688 + v702);
                        int4* v704;
                        v704 = reinterpret_cast<int4*>(v696 + v701);
                        assert("Pointer alignment check" && (unsigned long long)(v703) % 2 == 0 && (unsigned long long)(v704) % 2 == 0);
                        *v704 = *v703;
                        int4* v705;
                        v705 = reinterpret_cast<int4*>(v689 + v702);
                        int4* v706;
                        v706 = reinterpret_cast<int4*>(v697 + v701);
                        assert("Pointer alignment check" && (unsigned long long)(v705) % 2 == 0 && (unsigned long long)(v706) % 2 == 0);
                        *v706 = *v705;
                        v699 += 1 ;
                    }
                    int v707;
                    v707 = 0;
                    while (while_method_6(v707)){
                        int v709;
                        v709 = 0;
                        while (while_method_0(v709)){
                            bool v711;
                            v711 = 0 <= v709;
                            bool v713;
                            if (v711){
                                bool v712;
                                v712 = v709 < 2;
                                v713 = v712;
                            } else {
                                v713 = false;
                            }
                            bool v714;
                            v714 = v713 == false;
                            if (v714){
                                assert("The indices should be inside the range of the dimension." && v713);
                            } else {
                            }
                            bool v716;
                            v716 = 0 <= v670;
                            bool v718;
                            if (v716){
                                bool v717;
                                v717 = v670 < 1;
                                v718 = v717;
                            } else {
                                v718 = false;
                            }
                            bool v719;
                            v719 = v718 == false;
                            if (v719){
                                assert("The indices should be inside the range of the dimension." && v718);
                            } else {
                            }
                            int v721;
                            v721 = v670 * 2;
                            int v722;
                            v722 = v709 + v721;
                            bool v723;
                            v723 = 0 <= v707;
                            bool v725;
                            if (v723){
                                bool v724;
                                v724 = v707 < 1;
                                v725 = v724;
                            } else {
                                v725 = false;
                            }
                            bool v726;
                            v726 = v725 == false;
                            if (v726){
                                assert("The indices should be inside the range of the dimension." && v725);
                            } else {
                            }
                            int v728;
                            v728 = v707 * 2;
                            int v729;
                            v729 = v722 + v728;
                            assert("Tensor range check" && 0 <= v707 && v707 < 1);
                            assert("Tensor range check" && 0 <= v709 && v709 < 2);
                            int v730;
                            v730 = 2 * v707;
                            int v731;
                            v731 = v730 + v709;
                            v698[v731] = v729;
                            v709 += 1 ;
                        }
                        v707 += 1 ;
                    }
                    double v732[2];
                    double v733[2];
                    int v734;
                    v734 = 0;
                    while (while_method_6(v734)){
                        int v736;
                        v736 = 0;
                        while (while_method_0(v736)){
                            assert("Tensor range check" && 0 <= v734 && v734 < 1);
                            assert("Tensor range check" && 0 <= v736 && v736 < 2);
                            int v738;
                            v738 = 2 * v734;
                            int v739;
                            v739 = v738 + v736;
                            double v740;
                            v740 = v696[v739];
                            double v741;
                            v741 = v697[v739];
                            assert("Tensor range check" && 0 <= v734 && v734 < 1);
                            assert("Tensor range check" && 0 <= v736 && v736 < 2);
                            v732[v739] = 0.0;
                            v733[v739] = 0.0;
                            v736 += 1 ;
                        }
                        v734 += 1 ;
                    }
                    int v742;
                    v742 = 0;
                    while (while_method_6(v742)){
                        assert("Tensor range check" && 0 <= v742 && v742 < 1);
                        int v744;
                        v744 = 2 * v742;
                        int v745;
                        v745 = v744 + v695;
                        assert("Tensor range check" && 0 <= v742 && v742 < 1);
                        int4* v746;
                        v746 = reinterpret_cast<int4*>(v732 + v744);
                        int4* v747;
                        v747 = reinterpret_cast<int4*>(v690 + v745);
                        assert("Pointer alignment check" && (unsigned long long)(v746) % 2 == 0 && (unsigned long long)(v747) % 2 == 0);
                        *v747 = *v746;
                        int4* v748;
                        v748 = reinterpret_cast<int4*>(v733 + v744);
                        int4* v749;
                        v749 = reinterpret_cast<int4*>(v691 + v745);
                        assert("Pointer alignment check" && (unsigned long long)(v748) % 2 == 0 && (unsigned long long)(v749) % 2 == 0);
                        *v749 = *v748;
                        v742 += 1 ;
                    }
                    assert("Tensor range check" && 0 <= v685 && v685 < 256);
                    v674 += 1 ;
                }
                asm("barrier.cta.sync %0;" :: "r"(0));
                assert("Tensor range check" && 0 <= v666 && v666 < 256);
                asm("barrier.cta.sync %0;" :: "r"(0));
                assert("Tensor range check" && 0 <= v612 && v612 < 4);
                assert("Tensor range check" && 0 <= v617 && v617 < 6144);
                int v750;
                v750 = 6144 * v612;
                int v751;
                v751 = v750 + v617;
                v610[v751] = 0;
                v612 += 1 ;
            }
            v36 += 1 ;
        }
        cooperative_groups::grid_group & v752 = v27.v1;
        cooperative_groups::grid_group & v753 = v752;
        curandStatePhilox4_32_10_t & v754 = v27.v5;
        curandStatePhilox4_32_10_t & v755 = v754;
        unsigned int * v756;
        v756 = reinterpret_cast<unsigned int *>(&v0[53477376ull]);
        int * v758;
        v758 = reinterpret_cast<int *>(&v2[4194304ull]);
        float * v760;
        v760 = reinterpret_cast<float *>(&v2[4194320ull]);
        float * v762;
        v762 = reinterpret_cast<float *>(&v2[5242896ull]);
        float * v764;
        v764 = reinterpret_cast<float *>(&v2[6291472ull]);
        float * v766;
        v766 = reinterpret_cast<float *>(&v2[7340048ull]);
        float * v768;
        v768 = reinterpret_cast<float *>(&v2[8388624ull]);
        float * v770;
        v770 = reinterpret_cast<float *>(&v2[9437200ull]);
        float * v772;
        v772 = reinterpret_cast<float *>(&v2[10485776ull]);
        int * v774;
        v774 = reinterpret_cast<int *>(&v0[53575680ull]);
        float * v776;
        v776 = reinterpret_cast<float *>(&v0[66158592ull]);
        int * v778;
        v778 = reinterpret_cast<int *>(&v0[78741504ull]);
        int * v780;
        v780 = reinterpret_cast<int *>(&v0[91324416ull]);
        double * v782;
        v782 = reinterpret_cast<double *>(&v0[103907328ull]);
        double * v784;
        v784 = reinterpret_cast<double *>(&v0[154238976ull]);
        double * v786;
        v786 = reinterpret_cast<double *>(&v2[11534352ull]);
        double * v788;
        v788 = reinterpret_cast<double *>(&v2[11927568ull]);
        int * v790;
        v790 = reinterpret_cast<int *>(&v2[12320784ull]);
        v753.sync() ;
        int v792;
        v792 = threadIdx.x;
        int v793;
        v793 = blockIdx.x;
        int v794;
        v794 = v793 * 256;
        int v795;
        v795 = v792 + v794;
        bool v796;
        v796 = v795 == 0;
        if (v796){
            int v797;
            v797 = 0;
            int v798;
            v798 = 4;
            int v799;
            v799 = int_range_44(v798, v797, v755);
            v758[0] = v799;
        } else {
        }
        __syncwarp();
        int v800;
        v800 = threadIdx.x;
        bool v801;
        v801 = 0 <= v800;
        bool v802;
        v802 = v801 == false;
        if (v802){
            assert("The index needs to be zero or positive." && v801);
        } else {
        }
        int v804;
        v804 = v800 % 4;
        int v805;
        v805 = v800 / 4;
        int v806;
        v806 = v805 % 64;
        int v807;
        v807 = v805 / 64;
        bool v808;
        v808 = v807 < 1;
        bool v809;
        v809 = v808 == false;
        if (v809){
            assert("The last element of the projection dimensions needs to be greater than the index remainder." && v808);
        } else {
        }
        assert("Tensor range check" && 0 <= v807 && v807 < 1);
        assert("Tensor range check" && 0 <= v806 && v806 < 64);
        assert("Tensor range check" && 0 <= v804 && v804 < 4);
        int v811;
        v811 = 4 * v804;
        int v812;
        v812 = 16 * v806;
        int v813;
        v813 = v812 + v811;
        int v814;
        v814 = 65536 * v807;
        int v815;
        v815 = v814 + v813;
        assert("Tensor range check" && 0 <= v807 && v807 < 1);
        assert("Tensor range check" && 0 <= v806 && v806 < 64);
        assert("Tensor range check" && 0 <= v804 && v804 < 4);
        int v816;
        v816 = blockIdx.x;
        int v817;
        v817 = v816;
        while (while_method_23(v817)){
            bool v819;
            v819 = 0 <= v817;
            bool v820;
            v820 = v819 == false;
            if (v820){
                assert("The index needs to be zero or positive." && v819);
            } else {
            }
            int v822;
            v822 = v817 % 64;
            int v823;
            v823 = v817 / 64;
            bool v824;
            v824 = v823 < 4;
            bool v825;
            v825 = v824 == false;
            if (v825){
                assert("The last element of the projection dimensions needs to be greater than the index remainder." && v824);
            } else {
            }
            assert("Tensor range check" && 0 <= v823 && v823 < 4);
            assert("Tensor range check" && 0 <= v822 && v822 < 64);
            int v827;
            v827 = 1024 * v822;
            int v828;
            v828 = v827 + v815;
            int v829;
            v829 = 65536 * v823;
            int v830;
            v830 = v829 + v828;
            float v831[4];
            float v832[4];
            float v833[4];
            float v834[4];
            float v835[4];
            float v836[4];
            float v837[4];
            int v838[4];
            int v839;
            v839 = 0;
            while (while_method_6(v839)){
                assert("Tensor range check" && 0 <= v839 && v839 < 1);
                int v841;
                v841 = 4 * v839;
                assert("Tensor range check" && 0 <= v839 && v839 < 1);
                int v842;
                v842 = 16 * v839;
                int v843;
                v843 = v842 + v830;
                int4* v844;
                v844 = reinterpret_cast<int4*>(v760 + v843);
                int4* v845;
                v845 = reinterpret_cast<int4*>(v831 + v841);
                assert("Pointer alignment check" && (unsigned long long)(v844) % 4 == 0 && (unsigned long long)(v845) % 4 == 0);
                *v845 = *v844;
                int4* v846;
                v846 = reinterpret_cast<int4*>(v762 + v843);
                int4* v847;
                v847 = reinterpret_cast<int4*>(v832 + v841);
                assert("Pointer alignment check" && (unsigned long long)(v846) % 4 == 0 && (unsigned long long)(v847) % 4 == 0);
                *v847 = *v846;
                int4* v848;
                v848 = reinterpret_cast<int4*>(v764 + v843);
                int4* v849;
                v849 = reinterpret_cast<int4*>(v833 + v841);
                assert("Pointer alignment check" && (unsigned long long)(v848) % 4 == 0 && (unsigned long long)(v849) % 4 == 0);
                *v849 = *v848;
                int4* v850;
                v850 = reinterpret_cast<int4*>(v766 + v843);
                int4* v851;
                v851 = reinterpret_cast<int4*>(v834 + v841);
                assert("Pointer alignment check" && (unsigned long long)(v850) % 4 == 0 && (unsigned long long)(v851) % 4 == 0);
                *v851 = *v850;
                int4* v852;
                v852 = reinterpret_cast<int4*>(v768 + v843);
                int4* v853;
                v853 = reinterpret_cast<int4*>(v835 + v841);
                assert("Pointer alignment check" && (unsigned long long)(v852) % 4 == 0 && (unsigned long long)(v853) % 4 == 0);
                *v853 = *v852;
                int4* v854;
                v854 = reinterpret_cast<int4*>(v770 + v843);
                int4* v855;
                v855 = reinterpret_cast<int4*>(v836 + v841);
                assert("Pointer alignment check" && (unsigned long long)(v854) % 4 == 0 && (unsigned long long)(v855) % 4 == 0);
                *v855 = *v854;
                int4* v856;
                v856 = reinterpret_cast<int4*>(v772 + v843);
                int4* v857;
                v857 = reinterpret_cast<int4*>(v837 + v841);
                assert("Pointer alignment check" && (unsigned long long)(v856) % 4 == 0 && (unsigned long long)(v857) % 4 == 0);
                *v857 = *v856;
                v839 += 1 ;
            }
            int v858;
            v858 = 0;
            while (while_method_6(v858)){
                int v860;
                v860 = 0;
                while (while_method_3(v860)){
                    bool v862;
                    v862 = 0 <= v860;
                    bool v864;
                    if (v862){
                        bool v863;
                        v863 = v860 < 4;
                        v864 = v863;
                    } else {
                        v864 = false;
                    }
                    bool v865;
                    v865 = v864 == false;
                    if (v865){
                        assert("The indices should be inside the range of the dimension." && v864);
                    } else {
                    }
                    bool v867;
                    v867 = 0 <= v804;
                    bool v869;
                    if (v867){
                        bool v868;
                        v868 = v804 < 4;
                        v869 = v868;
                    } else {
                        v869 = false;
                    }
                    bool v870;
                    v870 = v869 == false;
                    if (v870){
                        assert("The indices should be inside the range of the dimension." && v869);
                    } else {
                    }
                    int v872;
                    v872 = v804 * 4;
                    int v873;
                    v873 = v860 + v872;
                    bool v874;
                    v874 = 0 <= v858;
                    bool v876;
                    if (v874){
                        bool v875;
                        v875 = v858 < 1;
                        v876 = v875;
                    } else {
                        v876 = false;
                    }
                    bool v877;
                    v877 = v876 == false;
                    if (v877){
                        assert("The indices should be inside the range of the dimension." && v876);
                    } else {
                    }
                    int v879;
                    v879 = v858 * 16;
                    int v880;
                    v880 = v873 + v879;
                    assert("Tensor range check" && 0 <= v858 && v858 < 1);
                    assert("Tensor range check" && 0 <= v860 && v860 < 4);
                    int v881;
                    v881 = 4 * v858;
                    int v882;
                    v882 = v881 + v860;
                    v838[v882] = v880;
                    v860 += 1 ;
                }
                v858 += 1 ;
            }
            bool v883;
            v883 = 0 <= v807;
            bool v884;
            v884 = v883 && v808;
            bool v885;
            v885 = v884 == false;
            if (v885){
                assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v884);
            } else {
            }
            bool v887;
            v887 = 0 <= v806;
            bool v889;
            if (v887){
                bool v888;
                v888 = v806 < 64;
                v889 = v888;
            } else {
                v889 = false;
            }
            bool v890;
            v890 = v889 == false;
            if (v890){
                assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v889);
            } else {
            }
            bool v892;
            v892 = 0 <= v823;
            bool v893;
            v893 = v892 && v824;
            bool v894;
            v894 = v893 == false;
            if (v894){
                assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v893);
            } else {
            }
            bool v896;
            v896 = 0 <= v822;
            bool v898;
            if (v896){
                bool v897;
                v897 = v822 < 64;
                v898 = v897;
            } else {
                v898 = false;
            }
            bool v899;
            v899 = v898 == false;
            if (v899){
                assert("The rigid merge indices have to be greater than or equal to 0 and less than the dimensions." && v898);
            } else {
            }
            int v901;
            v901 = v822 * 64;
            int v902;
            v902 = v823 + v807;
            int v903;
            v903 = v901 + v806;
            bool v904[4];
            int v905;
            v905 = 0;
            while (while_method_6(v905)){
                int v907;
                v907 = 0;
                while (while_method_3(v907)){
                    assert("Tensor range check" && 0 <= v905 && v905 < 1);
                    assert("Tensor range check" && 0 <= v907 && v907 < 4);
                    int v909;
                    v909 = 4 * v905;
                    int v910;
                    v910 = v909 + v907;
                    float v911;
                    v911 = v833[v910];
                    bool v912;
                    v912 = v911 == 0.0f;
                    bool v913;
                    v913 = v912 != true;
                    assert("Tensor range check" && 0 <= v905 && v905 < 1);
                    assert("Tensor range check" && 0 <= v907 && v907 < 4);
                    v904[v910] = v913;
                    v907 += 1 ;
                }
                v905 += 1 ;
            }
            bool v914;
            v914 = false;
            int v915;
            v915 = 0;
            while (while_method_6(v915)){
                int v917;
                v917 = 0;
                while (while_method_3(v917)){
                    assert("Tensor range check" && 0 <= v915 && v915 < 1);
                    assert("Tensor range check" && 0 <= v917 && v917 < 4);
                    int v919;
                    v919 = 4 * v915;
                    int v920;
                    v920 = v919 + v917;
                    bool v921;
                    v921 = v904[v920];
                    bool v922;
                    v922 = v914 || v921;
                    v914 = v922;
                    v917 += 1 ;
                }
                v915 += 1 ;
            }
            auto v923 = cooperative_groups::coalesced_threads();
            int v924;
            v924 = threadIdx.x;
            int v925;
            v925 = v924 / 4;
            auto v926 = cooperative_groups::labeled_partition(v923,v925);
            Closure8 v927{};
            bool v928;
            v928 = cooperative_groups::reduce(v926, v914, v927);
            if (v928){
                float v929[4];
                int v930;
                v930 = 0;
                while (while_method_6(v930)){
                    int v932;
                    v932 = 0;
                    while (while_method_3(v932)){
                        assert("Tensor range check" && 0 <= v930 && v930 < 1);
                        assert("Tensor range check" && 0 <= v932 && v932 < 4);
                        int v934;
                        v934 = 4 * v930;
                        int v935;
                        v935 = v934 + v932;
                        float v936;
                        v936 = v832[v935];
                        float v937;
                        v937 = v833[v935];
                        float v938;
                        v938 = v936 + v937;
                        bool v939;
                        v939 = 0.0f >= v938;
                        float v940;
                        if (v939){
                            v940 = 0.0f;
                        } else {
                            v940 = v938;
                        }
                        assert("Tensor range check" && 0 <= v930 && v930 < 1);
                        assert("Tensor range check" && 0 <= v932 && v932 < 4);
                        v929[v935] = v940;
                        v932 += 1 ;
                    }
                    v930 += 1 ;
                }
                float v941[4];
                int v942;
                v942 = 0;
                while (while_method_6(v942)){
                    int v944;
                    v944 = 0;
                    while (while_method_3(v944)){
                        assert("Tensor range check" && 0 <= v942 && v942 < 1);
                        assert("Tensor range check" && 0 <= v944 && v944 < 4);
                        int v946;
                        v946 = 4 * v942;
                        int v947;
                        v947 = v946 + v944;
                        float v948;
                        v948 = v929[v947];
                        bool v949;
                        v949 = 0.0f >= v948;
                        float v950;
                        if (v949){
                            v950 = 0.0f;
                        } else {
                            v950 = v948;
                        }
                        assert("Tensor range check" && 0 <= v942 && v942 < 1);
                        assert("Tensor range check" && 0 <= v944 && v944 < 4);
                        v941[v947] = v950;
                        v944 += 1 ;
                    }
                    v942 += 1 ;
                }
                float v951;
                v951 = 0.0f;
                int v952;
                v952 = 0;
                while (while_method_6(v952)){
                    int v954;
                    v954 = 0;
                    while (while_method_3(v954)){
                        assert("Tensor range check" && 0 <= v952 && v952 < 1);
                        assert("Tensor range check" && 0 <= v954 && v954 < 4);
                        int v956;
                        v956 = 4 * v952;
                        int v957;
                        v957 = v956 + v954;
                        float v958;
                        v958 = v941[v957];
                        float v959;
                        v959 = v951 + v958;
                        v951 = v959;
                        v954 += 1 ;
                    }
                    v952 += 1 ;
                }
                auto v960 = cooperative_groups::coalesced_threads();
                int v961;
                v961 = threadIdx.x;
                int v962;
                v962 = v961 / 4;
                auto v963 = cooperative_groups::labeled_partition(v960,v962);
                Closure1 v964{};
                float v965;
                v965 = cooperative_groups::reduce(v963, v951, v964);
                float v966[4];
                int v967;
                v967 = 0;
                while (while_method_6(v967)){
                    int v969;
                    v969 = 0;
                    while (while_method_3(v969)){
                        assert("Tensor range check" && 0 <= v967 && v967 < 1);
                        assert("Tensor range check" && 0 <= v969 && v969 < 4);
                        int v971;
                        v971 = 4 * v967;
                        int v972;
                        v972 = v971 + v969;
                        float v973;
                        v973 = v941[v972];
                        bool v974;
                        v974 = v965 == 0.0f;
                        bool v975;
                        v975 = v974 != true;
                        float v977;
                        if (v975){
                            float v976;
                            v976 = v973 / v965;
                            v977 = v976;
                        } else {
                            v977 = 0.0625f;
                        }
                        assert("Tensor range check" && 0 <= v967 && v967 < 1);
                        assert("Tensor range check" && 0 <= v969 && v969 < 4);
                        v966[v972] = v977;
                        v969 += 1 ;
                    }
                    v967 += 1 ;
                }
                float v978[4];
                int v979;
                v979 = 0;
                while (while_method_6(v979)){
                    int v981;
                    v981 = 0;
                    while (while_method_3(v981)){
                        assert("Tensor range check" && 0 <= v979 && v979 < 1);
                        assert("Tensor range check" && 0 <= v981 && v981 < 4);
                        int v983;
                        v983 = 4 * v979;
                        int v984;
                        v984 = v983 + v981;
                        float v985;
                        v985 = v831[v984];
                        float v986;
                        v986 = v966[v984];
                        float v987;
                        v987 = v985 + v986;
                        assert("Tensor range check" && 0 <= v979 && v979 < 1);
                        assert("Tensor range check" && 0 <= v981 && v981 < 4);
                        v978[v984] = v987;
                        v981 += 1 ;
                    }
                    v979 += 1 ;
                }
                float v988[4];
                int v989;
                v989 = 0;
                while (while_method_6(v989)){
                    int v991;
                    v991 = 0;
                    while (while_method_3(v991)){
                        assert("Tensor range check" && 0 <= v989 && v989 < 1);
                        assert("Tensor range check" && 0 <= v991 && v991 < 4);
                        int v993;
                        v993 = 4 * v989;
                        int v994;
                        v994 = v993 + v991;
                        float v995;
                        v995 = v978[v994];
                        float v996;
                        v996 = -v995;
                        bool v997;
                        v997 = v995 >= v996;
                        float v998;
                        if (v997){
                            v998 = v995;
                        } else {
                            v998 = v996;
                        }
                        assert("Tensor range check" && 0 <= v989 && v989 < 1);
                        assert("Tensor range check" && 0 <= v991 && v991 < 4);
                        v988[v994] = v998;
                        v991 += 1 ;
                    }
                    v989 += 1 ;
                }
                float v999;
                v999 = 0.0f;
                int v1000;
                v1000 = 0;
                while (while_method_6(v1000)){
                    int v1002;
                    v1002 = 0;
                    while (while_method_3(v1002)){
                        assert("Tensor range check" && 0 <= v1000 && v1000 < 1);
                        assert("Tensor range check" && 0 <= v1002 && v1002 < 4);
                        int v1004;
                        v1004 = 4 * v1000;
                        int v1005;
                        v1005 = v1004 + v1002;
                        float v1006;
                        v1006 = v988[v1005];
                        float v1007;
                        v1007 = v999 + v1006;
                        v999 = v1007;
                        v1002 += 1 ;
                    }
                    v1000 += 1 ;
                }
                auto v1008 = cooperative_groups::coalesced_threads();
                int v1009;
                v1009 = threadIdx.x;
                int v1010;
                v1010 = v1009 / 4;
                auto v1011 = cooperative_groups::labeled_partition(v1008,v1010);
                float v1012;
                v1012 = cooperative_groups::reduce(v1011, v999, v964);
                bool v1013;
                v1013 = v1012 > 100.0f;
                float v1015;
                if (v1013){
                    float v1014;
                    v1014 = 100.0f / v1012;
                    v1015 = v1014;
                } else {
                    v1015 = 1.0f;
                }
                float v1016[4];
                int v1017;
                v1017 = 0;
                while (while_method_6(v1017)){
                    int v1019;
                    v1019 = 0;
                    while (while_method_3(v1019)){
                        assert("Tensor range check" && 0 <= v1017 && v1017 < 1);
                        assert("Tensor range check" && 0 <= v1019 && v1019 < 4);
                        int v1021;
                        v1021 = 4 * v1017;
                        int v1022;
                        v1022 = v1021 + v1019;
                        float v1023;
                        v1023 = v988[v1022];
                        float v1024;
                        v1024 = v1015 * v1023;
                        assert("Tensor range check" && 0 <= v1017 && v1017 < 1);
                        assert("Tensor range check" && 0 <= v1019 && v1019 < 4);
                        v1016[v1022] = v1024;
                        v1019 += 1 ;
                    }
                    v1017 += 1 ;
                }
                float v1025[4];
                float v1026[4];
                int v1027;
                v1027 = 0;
                while (while_method_6(v1027)){
                    int v1029;
                    v1029 = 0;
                    while (while_method_3(v1029)){
                        assert("Tensor range check" && 0 <= v1027 && v1027 < 1);
                        assert("Tensor range check" && 0 <= v1029 && v1029 < 4);
                        int v1031;
                        v1031 = 4 * v1027;
                        int v1032;
                        v1032 = v1031 + v1029;
                        float v1033;
                        v1033 = v831[v1032];
                        float v1034;
                        v1034 = v832[v1032];
                        float v1035;
                        v1035 = v833[v1032];
                        float v1036;
                        v1036 = v834[v1032];
                        float v1037;
                        v1037 = v835[v1032];
                        float v1038;
                        v1038 = v836[v1032];
                        float v1039;
                        v1039 = v837[v1032];
                        float v1040;
                        v1040 = v1036 + v1038;
                        float v1041;
                        v1041 = v1037 + v1039;
                        assert("Tensor range check" && 0 <= v1027 && v1027 < 1);
                        assert("Tensor range check" && 0 <= v1029 && v1029 < 4);
                        v1025[v1032] = v1040;
                        v1026[v1032] = v1041;
                        v1029 += 1 ;
                    }
                    v1027 += 1 ;
                }
                int v1042;
                v1042 = 0;
                while (while_method_6(v1042)){
                    int v1044;
                    v1044 = 0;
                    while (while_method_3(v1044)){
                        assert("Tensor range check" && 0 <= v1042 && v1042 < 1);
                        assert("Tensor range check" && 0 <= v1044 && v1044 < 4);
                        int v1046;
                        v1046 = 4 * v1042;
                        int v1047;
                        v1047 = v1046 + v1044;
                        float v1048;
                        v1048 = v1016[v1047];
                        float v1049;
                        v1049 = v929[v1047];
                        float v1050;
                        v1050 = v1025[v1047];
                        float v1051;
                        v1051 = v1026[v1047];
                        assert("Tensor range check" && 0 <= v1042 && v1042 < 1);
                        assert("Tensor range check" && 0 <= v1044 && v1044 < 4);
                        v831[v1047] = v1048;
                        v832[v1047] = v1049;
                        v833[v1047] = 0.0f;
                        v834[v1047] = v1050;
                        v835[v1047] = v1051;
                        v836[v1047] = 0.0f;
                        v837[v1047] = 0.0f;
                        v1044 += 1 ;
                    }
                    v1042 += 1 ;
                }
            } else {
            }
            assert("Tensor range check" && 0 <= v823 && v823 < 4);
            assert("Tensor range check" && 0 <= v822 && v822 < 64);
            int v1052;
            v1052 = 0;
            while (while_method_6(v1052)){
                assert("Tensor range check" && 0 <= v1052 && v1052 < 1);
                int v1054;
                v1054 = 16 * v1052;
                int v1055;
                v1055 = v1054 + v830;
                assert("Tensor range check" && 0 <= v1052 && v1052 < 1);
                int v1056;
                v1056 = 4 * v1052;
                int4* v1057;
                v1057 = reinterpret_cast<int4*>(v831 + v1056);
                int4* v1058;
                v1058 = reinterpret_cast<int4*>(v760 + v1055);
                assert("Pointer alignment check" && (unsigned long long)(v1057) % 4 == 0 && (unsigned long long)(v1058) % 4 == 0);
                *v1058 = *v1057;
                int4* v1059;
                v1059 = reinterpret_cast<int4*>(v832 + v1056);
                int4* v1060;
                v1060 = reinterpret_cast<int4*>(v762 + v1055);
                assert("Pointer alignment check" && (unsigned long long)(v1059) % 4 == 0 && (unsigned long long)(v1060) % 4 == 0);
                *v1060 = *v1059;
                int4* v1061;
                v1061 = reinterpret_cast<int4*>(v833 + v1056);
                int4* v1062;
                v1062 = reinterpret_cast<int4*>(v764 + v1055);
                assert("Pointer alignment check" && (unsigned long long)(v1061) % 4 == 0 && (unsigned long long)(v1062) % 4 == 0);
                *v1062 = *v1061;
                int4* v1063;
                v1063 = reinterpret_cast<int4*>(v834 + v1056);
                int4* v1064;
                v1064 = reinterpret_cast<int4*>(v766 + v1055);
                assert("Pointer alignment check" && (unsigned long long)(v1063) % 4 == 0 && (unsigned long long)(v1064) % 4 == 0);
                *v1064 = *v1063;
                int4* v1065;
                v1065 = reinterpret_cast<int4*>(v835 + v1056);
                int4* v1066;
                v1066 = reinterpret_cast<int4*>(v768 + v1055);
                assert("Pointer alignment check" && (unsigned long long)(v1065) % 4 == 0 && (unsigned long long)(v1066) % 4 == 0);
                *v1066 = *v1065;
                int4* v1067;
                v1067 = reinterpret_cast<int4*>(v836 + v1056);
                int4* v1068;
                v1068 = reinterpret_cast<int4*>(v770 + v1055);
                assert("Pointer alignment check" && (unsigned long long)(v1067) % 4 == 0 && (unsigned long long)(v1068) % 4 == 0);
                *v1068 = *v1067;
                int4* v1069;
                v1069 = reinterpret_cast<int4*>(v837 + v1056);
                int4* v1070;
                v1070 = reinterpret_cast<int4*>(v772 + v1055);
                assert("Pointer alignment check" && (unsigned long long)(v1069) % 4 == 0 && (unsigned long long)(v1070) % 4 == 0);
                *v1070 = *v1069;
                v1052 += 1 ;
            }
            v817 += 24 ;
        }
        v753.sync() ;
        v34 += 1 ;
    }
    cooperative_groups::grid_group & v1071 = v27.v1;
    cooperative_groups::grid_group & v1072 = v1071;
    int v1073;
    v1073 = threadIdx.x;
    int v1074;
    v1074 = blockIdx.x;
    int v1075;
    v1075 = v1074 * 256;
    int v1076;
    v1076 = v1073 + v1075;
    int v1077;
    v1077 = v1076;
    while (while_method_0(v1077)){
        bool v1079;
        v1079 = 0 <= v1077;
        bool v1080;
        v1080 = v1079 == false;
        if (v1080){
            assert("The index needs to be zero or positive." && v1079);
        } else {
        }
        int v1082;
        v1082 = v1077 % 1;
        bool v1083;
        v1083 = v1077 < 2;
        bool v1084;
        v1084 = v1083 == false;
        if (v1084){
            assert("The last element of the projection dimensions needs to be greater than the index remainder." && v1083);
        } else {
        }
        assert("Tensor range check" && 0 <= v1077 && v1077 < 2);
        assert("Tensor range check" && 0 <= v1082 && v1082 < 1);
        int v1086;
        v1086 = 4 * v1082;
        int v1087;
        v1087 = 4 * v1077;
        int v1088;
        v1088 = v1087 + v1086;
        assert("Tensor range check" && 0 <= v1077 && v1077 < 2);
        assert("Tensor range check" && 0 <= v1082 && v1082 < 1);
        float v1089[4];
        float v1090[4];
        float v1091[4];
        int4* v1092;
        v1092 = reinterpret_cast<int4*>(v4 + v1088);
        int4* v1093;
        v1093 = reinterpret_cast<int4*>(v1089 + 0);
        assert("Pointer alignment check" && (unsigned long long)(v1092) % 4 == 0 && (unsigned long long)(v1093) % 4 == 0);
        *v1093 = *v1092;
        int4* v1094;
        v1094 = reinterpret_cast<int4*>(v5 + v1088);
        int4* v1095;
        v1095 = reinterpret_cast<int4*>(v1090 + 0);
        assert("Pointer alignment check" && (unsigned long long)(v1094) % 4 == 0 && (unsigned long long)(v1095) % 4 == 0);
        *v1095 = *v1094;
        // Pushing the loop unrolling to: 0
        int v1096;
        v1096 = 0;
        #pragma unroll
        while (while_method_3(v1096)){
            assert("Tensor range check" && 0 <= v1096 && v1096 < 4);
            float v1098;
            v1098 = v1089[v1096];
            float v1099;
            v1099 = v1090[v1096];
            bool v1100;
            v1100 = v1099 == 0.0f;
            bool v1101;
            v1101 = v1100 != true;
            float v1103;
            if (v1101){
                float v1102;
                v1102 = v1098 / v1099;
                v1103 = v1102;
            } else {
                v1103 = 0.0f;
            }
            assert("Tensor range check" && 0 <= v1096 && v1096 < 4);
            v1091[v1096] = v1103;
            v1096 += 1 ;
        }
        // Poping the loop unrolling to: 0
        int4* v1104;
        v1104 = reinterpret_cast<int4*>(v1091 + 0);
        int4* v1105;
        v1105 = reinterpret_cast<int4*>(v6 + v1088);
        assert("Pointer alignment check" && (unsigned long long)(v1104) % 4 == 0 && (unsigned long long)(v1105) % 4 == 0);
        *v1105 = *v1104;
        v1077 += 6144 ;
    }
    v1072.sync() ;
    return ;
}
"""
class static_array():
    def __init__(self, length):
        self.ptr = []
        for _ in range(length):
            self.ptr.append(None)

    def __getitem__(self, index):
        assert 0 <= index < len(self.ptr), "The get index needs to be in range."
        return self.ptr[index]
    
    def __setitem__(self, index, value):
        assert 0 <= index < len(self.ptr), "The set index needs to be in range."
        self.ptr[index] = value

class static_array_list(static_array):
    def __init__(self, length):
        super().__init__(length)
        self.length = 0

    def __getitem__(self, index):
        assert 0 <= index < self.length, "The get index needs to be in range."
        return self.ptr[index]
    
    def __setitem__(self, index, value):
        assert 0 <= index < self.length, "The set index needs to be in range."
        self.ptr[index] = value

    def push(self,value):
        assert (self.length < len(self.ptr)), "The length before pushing has to be less than the maximum length of the array."
        self.ptr[self.length] = value
        self.length += 1

    def pop(self):
        assert (0 < self.length), "The length before popping has to be greater than 0."
        self.length -= 1
        return self.ptr[self.length]

    def unsafe_set_length(self,i):
        assert 0 <= i <= len(self.ptr), "The new length has to be in range."
        self.length = i

class dynamic_array(static_array): 
    pass

class dynamic_array_list(static_array_list):
    def length_(self): return self.length

import cupy as cp
from dataclasses import dataclass
from typing import NamedTuple, Union, Callable, Tuple
i8 = int; i16 = int; i32 = int; i64 = int; u8 = int; u16 = int; u32 = int; u64 = int; f32 = float; f64 = float; char = str; string = str

import time
options = []
options.append('--dopt=on')
options.append('--diag-suppress=550,20012,68,39,177')
options.append('--restrict')
options.append('--maxrregcount=255')
options.append('--std=c++20')
options.append('-D__CUDA_NO_HALF_CONVERSIONS__')
raw_module = cp.RawModule(code=kernel, backend='nvcc', enable_cooperative_groups=True, options=tuple(options))
import collections
class US1_0(NamedTuple): # A_All_In
    tag = 0
class US1_1(NamedTuple): # A_Call
    tag = 1
class US1_2(NamedTuple): # A_Fold
    tag = 2
class US1_3(NamedTuple): # A_Raise
    v0 : i32
    tag = 3
US1 = Union[US1_0, US1_1, US1_2, US1_3]
class US0_0(NamedTuple): # ActionSelected
    v0 : US1
    tag = 0
class US0_1(NamedTuple): # PlayerChanged
    v0 : static_array
    tag = 1
class US0_2(NamedTuple): # StartGame
    tag = 2
class US0_3(NamedTuple): # StartTrainingVsRando
    tag = 3
class US0_4(NamedTuple): # StartTrainingVsSelf
    tag = 4
US0 = Union[US0_0, US0_1, US0_2, US0_3, US0_4]
class US2_0(NamedTuple): # Computer
    tag = 0
class US2_1(NamedTuple): # Human
    tag = 1
class US2_2(NamedTuple): # Random
    tag = 2
US2 = Union[US2_0, US2_1, US2_2]
class US5_0(NamedTuple): # Flop
    v0 : static_array
    tag = 0
class US5_1(NamedTuple): # Preflop
    tag = 1
class US5_2(NamedTuple): # River
    v0 : static_array
    tag = 2
class US5_3(NamedTuple): # Turn
    v0 : static_array
    tag = 3
US5 = Union[US5_0, US5_1, US5_2, US5_3]
class US4_0(NamedTuple): # G_Flop
    v0 : i32
    v1 : static_array
    v2 : static_array
    v3 : i32
    v4 : static_array
    v5 : US5
    tag = 0
class US4_1(NamedTuple): # G_Fold
    v0 : i32
    v1 : static_array
    v2 : static_array
    v3 : i32
    v4 : static_array
    v5 : US5
    tag = 1
class US4_2(NamedTuple): # G_Preflop
    tag = 2
class US4_3(NamedTuple): # G_River
    v0 : i32
    v1 : static_array
    v2 : static_array
    v3 : i32
    v4 : static_array
    v5 : US5
    tag = 3
class US4_4(NamedTuple): # G_Round
    v0 : i32
    v1 : static_array
    v2 : static_array
    v3 : i32
    v4 : static_array
    v5 : US5
    tag = 4
class US4_5(NamedTuple): # G_Round'
    v0 : i32
    v1 : static_array
    v2 : static_array
    v3 : i32
    v4 : static_array
    v5 : US5
    v6 : US1
    tag = 5
class US4_6(NamedTuple): # G_Showdown
    v0 : i32
    v1 : static_array
    v2 : static_array
    v3 : i32
    v4 : static_array
    v5 : US5
    tag = 6
class US4_7(NamedTuple): # G_Turn
    v0 : i32
    v1 : static_array
    v2 : static_array
    v3 : i32
    v4 : static_array
    v5 : US5
    tag = 7
US4 = Union[US4_0, US4_1, US4_2, US4_3, US4_4, US4_5, US4_6, US4_7]
class US3_0(NamedTuple): # None
    tag = 0
class US3_1(NamedTuple): # Some
    v0 : US4
    tag = 1
US3 = Union[US3_0, US3_1]
class US6_0(NamedTuple): # GameNotStarted
    tag = 0
class US6_1(NamedTuple): # GameOver
    v0 : i32
    v1 : static_array
    v2 : static_array
    v3 : i32
    v4 : static_array
    v5 : US5
    tag = 1
class US6_2(NamedTuple): # WaitingForActionFromPlayerId
    v0 : i32
    v1 : static_array
    v2 : static_array
    v3 : i32
    v4 : static_array
    v5 : US5
    tag = 2
US6 = Union[US6_0, US6_1, US6_2]
class US7_0(NamedTuple): # CommunityCardsAre
    v0 : static_array_list
    tag = 0
class US7_1(NamedTuple): # Fold
    v0 : i32
    v1 : i32
    tag = 1
class US7_2(NamedTuple): # PlayerAction
    v0 : i32
    v1 : US1
    tag = 2
class US7_3(NamedTuple): # PlayerGotCards
    v0 : i32
    v1 : static_array
    tag = 3
class US7_4(NamedTuple): # Showdown
    v0 : i32
    v1 : static_array
    v2 : i32
    tag = 4
US7 = Union[US7_0, US7_1, US7_2, US7_3, US7_4]
class US8_0(NamedTuple): # AddRewardsRando
    v0 : list
    tag = 0
class US8_1(NamedTuple): # AddRewardsSelf
    v0 : list
    tag = 1
US8 = Union[US8_0, US8_1]
def Closure0():
    def inner(v0 : object, v1 : object) -> object:
        v2 = method0(v0)
        v3, v4, v5, v6, v7, v8, v9, v10, v11 = method8(v1)
        v12 = cp.empty(16,dtype=cp.uint8)
        v13 = cp.empty(6304,dtype=cp.uint8)
        method46(v13, v3, v4, v5, v6, v7)
        del v3, v4, v5, v6, v7
        v16 = "{}\n"
        v17 = "Going to run the NL Holdem full kernel."
        print(v16.format(v17),end="")
        del v16, v17
        v18 = time.perf_counter()
        v19 = []
        match v2:
            case US0_0(_): # ActionSelected
                method78(v12, v2)
                v78 = cp.cuda.Device().attributes['MultiProcessorCount']
                v79 = v78 == 24
                del v78
                v80 = v79 == False
                if v80:
                    v81 = "The number of SMs per GPU at runtime must much that what is declared atop of corecuda.base. Make sure to use the correct constant so it can be propagated at compile time."
                    assert v79, v81
                    del v81
                else:
                    pass
                del v79, v80
                v82 = 0
                v83 = raw_module.get_function(f"entry{v82}")
                del v82
                v83.max_dynamic_shared_size_bytes = 98304 
                print(f'DEBUG MODE. Threads per block, blocks per grid: {256}, {24}')
                v83((24,),(256,),(v13, v12, v8, v9, v10, v11),shared_mem=98304)
                del v83
            case US0_1(_): # PlayerChanged
                method78(v12, v2)
                v71 = cp.cuda.Device().attributes['MultiProcessorCount']
                v72 = v71 == 24
                del v71
                v73 = v72 == False
                if v73:
                    v74 = "The number of SMs per GPU at runtime must much that what is declared atop of corecuda.base. Make sure to use the correct constant so it can be propagated at compile time."
                    assert v72, v74
                    del v74
                else:
                    pass
                del v72, v73
                v75 = 0
                v76 = raw_module.get_function(f"entry{v75}")
                del v75
                v76.max_dynamic_shared_size_bytes = 98304 
                print(f'DEBUG MODE. Threads per block, blocks per grid: {256}, {24}')
                v76((24,),(256,),(v13, v12, v8, v9, v10, v11),shared_mem=98304)
                del v76
            case US0_2(): # StartGame
                method78(v12, v2)
                v64 = cp.cuda.Device().attributes['MultiProcessorCount']
                v65 = v64 == 24
                del v64
                v66 = v65 == False
                if v66:
                    v67 = "The number of SMs per GPU at runtime must much that what is declared atop of corecuda.base. Make sure to use the correct constant so it can be propagated at compile time."
                    assert v65, v67
                    del v67
                else:
                    pass
                del v65, v66
                v68 = 0
                v69 = raw_module.get_function(f"entry{v68}")
                del v68
                v69.max_dynamic_shared_size_bytes = 98304 
                print(f'DEBUG MODE. Threads per block, blocks per grid: {256}, {24}')
                v69((24,),(256,),(v13, v12, v8, v9, v10, v11),shared_mem=98304)
                del v69
            case US0_3(): # StartTrainingVsRando
                v20 = cp.zeros(16,dtype=cp.float32) # type: ignore
                v21 = cp.zeros(16,dtype=cp.float32) # type: ignore
                v22 = cp.empty(16,dtype=cp.float32)
                v23 = cp.cuda.Device().attributes['MultiProcessorCount']
                v24 = v23 == 24
                del v23
                v25 = v24 == False
                if v25:
                    v26 = "The number of SMs per GPU at runtime must much that what is declared atop of corecuda.base. Make sure to use the correct constant so it can be propagated at compile time."
                    assert v24, v26
                    del v26
                else:
                    pass
                del v24, v25
                v27 = 1
                v28 = raw_module.get_function(f"entry{v27}")
                del v27
                v28.max_dynamic_shared_size_bytes = 98304 
                print(f'DEBUG MODE. Threads per block, blocks per grid: {256}, {24}')
                v28((24,),(256,),(v8, v9, v10, v11, v20, v21, v22),shared_mem=98304)
                del v20, v21, v28
                v29 = []
                v31 = v22[0:]
                del v22
                v32 = v31.get()
                del v31
                v33 = 0
                while method63(v33):
                    v35 = []
                    v36 = 0
                    while method63(v36):
                        assert 0 <= v33 < 4, 'Tensor range check'
                        assert 0 <= v36 < 4, 'Tensor range check'
                        v38 = 4 * v33
                        v39 = v38 + v36
                        del v38
                        v40 = v32[v39].item()
                        del v39
                        v35.append(v40)
                        del v40
                        v36 += 1 
                    del v36
                    v29.append(v35)
                    del v35
                    v33 += 1 
                del v32, v33
                v41 = US8_0(v29)
                del v29
                v19.append(v41)
                del v41
            case US0_4(): # StartTrainingVsSelf
                v42 = cp.zeros(8,dtype=cp.float32) # type: ignore
                v43 = cp.zeros(8,dtype=cp.float32) # type: ignore
                v44 = cp.empty(8,dtype=cp.float32)
                v45 = cp.cuda.Device().attributes['MultiProcessorCount']
                v46 = v45 == 24
                del v45
                v47 = v46 == False
                if v47:
                    v48 = "The number of SMs per GPU at runtime must much that what is declared atop of corecuda.base. Make sure to use the correct constant so it can be propagated at compile time."
                    assert v46, v48
                    del v48
                else:
                    pass
                del v46, v47
                v49 = 2
                v50 = raw_module.get_function(f"entry{v49}")
                del v49
                v50.max_dynamic_shared_size_bytes = 98304 
                print(f'DEBUG MODE. Threads per block, blocks per grid: {256}, {24}')
                v50((24,),(256,),(v8, v9, v10, v11, v42, v43, v44),shared_mem=98304)
                del v42, v43, v50
                v51 = []
                v53 = v44[0:]
                del v44
                v54 = v53.get()
                del v53
                v55 = 0
                while method53(v55):
                    v57 = []
                    v58 = 0
                    while method63(v58):
                        assert 0 <= v55 < 2, 'Tensor range check'
                        assert 0 <= v58 < 4, 'Tensor range check'
                        v60 = 4 * v55
                        v61 = v60 + v58
                        del v60
                        v62 = v54[v61].item()
                        del v61
                        v57.append(v62)
                        del v62
                        v58 += 1 
                    del v58
                    v51.append(v57)
                    del v57
                    v55 += 1 
                del v54, v55
                v63 = US8_1(v51)
                del v51
                v19.append(v63)
                del v63
            case t:
                raise Exception(f'Pattern matching miss. Got: {t}')
        del v2, v12
        cp.cuda.get_current_stream().synchronize()
        v84 = time.perf_counter()
        v87 = "{}"
        v88 = "The time it took to run the kernel (in seconds) is: "
        print(v87.format(v88),end="")
        del v87, v88
        v89 = v84 - v18
        del v18, v84
        v92 = "{:.6f}\n"
        print(v92.format(v89),end="")
        del v89, v92
        v93, v94, v95, v96, v97 = method81(v13)
        del v13
        return method109(v93, v94, v95, v96, v97, v8, v9, v10, v11, v19)
    return inner
def Closure1():
    def inner() -> object:
        v1 = static_array(2)
        v3 = US2_0()
        v1[0] = v3
        del v3
        v5 = US2_1()
        v1[1] = v5
        del v5
        v7 = static_array_list(128)
        v8 = cp.empty(12419088,dtype=cp.uint8)
        v9 = cp.empty(204570624,dtype=cp.uint8)
        v11 = v8[0:0+4*1048576].view(cp.float32)
        v12 = cp.random.normal(0.0,0.0009765625,1048576,dtype=cp.float32) # type: ignore
        cp.copyto(v11[0:0+1048576],v12[0:0+1048576])
        del v11, v12
        v14 = v8[4194304:4194304+4*1].view(cp.int32)
        v16 = v8[4194320:4194320+4*262144].view(cp.float32)
        v18 = v8[5242896:5242896+4*262144].view(cp.float32)
        v20 = v8[6291472:6291472+4*262144].view(cp.float32)
        v22 = v8[7340048:7340048+4*262144].view(cp.float32)
        v24 = v8[8388624:8388624+4*262144].view(cp.float32)
        v26 = v8[9437200:9437200+4*262144].view(cp.float32)
        v28 = v8[10485776:10485776+4*262144].view(cp.float32)
        v14[:] = 0
        del v14
        v16[:] = 0
        del v16
        v18[:] = 0
        del v18
        v20[:] = 0
        del v20
        v22[:] = 0
        del v22
        v24[:] = 0
        del v24
        v26[:] = 0
        del v26
        v28[:] = 0
        del v28
        v30 = v8[11534352:11534352+8*49152].view(cp.float64)
        v32 = v8[11927568:11927568+8*49152].view(cp.float64)
        v34 = v8[12320784:12320784+4*24576].view(cp.int32)
        v30[:] = 0
        del v30
        v32[:] = 0
        del v32
        v34[:] = 0
        del v34
        v35 = 4503599627370495
        v36 = US3_0()
        v37 = US6_0()
        v38 = 204570624
        v39 = 12419088
        return method158(v35, v36, v7, v1, v37, v9, v38, v8, v39)
    return inner
def method3(v0 : object) -> None:
    assert v0 == [], f'Expected an unit type. Got: {v0}'
    del v0
    return 
def method4(v0 : object) -> i32:
    assert isinstance(v0,i32), f'The object needs to be the right primitive type. Got: {v0}'
    v1 = v0
    del v0
    return v1
def method2(v0 : object) -> US1:
    v1 = v0[0] # type: ignore
    v2 = v0[1] # type: ignore
    del v0
    v3 = "A_All_In" == v1
    if v3:
        del v1, v3
        method3(v2)
        del v2
        return US1_0()
    else:
        del v3
        v5 = "A_Call" == v1
        if v5:
            del v1, v5
            method3(v2)
            del v2
            return US1_1()
        else:
            del v5
            v7 = "A_Fold" == v1
            if v7:
                del v1, v7
                method3(v2)
                del v2
                return US1_2()
            else:
                del v7
                v9 = "A_Raise" == v1
                if v9:
                    del v1, v9
                    v10 = method4(v2)
                    del v2
                    return US1_3(v10)
                else:
                    del v2, v9
                    raise TypeError(f"Cannot convert the Python object into a Spiral union type. Invalid string tag. Got: {v1}")
                    del v1
                    raise Exception("Error")
def method6(v0 : i32, v1 : i32) -> bool:
    v2 = v1 < v0
    del v0, v1
    return v2
def method7(v0 : object) -> US2:
    v1 = v0[0] # type: ignore
    v2 = v0[1] # type: ignore
    del v0
    v3 = "Computer" == v1
    if v3:
        del v1, v3
        method3(v2)
        del v2
        return US2_0()
    else:
        del v3
        v5 = "Human" == v1
        if v5:
            del v1, v5
            method3(v2)
            del v2
            return US2_1()
        else:
            del v5
            v7 = "Random" == v1
            if v7:
                del v1, v7
                method3(v2)
                del v2
                return US2_2()
            else:
                del v2, v7
                raise TypeError(f"Cannot convert the Python object into a Spiral union type. Invalid string tag. Got: {v1}")
                del v1
                raise Exception("Error")
def method5(v0 : object) -> static_array:
    assert isinstance(v0,list), f'The object needs to be a Python list. Got: {v0}'
    v1 = len(v0) # type: ignore
    v2 = 2 == v1
    v3 = v2 == False
    if v3:
        v4 = "The type level dimension has to equal the value passed at runtime into create."
        assert v2, v4
        del v4
    else:
        pass
    del v2, v3
    v6 = static_array(2)
    v7 = 0
    while method6(v1, v7):
        v9 = v0[v7]
        v10 = method7(v9)
        del v9
        v6[v7] = v10
        del v10
        v7 += 1 
    del v0, v1, v7
    return v6
def method1(v0 : object) -> US0:
    v1 = v0[0] # type: ignore
    v2 = v0[1] # type: ignore
    del v0
    v3 = "ActionSelected" == v1
    if v3:
        del v1, v3
        v4 = method2(v2)
        del v2
        return US0_0(v4)
    else:
        del v3
        v6 = "PlayerChanged" == v1
        if v6:
            del v1, v6
            v7 = method5(v2)
            del v2
            return US0_1(v7)
        else:
            del v6
            v9 = "StartGame" == v1
            if v9:
                del v1, v9
                method3(v2)
                del v2
                return US0_2()
            else:
                del v9
                v11 = "StartTrainingVsRando" == v1
                if v11:
                    del v1, v11
                    method3(v2)
                    del v2
                    return US0_3()
                else:
                    del v11
                    v13 = "StartTrainingVsSelf" == v1
                    if v13:
                        del v1, v13
                        method3(v2)
                        del v2
                        return US0_4()
                    else:
                        del v2, v13
                        raise TypeError(f"Cannot convert the Python object into a Spiral union type. Invalid string tag. Got: {v1}")
                        del v1
                        raise Exception("Error")
def method0(v0 : object) -> US0:
    return method1(v0)
def method13(v0 : object) -> u64:
    assert isinstance(v0,u64), f'The object needs to be the right primitive type. Got: {v0}'
    v1 = v0
    del v0
    return v1
def method12(v0 : object) -> u64:
    v1 = method13(v0)
    del v0
    return v1
def method20(v0 : object) -> u8:
    assert isinstance(v0,u8), f'The object needs to be the right primitive type. Got: {v0}'
    v1 = v0
    del v0
    return v1
def method19(v0 : object) -> u8:
    v1 = method20(v0)
    del v0
    return v1
def method18(v0 : object) -> static_array:
    assert isinstance(v0,list), f'The object needs to be a Python list. Got: {v0}'
    v1 = len(v0) # type: ignore
    v2 = 2 == v1
    v3 = v2 == False
    if v3:
        v4 = "The type level dimension has to equal the value passed at runtime into create."
        assert v2, v4
        del v4
    else:
        pass
    del v2, v3
    v6 = static_array(2)
    v7 = 0
    while method6(v1, v7):
        v9 = v0[v7]
        v10 = method19(v9)
        del v9
        v6[v7] = v10
        del v10
        v7 += 1 
    del v0, v1, v7
    return v6
def method17(v0 : object) -> static_array:
    assert isinstance(v0,list), f'The object needs to be a Python list. Got: {v0}'
    v1 = len(v0) # type: ignore
    v2 = 2 == v1
    v3 = v2 == False
    if v3:
        v4 = "The type level dimension has to equal the value passed at runtime into create."
        assert v2, v4
        del v4
    else:
        pass
    del v2, v3
    v6 = static_array(2)
    v7 = 0
    while method6(v1, v7):
        v9 = v0[v7]
        v10 = method18(v9)
        del v9
        v6[v7] = v10
        del v10
        v7 += 1 
    del v0, v1, v7
    return v6
def method21(v0 : object) -> static_array:
    assert isinstance(v0,list), f'The object needs to be a Python list. Got: {v0}'
    v1 = len(v0) # type: ignore
    v2 = 2 == v1
    v3 = v2 == False
    if v3:
        v4 = "The type level dimension has to equal the value passed at runtime into create."
        assert v2, v4
        del v4
    else:
        pass
    del v2, v3
    v6 = static_array(2)
    v7 = 0
    while method6(v1, v7):
        v9 = v0[v7]
        v10 = method4(v9)
        del v9
        v6[v7] = v10
        del v10
        v7 += 1 
    del v0, v1, v7
    return v6
def method23(v0 : object) -> static_array:
    assert isinstance(v0,list), f'The object needs to be a Python list. Got: {v0}'
    v1 = len(v0) # type: ignore
    v2 = 3 == v1
    v3 = v2 == False
    if v3:
        v4 = "The type level dimension has to equal the value passed at runtime into create."
        assert v2, v4
        del v4
    else:
        pass
    del v2, v3
    v6 = static_array(3)
    v7 = 0
    while method6(v1, v7):
        v9 = v0[v7]
        v10 = method19(v9)
        del v9
        v6[v7] = v10
        del v10
        v7 += 1 
    del v0, v1, v7
    return v6
def method24(v0 : object) -> static_array:
    assert isinstance(v0,list), f'The object needs to be a Python list. Got: {v0}'
    v1 = len(v0) # type: ignore
    v2 = 5 == v1
    v3 = v2 == False
    if v3:
        v4 = "The type level dimension has to equal the value passed at runtime into create."
        assert v2, v4
        del v4
    else:
        pass
    del v2, v3
    v6 = static_array(5)
    v7 = 0
    while method6(v1, v7):
        v9 = v0[v7]
        v10 = method19(v9)
        del v9
        v6[v7] = v10
        del v10
        v7 += 1 
    del v0, v1, v7
    return v6
def method25(v0 : object) -> static_array:
    assert isinstance(v0,list), f'The object needs to be a Python list. Got: {v0}'
    v1 = len(v0) # type: ignore
    v2 = 4 == v1
    v3 = v2 == False
    if v3:
        v4 = "The type level dimension has to equal the value passed at runtime into create."
        assert v2, v4
        del v4
    else:
        pass
    del v2, v3
    v6 = static_array(4)
    v7 = 0
    while method6(v1, v7):
        v9 = v0[v7]
        v10 = method19(v9)
        del v9
        v6[v7] = v10
        del v10
        v7 += 1 
    del v0, v1, v7
    return v6
def method22(v0 : object) -> US5:
    v1 = v0[0] # type: ignore
    v2 = v0[1] # type: ignore
    del v0
    v3 = "Flop" == v1
    if v3:
        del v1, v3
        v4 = method23(v2)
        del v2
        return US5_0(v4)
    else:
        del v3
        v6 = "Preflop" == v1
        if v6:
            del v1, v6
            method3(v2)
            del v2
            return US5_1()
        else:
            del v6
            v8 = "River" == v1
            if v8:
                del v1, v8
                v9 = method24(v2)
                del v2
                return US5_2(v9)
            else:
                del v8
                v11 = "Turn" == v1
                if v11:
                    del v1, v11
                    v12 = method25(v2)
                    del v2
                    return US5_3(v12)
                else:
                    del v2, v11
                    raise TypeError(f"Cannot convert the Python object into a Spiral union type. Invalid string tag. Got: {v1}")
                    del v1
                    raise Exception("Error")
def method16(v0 : object) -> Tuple[i32, static_array, static_array, i32, static_array, US5]:
    v1 = v0["min_raise"] # type: ignore
    v2 = method4(v1)
    del v1
    v3 = v0["pl_card"] # type: ignore
    v4 = method17(v3)
    del v3
    v5 = v0["pot"] # type: ignore
    v6 = method21(v5)
    del v5
    v7 = v0["round_turn"] # type: ignore
    v8 = method4(v7)
    del v7
    v9 = v0["stack"] # type: ignore
    v10 = method21(v9)
    del v9
    v11 = v0["street"] # type: ignore
    del v0
    v12 = method22(v11)
    del v11
    return v2, v4, v6, v8, v10, v12
def method26(v0 : object) -> Tuple[i32, static_array, static_array, i32, static_array, US5, US1]:
    v1 = v0[0] # type: ignore
    v2, v3, v4, v5, v6, v7 = method16(v1)
    del v1
    v8 = v0[1] # type: ignore
    del v0
    v9 = method2(v8)
    del v8
    return v2, v3, v4, v5, v6, v7, v9
def method15(v0 : object) -> US4:
    v1 = v0[0] # type: ignore
    v2 = v0[1] # type: ignore
    del v0
    v3 = "G_Flop" == v1
    if v3:
        del v1, v3
        v4, v5, v6, v7, v8, v9 = method16(v2)
        del v2
        return US4_0(v4, v5, v6, v7, v8, v9)
    else:
        del v3
        v11 = "G_Fold" == v1
        if v11:
            del v1, v11
            v12, v13, v14, v15, v16, v17 = method16(v2)
            del v2
            return US4_1(v12, v13, v14, v15, v16, v17)
        else:
            del v11
            v19 = "G_Preflop" == v1
            if v19:
                del v1, v19
                method3(v2)
                del v2
                return US4_2()
            else:
                del v19
                v21 = "G_River" == v1
                if v21:
                    del v1, v21
                    v22, v23, v24, v25, v26, v27 = method16(v2)
                    del v2
                    return US4_3(v22, v23, v24, v25, v26, v27)
                else:
                    del v21
                    v29 = "G_Round" == v1
                    if v29:
                        del v1, v29
                        v30, v31, v32, v33, v34, v35 = method16(v2)
                        del v2
                        return US4_4(v30, v31, v32, v33, v34, v35)
                    else:
                        del v29
                        v37 = "G_Round'" == v1
                        if v37:
                            del v1, v37
                            v38, v39, v40, v41, v42, v43, v44 = method26(v2)
                            del v2
                            return US4_5(v38, v39, v40, v41, v42, v43, v44)
                        else:
                            del v37
                            v46 = "G_Showdown" == v1
                            if v46:
                                del v1, v46
                                v47, v48, v49, v50, v51, v52 = method16(v2)
                                del v2
                                return US4_6(v47, v48, v49, v50, v51, v52)
                            else:
                                del v46
                                v54 = "G_Turn" == v1
                                if v54:
                                    del v1, v54
                                    v55, v56, v57, v58, v59, v60 = method16(v2)
                                    del v2
                                    return US4_7(v55, v56, v57, v58, v59, v60)
                                else:
                                    del v2, v54
                                    raise TypeError(f"Cannot convert the Python object into a Spiral union type. Invalid string tag. Got: {v1}")
                                    del v1
                                    raise Exception("Error")
def method14(v0 : object) -> US3:
    v1 = v0[0] # type: ignore
    v2 = v0[1] # type: ignore
    del v0
    v3 = "None" == v1
    if v3:
        del v1, v3
        method3(v2)
        del v2
        return US3_0()
    else:
        del v3
        v5 = "Some" == v1
        if v5:
            del v1, v5
            v6 = method15(v2)
            del v2
            return US3_1(v6)
        else:
            del v2, v5
            raise TypeError(f"Cannot convert the Python object into a Spiral union type. Invalid string tag. Got: {v1}")
            del v1
            raise Exception("Error")
def method11(v0 : object) -> Tuple[u64, US3]:
    v1 = v0["deck"] # type: ignore
    v2 = method12(v1)
    del v1
    v3 = v0["game"] # type: ignore
    del v0
    v4 = method14(v3)
    del v3
    return v2, v4
def method30(v0 : object) -> static_array_list:
    v1 = len(v0) # type: ignore
    assert (5 >= v1), f'The length of the original object has to be greater than or equal to the static array dimension.\nExpected: 5\nGot: {v1} '
    del v1
    assert isinstance(v0,list), f'The object needs to be a Python list. Got: {v0}'
    v2 = len(v0) # type: ignore
    v3 = 5 >= v2
    v4 = v3 == False
    if v4:
        v5 = "The type level dimension has to equal the value passed at runtime into create."
        assert v3, v5
        del v5
    else:
        pass
    del v3, v4
    v7 = static_array_list(5)
    v7.unsafe_set_length(v2)
    v8 = 0
    while method6(v2, v8):
        v10 = v0[v8]
        v11 = method19(v10)
        del v10
        v7[v8] = v11
        del v11
        v8 += 1 
    del v0, v2, v8
    return v7
def method31(v0 : object) -> Tuple[i32, i32]:
    v1 = v0["chips_won"] # type: ignore
    v2 = method4(v1)
    del v1
    v3 = v0["winner_id"] # type: ignore
    del v0
    v4 = method4(v3)
    del v3
    return v2, v4
def method32(v0 : object) -> Tuple[i32, US1]:
    v1 = v0[0] # type: ignore
    v2 = method4(v1)
    del v1
    v3 = v0[1] # type: ignore
    del v0
    v4 = method2(v3)
    del v3
    return v2, v4
def method33(v0 : object) -> Tuple[i32, static_array]:
    v1 = v0[0] # type: ignore
    v2 = method4(v1)
    del v1
    v3 = v0[1] # type: ignore
    del v0
    v4 = method18(v3)
    del v3
    return v2, v4
def method38(v0 : object) -> i8:
    assert isinstance(v0,i8), f'The object needs to be the right primitive type. Got: {v0}'
    v1 = v0
    del v0
    return v1
def method37(v0 : object) -> Tuple[static_array, i8]:
    v1 = v0["hand"] # type: ignore
    v2 = method24(v1)
    del v1
    v3 = v0["score"] # type: ignore
    del v0
    v4 = method38(v3)
    del v3
    return v2, v4
def method36(v0 : object) -> Tuple[static_array, i8]:
    v1, v2 = method37(v0)
    del v0
    return v1, v2
def method35(v0 : object) -> static_array:
    assert isinstance(v0,list), f'The object needs to be a Python list. Got: {v0}'
    v1 = len(v0) # type: ignore
    v2 = 2 == v1
    v3 = v2 == False
    if v3:
        v4 = "The type level dimension has to equal the value passed at runtime into create."
        assert v2, v4
        del v4
    else:
        pass
    del v2, v3
    v6 = static_array(2)
    v7 = 0
    while method6(v1, v7):
        v9 = v0[v7]
        v10, v11 = method36(v9)
        del v9
        v6[v7] = (v10, v11)
        del v10, v11
        v7 += 1 
    del v0, v1, v7
    return v6
def method34(v0 : object) -> Tuple[i32, static_array, i32]:
    v1 = v0["chips_won"] # type: ignore
    v2 = method4(v1)
    del v1
    v3 = v0["hands_shown"] # type: ignore
    v4 = method35(v3)
    del v3
    v5 = v0["winner_id"] # type: ignore
    del v0
    v6 = method4(v5)
    del v5
    return v2, v4, v6
def method29(v0 : object) -> US7:
    v1 = v0[0] # type: ignore
    v2 = v0[1] # type: ignore
    del v0
    v3 = "CommunityCardsAre" == v1
    if v3:
        del v1, v3
        v4 = method30(v2)
        del v2
        return US7_0(v4)
    else:
        del v3
        v6 = "Fold" == v1
        if v6:
            del v1, v6
            v7, v8 = method31(v2)
            del v2
            return US7_1(v7, v8)
        else:
            del v6
            v10 = "PlayerAction" == v1
            if v10:
                del v1, v10
                v11, v12 = method32(v2)
                del v2
                return US7_2(v11, v12)
            else:
                del v10
                v14 = "PlayerGotCards" == v1
                if v14:
                    del v1, v14
                    v15, v16 = method33(v2)
                    del v2
                    return US7_3(v15, v16)
                else:
                    del v14
                    v18 = "Showdown" == v1
                    if v18:
                        del v1, v18
                        v19, v20, v21 = method34(v2)
                        del v2
                        return US7_4(v19, v20, v21)
                    else:
                        del v2, v18
                        raise TypeError(f"Cannot convert the Python object into a Spiral union type. Invalid string tag. Got: {v1}")
                        del v1
                        raise Exception("Error")
def method28(v0 : object) -> static_array_list:
    v1 = len(v0) # type: ignore
    assert (128 >= v1), f'The length of the original object has to be greater than or equal to the static array dimension.\nExpected: 128\nGot: {v1} '
    del v1
    assert isinstance(v0,list), f'The object needs to be a Python list. Got: {v0}'
    v2 = len(v0) # type: ignore
    v3 = 128 >= v2
    v4 = v3 == False
    if v4:
        v5 = "The type level dimension has to equal the value passed at runtime into create."
        assert v3, v5
        del v5
    else:
        pass
    del v3, v4
    v7 = static_array_list(128)
    v7.unsafe_set_length(v2)
    v8 = 0
    while method6(v2, v8):
        v10 = v0[v8]
        v11 = method29(v10)
        del v10
        v7[v8] = v11
        del v11
        v8 += 1 
    del v0, v2, v8
    return v7
def method39(v0 : object) -> US6:
    v1 = v0[0] # type: ignore
    v2 = v0[1] # type: ignore
    del v0
    v3 = "GameNotStarted" == v1
    if v3:
        del v1, v3
        method3(v2)
        del v2
        return US6_0()
    else:
        del v3
        v5 = "GameOver" == v1
        if v5:
            del v1, v5
            v6, v7, v8, v9, v10, v11 = method16(v2)
            del v2
            return US6_1(v6, v7, v8, v9, v10, v11)
        else:
            del v5
            v13 = "WaitingForActionFromPlayerId" == v1
            if v13:
                del v1, v13
                v14, v15, v16, v17, v18, v19 = method16(v2)
                del v2
                return US6_2(v14, v15, v16, v17, v18, v19)
            else:
                del v2, v13
                raise TypeError(f"Cannot convert the Python object into a Spiral union type. Invalid string tag. Got: {v1}")
                del v1
                raise Exception("Error")
def method27(v0 : object) -> Tuple[static_array_list, static_array, US6]:
    v1 = v0["messages"] # type: ignore
    v2 = method28(v1)
    del v1
    v3 = v0["pl_type"] # type: ignore
    v4 = method5(v3)
    del v3
    v5 = v0["ui_game_state"] # type: ignore
    del v0
    v6 = method39(v5)
    del v5
    return v2, v4, v6
def method10(v0 : object) -> Tuple[u64, US3, static_array_list, static_array, US6]:
    v1 = v0["private"] # type: ignore
    v2, v3 = method11(v1)
    del v1
    v4 = v0["public"] # type: ignore
    del v0
    v5, v6, v7 = method27(v4)
    del v4
    return v2, v3, v5, v6, v7
def method45(v0 : object) -> cp.ndarray:
    assert isinstance(v0,cp.ndarray), f'The object needs to be the right primitive type. Got: {v0}'
    v1 = v0
    del v0
    return v1
def method44(v0 : object) -> cp.ndarray:
    v1 = method45(v0)
    del v0
    return v1
def method43(v0 : object) -> Tuple[cp.ndarray, u64]:
    v1 = v0[0] # type: ignore
    v2 = method44(v1)
    del v1
    v3 = v0[1] # type: ignore
    del v0
    v4 = method13(v3)
    del v3
    return v2, v4
def method42(v0 : object) -> Tuple[cp.ndarray, u64, cp.ndarray, u64]:
    v1 = v0["output"] # type: ignore
    v2, v3 = method43(v1)
    del v1
    v4 = v0["param"] # type: ignore
    del v0
    v5, v6 = method43(v4)
    del v4
    return v2, v3, v5, v6
def method41(v0 : object) -> Tuple[cp.ndarray, u64, cp.ndarray, u64]:
    v1, v2, v3, v4 = method42(v0)
    del v0
    return v1, v2, v3, v4
def method40(v0 : object) -> Tuple[cp.ndarray, u64, cp.ndarray, u64]:
    v1 = v0["model_data"] # type: ignore
    del v0
    v2, v3, v4, v5 = method41(v1)
    del v1
    return v2, v3, v4, v5
def method9(v0 : object) -> Tuple[u64, US3, static_array_list, static_array, US6, cp.ndarray, u64, cp.ndarray, u64]:
    v1 = v0["game"] # type: ignore
    v2, v3, v4, v5, v6 = method10(v1)
    del v1
    v7 = v0["neural"] # type: ignore
    del v0
    v8, v9, v10, v11 = method40(v7)
    del v7
    return v2, v3, v4, v5, v6, v8, v9, v10, v11
def method8(v0 : object) -> Tuple[u64, US3, static_array_list, static_array, US6, cp.ndarray, u64, cp.ndarray, u64]:
    return method9(v0)
def method47(v0 : cp.ndarray, v1 : u64) -> None:
    v3 = v0[0:].view(cp.uint64)
    del v0
    v3[0] = v1
    del v1, v3
    return 
def method48(v0 : cp.ndarray, v1 : i32) -> None:
    v3 = v0[8:].view(cp.int32)
    del v0
    v3[0] = v1
    del v1, v3
    return 
def method49(v0 : cp.ndarray) -> None:
    del v0
    return 
def method51(v0 : cp.ndarray, v1 : i32) -> None:
    v3 = v0[0:].view(cp.int32)
    del v0
    v3[0] = v1
    del v1, v3
    return 
def method53(v0 : i32) -> bool:
    v1 = v0 < 2
    del v0
    return v1
def method56(v0 : cp.ndarray, v1 : u8) -> None:
    v3 = v0[0:].view(cp.uint8)
    del v0
    v3[0] = v1
    del v1, v3
    return 
def method55(v0 : cp.ndarray, v1 : u8) -> None:
    return method56(v0, v1)
def method54(v0 : cp.ndarray, v1 : static_array) -> None:
    v2 = 0
    while method53(v2):
        v4 = u64(v2)
        v6 = v0[v4:].view(cp.uint8)
        del v4
        v8 = v1[v2]
        method55(v6, v8)
        del v6, v8
        v2 += 1 
    del v0, v1, v2
    return 
def method57(v0 : cp.ndarray, v1 : i32) -> None:
    v3 = v0[28:].view(cp.int32)
    del v0
    v3[0] = v1
    del v1, v3
    return 
def method59(v0 : i32) -> bool:
    v1 = v0 < 3
    del v0
    return v1
def method58(v0 : cp.ndarray, v1 : static_array) -> None:
    v2 = 0
    while method59(v2):
        v4 = u64(v2)
        v6 = v0[v4:].view(cp.uint8)
        del v4
        v8 = v1[v2]
        method55(v6, v8)
        del v6, v8
        v2 += 1 
    del v0, v1, v2
    return 
def method61(v0 : i32) -> bool:
    v1 = v0 < 5
    del v0
    return v1
def method60(v0 : cp.ndarray, v1 : static_array) -> None:
    v2 = 0
    while method61(v2):
        v4 = u64(v2)
        v6 = v0[v4:].view(cp.uint8)
        del v4
        v8 = v1[v2]
        method55(v6, v8)
        del v6, v8
        v2 += 1 
    del v0, v1, v2
    return 
def method63(v0 : i32) -> bool:
    v1 = v0 < 4
    del v0
    return v1
def method62(v0 : cp.ndarray, v1 : static_array) -> None:
    v2 = 0
    while method63(v2):
        v4 = u64(v2)
        v6 = v0[v4:].view(cp.uint8)
        del v4
        v8 = v1[v2]
        method55(v6, v8)
        del v6, v8
        v2 += 1 
    del v0, v1, v2
    return 
def method52(v0 : cp.ndarray, v1 : i32, v2 : static_array, v3 : static_array, v4 : i32, v5 : static_array, v6 : US5) -> None:
    v8 = v0[0:].view(cp.int32)
    v8[0] = v1
    del v1, v8
    v9 = 0
    while method53(v9):
        v11 = u64(v9)
        v12 = v11 * 2
        del v11
        v13 = 4 + v12
        del v12
        v15 = v0[v13:].view(cp.uint8)
        del v13
        v17 = v2[v9]
        method54(v15, v17)
        del v15, v17
        v9 += 1 
    del v2, v9
    v18 = 0
    while method53(v18):
        v20 = u64(v18)
        v21 = v20 * 4
        del v20
        v22 = 8 + v21
        del v21
        v24 = v0[v22:].view(cp.uint8)
        del v22
        v26 = v3[v18]
        method51(v24, v26)
        del v24, v26
        v18 += 1 
    del v3, v18
    v28 = v0[16:].view(cp.int32)
    v28[0] = v4
    del v4, v28
    v29 = 0
    while method53(v29):
        v31 = u64(v29)
        v32 = v31 * 4
        del v31
        v33 = 20 + v32
        del v32
        v35 = v0[v33:].view(cp.uint8)
        del v33
        v37 = v5[v29]
        method51(v35, v37)
        del v35, v37
        v29 += 1 
    del v5, v29
    v38 = v6.tag
    method57(v0, v38)
    del v38
    v40 = v0[32:].view(cp.uint8)
    del v0
    match v6:
        case US5_0(v41): # Flop
            del v6
            return method58(v40, v41)
        case US5_1(): # Preflop
            del v6
            return method49(v40)
        case US5_2(v42): # River
            del v6
            return method60(v40, v42)
        case US5_3(v43): # Turn
            del v6
            return method62(v40, v43)
        case t:
            raise Exception(f'Pattern matching miss. Got: {t}')
def method65(v0 : cp.ndarray, v1 : i32) -> None:
    v3 = v0[40:].view(cp.int32)
    del v0
    v3[0] = v1
    del v1, v3
    return 
def method64(v0 : cp.ndarray, v1 : i32, v2 : static_array, v3 : static_array, v4 : i32, v5 : static_array, v6 : US5, v7 : US1) -> None:
    v9 = v0[0:].view(cp.int32)
    v9[0] = v1
    del v1, v9
    v10 = 0
    while method53(v10):
        v12 = u64(v10)
        v13 = v12 * 2
        del v12
        v14 = 4 + v13
        del v13
        v16 = v0[v14:].view(cp.uint8)
        del v14
        v18 = v2[v10]
        method54(v16, v18)
        del v16, v18
        v10 += 1 
    del v2, v10
    v19 = 0
    while method53(v19):
        v21 = u64(v19)
        v22 = v21 * 4
        del v21
        v23 = 8 + v22
        del v22
        v25 = v0[v23:].view(cp.uint8)
        del v23
        v27 = v3[v19]
        method51(v25, v27)
        del v25, v27
        v19 += 1 
    del v3, v19
    v29 = v0[16:].view(cp.int32)
    v29[0] = v4
    del v4, v29
    v30 = 0
    while method53(v30):
        v32 = u64(v30)
        v33 = v32 * 4
        del v32
        v34 = 20 + v33
        del v33
        v36 = v0[v34:].view(cp.uint8)
        del v34
        v38 = v5[v30]
        method51(v36, v38)
        del v36, v38
        v30 += 1 
    del v5, v30
    v39 = v6.tag
    method57(v0, v39)
    del v39
    v41 = v0[32:].view(cp.uint8)
    match v6:
        case US5_0(v42): # Flop
            method58(v41, v42)
        case US5_1(): # Preflop
            method49(v41)
        case US5_2(v43): # River
            method60(v41, v43)
        case US5_3(v44): # Turn
            method62(v41, v44)
        case t:
            raise Exception(f'Pattern matching miss. Got: {t}')
    del v6, v41
    v45 = v7.tag
    method65(v0, v45)
    del v45
    v47 = v0[44:].view(cp.uint8)
    del v0
    match v7:
        case US1_0(): # A_All_In
            del v7
            return method49(v47)
        case US1_1(): # A_Call
            del v7
            return method49(v47)
        case US1_2(): # A_Fold
            del v7
            return method49(v47)
        case US1_3(v48): # A_Raise
            del v7
            return method51(v47, v48)
        case t:
            raise Exception(f'Pattern matching miss. Got: {t}')
def method50(v0 : cp.ndarray, v1 : US4) -> None:
    v2 = v1.tag
    method51(v0, v2)
    del v2
    v4 = v0[16:].view(cp.uint8)
    del v0
    match v1:
        case US4_0(v5, v6, v7, v8, v9, v10): # G_Flop
            del v1
            return method52(v4, v5, v6, v7, v8, v9, v10)
        case US4_1(v11, v12, v13, v14, v15, v16): # G_Fold
            del v1
            return method52(v4, v11, v12, v13, v14, v15, v16)
        case US4_2(): # G_Preflop
            del v1
            return method49(v4)
        case US4_3(v17, v18, v19, v20, v21, v22): # G_River
            del v1
            return method52(v4, v17, v18, v19, v20, v21, v22)
        case US4_4(v23, v24, v25, v26, v27, v28): # G_Round
            del v1
            return method52(v4, v23, v24, v25, v26, v27, v28)
        case US4_5(v29, v30, v31, v32, v33, v34, v35): # G_Round'
            del v1
            return method64(v4, v29, v30, v31, v32, v33, v34, v35)
        case US4_6(v36, v37, v38, v39, v40, v41): # G_Showdown
            del v1
            return method52(v4, v36, v37, v38, v39, v40, v41)
        case US4_7(v42, v43, v44, v45, v46, v47): # G_Turn
            del v1
            return method52(v4, v42, v43, v44, v45, v46, v47)
        case t:
            raise Exception(f'Pattern matching miss. Got: {t}')
def method66(v0 : cp.ndarray, v1 : i32) -> None:
    v3 = v0[80:].view(cp.int32)
    del v0
    v3[0] = v1
    del v1, v3
    return 
def method68(v0 : cp.ndarray, v1 : static_array_list) -> None:
    v2 = v1.length
    method51(v0, v2)
    del v2
    v3 = v1.length
    v4 = 0
    while method6(v3, v4):
        v6 = u64(v4)
        v7 = 4 + v6
        del v6
        v9 = v0[v7:].view(cp.uint8)
        del v7
        v11 = v1[v4]
        method55(v9, v11)
        del v9, v11
        v4 += 1 
    del v0, v1, v3, v4
    return 
def method69(v0 : cp.ndarray, v1 : i32, v2 : i32) -> None:
    v4 = v0[0:].view(cp.int32)
    v4[0] = v1
    del v1, v4
    v6 = v0[4:].view(cp.int32)
    del v0
    v6[0] = v2
    del v2, v6
    return 
def method71(v0 : cp.ndarray, v1 : i32) -> None:
    v3 = v0[4:].view(cp.int32)
    del v0
    v3[0] = v1
    del v1, v3
    return 
def method70(v0 : cp.ndarray, v1 : i32, v2 : US1) -> None:
    v4 = v0[0:].view(cp.int32)
    v4[0] = v1
    del v1, v4
    v5 = v2.tag
    method71(v0, v5)
    del v5
    v7 = v0[8:].view(cp.uint8)
    del v0
    match v2:
        case US1_0(): # A_All_In
            del v2
            return method49(v7)
        case US1_1(): # A_Call
            del v2
            return method49(v7)
        case US1_2(): # A_Fold
            del v2
            return method49(v7)
        case US1_3(v8): # A_Raise
            del v2
            return method51(v7, v8)
        case t:
            raise Exception(f'Pattern matching miss. Got: {t}')
def method72(v0 : cp.ndarray, v1 : i32, v2 : static_array) -> None:
    v4 = v0[0:].view(cp.int32)
    v4[0] = v1
    del v1, v4
    v5 = 0
    while method53(v5):
        v7 = u64(v5)
        v8 = 4 + v7
        del v7
        v10 = v0[v8:].view(cp.uint8)
        del v8
        v12 = v2[v5]
        method55(v10, v12)
        del v10, v12
        v5 += 1 
    del v0, v2, v5
    return 
def method75(v0 : cp.ndarray, v1 : static_array, v2 : i8) -> None:
    v3 = 0
    while method61(v3):
        v5 = u64(v3)
        v7 = v0[v5:].view(cp.uint8)
        del v5
        v9 = v1[v3]
        method55(v7, v9)
        del v7, v9
        v3 += 1 
    del v1, v3
    v11 = v0[5:].view(cp.int8)
    del v0
    v11[0] = v2
    del v2, v11
    return 
def method74(v0 : cp.ndarray, v1 : static_array, v2 : i8) -> None:
    return method75(v0, v1, v2)
def method73(v0 : cp.ndarray, v1 : i32, v2 : static_array, v3 : i32) -> None:
    v5 = v0[0:].view(cp.int32)
    v5[0] = v1
    del v1, v5
    v6 = 0
    while method53(v6):
        v8 = u64(v6)
        v9 = v8 * 8
        del v8
        v10 = 8 + v9
        del v9
        v12 = v0[v10:].view(cp.uint8)
        del v10
        v15, v16 = v2[v6]
        method74(v12, v15, v16)
        del v12, v15, v16
        v6 += 1 
    del v2, v6
    v18 = v0[24:].view(cp.int32)
    del v0
    v18[0] = v3
    del v3, v18
    return 
def method67(v0 : cp.ndarray, v1 : US7) -> None:
    v2 = v1.tag
    method51(v0, v2)
    del v2
    v4 = v0[16:].view(cp.uint8)
    del v0
    match v1:
        case US7_0(v5): # CommunityCardsAre
            del v1
            return method68(v4, v5)
        case US7_1(v6, v7): # Fold
            del v1
            return method69(v4, v6, v7)
        case US7_2(v8, v9): # PlayerAction
            del v1
            return method70(v4, v8, v9)
        case US7_3(v10, v11): # PlayerGotCards
            del v1
            return method72(v4, v10, v11)
        case US7_4(v12, v13, v14): # Showdown
            del v1
            return method73(v4, v12, v13, v14)
        case t:
            raise Exception(f'Pattern matching miss. Got: {t}')
def method76(v0 : cp.ndarray, v1 : US2) -> None:
    v2 = v1.tag
    method51(v0, v2)
    del v2
    v4 = v0[4:].view(cp.uint8)
    del v0
    match v1:
        case US2_0(): # Computer
            del v1
            return method49(v4)
        case US2_1(): # Human
            del v1
            return method49(v4)
        case US2_2(): # Random
            del v1
            return method49(v4)
        case t:
            raise Exception(f'Pattern matching miss. Got: {t}')
def method77(v0 : cp.ndarray, v1 : i32) -> None:
    v3 = v0[6248:].view(cp.int32)
    del v0
    v3[0] = v1
    del v1, v3
    return 
def method46(v0 : cp.ndarray, v1 : u64, v2 : US3, v3 : static_array_list, v4 : static_array, v5 : US6) -> None:
    method47(v0, v1)
    del v1
    v6 = v2.tag
    method48(v0, v6)
    del v6
    v8 = v0[16:].view(cp.uint8)
    match v2:
        case US3_0(): # None
            method49(v8)
        case US3_1(v9): # Some
            method50(v8, v9)
        case t:
            raise Exception(f'Pattern matching miss. Got: {t}')
    del v2, v8
    v10 = v3.length
    method66(v0, v10)
    del v10
    v11 = v3.length
    v12 = 0
    while method6(v11, v12):
        v14 = u64(v12)
        v15 = v14 * 48
        del v14
        v16 = 96 + v15
        del v15
        v18 = v0[v16:].view(cp.uint8)
        del v16
        v20 = v3[v12]
        method67(v18, v20)
        del v18, v20
        v12 += 1 
    del v3, v11, v12
    v21 = 0
    while method53(v21):
        v23 = u64(v21)
        v24 = v23 * 4
        del v23
        v25 = 6240 + v24
        del v24
        v27 = v0[v25:].view(cp.uint8)
        del v25
        v29 = v4[v21]
        method76(v27, v29)
        del v27, v29
        v21 += 1 
    del v4, v21
    v30 = v5.tag
    method77(v0, v30)
    del v30
    v32 = v0[6256:].view(cp.uint8)
    del v0
    match v5:
        case US6_0(): # GameNotStarted
            del v5
            return method49(v32)
        case US6_1(v33, v34, v35, v36, v37, v38): # GameOver
            del v5
            return method52(v32, v33, v34, v35, v36, v37, v38)
        case US6_2(v39, v40, v41, v42, v43, v44): # WaitingForActionFromPlayerId
            del v5
            return method52(v32, v39, v40, v41, v42, v43, v44)
        case t:
            raise Exception(f'Pattern matching miss. Got: {t}')
def method79(v0 : cp.ndarray, v1 : US1) -> None:
    v2 = v1.tag
    method51(v0, v2)
    del v2
    v4 = v0[4:].view(cp.uint8)
    del v0
    match v1:
        case US1_0(): # A_All_In
            del v1
            return method49(v4)
        case US1_1(): # A_Call
            del v1
            return method49(v4)
        case US1_2(): # A_Fold
            del v1
            return method49(v4)
        case US1_3(v5): # A_Raise
            del v1
            return method51(v4, v5)
        case t:
            raise Exception(f'Pattern matching miss. Got: {t}')
def method80(v0 : cp.ndarray, v1 : static_array) -> None:
    v2 = 0
    while method53(v2):
        v4 = u64(v2)
        v5 = v4 * 4
        del v4
        v7 = v0[v5:].view(cp.uint8)
        del v5
        v9 = v1[v2]
        method76(v7, v9)
        del v7, v9
        v2 += 1 
    del v0, v1, v2
    return 
def method78(v0 : cp.ndarray, v1 : US0) -> None:
    v2 = v1.tag
    method51(v0, v2)
    del v2
    v4 = v0[8:].view(cp.uint8)
    del v0
    match v1:
        case US0_0(v5): # ActionSelected
            del v1
            return method79(v4, v5)
        case US0_1(v6): # PlayerChanged
            del v1
            return method80(v4, v6)
        case US0_2(): # StartGame
            del v1
            return method49(v4)
        case US0_3(): # StartTrainingVsRando
            del v1
            return method49(v4)
        case US0_4(): # StartTrainingVsSelf
            del v1
            return method49(v4)
        case t:
            raise Exception(f'Pattern matching miss. Got: {t}')
def method82(v0 : cp.ndarray) -> u64:
    v2 = v0[0:].view(cp.uint64)
    del v0
    v3 = v2[0].item()
    del v2
    return v3
def method83(v0 : cp.ndarray) -> i32:
    v2 = v0[8:].view(cp.int32)
    del v0
    v3 = v2[0].item()
    del v2
    return v3
def method84(v0 : cp.ndarray) -> None:
    del v0
    return 
def method86(v0 : cp.ndarray) -> i32:
    v2 = v0[0:].view(cp.int32)
    del v0
    v3 = v2[0].item()
    del v2
    return v3
def method90(v0 : cp.ndarray) -> u8:
    v2 = v0[0:].view(cp.uint8)
    del v0
    v3 = v2[0].item()
    del v2
    return v3
def method89(v0 : cp.ndarray) -> u8:
    v1 = method90(v0)
    del v0
    return v1
def method88(v0 : cp.ndarray) -> static_array:
    v2 = static_array(2)
    v3 = 0
    while method53(v3):
        v5 = u64(v3)
        v7 = v0[v5:].view(cp.uint8)
        del v5
        v8 = method89(v7)
        del v7
        v2[v3] = v8
        del v8
        v3 += 1 
    del v0, v3
    return v2
def method91(v0 : cp.ndarray) -> i32:
    v2 = v0[28:].view(cp.int32)
    del v0
    v3 = v2[0].item()
    del v2
    return v3
def method92(v0 : cp.ndarray) -> static_array:
    v2 = static_array(3)
    v3 = 0
    while method59(v3):
        v5 = u64(v3)
        v7 = v0[v5:].view(cp.uint8)
        del v5
        v8 = method89(v7)
        del v7
        v2[v3] = v8
        del v8
        v3 += 1 
    del v0, v3
    return v2
def method93(v0 : cp.ndarray) -> static_array:
    v2 = static_array(5)
    v3 = 0
    while method61(v3):
        v5 = u64(v3)
        v7 = v0[v5:].view(cp.uint8)
        del v5
        v8 = method89(v7)
        del v7
        v2[v3] = v8
        del v8
        v3 += 1 
    del v0, v3
    return v2
def method94(v0 : cp.ndarray) -> static_array:
    v2 = static_array(4)
    v3 = 0
    while method63(v3):
        v5 = u64(v3)
        v7 = v0[v5:].view(cp.uint8)
        del v5
        v8 = method89(v7)
        del v7
        v2[v3] = v8
        del v8
        v3 += 1 
    del v0, v3
    return v2
def method87(v0 : cp.ndarray) -> Tuple[i32, static_array, static_array, i32, static_array, US5]:
    v2 = v0[0:].view(cp.int32)
    v3 = v2[0].item()
    del v2
    v5 = static_array(2)
    v6 = 0
    while method53(v6):
        v8 = u64(v6)
        v9 = v8 * 2
        del v8
        v10 = 4 + v9
        del v9
        v12 = v0[v10:].view(cp.uint8)
        del v10
        v13 = method88(v12)
        del v12
        v5[v6] = v13
        del v13
        v6 += 1 
    del v6
    v15 = static_array(2)
    v16 = 0
    while method53(v16):
        v18 = u64(v16)
        v19 = v18 * 4
        del v18
        v20 = 8 + v19
        del v19
        v22 = v0[v20:].view(cp.uint8)
        del v20
        v23 = method86(v22)
        del v22
        v15[v16] = v23
        del v23
        v16 += 1 
    del v16
    v25 = v0[16:].view(cp.int32)
    v26 = v25[0].item()
    del v25
    v28 = static_array(2)
    v29 = 0
    while method53(v29):
        v31 = u64(v29)
        v32 = v31 * 4
        del v31
        v33 = 20 + v32
        del v32
        v35 = v0[v33:].view(cp.uint8)
        del v33
        v36 = method86(v35)
        del v35
        v28[v29] = v36
        del v36
        v29 += 1 
    del v29
    v37 = method91(v0)
    v39 = v0[32:].view(cp.uint8)
    del v0
    if v37 == 0:
        v41 = method92(v39)
        v48 = US5_0(v41)
    elif v37 == 1:
        method84(v39)
        v48 = US5_1()
    elif v37 == 2:
        v44 = method93(v39)
        v48 = US5_2(v44)
    elif v37 == 3:
        v46 = method94(v39)
        v48 = US5_3(v46)
    else:
        raise Exception("Invalid tag.")
    del v37, v39
    return v3, v5, v15, v26, v28, v48
def method96(v0 : cp.ndarray) -> i32:
    v2 = v0[40:].view(cp.int32)
    del v0
    v3 = v2[0].item()
    del v2
    return v3
def method95(v0 : cp.ndarray) -> Tuple[i32, static_array, static_array, i32, static_array, US5, US1]:
    v2 = v0[0:].view(cp.int32)
    v3 = v2[0].item()
    del v2
    v5 = static_array(2)
    v6 = 0
    while method53(v6):
        v8 = u64(v6)
        v9 = v8 * 2
        del v8
        v10 = 4 + v9
        del v9
        v12 = v0[v10:].view(cp.uint8)
        del v10
        v13 = method88(v12)
        del v12
        v5[v6] = v13
        del v13
        v6 += 1 
    del v6
    v15 = static_array(2)
    v16 = 0
    while method53(v16):
        v18 = u64(v16)
        v19 = v18 * 4
        del v18
        v20 = 8 + v19
        del v19
        v22 = v0[v20:].view(cp.uint8)
        del v20
        v23 = method86(v22)
        del v22
        v15[v16] = v23
        del v23
        v16 += 1 
    del v16
    v25 = v0[16:].view(cp.int32)
    v26 = v25[0].item()
    del v25
    v28 = static_array(2)
    v29 = 0
    while method53(v29):
        v31 = u64(v29)
        v32 = v31 * 4
        del v31
        v33 = 20 + v32
        del v32
        v35 = v0[v33:].view(cp.uint8)
        del v33
        v36 = method86(v35)
        del v35
        v28[v29] = v36
        del v36
        v29 += 1 
    del v29
    v37 = method91(v0)
    v39 = v0[32:].view(cp.uint8)
    if v37 == 0:
        v41 = method92(v39)
        v48 = US5_0(v41)
    elif v37 == 1:
        method84(v39)
        v48 = US5_1()
    elif v37 == 2:
        v44 = method93(v39)
        v48 = US5_2(v44)
    elif v37 == 3:
        v46 = method94(v39)
        v48 = US5_3(v46)
    else:
        raise Exception("Invalid tag.")
    del v37, v39
    v49 = method96(v0)
    v51 = v0[44:].view(cp.uint8)
    del v0
    if v49 == 0:
        method84(v51)
        v58 = US1_0()
    elif v49 == 1:
        method84(v51)
        v58 = US1_1()
    elif v49 == 2:
        method84(v51)
        v58 = US1_2()
    elif v49 == 3:
        v56 = method86(v51)
        v58 = US1_3(v56)
    else:
        raise Exception("Invalid tag.")
    del v49, v51
    return v3, v5, v15, v26, v28, v48, v58
def method85(v0 : cp.ndarray) -> US4:
    v1 = method86(v0)
    v3 = v0[16:].view(cp.uint8)
    del v0
    if v1 == 0:
        del v1
        v5, v6, v7, v8, v9, v10 = method87(v3)
        del v3
        return US4_0(v5, v6, v7, v8, v9, v10)
    elif v1 == 1:
        del v1
        v12, v13, v14, v15, v16, v17 = method87(v3)
        del v3
        return US4_1(v12, v13, v14, v15, v16, v17)
    elif v1 == 2:
        del v1
        method84(v3)
        del v3
        return US4_2()
    elif v1 == 3:
        del v1
        v20, v21, v22, v23, v24, v25 = method87(v3)
        del v3
        return US4_3(v20, v21, v22, v23, v24, v25)
    elif v1 == 4:
        del v1
        v27, v28, v29, v30, v31, v32 = method87(v3)
        del v3
        return US4_4(v27, v28, v29, v30, v31, v32)
    elif v1 == 5:
        del v1
        v34, v35, v36, v37, v38, v39, v40 = method95(v3)
        del v3
        return US4_5(v34, v35, v36, v37, v38, v39, v40)
    elif v1 == 6:
        del v1
        v42, v43, v44, v45, v46, v47 = method87(v3)
        del v3
        return US4_6(v42, v43, v44, v45, v46, v47)
    elif v1 == 7:
        del v1
        v49, v50, v51, v52, v53, v54 = method87(v3)
        del v3
        return US4_7(v49, v50, v51, v52, v53, v54)
    else:
        del v1, v3
        raise Exception("Invalid tag.")
def method97(v0 : cp.ndarray) -> i32:
    v2 = v0[80:].view(cp.int32)
    del v0
    v3 = v2[0].item()
    del v2
    return v3
def method99(v0 : cp.ndarray) -> static_array_list:
    v2 = static_array_list(5)
    v3 = method86(v0)
    v2.unsafe_set_length(v3)
    del v3
    v4 = v2.length
    v5 = 0
    while method6(v4, v5):
        v7 = u64(v5)
        v8 = 4 + v7
        del v7
        v10 = v0[v8:].view(cp.uint8)
        del v8
        v11 = method89(v10)
        del v10
        v2[v5] = v11
        del v11
        v5 += 1 
    del v0, v4, v5
    return v2
def method100(v0 : cp.ndarray) -> Tuple[i32, i32]:
    v2 = v0[0:].view(cp.int32)
    v3 = v2[0].item()
    del v2
    v5 = v0[4:].view(cp.int32)
    del v0
    v6 = v5[0].item()
    del v5
    return v3, v6
def method102(v0 : cp.ndarray) -> i32:
    v2 = v0[4:].view(cp.int32)
    del v0
    v3 = v2[0].item()
    del v2
    return v3
def method101(v0 : cp.ndarray) -> Tuple[i32, US1]:
    v2 = v0[0:].view(cp.int32)
    v3 = v2[0].item()
    del v2
    v4 = method102(v0)
    v6 = v0[8:].view(cp.uint8)
    del v0
    if v4 == 0:
        method84(v6)
        v13 = US1_0()
    elif v4 == 1:
        method84(v6)
        v13 = US1_1()
    elif v4 == 2:
        method84(v6)
        v13 = US1_2()
    elif v4 == 3:
        v11 = method86(v6)
        v13 = US1_3(v11)
    else:
        raise Exception("Invalid tag.")
    del v4, v6
    return v3, v13
def method103(v0 : cp.ndarray) -> Tuple[i32, static_array]:
    v2 = v0[0:].view(cp.int32)
    v3 = v2[0].item()
    del v2
    v5 = static_array(2)
    v6 = 0
    while method53(v6):
        v8 = u64(v6)
        v9 = 4 + v8
        del v8
        v11 = v0[v9:].view(cp.uint8)
        del v9
        v12 = method89(v11)
        del v11
        v5[v6] = v12
        del v12
        v6 += 1 
    del v0, v6
    return v3, v5
def method106(v0 : cp.ndarray) -> Tuple[static_array, i8]:
    v2 = static_array(5)
    v3 = 0
    while method61(v3):
        v5 = u64(v3)
        v7 = v0[v5:].view(cp.uint8)
        del v5
        v8 = method89(v7)
        del v7
        v2[v3] = v8
        del v8
        v3 += 1 
    del v3
    v10 = v0[5:].view(cp.int8)
    del v0
    v11 = v10[0].item()
    del v10
    return v2, v11
def method105(v0 : cp.ndarray) -> Tuple[static_array, i8]:
    v1, v2 = method106(v0)
    del v0
    return v1, v2
def method104(v0 : cp.ndarray) -> Tuple[i32, static_array, i32]:
    v2 = v0[0:].view(cp.int32)
    v3 = v2[0].item()
    del v2
    v5 = static_array(2)
    v6 = 0
    while method53(v6):
        v8 = u64(v6)
        v9 = v8 * 8
        del v8
        v10 = 8 + v9
        del v9
        v12 = v0[v10:].view(cp.uint8)
        del v10
        v13, v14 = method105(v12)
        del v12
        v5[v6] = (v13, v14)
        del v13, v14
        v6 += 1 
    del v6
    v16 = v0[24:].view(cp.int32)
    del v0
    v17 = v16[0].item()
    del v16
    return v3, v5, v17
def method98(v0 : cp.ndarray) -> US7:
    v1 = method86(v0)
    v3 = v0[16:].view(cp.uint8)
    del v0
    if v1 == 0:
        del v1
        v5 = method99(v3)
        del v3
        return US7_0(v5)
    elif v1 == 1:
        del v1
        v7, v8 = method100(v3)
        del v3
        return US7_1(v7, v8)
    elif v1 == 2:
        del v1
        v10, v11 = method101(v3)
        del v3
        return US7_2(v10, v11)
    elif v1 == 3:
        del v1
        v13, v14 = method103(v3)
        del v3
        return US7_3(v13, v14)
    elif v1 == 4:
        del v1
        v16, v17, v18 = method104(v3)
        del v3
        return US7_4(v16, v17, v18)
    else:
        del v1, v3
        raise Exception("Invalid tag.")
def method107(v0 : cp.ndarray) -> US2:
    v1 = method86(v0)
    v3 = v0[4:].view(cp.uint8)
    del v0
    if v1 == 0:
        del v1
        method84(v3)
        del v3
        return US2_0()
    elif v1 == 1:
        del v1
        method84(v3)
        del v3
        return US2_1()
    elif v1 == 2:
        del v1
        method84(v3)
        del v3
        return US2_2()
    else:
        del v1, v3
        raise Exception("Invalid tag.")
def method108(v0 : cp.ndarray) -> i32:
    v2 = v0[6248:].view(cp.int32)
    del v0
    v3 = v2[0].item()
    del v2
    return v3
def method81(v0 : cp.ndarray) -> Tuple[u64, US3, static_array_list, static_array, US6]:
    v1 = method82(v0)
    v2 = method83(v0)
    v4 = v0[16:].view(cp.uint8)
    if v2 == 0:
        method84(v4)
        v9 = US3_0()
    elif v2 == 1:
        v7 = method85(v4)
        v9 = US3_1(v7)
    else:
        raise Exception("Invalid tag.")
    del v2, v4
    v11 = static_array_list(128)
    v12 = method97(v0)
    v11.unsafe_set_length(v12)
    del v12
    v13 = v11.length
    v14 = 0
    while method6(v13, v14):
        v16 = u64(v14)
        v17 = v16 * 48
        del v16
        v18 = 96 + v17
        del v17
        v20 = v0[v18:].view(cp.uint8)
        del v18
        v21 = method98(v20)
        del v20
        v11[v14] = v21
        del v21
        v14 += 1 
    del v13, v14
    v23 = static_array(2)
    v24 = 0
    while method53(v24):
        v26 = u64(v24)
        v27 = v26 * 4
        del v26
        v28 = 6240 + v27
        del v27
        v30 = v0[v28:].view(cp.uint8)
        del v28
        v31 = method107(v30)
        del v30
        v23[v24] = v31
        del v31
        v24 += 1 
    del v24
    v32 = method108(v0)
    v34 = v0[6256:].view(cp.uint8)
    del v0
    if v32 == 0:
        method84(v34)
        v51 = US6_0()
    elif v32 == 1:
        v37, v38, v39, v40, v41, v42 = method87(v34)
        v51 = US6_1(v37, v38, v39, v40, v41, v42)
    elif v32 == 2:
        v44, v45, v46, v47, v48, v49 = method87(v34)
        v51 = US6_2(v44, v45, v46, v47, v48, v49)
    else:
        raise Exception("Invalid tag.")
    del v32, v34
    return v1, v9, v11, v23, v51
def method115(v0 : u64) -> object:
    v1 = v0
    del v0
    return v1
def method114(v0 : u64) -> object:
    return method115(v0)
def method117() -> object:
    v0 = []
    return v0
def method120(v0 : i32) -> object:
    v1 = v0
    del v0
    return v1
def method124(v0 : u8) -> object:
    v1 = v0
    del v0
    return v1
def method123(v0 : u8) -> object:
    return method124(v0)
def method122(v0 : static_array) -> object:
    v1 = []
    v2 = 0
    while method53(v2):
        v5 = v0[v2]
        v6 = method123(v5)
        del v5
        v1.append(v6)
        del v6
        v2 += 1 
    del v0, v2
    return v1
def method121(v0 : static_array) -> object:
    v1 = []
    v2 = 0
    while method53(v2):
        v5 = v0[v2]
        v6 = method122(v5)
        del v5
        v1.append(v6)
        del v6
        v2 += 1 
    del v0, v2
    return v1
def method125(v0 : static_array) -> object:
    v1 = []
    v2 = 0
    while method53(v2):
        v5 = v0[v2]
        v6 = method120(v5)
        del v5
        v1.append(v6)
        del v6
        v2 += 1 
    del v0, v2
    return v1
def method127(v0 : static_array) -> object:
    v1 = []
    v2 = 0
    while method59(v2):
        v5 = v0[v2]
        v6 = method123(v5)
        del v5
        v1.append(v6)
        del v6
        v2 += 1 
    del v0, v2
    return v1
def method128(v0 : static_array) -> object:
    v1 = []
    v2 = 0
    while method61(v2):
        v5 = v0[v2]
        v6 = method123(v5)
        del v5
        v1.append(v6)
        del v6
        v2 += 1 
    del v0, v2
    return v1
def method129(v0 : static_array) -> object:
    v1 = []
    v2 = 0
    while method63(v2):
        v5 = v0[v2]
        v6 = method123(v5)
        del v5
        v1.append(v6)
        del v6
        v2 += 1 
    del v0, v2
    return v1
def method126(v0 : US5) -> object:
    match v0:
        case US5_0(v1): # Flop
            del v0
            v2 = method127(v1)
            del v1
            v3 = "Flop"
            v4 = [v3,v2]
            del v2, v3
            return v4
        case US5_1(): # Preflop
            del v0
            v5 = method117()
            v6 = "Preflop"
            v7 = [v6,v5]
            del v5, v6
            return v7
        case US5_2(v8): # River
            del v0
            v9 = method128(v8)
            del v8
            v10 = "River"
            v11 = [v10,v9]
            del v9, v10
            return v11
        case US5_3(v12): # Turn
            del v0
            v13 = method129(v12)
            del v12
            v14 = "Turn"
            v15 = [v14,v13]
            del v13, v14
            return v15
        case t:
            raise Exception(f'Pattern matching miss. Got: {t}')
def method119(v0 : i32, v1 : static_array, v2 : static_array, v3 : i32, v4 : static_array, v5 : US5) -> object:
    v6 = method120(v0)
    del v0
    v7 = method121(v1)
    del v1
    v8 = method125(v2)
    del v2
    v9 = method120(v3)
    del v3
    v10 = method125(v4)
    del v4
    v11 = method126(v5)
    del v5
    v12 = {'min_raise': v6, 'pl_card': v7, 'pot': v8, 'round_turn': v9, 'stack': v10, 'street': v11}
    del v6, v7, v8, v9, v10, v11
    return v12
def method131(v0 : US1) -> object:
    match v0:
        case US1_0(): # A_All_In
            del v0
            v1 = method117()
            v2 = "A_All_In"
            v3 = [v2,v1]
            del v1, v2
            return v3
        case US1_1(): # A_Call
            del v0
            v4 = method117()
            v5 = "A_Call"
            v6 = [v5,v4]
            del v4, v5
            return v6
        case US1_2(): # A_Fold
            del v0
            v7 = method117()
            v8 = "A_Fold"
            v9 = [v8,v7]
            del v7, v8
            return v9
        case US1_3(v10): # A_Raise
            del v0
            v11 = method120(v10)
            del v10
            v12 = "A_Raise"
            v13 = [v12,v11]
            del v11, v12
            return v13
        case t:
            raise Exception(f'Pattern matching miss. Got: {t}')
def method130(v0 : i32, v1 : static_array, v2 : static_array, v3 : i32, v4 : static_array, v5 : US5, v6 : US1) -> object:
    v7 = []
    v8 = method119(v0, v1, v2, v3, v4, v5)
    del v0, v1, v2, v3, v4, v5
    v7.append(v8)
    del v8
    v9 = method131(v6)
    del v6
    v7.append(v9)
    del v9
    v10 = v7
    del v7
    return v10
def method118(v0 : US4) -> object:
    match v0:
        case US4_0(v1, v2, v3, v4, v5, v6): # G_Flop
            del v0
            v7 = method119(v1, v2, v3, v4, v5, v6)
            del v1, v2, v3, v4, v5, v6
            v8 = "G_Flop"
            v9 = [v8,v7]
            del v7, v8
            return v9
        case US4_1(v10, v11, v12, v13, v14, v15): # G_Fold
            del v0
            v16 = method119(v10, v11, v12, v13, v14, v15)
            del v10, v11, v12, v13, v14, v15
            v17 = "G_Fold"
            v18 = [v17,v16]
            del v16, v17
            return v18
        case US4_2(): # G_Preflop
            del v0
            v19 = method117()
            v20 = "G_Preflop"
            v21 = [v20,v19]
            del v19, v20
            return v21
        case US4_3(v22, v23, v24, v25, v26, v27): # G_River
            del v0
            v28 = method119(v22, v23, v24, v25, v26, v27)
            del v22, v23, v24, v25, v26, v27
            v29 = "G_River"
            v30 = [v29,v28]
            del v28, v29
            return v30
        case US4_4(v31, v32, v33, v34, v35, v36): # G_Round
            del v0
            v37 = method119(v31, v32, v33, v34, v35, v36)
            del v31, v32, v33, v34, v35, v36
            v38 = "G_Round"
            v39 = [v38,v37]
            del v37, v38
            return v39
        case US4_5(v40, v41, v42, v43, v44, v45, v46): # G_Round'
            del v0
            v47 = method130(v40, v41, v42, v43, v44, v45, v46)
            del v40, v41, v42, v43, v44, v45, v46
            v48 = "G_Round'"
            v49 = [v48,v47]
            del v47, v48
            return v49
        case US4_6(v50, v51, v52, v53, v54, v55): # G_Showdown
            del v0
            v56 = method119(v50, v51, v52, v53, v54, v55)
            del v50, v51, v52, v53, v54, v55
            v57 = "G_Showdown"
            v58 = [v57,v56]
            del v56, v57
            return v58
        case US4_7(v59, v60, v61, v62, v63, v64): # G_Turn
            del v0
            v65 = method119(v59, v60, v61, v62, v63, v64)
            del v59, v60, v61, v62, v63, v64
            v66 = "G_Turn"
            v67 = [v66,v65]
            del v65, v66
            return v67
        case t:
            raise Exception(f'Pattern matching miss. Got: {t}')
def method116(v0 : US3) -> object:
    match v0:
        case US3_0(): # None
            del v0
            v1 = method117()
            v2 = "None"
            v3 = [v2,v1]
            del v1, v2
            return v3
        case US3_1(v4): # Some
            del v0
            v5 = method118(v4)
            del v4
            v6 = "Some"
            v7 = [v6,v5]
            del v5, v6
            return v7
        case t:
            raise Exception(f'Pattern matching miss. Got: {t}')
def method113(v0 : u64, v1 : US3) -> object:
    v2 = method114(v0)
    del v0
    v3 = method116(v1)
    del v1
    v4 = {'deck': v2, 'game': v3}
    del v2, v3
    return v4
def method135(v0 : static_array_list) -> object:
    v1 = []
    v2 = v0.length
    v3 = 0
    while method6(v2, v3):
        v6 = v0[v3]
        v7 = method123(v6)
        del v6
        v1.append(v7)
        del v7
        v3 += 1 
    del v0, v2, v3
    return v1
def method136(v0 : i32, v1 : i32) -> object:
    v2 = method120(v0)
    del v0
    v3 = method120(v1)
    del v1
    v4 = {'chips_won': v2, 'winner_id': v3}
    del v2, v3
    return v4
def method137(v0 : i32, v1 : US1) -> object:
    v2 = []
    v3 = method120(v0)
    del v0
    v2.append(v3)
    del v3
    v4 = method131(v1)
    del v1
    v2.append(v4)
    del v4
    v5 = v2
    del v2
    return v5
def method138(v0 : i32, v1 : static_array) -> object:
    v2 = []
    v3 = method120(v0)
    del v0
    v2.append(v3)
    del v3
    v4 = method122(v1)
    del v1
    v2.append(v4)
    del v4
    v5 = v2
    del v2
    return v5
def method143(v0 : i8) -> object:
    v1 = v0
    del v0
    return v1
def method142(v0 : static_array, v1 : i8) -> object:
    v2 = method128(v0)
    del v0
    v3 = method143(v1)
    del v1
    v4 = {'hand': v2, 'score': v3}
    del v2, v3
    return v4
def method141(v0 : static_array, v1 : i8) -> object:
    return method142(v0, v1)
def method140(v0 : static_array) -> object:
    v1 = []
    v2 = 0
    while method53(v2):
        v6, v7 = v0[v2]
        v8 = method141(v6, v7)
        del v6, v7
        v1.append(v8)
        del v8
        v2 += 1 
    del v0, v2
    return v1
def method139(v0 : i32, v1 : static_array, v2 : i32) -> object:
    v3 = method120(v0)
    del v0
    v4 = method140(v1)
    del v1
    v5 = method120(v2)
    del v2
    v6 = {'chips_won': v3, 'hands_shown': v4, 'winner_id': v5}
    del v3, v4, v5
    return v6
def method134(v0 : US7) -> object:
    match v0:
        case US7_0(v1): # CommunityCardsAre
            del v0
            v2 = method135(v1)
            del v1
            v3 = "CommunityCardsAre"
            v4 = [v3,v2]
            del v2, v3
            return v4
        case US7_1(v5, v6): # Fold
            del v0
            v7 = method136(v5, v6)
            del v5, v6
            v8 = "Fold"
            v9 = [v8,v7]
            del v7, v8
            return v9
        case US7_2(v10, v11): # PlayerAction
            del v0
            v12 = method137(v10, v11)
            del v10, v11
            v13 = "PlayerAction"
            v14 = [v13,v12]
            del v12, v13
            return v14
        case US7_3(v15, v16): # PlayerGotCards
            del v0
            v17 = method138(v15, v16)
            del v15, v16
            v18 = "PlayerGotCards"
            v19 = [v18,v17]
            del v17, v18
            return v19
        case US7_4(v20, v21, v22): # Showdown
            del v0
            v23 = method139(v20, v21, v22)
            del v20, v21, v22
            v24 = "Showdown"
            v25 = [v24,v23]
            del v23, v24
            return v25
        case t:
            raise Exception(f'Pattern matching miss. Got: {t}')
def method133(v0 : static_array_list) -> object:
    v1 = []
    v2 = v0.length
    v3 = 0
    while method6(v2, v3):
        v6 = v0[v3]
        v7 = method134(v6)
        del v6
        v1.append(v7)
        del v7
        v3 += 1 
    del v0, v2, v3
    return v1
def method145(v0 : US2) -> object:
    match v0:
        case US2_0(): # Computer
            del v0
            v1 = method117()
            v2 = "Computer"
            v3 = [v2,v1]
            del v1, v2
            return v3
        case US2_1(): # Human
            del v0
            v4 = method117()
            v5 = "Human"
            v6 = [v5,v4]
            del v4, v5
            return v6
        case US2_2(): # Random
            del v0
            v7 = method117()
            v8 = "Random"
            v9 = [v8,v7]
            del v7, v8
            return v9
        case t:
            raise Exception(f'Pattern matching miss. Got: {t}')
def method144(v0 : static_array) -> object:
    v1 = []
    v2 = 0
    while method53(v2):
        v5 = v0[v2]
        v6 = method145(v5)
        del v5
        v1.append(v6)
        del v6
        v2 += 1 
    del v0, v2
    return v1
def method146(v0 : US6) -> object:
    match v0:
        case US6_0(): # GameNotStarted
            del v0
            v1 = method117()
            v2 = "GameNotStarted"
            v3 = [v2,v1]
            del v1, v2
            return v3
        case US6_1(v4, v5, v6, v7, v8, v9): # GameOver
            del v0
            v10 = method119(v4, v5, v6, v7, v8, v9)
            del v4, v5, v6, v7, v8, v9
            v11 = "GameOver"
            v12 = [v11,v10]
            del v10, v11
            return v12
        case US6_2(v13, v14, v15, v16, v17, v18): # WaitingForActionFromPlayerId
            del v0
            v19 = method119(v13, v14, v15, v16, v17, v18)
            del v13, v14, v15, v16, v17, v18
            v20 = "WaitingForActionFromPlayerId"
            v21 = [v20,v19]
            del v19, v20
            return v21
        case t:
            raise Exception(f'Pattern matching miss. Got: {t}')
def method132(v0 : static_array_list, v1 : static_array, v2 : US6) -> object:
    v3 = method133(v0)
    del v0
    v4 = method144(v1)
    del v1
    v5 = method146(v2)
    del v2
    v6 = {'messages': v3, 'pl_type': v4, 'ui_game_state': v5}
    del v3, v4, v5
    return v6
def method112(v0 : u64, v1 : US3, v2 : static_array_list, v3 : static_array, v4 : US6) -> object:
    v5 = method113(v0, v1)
    del v0, v1
    v6 = method132(v2, v3, v4)
    del v2, v3, v4
    v7 = {'private': v5, 'public': v6}
    del v5, v6
    return v7
def method152(v0 : cp.ndarray) -> object:
    v1 = v0
    del v0
    return v1
def method151(v0 : cp.ndarray) -> object:
    return method152(v0)
def method150(v0 : cp.ndarray, v1 : u64) -> object:
    v2 = []
    v3 = method151(v0)
    del v0
    v2.append(v3)
    del v3
    v4 = method115(v1)
    del v1
    v2.append(v4)
    del v4
    v5 = v2
    del v2
    return v5
def method149(v0 : cp.ndarray, v1 : u64, v2 : cp.ndarray, v3 : u64) -> object:
    v4 = method150(v0, v1)
    del v0, v1
    v5 = method150(v2, v3)
    del v2, v3
    v6 = {'output': v4, 'param': v5}
    del v4, v5
    return v6
def method148(v0 : cp.ndarray, v1 : u64, v2 : cp.ndarray, v3 : u64) -> object:
    return method149(v0, v1, v2, v3)
def method147(v0 : cp.ndarray, v1 : u64, v2 : cp.ndarray, v3 : u64) -> object:
    v4 = method148(v0, v1, v2, v3)
    del v0, v1, v2, v3
    v5 = {'model_data': v4}
    del v4
    return v5
def method111(v0 : u64, v1 : US3, v2 : static_array_list, v3 : static_array, v4 : US6, v5 : cp.ndarray, v6 : u64, v7 : cp.ndarray, v8 : u64) -> object:
    v9 = method112(v0, v1, v2, v3, v4)
    del v0, v1, v2, v3, v4
    v10 = method147(v5, v6, v7, v8)
    del v5, v6, v7, v8
    v11 = {'game': v9, 'neural': v10}
    del v9, v10
    return v11
def method157(v0 : f32) -> object:
    v1 = v0
    del v0
    return v1
def method156(v0 : list) -> object:
    v1 = []
    v2 = len(v0)
    v3 = 0
    while method6(v2, v3):
        v5 = v0[v3]
        v6 = method157(v5)
        del v5
        v1.append(v6)
        del v6
        v3 += 1 
    del v0, v2, v3
    return v1
def method155(v0 : list) -> object:
    v1 = []
    v2 = len(v0)
    v3 = 0
    while method6(v2, v3):
        v5 = v0[v3]
        v6 = method156(v5)
        del v5
        v1.append(v6)
        del v6
        v3 += 1 
    del v0, v2, v3
    return v1
def method154(v0 : US8) -> object:
    match v0:
        case US8_0(v1): # AddRewardsRando
            del v0
            v2 = method155(v1)
            del v1
            v3 = "AddRewardsRando"
            v4 = [v3,v2]
            del v2, v3
            return v4
        case US8_1(v5): # AddRewardsSelf
            del v0
            v6 = method155(v5)
            del v5
            v7 = "AddRewardsSelf"
            v8 = [v7,v6]
            del v6, v7
            return v8
        case t:
            raise Exception(f'Pattern matching miss. Got: {t}')
def method153(v0 : list) -> object:
    v1 = []
    v2 = len(v0)
    v3 = 0
    while method6(v2, v3):
        v5 = v0[v3]
        v6 = method154(v5)
        del v5
        v1.append(v6)
        del v6
        v3 += 1 
    del v0, v2, v3
    return v1
def method110(v0 : u64, v1 : US3, v2 : static_array_list, v3 : static_array, v4 : US6, v5 : cp.ndarray, v6 : u64, v7 : cp.ndarray, v8 : u64, v9 : list) -> object:
    v10 = []
    v11 = method111(v0, v1, v2, v3, v4, v5, v6, v7, v8)
    del v0, v1, v2, v3, v4, v5, v6, v7, v8
    v10.append(v11)
    del v11
    v12 = method153(v9)
    del v9
    v10.append(v12)
    del v12
    v13 = v10
    del v10
    return v13
def method109(v0 : u64, v1 : US3, v2 : static_array_list, v3 : static_array, v4 : US6, v5 : cp.ndarray, v6 : u64, v7 : cp.ndarray, v8 : u64, v9 : list) -> object:
    v10 = method110(v0, v1, v2, v3, v4, v5, v6, v7, v8, v9)
    del v0, v1, v2, v3, v4, v5, v6, v7, v8, v9
    return v10
def method158(v0 : u64, v1 : US3, v2 : static_array_list, v3 : static_array, v4 : US6, v5 : cp.ndarray, v6 : u64, v7 : cp.ndarray, v8 : u64) -> object:
    v9 = method111(v0, v1, v2, v3, v4, v5, v6, v7, v8)
    del v0, v1, v2, v3, v4, v5, v6, v7, v8
    return v9
def main_body():
    v0 = Closure0()
    v1 = Closure1()
    v2 = collections.namedtuple("Holdem_Full",['event_loop_gpu', 'init'])(v0, v1)
    del v0, v1
    return v2

def main():
    r = main_body()
    cp.cuda.get_current_stream().synchronize() # This line is here so the `__trap()` calls on the kernel aren't missed.
    return r

if __name__ == '__main__': print(main())
